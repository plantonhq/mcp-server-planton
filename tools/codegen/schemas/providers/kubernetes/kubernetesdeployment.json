{
  "name": "KubernetesDeployment",
  "kind": "KubernetesDeployment",
  "cloudProvider": "kubernetes",
  "apiVersion": "kubernetes.openmcf.org/v1",
  "description": "microservice-kubernetes",
  "protoPackage": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1",
  "protoFiles": {
    "api": "org/openmcf/provider/kubernetes/kubernetesdeployment/v1/api.proto",
    "spec": "org/openmcf/provider/kubernetes/kubernetesdeployment/v1/spec.proto"
  },
  "spec": {
    "name": "KubernetesDeploymentSpec",
    "fields": [
      {
        "name": "TargetCluster",
        "jsonName": "targetCluster",
        "protoField": "target_cluster",
        "type": {
          "kind": "message",
          "messageType": "KubernetesClusterSelector"
        },
        "description": "Target Kubernetes Cluster",
        "required": false
      },
      {
        "name": "Namespace",
        "jsonName": "namespace",
        "protoField": "namespace",
        "type": {
          "kind": "string"
        },
        "description": "Kubernetes Namespace",
        "required": true,
        "validation": {
          "required": true
        },
        "referenceKind": "KubernetesNamespace",
        "referenceFieldPath": "spec.name"
      },
      {
        "name": "CreateNamespace",
        "jsonName": "createNamespace",
        "protoField": "create_namespace",
        "type": {
          "kind": "bool"
        },
        "description": "flag to indicate if the namespace should be created",
        "required": false
      },
      {
        "name": "Version",
        "jsonName": "version",
        "protoField": "version",
        "type": {
          "kind": "string"
        },
        "description": "The version of the microservice being deployed.\nThis is usually either \"main\" (the default git branch name) or \"review-\u003cid\u003e\" where \u003cid\u003e is the merge request number.\nIt must be between 1 and 30 characters and can only contain lowercase letters, numbers, and hyphens.",
        "required": false,
        "validation": {
          "minLength": 1,
          "maxLength": 30
        }
      },
      {
        "name": "Container",
        "jsonName": "container",
        "protoField": "container",
        "type": {
          "kind": "message",
          "messageType": "KubernetesDeploymentContainer"
        },
        "description": "The container specifications for the microservice deployment.\nThis includes configurations for the main application container and any sidecar containers.",
        "required": true,
        "validation": {
          "required": true
        }
      },
      {
        "name": "Ingress",
        "jsonName": "ingress",
        "protoField": "ingress",
        "type": {
          "kind": "message",
          "messageType": "KubernetesDeploymentIngress"
        },
        "description": "The ingress configuration for the microservice.\nThis defines how the microservice can be accessed externally.",
        "required": false
      },
      {
        "name": "Availability",
        "jsonName": "availability",
        "protoField": "availability",
        "type": {
          "kind": "message",
          "messageType": "KubernetesDeploymentAvailability"
        },
        "description": "The availability configuration for the microservice.\nThis includes settings for replicas, autoscaling, deployment strategy, and pod disruption budgets.",
        "required": false
      },
      {
        "name": "ConfigMaps",
        "jsonName": "configMaps",
        "protoField": "config_maps",
        "type": {
          "kind": "map",
          "keyType": {
            "kind": "string"
          },
          "valueType": {
            "kind": "string"
          }
        },
        "description": "*\n ConfigMaps to create alongside the deployment.\n Key is the ConfigMap name, value is the content.\n For multi-key ConfigMaps, use YAML format in the value.\n These ConfigMaps can be referenced in volume mounts.\n\n Example:\n   config_maps:\n     app-config: |\n       key1: value1\n       key2: value2\n     nginx-conf: |\n       server {\n         listen 80;\n       }",
        "required": false
      }
    ]
  },
  "nestedTypes": [
    {
      "name": "ConfigMapVolumeSource",
      "description": "*\n ConfigMapVolumeSource mounts a ConfigMap as a volume.\n The ConfigMap can be one defined in spec.config_maps or an existing ConfigMap in the namespace.\n\n When 'key' is specified, only that key is mounted as a single file.\n When 'key' is not specified, all keys are mounted as files in the directory.\n\n Example - Mount entire ConfigMap as directory:\n   configMap:\n     name: app-config\n\n Example - Mount single key as file:\n   configMap:\n     name: app-config\n     key: database.yaml\n     path: db-config.yaml",
      "protoType": "org.openmcf.provider.kubernetes.ConfigMapVolumeSource",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "Name of the ConfigMap to mount.\n Can reference a ConfigMap defined in spec.config_maps or an existing one in the namespace.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Key",
          "jsonName": "key",
          "protoField": "key",
          "type": {
            "kind": "string"
          },
          "description": "Specific key from the ConfigMap to mount as a single file.\n If not specified, all keys are mounted as files in the directory.",
          "required": false
        },
        {
          "name": "Path",
          "jsonName": "path",
          "protoField": "path",
          "type": {
            "kind": "string"
          },
          "description": "If key is specified, this is the filename to use for the mounted file.\n Defaults to the key name if not specified.\n Example: key=\"config\" path=\"app.yaml\" mounts the \"config\" key as \"app.yaml\"",
          "required": false
        },
        {
          "name": "DefaultMode",
          "jsonName": "defaultMode",
          "protoField": "default_mode",
          "type": {
            "kind": "int32"
          },
          "description": "Mode bits to use on created files. Must be a value between 0 and 0777.\n Defaults to 0644.\n Use 0755 (493 in decimal) for executable scripts.",
          "required": false
        }
      ]
    },
    {
      "name": "Container",
      "description": "**Container** defines the specifications for a container within a microservice deployment configuration.\n This message mirrors the Kubernetes container spec (https://pkg.go.dev/k8s.io/api/core/v1#Container),\n allowing you to specify container attributes such as the image, ports, resources, and environment variables.\n **Warning:** The sidecar feature currently does not support all features of a Kubernetes container spec.",
      "protoType": "org.openmcf.provider.kubernetes.Container",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "The name of the container.",
          "required": false
        },
        {
          "name": "Image",
          "jsonName": "image",
          "protoField": "image",
          "type": {
            "kind": "string"
          },
          "description": "The container image to be used.",
          "required": false
        },
        {
          "name": "Ports",
          "jsonName": "ports",
          "protoField": "ports",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "message",
              "messageType": "ContainerPort"
            }
          },
          "description": "A list of ports exposed by the container.",
          "required": false
        },
        {
          "name": "Resources",
          "jsonName": "resources",
          "protoField": "resources",
          "type": {
            "kind": "message",
            "messageType": "ContainerResources"
          },
          "description": "Resource specifications for the container, including CPU and memory limits and requests.",
          "required": false
        },
        {
          "name": "Env",
          "jsonName": "env",
          "protoField": "env",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "message",
              "messageType": "ContainerEnvVar"
            }
          },
          "description": "A list of environment variables to be set in the container.",
          "required": false
        }
      ]
    },
    {
      "name": "ContainerEnvVar",
      "description": "**ContainerEnvVar** represents an environment variable to be set in the container.\n It allows you to pass configuration or sensitive information to the container at runtime.",
      "protoType": "org.openmcf.provider.kubernetes.ContainerEnvVar",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "The name of the environment variable.",
          "required": false
        },
        {
          "name": "Value",
          "jsonName": "value",
          "protoField": "value",
          "type": {
            "kind": "string"
          },
          "description": "The value of the environment variable.",
          "required": false
        }
      ]
    },
    {
      "name": "ContainerImage",
      "description": "**ContainerImage** represents the container image information.\n It includes the repository, tag, and optional image pull secret for private registries.",
      "protoType": "org.openmcf.provider.kubernetes.ContainerImage",
      "fields": [
        {
          "name": "Repo",
          "jsonName": "repo",
          "protoField": "repo",
          "type": {
            "kind": "string"
          },
          "description": "The repository of the image (e.g., \"gcr.io/project/image\").",
          "required": false
        },
        {
          "name": "Tag",
          "jsonName": "tag",
          "protoField": "tag",
          "type": {
            "kind": "string"
          },
          "description": "The tag of the image (e.g., \"latest\" or \"1.0.0\").",
          "required": false
        },
        {
          "name": "PullSecretName",
          "jsonName": "pullSecretName",
          "protoField": "pull_secret_name",
          "type": {
            "kind": "string"
          },
          "description": "The name of the image pull secret for private image repositories.",
          "required": false
        }
      ]
    },
    {
      "name": "ContainerPort",
      "description": "**ContainerPort** specifies a network port in a single container.\n It allows you to expose ports for communication with other services or the external network.",
      "protoType": "org.openmcf.provider.kubernetes.ContainerPort",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "The name of the port.",
          "required": false
        },
        {
          "name": "ContainerPort",
          "jsonName": "containerPort",
          "protoField": "container_port",
          "type": {
            "kind": "int32"
          },
          "description": "The port number on the container.",
          "required": false
        },
        {
          "name": "Protocol",
          "jsonName": "protocol",
          "protoField": "protocol",
          "type": {
            "kind": "string"
          },
          "description": "The protocol used by the port (e.g., \"TCP\" or \"UDP\").",
          "required": false
        }
      ]
    },
    {
      "name": "ContainerResources",
      "description": "**ContainerResources** specifies the CPU and memory resources for a container.\n It allows you to define resource limits and requests to manage resource allocation and ensure optimal performance.",
      "protoType": "org.openmcf.provider.kubernetes.ContainerResources",
      "fields": [
        {
          "name": "Limits",
          "jsonName": "limits",
          "protoField": "limits",
          "type": {
            "kind": "message",
            "messageType": "CpuMemory"
          },
          "description": "The resource limits for the container.\n Specify the maximum amount of CPU and memory that the container can use.",
          "required": false
        },
        {
          "name": "Requests",
          "jsonName": "requests",
          "protoField": "requests",
          "type": {
            "kind": "message",
            "messageType": "CpuMemory"
          },
          "description": "The resource requests for the container.\n Specify the minimum amount of CPU and memory that the container is guaranteed.",
          "required": false
        }
      ]
    },
    {
      "name": "CpuMemory",
      "description": "**CpuMemory** defines CPU and memory resource quantities for a container.\n It is used to specify the limits and requests for CPU and memory resources.",
      "protoType": "org.openmcf.provider.kubernetes.CpuMemory",
      "fields": [
        {
          "name": "Cpu",
          "jsonName": "cpu",
          "protoField": "cpu",
          "type": {
            "kind": "string"
          },
          "required": false
        },
        {
          "name": "Memory",
          "jsonName": "memory",
          "protoField": "memory",
          "type": {
            "kind": "string"
          },
          "required": false
        }
      ]
    },
    {
      "name": "EmptyDirVolumeSource",
      "description": "*\n EmptyDirVolumeSource creates an empty directory for temporary storage.\n The directory is created when a pod is assigned to a node and exists as long as the pod runs.\n Data is deleted when the pod is removed.\n\n Use cases:\n - Scratch space for computations\n - Checkpoint storage for crash recovery\n - Shared space between containers in a pod\n\n Example - Default (disk-backed):\n   emptyDir: {}\n\n Example - Memory-backed (faster, but uses RAM):\n   emptyDir:\n     medium: Memory\n     sizeLimit: 256Mi",
      "protoType": "org.openmcf.provider.kubernetes.EmptyDirVolumeSource",
      "fields": [
        {
          "name": "Medium",
          "jsonName": "medium",
          "protoField": "medium",
          "type": {
            "kind": "string"
          },
          "description": "Medium for the empty directory.\n \"\" (default) uses the node's default medium (typically disk).\n \"Memory\" uses a tmpfs (RAM-backed filesystem).\n\n Memory-backed volumes are faster but:\n - Count against container memory limits\n - Are lost on node restart\n - Should have sizeLimit set to prevent OOM",
          "required": false
        },
        {
          "name": "SizeLimit",
          "jsonName": "sizeLimit",
          "protoField": "size_limit",
          "type": {
            "kind": "string"
          },
          "description": "Size limit for the empty directory.\n Format: Kubernetes quantity (e.g., \"1Gi\", \"500Mi\").\n Only strictly enforced when medium is \"Memory\".\n For disk-backed volumes, this is a best-effort limit.",
          "required": false
        }
      ]
    },
    {
      "name": "ExecAction",
      "description": "**ExecAction** describes a command-based health check.",
      "protoType": "org.openmcf.provider.kubernetes.ExecAction",
      "fields": [
        {
          "name": "Command",
          "jsonName": "command",
          "protoField": "command",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "string"
            }
          },
          "description": "Command is the command line to execute inside the container.\n The command is run in the container's root filesystem.\n The command's exit status is used to determine the health:\n - 0: Success\n - Non-zero: Failure",
          "required": false
        }
      ]
    },
    {
      "name": "GRPCAction",
      "description": "**GRPCAction** describes an action based on gRPC health checking protocol.\n Reference: https://github.com/grpc/grpc/blob/master/doc/health-checking.md",
      "protoType": "org.openmcf.provider.kubernetes.GRPCAction",
      "fields": [
        {
          "name": "Port",
          "jsonName": "port",
          "protoField": "port",
          "type": {
            "kind": "int32"
          },
          "description": "Port number of the gRPC service.\n Number must be in the range 1 to 65535.",
          "required": false,
          "validation": {
            "min": 1,
            "max": 65535
          }
        },
        {
          "name": "Service",
          "jsonName": "service",
          "protoField": "service",
          "type": {
            "kind": "string"
          },
          "description": "Service is the name of the service to check.\n If not specified, the default behavior defined by gRPC is used.\n For standard gRPC health checks, leave empty to check overall server health.",
          "required": false
        }
      ]
    },
    {
      "name": "HTTPGetAction",
      "description": "**HTTPGetAction** describes an action based on HTTP Get requests.",
      "protoType": "org.openmcf.provider.kubernetes.HTTPGetAction",
      "fields": [
        {
          "name": "Path",
          "jsonName": "path",
          "protoField": "path",
          "type": {
            "kind": "string"
          },
          "description": "Path to access on the HTTP server.\n Defaults to '/'.",
          "required": false
        },
        {
          "name": "PortNumber",
          "jsonName": "portNumber",
          "protoField": "port_number",
          "type": {
            "kind": "int32"
          },
          "required": false,
          "oneofGroup": "port"
        },
        {
          "name": "PortName",
          "jsonName": "portName",
          "protoField": "port_name",
          "type": {
            "kind": "string"
          },
          "required": false,
          "oneofGroup": "port"
        },
        {
          "name": "Host",
          "jsonName": "host",
          "protoField": "host",
          "type": {
            "kind": "string"
          },
          "description": "Host name to connect to, defaults to the pod IP.\n You probably want to set \"Host\" in http_headers instead.",
          "required": false
        },
        {
          "name": "Scheme",
          "jsonName": "scheme",
          "protoField": "scheme",
          "type": {
            "kind": "string"
          },
          "description": "Scheme to use for connecting to the host (HTTP or HTTPS).\n Defaults to HTTP.",
          "required": false
        },
        {
          "name": "HttpHeaders",
          "jsonName": "httpHeaders",
          "protoField": "http_headers",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "message",
              "messageType": "HTTPHeader"
            }
          },
          "description": "Custom headers to set in the request.\n HTTP allows repeated headers.",
          "required": false
        }
      ]
    },
    {
      "name": "HTTPHeader",
      "description": "**HTTPHeader** describes a custom header to be used in HTTP probes.",
      "protoType": "org.openmcf.provider.kubernetes.HTTPHeader",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "The header field name.",
          "required": false
        },
        {
          "name": "Value",
          "jsonName": "value",
          "protoField": "value",
          "type": {
            "kind": "string"
          },
          "description": "The header field value.",
          "required": false
        }
      ]
    },
    {
      "name": "HostPathVolumeSource",
      "description": "*\n HostPathVolumeSource mounts a file or directory from the host node's filesystem.\n Use with caution as it ties pods to specific nodes.\n\n Common use cases:\n - Log collection DaemonSets mounting /var/log\n - Node monitoring agents mounting /sys or /proc\n - Container runtime sockets (e.g., /var/run/docker.sock)\n\n Example:\n   hostPath:\n     path: /var/log\n     type: Directory",
      "protoType": "org.openmcf.provider.kubernetes.HostPathVolumeSource",
      "fields": [
        {
          "name": "Path",
          "jsonName": "path",
          "protoField": "path",
          "type": {
            "kind": "string"
          },
          "description": "Path on the host to mount.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Type",
          "jsonName": "type",
          "protoField": "type",
          "type": {
            "kind": "string"
          },
          "description": "Type of the host path.\n Valid values:\n   \"\" - Empty string (default) means no check is performed before mounting\n   \"DirectoryOrCreate\" - Create directory if it doesn't exist\n   \"Directory\" - Directory must exist\n   \"FileOrCreate\" - Create file if it doesn't exist\n   \"File\" - File must exist\n   \"Socket\" - UNIX socket must exist\n   \"CharDevice\" - Character device must exist\n   \"BlockDevice\" - Block device must exist",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesClusterSelector",
      "description": "**KubernetesClusterSelector** defines a selector for a Kubernetes cluster in the same environment as the addon.",
      "protoType": "org.openmcf.provider.kubernetes.KubernetesClusterSelector",
      "fields": [
        {
          "name": "ClusterKind",
          "jsonName": "clusterKind",
          "protoField": "cluster_kind",
          "type": {
            "kind": "enum",
            "enumType": "org.openmcf.shared.cloudresourcekind.CloudResourceKind",
            "enumValues": [
              "TestCloudResourceOne",
              "TestCloudResourceTwo",
              "TestCloudResourceThree",
              "ConfluentKafka",
              "MongodbAtlas",
              "SnowflakeDatabase",
              "AwsAlb",
              "AwsCertManagerCert",
              "AwsCloudFront",
              "AwsDynamodb",
              "AwsEcrRepo",
              "AwsEcsCluster",
              "AwsEcsService",
              "AwsEksCluster",
              "AwsIamRole",
              "AwsLambda",
              "AwsRdsCluster",
              "AwsRdsInstance",
              "AwsRoute53Zone",
              "AwsS3Bucket",
              "AwsSecretsManager",
              "AwsSecurityGroup",
              "AwsVpc",
              "AwsEksNodeGroup",
              "AwsIamUser",
              "AwsKmsKey",
              "AwsEc2Instance",
              "AwsClientVpn",
              "AwsDocumentDb",
              "AwsRoute53DnsRecord",
              "AwsS3ObjectSet",
              "AwsSqsQueue",
              "AwsSnsTopic",
              "AwsEventBridgeBus",
              "AwsEventBridgeRule",
              "AwsHttpApiGateway",
              "AwsStepFunction",
              "AwsRedisElasticache",
              "AwsOpenSearchDomain",
              "AwsMemcachedElasticache",
              "AwsServerlessElasticache",
              "AwsNetworkLoadBalancer",
              "AwsElasticIp",
              "AwsTransitGateway",
              "AwsGlobalAccelerator",
              "AwsElasticFileSystem",
              "AwsFsxLustreFileSystem",
              "AwsFsxOpenzfsFileSystem",
              "AwsFsxWindowsFileSystem",
              "AwsFsxOntapFileSystem",
              "AwsFsxOntapStorageVirtualMachine",
              "AwsFsxOntapVolume",
              "AwsCognitoUserPool",
              "AwsCognitoIdentityProvider",
              "AwsWafWebAcl",
              "AwsCloudwatchLogGroup",
              "AwsCloudwatchAlarm",
              "AwsKinesisStream",
              "AwsKinesisFirehose",
              "AwsKinesisStreamConsumer",
              "AwsAthenaWorkgroup",
              "AwsGlueCatalogDatabase",
              "AwsRedshiftCluster",
              "AwsSagemakerDomain",
              "AwsAppRunnerService",
              "AwsBatchComputeEnvironment",
              "AwsCodeBuildProject",
              "AwsCodePipeline",
              "AwsMwaaEnvironment",
              "AwsNeptuneCluster",
              "AwsMemorydbCluster",
              "AwsMskCluster",
              "AzureResourceGroup",
              "AzureAksCluster",
              "AzureAksNodePool",
              "AzureContainerRegistry",
              "AzureDnsZone",
              "AzureKeyVault",
              "AzureVpc",
              "AzureNatGateway",
              "AzureVirtualMachine",
              "AzureStorageAccount",
              "AzureDnsRecord",
              "AzureSubnet",
              "AzureNetworkSecurityGroup",
              "AzurePublicIp",
              "AzurePrivateEndpoint",
              "AzurePrivateDnsZone",
              "AzureApplicationGateway",
              "AzureLoadBalancer",
              "AzurePostgresqlFlexibleServer",
              "AzureRedisCache",
              "AzureCosmosdbAccount",
              "AzureMssqlServer",
              "AzureMysqlFlexibleServer",
              "AzureContainerAppEnvironment",
              "AzureContainerApp",
              "AzureServicePlan",
              "AzureFunctionApp",
              "AzureLinuxWebApp",
              "AzureLogAnalyticsWorkspace",
              "AzureApplicationInsights",
              "AzureUserAssignedIdentity",
              "AzureServiceBusNamespace",
              "AzureEventHubNamespace",
              "AzureFrontDoorProfile",
              "GcpArtifactRegistryRepo",
              "GcpCloudCdn",
              "GcpCloudFunction",
              "GcpCloudRun",
              "GcpCloudSql",
              "GcpDnsZone",
              "GcpGcsBucket",
              "GcpGkeCluster",
              "GcpSecretsManager",
              "GcpProject",
              "GcpVpc",
              "GcpSubnetwork",
              "GcpRouterNat",
              "GcpGkeNodePool",
              "GcpServiceAccount",
              "GcpGkeWorkloadIdentityBinding",
              "GcpCertManagerCert",
              "GcpComputeInstance",
              "GcpDnsRecord",
              "GcpFirewallRule",
              "GcpGlobalAddress",
              "GcpCloudArmorPolicy",
              "GcpAlloydbCluster",
              "GcpRedisInstance",
              "GcpFirestoreDatabase",
              "GcpSpannerInstance",
              "GcpSpannerDatabase",
              "GcpBigtableInstance",
              "GcpMemorystoreInstance",
              "GcpBigQueryDataset",
              "GcpDataprocCluster",
              "GcpDataprocVirtualCluster",
              "GcpPubSubTopic",
              "GcpPubSubSubscription",
              "GcpCloudTasksQueue",
              "GcpCloudSchedulerJob",
              "GcpVertexAiNotebook",
              "GcpVertexAiEndpoint",
              "GcpCloudComposerEnvironment",
              "GcpKmsKeyRing",
              "GcpKmsKey",
              "GcpFilestoreInstance",
              "KubernetesArgocd",
              "KubernetesCronJob",
              "KubernetesElasticsearch",
              "KubernetesGitlab",
              "KubernetesGrafana",
              "KubernetesHelmRelease",
              "KubernetesJenkins",
              "KubernetesKafka",
              "KubernetesKeycloak",
              "KubernetesLocust",
              "KubernetesDeployment",
              "KubernetesMongodb",
              "KubernetesNeo4j",
              "KubernetesOpenFga",
              "KubernetesPostgres",
              "KubernetesPrometheus",
              "KubernetesRedis",
              "KubernetesSignoz",
              "KubernetesSolr",
              "KubernetesTemporal",
              "KubernetesNats",
              "KubernetesCertManager",
              "KubernetesElasticOperator",
              "KubernetesExternalDns",
              "KubernetesIngressNginx",
              "KubernetesIstio",
              "KubernetesStrimziKafkaOperator",
              "KubernetesZalandoPostgresOperator",
              "KubernetesSolrOperator",
              "KubernetesExternalSecrets",
              "KubernetesClickHouse",
              "KubernetesAltinityOperator",
              "KubernetesPerconaPostgresOperator",
              "KubernetesPerconaMongoOperator",
              "KubernetesPerconaMysqlOperator",
              "KubernetesHarbor",
              "KubernetesNamespace",
              "KubernetesGatewayApiCrds",
              "KubernetesTektonOperator",
              "KubernetesTekton",
              "KubernetesStatefulSet",
              "KubernetesDaemonSet",
              "KubernetesManifest",
              "KubernetesGhaRunnerScaleSetController",
              "KubernetesGhaRunnerScaleSet",
              "KubernetesOpenBao",
              "KubernetesJob",
              "KubernetesRookCephOperator",
              "KubernetesRookCephCluster",
              "KubernetesService",
              "KubernetesSecret",
              "DigitalOceanAppPlatformService",
              "DigitalOceanBucket",
              "DigitalOceanContainerRegistry",
              "DigitalOceanDatabaseCluster",
              "DigitalOceanDnsZone",
              "DigitalOceanDroplet",
              "DigitalOceanFirewall",
              "DigitalOceanFunction",
              "DigitalOceanKubernetesCluster",
              "DigitalOceanKubernetesNodePool",
              "DigitalOceanLoadBalancer",
              "DigitalOceanVolume",
              "DigitalOceanVpc",
              "DigitalOceanCertificate",
              "DigitalOceanDnsRecord",
              "CivoBucket",
              "CivoCertificate",
              "CivoComputeInstance",
              "CivoDatabase",
              "CivoDnsZone",
              "CivoFirewall",
              "CivoIpAddress",
              "CivoKubernetesCluster",
              "CivoKubernetesNodePool",
              "CivoVolume",
              "CivoVpc",
              "CivoDnsRecord",
              "CloudflareDnsZone",
              "CloudflareKvNamespace",
              "CloudflareR2Bucket",
              "CloudflareWorker",
              "CloudflareLoadBalancer",
              "CloudflareD1Database",
              "CloudflareZeroTrustAccessApplication",
              "CloudflareDnsRecord",
              "Auth0Connection",
              "Auth0Client",
              "Auth0EventStream",
              "Auth0ResourceServer",
              "OpenFgaStore",
              "OpenFgaAuthorizationModel",
              "OpenFgaRelationshipTuple",
              "OpenStackKeypair",
              "OpenStackNetwork",
              "OpenStackSubnet",
              "OpenStackRouter",
              "OpenStackRouterInterface",
              "OpenStackSecurityGroup",
              "OpenStackFloatingIp",
              "OpenStackNetworkPort",
              "OpenStackSecurityGroupRule",
              "OpenStackFloatingIpAssociate",
              "OpenStackInstance",
              "OpenStackServerGroup",
              "OpenStackVolume",
              "OpenStackVolumeAttach",
              "OpenStackProject",
              "OpenStackApplicationCredential",
              "OpenStackImage",
              "OpenStackRoleAssignment",
              "OpenStackLoadBalancer",
              "OpenStackLoadBalancerListener",
              "OpenStackLoadBalancerPool",
              "OpenStackLoadBalancerMember",
              "OpenStackLoadBalancerMonitor",
              "OpenStackDnsZone",
              "OpenStackDnsRecord",
              "OpenStackContainerClusterTemplate",
              "OpenStackContainerCluster",
              "ScalewayVpc",
              "ScalewayPrivateNetwork",
              "ScalewayPublicGateway",
              "ScalewayLoadBalancer",
              "ScalewayInstanceSecurityGroup",
              "ScalewayInstance",
              "ScalewayKapsuleCluster",
              "ScalewayKapsulePool",
              "ScalewayRdbInstance",
              "ScalewayRedisCluster",
              "ScalewayMongodbInstance",
              "ScalewayObjectBucket",
              "ScalewayBlockVolume",
              "ScalewayContainerRegistry",
              "ScalewayDnsZone",
              "ScalewayDnsRecord",
              "ScalewayServerlessFunction",
              "ScalewayServerlessContainer",
              "AliCloudLogProject",
              "AliCloudRamRole",
              "AliCloudRamPolicy",
              "AliCloudVpc",
              "AliCloudVswitch",
              "AliCloudSecurityGroup",
              "AliCloudEipAddress",
              "AliCloudNatGateway",
              "AliCloudApplicationLoadBalancer",
              "AliCloudNetworkLoadBalancer",
              "AliCloudVpnGateway",
              "AliCloudDnsZone",
              "AliCloudDnsRecord",
              "AliCloudPrivateDnsZone",
              "AliCloudStorageBucket",
              "AliCloudNasFileSystem",
              "AliCloudKmsKey",
              "AliCloudRdsInstance",
              "AliCloudPolardbCluster",
              "AliCloudRedisInstance",
              "AliCloudMongodbInstance",
              "AliCloudEcsInstance",
              "AliCloudContainerRegistry",
              "AliCloudKubernetesCluster",
              "AliCloudKubernetesNodePool",
              "AliCloudCdnDomain",
              "AliCloudFunction",
              "AliCloudSaeApplication",
              "AliCloudRocketmqInstance",
              "AliCloudCenInstance",
              "OciVcn",
              "OciSubnet",
              "OciSecurityGroup",
              "OciCompartment",
              "OciIdentityPolicy",
              "OciDynamicGroup",
              "OciComputeInstance",
              "OciContainerEngineCluster",
              "OciContainerEngineNodePool",
              "OciContainerInstance",
              "OciApplicationLoadBalancer",
              "OciNetworkLoadBalancer",
              "OciDynamicRoutingGateway",
              "OciPublicIp",
              "OciAutonomousDatabase",
              "OciDbSystem",
              "OciMysqlDbSystem",
              "OciPostgresqlDbSystem",
              "OciRedisCluster",
              "OciNosqlTable",
              "OciObjectStorageBucket",
              "OciFileSystem",
              "OciBlockVolume",
              "OciKmsVault",
              "OciKmsKey",
              "OciVaultSecret",
              "OciBastion",
              "OciFunctionsApplication",
              "OciApiGateway",
              "OciStreamPool",
              "OciQueue",
              "OciAlarm",
              "OciLogGroup",
              "OciDnsZone",
              "OciDnsRecord",
              "OciNetworkFirewall",
              "OciDevopsProject",
              "HetznerCloudSshKey",
              "HetznerCloudPlacementGroup",
              "HetznerCloudFirewall",
              "HetznerCloudNetwork",
              "HetznerCloudPrimaryIp",
              "HetznerCloudFloatingIp",
              "HetznerCloudServer",
              "HetznerCloudVolume",
              "HetznerCloudSnapshot",
              "HetznerCloudCertificate",
              "HetznerCloudLoadBalancer",
              "HetznerCloudDnsZone"
            ]
          },
          "description": "can be one of the supported kubernetes cluster kinds",
          "required": false
        },
        {
          "name": "ClusterName",
          "jsonName": "clusterName",
          "protoField": "cluster_name",
          "type": {
            "kind": "string"
          },
          "description": "name of the kubernetes cluster in the same environment as the addon\n if the name is different from slug, use the value of slug here.\n for the purposes of readbility, this field is named as cluster_name vs cluster_slug but the expected value is always slug.\n the provided value is automatically converted to slug for example Prod Cluster -\u003e prod-cluster.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentAvailability",
      "description": "*\n **KubernetesDeploymentAvailability** specifies the availability configuration for the microservice.\n Groups all settings related to high availability: replicas, autoscaling, deployment strategy, and disruption budgets.\n Proper configuration of these fields enables zero-downtime deployments and resilient operations.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability",
      "fields": [
        {
          "name": "MinReplicas",
          "jsonName": "minReplicas",
          "protoField": "min_replicas",
          "type": {
            "kind": "int32"
          },
          "description": "The minimum number of pod replicas to maintain.",
          "required": false
        },
        {
          "name": "HorizontalPodAutoscaling",
          "jsonName": "horizontalPodAutoscaling",
          "protoField": "horizontal_pod_autoscaling",
          "type": {
            "kind": "message",
            "messageType": "KubernetesDeploymentAvailabilityHpa"
          },
          "description": "The configuration for horizontal pod autoscaling.",
          "required": false
        },
        {
          "name": "DeploymentStrategy",
          "jsonName": "deploymentStrategy",
          "protoField": "deployment_strategy",
          "type": {
            "kind": "message",
            "messageType": "KubernetesDeploymentDeploymentStrategy"
          },
          "description": "Deployment strategy configuration for rolling updates.\n Controls how pod updates are rolled out to achieve zero-downtime deployments.\n If not specified, uses Kubernetes default (maxUnavailable: 25%, maxSurge: 25%).",
          "required": false
        },
        {
          "name": "PodDisruptionBudget",
          "jsonName": "podDisruptionBudget",
          "protoField": "pod_disruption_budget",
          "type": {
            "kind": "message",
            "messageType": "KubernetesDeploymentPodDisruptionBudget"
          },
          "description": "Pod disruption budget configuration.\n Ensures minimum availability during voluntary disruptions (node maintenance, cluster upgrades).\n Helps prevent service outages during infrastructure operations.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentAvailabilityHpa",
      "description": "*\n **KubernetesDeploymentAvailabilityHpa** specifies the horizontal pod autoscaling configuration.\n It includes settings to enable autoscaling based on CPU and memory utilization.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa",
      "fields": [
        {
          "name": "IsEnabled",
          "jsonName": "isEnabled",
          "protoField": "is_enabled",
          "type": {
            "kind": "bool"
          },
          "description": "A flag to enable or disable horizontal pod autoscaling.",
          "required": false
        },
        {
          "name": "TargetCpuUtilizationPercent",
          "jsonName": "targetCpuUtilizationPercent",
          "protoField": "target_cpu_utilization_percent",
          "type": {
            "kind": "double"
          },
          "description": "The target CPU utilization percentage to trigger autoscaling (e.g., 60.0).",
          "required": false
        },
        {
          "name": "TargetMemoryUtilization",
          "jsonName": "targetMemoryUtilization",
          "protoField": "target_memory_utilization",
          "type": {
            "kind": "string"
          },
          "description": "The target memory utilization to trigger autoscaling (e.g., \"1Gi\").",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentContainer",
      "description": "*\n **KubernetesDeploymentContainer** specifies the container configuration for the microservice.\n It includes the main application container and any sidecar containers that need to run alongside it.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer",
      "fields": [
        {
          "name": "App",
          "jsonName": "app",
          "protoField": "app",
          "type": {
            "kind": "message",
            "messageType": "KubernetesDeploymentContainerApp"
          },
          "description": "The main application container specifications.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Sidecars",
          "jsonName": "sidecars",
          "protoField": "sidecars",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "message",
              "messageType": "Container"
            }
          },
          "description": "A list of sidecar containers to be deployed alongside the main application container.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentContainerApp",
      "description": "*\n **KubernetesDeploymentContainerApp** specifies the configuration for the main application container.\n It includes the container image, resource allocations, environment variables, ports, and health probes.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp",
      "fields": [
        {
          "name": "Image",
          "jsonName": "image",
          "protoField": "image",
          "type": {
            "kind": "message",
            "messageType": "ContainerImage"
          },
          "description": "*\n The container image to be used for the application.\n This value is computed during creation but can be updated.\n It is derived by combining the Docker repository of the artifact store configured for the environment and the code project path.\n The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes Deployment resource.\n It is determined by looking up the `container_image_artifact_store_id` from the environment where the microservice is deployed.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Resources",
          "jsonName": "resources",
          "protoField": "resources",
          "type": {
            "kind": "message",
            "messageType": "ContainerResources"
          },
          "description": "The CPU and memory resources allocated to the application container.",
          "required": false
        },
        {
          "name": "Env",
          "jsonName": "env",
          "protoField": "env",
          "type": {
            "kind": "message",
            "messageType": "KubernetesDeploymentContainerAppEnv"
          },
          "description": "*\n The environment variables and secrets for the application container.",
          "required": false
        },
        {
          "name": "Ports",
          "jsonName": "ports",
          "protoField": "ports",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "message",
              "messageType": "KubernetesDeploymentContainerAppPort"
            }
          },
          "description": "*\n A list of ports to be configured for the application container.",
          "required": false
        },
        {
          "name": "LivenessProbe",
          "jsonName": "livenessProbe",
          "protoField": "liveness_probe",
          "type": {
            "kind": "message",
            "messageType": "Probe"
          },
          "description": "*\n Liveness probe configuration.\n Periodic probe of container liveness. Container will be restarted if the probe fails.\n This helps detect and recover from deadlocks or unresponsive applications.\n Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes",
          "required": false
        },
        {
          "name": "ReadinessProbe",
          "jsonName": "readinessProbe",
          "protoField": "readiness_probe",
          "type": {
            "kind": "message",
            "messageType": "Probe"
          },
          "description": "*\n Readiness probe configuration.\n Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails.\n This ensures traffic is only routed to pods that are ready to handle requests.\n Essential for zero-downtime deployments.\n Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes",
          "required": false
        },
        {
          "name": "StartupProbe",
          "jsonName": "startupProbe",
          "protoField": "startup_probe",
          "type": {
            "kind": "message",
            "messageType": "Probe"
          },
          "description": "*\n Startup probe configuration.\n Indicates whether the application within the container is started.\n All other probes are disabled if a startup probe is provided, until it succeeds.\n Useful for slow-starting containers to avoid them getting killed by liveness probes before they are up.\n Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes",
          "required": false
        },
        {
          "name": "VolumeMounts",
          "jsonName": "volumeMounts",
          "protoField": "volume_mounts",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "message",
              "messageType": "VolumeMount"
            }
          },
          "description": "*\n Volume mounts for the application container.\n Supports mounting ConfigMaps, Secrets, HostPaths, EmptyDirs, and PVCs.\n ConfigMaps defined in spec.config_maps can be referenced here.\n\n Example:\n   volume_mounts:\n     - name: config-volume\n       mount_path: /etc/app/config.yaml\n       config_map:\n         name: app-config\n         key: app-config",
          "required": false
        },
        {
          "name": "Command",
          "jsonName": "command",
          "protoField": "command",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "string"
            }
          },
          "description": "*\n Command to run in the container (overrides the container image's ENTRYPOINT).\n Example: [\"/bin/sh\", \"-c\"]",
          "required": false
        },
        {
          "name": "Args",
          "jsonName": "args",
          "protoField": "args",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "string"
            }
          },
          "description": "*\n Arguments to pass to the command (overrides the container image's CMD).\n Example: [\"echo hello\"]",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentContainerAppEnv",
      "description": "*\n **KubernetesDeploymentContainerAppEnv** defines the environment variables and secrets for the application container.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv",
      "fields": [
        {
          "name": "Variables",
          "jsonName": "variables",
          "protoField": "variables",
          "type": {
            "kind": "map",
            "keyType": {
              "kind": "string"
            },
            "valueType": {
              "kind": "string"
            }
          },
          "description": "*\n A map of environment variable names to their values.\n Each variable can be provided either as a literal string value or as a reference\n to another OpenMCF resource's field.\n\n **Option 1: Direct string value**\n ```yaml\n variables:\n   DATABASE_PORT:\n     value: \"5432\"\n ```\n\n **Option 2: Reference to another resource's field**\n ```yaml\n variables:\n   DATABASE_HOST:\n     valueFrom:\n       kind: PostgresCluster\n       name: my-postgres\n       fieldPath: \"status.outputs.host\"\n ```\n\n When using valueFrom references, the orchestrator resolves the reference\n and populates the value field before invoking the IaC modules.",
          "required": false
        },
        {
          "name": "Secrets",
          "jsonName": "secrets",
          "protoField": "secrets",
          "type": {
            "kind": "map",
            "keyType": {
              "kind": "string"
            },
            "valueType": {
              "kind": "message",
              "messageType": "KubernetesSensitiveValue"
            }
          },
          "description": "*\n A map of secret environment variable names to their values.\n Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret.\n\n Using secret references is recommended for production deployments to avoid storing\n sensitive values in plain text within configuration files or version control.\n\n **Option 1: Direct string value (for development/testing)**\n ```yaml\n secrets:\n   DATABASE_PASSWORD:\n     stringValue: my-password\n ```\n\n **Option 2: Kubernetes Secret reference (recommended for production)**\n ```yaml\n secrets:\n   DATABASE_PASSWORD:\n     secretRef:\n       name: my-app-secrets\n       key: db-password\n ```\n\n When using string values, a Kubernetes Secret is automatically created and the environment\n variable references that secret. When using secret references, the environment variable\n directly references the specified external Kubernetes Secret.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentContainerAppPort",
      "description": "*\n **KubernetesDeploymentContainerAppPort** specifies the port configuration for the application container.\n It includes details such as the port name, container port, network protocol, application protocol, and service port.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "The name of the port (e.g., \"http\", \"grpc\").\nThe name must only contain lowercase alphanumeric characters and hyphens.\nPort names must also start and end with an alphanumeric character.\nFor example, \"123-abc\" and \"web\" are valid, but \"123_abc\" and \"-web\" are not.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "ContainerPort",
          "jsonName": "containerPort",
          "protoField": "container_port",
          "type": {
            "kind": "int32"
          },
          "description": "The port number on the container.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "NetworkProtocol",
          "jsonName": "networkProtocol",
          "protoField": "network_protocol",
          "type": {
            "kind": "string"
          },
          "description": "The network protocol used by the port (e.g., \"TCP\", \"UDP\", \"SCTP\").\nMust be one of \"TCP\", \"UDP\", or \"SCTP\".",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "AppProtocol",
          "jsonName": "appProtocol",
          "protoField": "app_protocol",
          "type": {
            "kind": "string"
          },
          "description": "The application protocol for the microservice (e.g., \"http\").\nThis field is used for setting up the name of the service port in Kubernetes.\nIt is used during microservice deployment and is relevant for deployment and stateful set pod managers.\nRefer to: https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "ServicePort",
          "jsonName": "servicePort",
          "protoField": "service_port",
          "type": {
            "kind": "int32"
          },
          "description": "The port number on the Kubernetes service.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "IsIngressPort",
          "jsonName": "isIngressPort",
          "protoField": "is_ingress_port",
          "type": {
            "kind": "bool"
          },
          "description": "A flag indicating whether this port should be exposed via ingress.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentDeploymentStrategy",
      "description": "*\n **KubernetesDeploymentDeploymentStrategy** defines the deployment strategy for rolling updates.\n This controls how Kubernetes replaces old pods with new ones during updates.\n Proper configuration enables zero-downtime deployments.\n Reference: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy",
      "fields": [
        {
          "name": "MaxUnavailable",
          "jsonName": "maxUnavailable",
          "protoField": "max_unavailable",
          "type": {
            "kind": "string"
          },
          "description": "*\n The maximum number of pods that can be unavailable during the update.\n Can be an absolute number (e.g., 0) or a percentage of desired pods (e.g., \"25%\").\n\n For zero-downtime deployments, set to 0 or \"0%\".\n This ensures at least the desired number of pods are always available.\n\n Defaults to 25% if not specified.\n Cannot be 0 if max_surge is also 0.",
          "required": false
        },
        {
          "name": "MaxSurge",
          "jsonName": "maxSurge",
          "protoField": "max_surge",
          "type": {
            "kind": "string"
          },
          "description": "*\n The maximum number of pods that can be created above the desired number of pods.\n Can be an absolute number (e.g., 1) or a percentage of desired pods (e.g., \"25%\").\n\n For zero-downtime deployments with max_unavailable=0, set to at least 1 or \"100%\".\n This allows new pods to be created before old ones are terminated.\n\n Defaults to 25% if not specified.\n Cannot be 0 if max_unavailable is also 0.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentIngress",
      "description": "*\n KubernetesDeploymentIngress defines ingress configuration for the deployment.",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress",
      "fields": [
        {
          "name": "Enabled",
          "jsonName": "enabled",
          "protoField": "enabled",
          "type": {
            "kind": "bool"
          },
          "description": "Flag to enable or disable ingress.",
          "required": false
        },
        {
          "name": "Hostname",
          "jsonName": "hostname",
          "protoField": "hostname",
          "type": {
            "kind": "string"
          },
          "description": "The full hostname for external access (e.g., \"myapp.example.com\").\n Required when enabled is true.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesDeploymentPodDisruptionBudget",
      "description": "*\n **KubernetesDeploymentPodDisruptionBudget** configures a PodDisruptionBudget (PDB) to ensure\n minimum availability during voluntary disruptions like node maintenance or cluster upgrades.\n Reference: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/",
      "protoType": "org.openmcf.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget",
      "fields": [
        {
          "name": "Enabled",
          "jsonName": "enabled",
          "protoField": "enabled",
          "type": {
            "kind": "bool"
          },
          "description": "*\n Enable or disable PodDisruptionBudget creation.\n When disabled, no PDB is created and the cluster can evict pods freely.\n When enabled, the cluster must respect the min_available constraint.",
          "required": false
        },
        {
          "name": "MinAvailable",
          "jsonName": "minAvailable",
          "protoField": "min_available",
          "type": {
            "kind": "string"
          },
          "description": "*\n Minimum number of pods that must be available during voluntary disruptions.\n Can be an absolute number (e.g., 1) or a percentage (e.g., \"50%\").\n\n For high availability, typically set to:\n - 1 for single-replica services (ensures at least one pod always available)\n - N-1 for N-replica services (allows one pod to be disrupted at a time)\n - A percentage like \"50%\" for large replica counts\n\n Cannot be used together with max_unavailable.\n If both min_available and max_unavailable are not set, defaults to 1.",
          "required": false
        },
        {
          "name": "MaxUnavailable",
          "jsonName": "maxUnavailable",
          "protoField": "max_unavailable",
          "type": {
            "kind": "string"
          },
          "description": "*\n Maximum number of pods that can be unavailable during voluntary disruptions.\n Can be an absolute number (e.g., 1) or a percentage (e.g., \"50%\").\n\n This is an alternative to min_available.\n Cannot be used together with min_available.",
          "required": false
        }
      ]
    },
    {
      "name": "KubernetesSecretKeyRef",
      "description": "*\n **KubernetesSecretKeyRef** is a reference to a specific key within a Kubernetes Secret.\n This allows components to retrieve sensitive values from existing secrets rather than\n storing them as plain text in the configuration.",
      "protoType": "org.openmcf.provider.kubernetes.KubernetesSecretKeyRef",
      "fields": [
        {
          "name": "Namespace",
          "jsonName": "namespace",
          "protoField": "namespace",
          "type": {
            "kind": "string"
          },
          "description": "*\n The namespace of the Kubernetes Secret.\n If not specified, defaults to the namespace where the component is deployed.\n Note: Cross-namespace secret references may not be supported by all Helm charts.",
          "required": false
        },
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "*\n The name of the Kubernetes Secret.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Key",
          "jsonName": "key",
          "protoField": "key",
          "type": {
            "kind": "string"
          },
          "description": "*\n The key within the Kubernetes Secret that contains the value.",
          "required": true,
          "validation": {
            "required": true
          }
        }
      ]
    },
    {
      "name": "KubernetesSensitiveValue",
      "description": "*\n **KubernetesSensitiveValue** represents a sensitive value that can be provided either\n as a literal string or as a reference to a Kubernetes Secret.\n\n Using secret references is recommended for production deployments to avoid storing\n sensitive values in plain text within configuration files or version control.",
      "protoType": "org.openmcf.provider.kubernetes.KubernetesSensitiveValue",
      "fields": [
        {
          "name": "Value",
          "jsonName": "value",
          "protoField": "value",
          "type": {
            "kind": "string"
          },
          "description": "*\n A literal string value.\n Warning: Using plain text for sensitive values is not recommended for production.\n Consider using secret_ref instead.",
          "required": false,
          "oneofGroup": "sensitive_value"
        },
        {
          "name": "SecretRef",
          "jsonName": "secretRef",
          "protoField": "secret_ref",
          "type": {
            "kind": "message",
            "messageType": "KubernetesSecretKeyRef"
          },
          "description": "*\n A reference to a key within a Kubernetes Secret.\n The secret must exist in the cluster before the component is deployed.",
          "required": false,
          "oneofGroup": "sensitive_value"
        }
      ]
    },
    {
      "name": "Probe",
      "description": "**Probe** defines a health check to be performed against a container to determine whether it is\n alive, ready, or has started successfully. Probes are essential for zero-downtime deployments.\n Reference: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/",
      "protoType": "org.openmcf.provider.kubernetes.Probe",
      "fields": [
        {
          "name": "InitialDelaySeconds",
          "jsonName": "initialDelaySeconds",
          "protoField": "initial_delay_seconds",
          "type": {
            "kind": "int32"
          },
          "description": "Number of seconds after the container has started before liveness or readiness probes are initiated.\n Defaults to 0 seconds. Minimum value is 0.",
          "required": false
        },
        {
          "name": "PeriodSeconds",
          "jsonName": "periodSeconds",
          "protoField": "period_seconds",
          "type": {
            "kind": "int32"
          },
          "description": "How often (in seconds) to perform the probe.\n Default to 10 seconds. Minimum value is 1.",
          "required": false
        },
        {
          "name": "TimeoutSeconds",
          "jsonName": "timeoutSeconds",
          "protoField": "timeout_seconds",
          "type": {
            "kind": "int32"
          },
          "description": "Number of seconds after which the probe times out.\n Defaults to 1 second. Minimum value is 1.",
          "required": false
        },
        {
          "name": "SuccessThreshold",
          "jsonName": "successThreshold",
          "protoField": "success_threshold",
          "type": {
            "kind": "int32"
          },
          "description": "Minimum consecutive successes for the probe to be considered successful after having failed.\n Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
          "required": false
        },
        {
          "name": "FailureThreshold",
          "jsonName": "failureThreshold",
          "protoField": "failure_threshold",
          "type": {
            "kind": "int32"
          },
          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded.\n Defaults to 3. Minimum value is 1.",
          "required": false
        },
        {
          "name": "HttpGet",
          "jsonName": "httpGet",
          "protoField": "http_get",
          "type": {
            "kind": "message",
            "messageType": "HTTPGetAction"
          },
          "description": "HTTPGet specifies the http request to perform.",
          "required": false,
          "oneofGroup": "handler"
        },
        {
          "name": "Grpc",
          "jsonName": "grpc",
          "protoField": "grpc",
          "type": {
            "kind": "message",
            "messageType": "GRPCAction"
          },
          "description": "GRPC specifies an action involving a GRPC port.",
          "required": false,
          "oneofGroup": "handler"
        },
        {
          "name": "TcpSocket",
          "jsonName": "tcpSocket",
          "protoField": "tcp_socket",
          "type": {
            "kind": "message",
            "messageType": "TCPSocketAction"
          },
          "description": "TCPSocket specifies an action involving a TCP port.",
          "required": false,
          "oneofGroup": "handler"
        },
        {
          "name": "Exec",
          "jsonName": "exec",
          "protoField": "exec",
          "type": {
            "kind": "message",
            "messageType": "ExecAction"
          },
          "description": "Exec specifies a command to execute inside the container.",
          "required": false,
          "oneofGroup": "handler"
        }
      ]
    },
    {
      "name": "PvcVolumeSource",
      "description": "*\n PvcVolumeSource mounts an existing PersistentVolumeClaim.\n\n For StatefulSets: The claimName can reference a volumeClaimTemplate name,\n and the StatefulSet controller will automatically handle per-pod PVC binding.\n\n Example:\n   pvc:\n     claimName: data-volume\n     readOnly: false",
      "protoType": "org.openmcf.provider.kubernetes.PvcVolumeSource",
      "fields": [
        {
          "name": "ClaimName",
          "jsonName": "claimName",
          "protoField": "claim_name",
          "type": {
            "kind": "string"
          },
          "description": "Name of the PersistentVolumeClaim to mount.\n For StatefulSets, this can be the name of a volumeClaimTemplate.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "ReadOnly",
          "jsonName": "readOnly",
          "protoField": "read_only",
          "type": {
            "kind": "bool"
          },
          "description": "Whether the PVC should be mounted read-only.\n Default is false.",
          "required": false
        }
      ]
    },
    {
      "name": "SecretVolumeSource",
      "description": "*\n SecretVolumeSource mounts a Secret as a volume.\n Works similarly to ConfigMapVolumeSource but for sensitive data.\n\n Example:\n   secret:\n     name: tls-certs\n     key: tls.crt\n     path: server.crt",
      "protoType": "org.openmcf.provider.kubernetes.SecretVolumeSource",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "Name of the Secret to mount.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Key",
          "jsonName": "key",
          "protoField": "key",
          "type": {
            "kind": "string"
          },
          "description": "Specific key from the Secret to mount as a single file.\n If not specified, all keys are mounted as files in the directory.",
          "required": false
        },
        {
          "name": "Path",
          "jsonName": "path",
          "protoField": "path",
          "type": {
            "kind": "string"
          },
          "description": "If key is specified, this is the filename to use for the mounted file.\n Defaults to the key name if not specified.",
          "required": false
        },
        {
          "name": "DefaultMode",
          "jsonName": "defaultMode",
          "protoField": "default_mode",
          "type": {
            "kind": "int32"
          },
          "description": "Mode bits to use on created files. Must be a value between 0 and 0777.\n Defaults to 0644.",
          "required": false
        }
      ]
    },
    {
      "name": "TCPSocketAction",
      "description": "**TCPSocketAction** describes an action based on opening a socket.",
      "protoType": "org.openmcf.provider.kubernetes.TCPSocketAction",
      "fields": [
        {
          "name": "PortNumber",
          "jsonName": "portNumber",
          "protoField": "port_number",
          "type": {
            "kind": "int32"
          },
          "required": false,
          "oneofGroup": "port"
        },
        {
          "name": "PortName",
          "jsonName": "portName",
          "protoField": "port_name",
          "type": {
            "kind": "string"
          },
          "required": false,
          "oneofGroup": "port"
        },
        {
          "name": "Host",
          "jsonName": "host",
          "protoField": "host",
          "type": {
            "kind": "string"
          },
          "description": "Host name to connect to, defaults to the pod IP.",
          "required": false
        }
      ]
    },
    {
      "name": "VolumeMount",
      "description": "*\n VolumeMount defines how to mount a volume into a container.\n Supports multiple volume types: ConfigMap, Secret, HostPath, EmptyDir, and PVC.\n Only one volume source should be specified per mount.\n\n Example usage:\n   volumeMounts:\n     - name: config\n       mountPath: /etc/app/config.yaml\n       configMap:\n         name: app-config\n         key: config.yaml\n     - name: logs\n       mountPath: /var/log\n       hostPath:\n         path: /var/log\n         type: Directory",
      "protoType": "org.openmcf.provider.kubernetes.VolumeMount",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "Name of the volume mount. Must be unique within the container.\n Used to correlate with the volume definition.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "MountPath",
          "jsonName": "mountPath",
          "protoField": "mount_path",
          "type": {
            "kind": "string"
          },
          "description": "Path within the container at which the volume should be mounted.\n Must be an absolute path.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "ReadOnly",
          "jsonName": "readOnly",
          "protoField": "read_only",
          "type": {
            "kind": "bool"
          },
          "description": "Whether the volume should be mounted read-only.\n Default is false.",
          "required": false
        },
        {
          "name": "SubPath",
          "jsonName": "subPath",
          "protoField": "sub_path",
          "type": {
            "kind": "string"
          },
          "description": "Path within the volume from which the container's volume should be mounted.\n Defaults to \"\" (volume's root).\n Useful for mounting a subdirectory of a volume.",
          "required": false
        },
        {
          "name": "ConfigMap",
          "jsonName": "configMap",
          "protoField": "config_map",
          "type": {
            "kind": "message",
            "messageType": "ConfigMapVolumeSource"
          },
          "description": "ConfigMap volume source.\n Use this to mount a ConfigMap as a file or directory.",
          "required": false
        },
        {
          "name": "Secret",
          "jsonName": "secret",
          "protoField": "secret",
          "type": {
            "kind": "message",
            "messageType": "SecretVolumeSource"
          },
          "description": "Secret volume source.\n Use this to mount a Secret as a file or directory.",
          "required": false
        },
        {
          "name": "HostPath",
          "jsonName": "hostPath",
          "protoField": "host_path",
          "type": {
            "kind": "message",
            "messageType": "HostPathVolumeSource"
          },
          "description": "HostPath volume source.\n Use this to mount a file or directory from the host node's filesystem.\n Common for DaemonSets that need access to node-level resources.",
          "required": false
        },
        {
          "name": "EmptyDir",
          "jsonName": "emptyDir",
          "protoField": "empty_dir",
          "type": {
            "kind": "message",
            "messageType": "EmptyDirVolumeSource"
          },
          "description": "EmptyDir volume source.\n Use this for temporary storage that is erased when the pod is removed.\n Useful for scratch space, caching, or sharing data between containers.",
          "required": false
        },
        {
          "name": "Pvc",
          "jsonName": "pvc",
          "protoField": "pvc",
          "type": {
            "kind": "message",
            "messageType": "PvcVolumeSource"
          },
          "description": "PersistentVolumeClaim volume source.\n Use this to mount an existing PVC.\n For StatefulSets, this can reference a volumeClaimTemplate.",
          "required": false
        }
      ]
    }
  ]
}
