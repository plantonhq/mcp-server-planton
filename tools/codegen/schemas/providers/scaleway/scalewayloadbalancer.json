{
  "name": "ScalewayLoadBalancer",
  "kind": "ScalewayLoadBalancer",
  "cloudProvider": "scaleway",
  "apiVersion": "scaleway.openmcf.org/v1",
  "description": "ScalewayLoadBalancer represents a managed Scaleway Load Balancer that bundles\n a Flexible IP, the LB appliance, backend server pools, frontend listeners,\n and optional TLS certificates into a single declarative resource.\n\n This is a composite resource. Applying a single ScalewayLoadBalancer manifest\n creates up to 5 different Scaleway resource types under the hood:\n   - scaleway_lb_ip       -- Dedicated Flexible IP\n   - scaleway_lb          -- Load Balancer appliance\n   - scaleway_lb_backend  -- Backend server pool(s)\n   - scaleway_lb_frontend -- Frontend listener(s)\n   - scaleway_lb_certificate -- TLS certificate(s)",
  "protoPackage": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1",
  "protoFiles": {
    "api": "org/openmcf/provider/scaleway/scalewayloadbalancer/v1/api.proto",
    "spec": "org/openmcf/provider/scaleway/scalewayloadbalancer/v1/spec.proto"
  },
  "spec": {
    "name": "ScalewayLoadBalancerSpec",
    "fields": [
      {
        "name": "Zone",
        "jsonName": "zone",
        "protoField": "zone",
        "type": {
          "kind": "string"
        },
        "description": "The Scaleway zone where the Load Balancer will be created.\n Examples: \"fr-par-1\", \"nl-ams-1\", \"pl-waw-1\"\n\n Load Balancers are zonal resources. The zone must be within the same\n region as any Private Network the LB is attached to. For example, if\n the Private Network is in region \"fr-par\", the LB zone must be\n \"fr-par-1\", \"fr-par-2\", etc.\n\n This field is required and cannot be changed after creation.",
        "required": true,
        "validation": {
          "required": true
        }
      },
      {
        "name": "Type",
        "jsonName": "type",
        "protoField": "type",
        "type": {
          "kind": "string"
        },
        "description": "Load Balancer type determines bandwidth, throughput, and pricing tier.\n\n Available types (subject to Scaleway's current offering):\n   - \"LB-S\"     -- Small. Up to 400 Mbps. Good for development and small apps.\n   - \"LB-GP-M\"  -- Medium. Up to 4 Gbps. General-purpose production workloads.\n   - \"LB-GP-L\"  -- Large. Up to 8 Gbps. High-traffic applications.\n   - \"LB-GP-XL\" -- Extra Large. Up to 10 Gbps. Maximum throughput.\n\n Choose \"LB-S\" for development and \"LB-GP-M\" for most production workloads.\n Type can be changed after creation (scale up/down).",
        "required": true,
        "validation": {
          "required": true
        },
        "recommendedDefault": "LB-S"
      },
      {
        "name": "PrivateNetworkId",
        "jsonName": "privateNetworkId",
        "protoField": "private_network_id",
        "type": {
          "kind": "string"
        },
        "description": "The Private Network to attach the Load Balancer to.\n\n When set, the LB receives a private IP on this network and can reach\n backend servers via their private IPs. This is the recommended topology\n for production: keep backend servers off the public internet and let\n the LB handle ingress.\n\n In infra charts, this is typically wired via valueFrom:\n\n   privateNetworkId:\n     valueFrom:\n       kind: ScalewayPrivateNetwork\n       name: app-network\n       fieldPath: status.outputs.private_network_id\n\n Optional. If omitted, the LB operates on the public network only.",
        "required": false,
        "referenceKind": "ScalewayPrivateNetwork",
        "referenceFieldPath": "status.outputs.private_network_id"
      },
      {
        "name": "Description",
        "jsonName": "description",
        "protoField": "description",
        "type": {
          "kind": "string"
        },
        "description": "Human-readable description for the Load Balancer.\n\n Optional. Useful for organizational purposes in the Scaleway console.",
        "required": false
      },
      {
        "name": "SslCompatibilityLevel",
        "jsonName": "sslCompatibilityLevel",
        "protoField": "ssl_compatibility_level",
        "type": {
          "kind": "string"
        },
        "description": "Minimum SSL/TLS compatibility level for HTTPS frontends.\n\n Controls the minimum TLS version clients must support to connect.\n Options:\n   - \"ssl_compatibility_level_intermediate\" (default) -- TLS 1.2+. Broad compatibility.\n   - \"ssl_compatibility_level_modern\" -- TLS 1.3 only. Maximum security.\n\n Only relevant when using HTTPS frontends with certificates. If omitted,\n Scaleway uses the \"intermediate\" level.",
        "required": false
      },
      {
        "name": "Backends",
        "jsonName": "backends",
        "protoField": "backends",
        "type": {
          "kind": "array",
          "elementType": {
            "kind": "message",
            "messageType": "ScalewayLoadBalancerBackend"
          }
        },
        "description": "Backend pools. Each backend defines a named set of servers that receive\n traffic, along with health check rules and load-balancing configuration.\n\n At least one backend is required. Frontends reference backends by name\n to route traffic.\n\n Example: A backend named \"web\" with two server IPs on port 80.",
        "required": true,
        "validation": {
          "required": true,
          "minItems": 1
        }
      },
      {
        "name": "Frontends",
        "jsonName": "frontends",
        "protoField": "frontends",
        "type": {
          "kind": "array",
          "elementType": {
            "kind": "message",
            "messageType": "ScalewayLoadBalancerFrontend"
          }
        },
        "description": "Frontends. Each frontend defines a named listener on a specific port\n that routes incoming traffic to a backend.\n\n At least one frontend is required. Each frontend must reference a\n backend by name (the `backend_name` field must match a backend's `name`).\n\n Example: A frontend named \"http\" listening on port 80 routing to backend \"web\".",
        "required": true,
        "validation": {
          "required": true,
          "minItems": 1
        }
      },
      {
        "name": "Certificates",
        "jsonName": "certificates",
        "protoField": "certificates",
        "type": {
          "kind": "array",
          "elementType": {
            "kind": "message",
            "messageType": "ScalewayLoadBalancerCertificate"
          }
        },
        "description": "TLS certificates for HTTPS frontends.\n\n Each certificate has a name and is either auto-provisioned via Let's Encrypt\n or provided as a custom PEM chain. Frontends reference certificates by\n name in their `certificate_names` field.\n\n Optional. Only needed when frontends serve HTTPS traffic.",
        "required": false
      }
    ]
  },
  "nestedTypes": [
    {
      "name": "ScalewayLoadBalancerBackend",
      "description": "ScalewayLoadBalancerBackend defines a named backend server pool.\n\n Each backend is a group of servers (identified by IP) that receive traffic\n forwarded by one or more frontends. Backends include health check\n configuration to detect and remove unhealthy servers from rotation.\n\n Backend names must be unique within the Load Balancer spec. Frontends\n reference backends by their `name` field.",
      "protoType": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1.ScalewayLoadBalancerBackend",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "Name identifying this backend. Used by frontends to reference this pool.\n\n Must be unique within the Load Balancer spec. Use descriptive names\n like \"web\", \"api\", \"grpc\" to make the configuration self-documenting.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "ServerIps",
          "jsonName": "serverIps",
          "protoField": "server_ips",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "string"
            }
          },
          "description": "IP addresses of backend servers.\n\n These are the servers that will receive forwarded traffic. When the LB\n is attached to a Private Network, use private IPs (e.g., \"10.0.1.5\").\n Without a Private Network, use public IPs.\n\n At least one server IP is required.",
          "required": true,
          "validation": {
            "required": true,
            "minItems": 1
          }
        },
        {
          "name": "ForwardPort",
          "jsonName": "forwardPort",
          "protoField": "forward_port",
          "type": {
            "kind": "int32"
          },
          "description": "Port on backend servers that receives forwarded traffic.\n\n This is the port your application listens on (e.g., 80 for HTTP,\n 443 for HTTPS, 8080 for a custom app server).",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "ForwardProtocol",
          "jsonName": "forwardProtocol",
          "protoField": "forward_protocol",
          "type": {
            "kind": "string"
          },
          "description": "Protocol for communication between the LB and backend servers.\n\n Options: \"http\", \"https\", \"tcp\"\n   - \"http\"  -- Layer 7. The LB inspects HTTP headers. Use for web apps.\n   - \"https\" -- Layer 7 with TLS to backends (ssl_bridging). Use when\n                backends require encrypted connections.\n   - \"tcp\"   -- Layer 4. The LB forwards raw TCP. Use for databases,\n                gRPC, or any non-HTTP protocol.",
          "required": true,
          "validation": {
            "required": true
          },
          "recommendedDefault": "http"
        },
        {
          "name": "ForwardPortAlgorithm",
          "jsonName": "forwardPortAlgorithm",
          "protoField": "forward_port_algorithm",
          "type": {
            "kind": "string"
          },
          "description": "Load-balancing algorithm for distributing connections across servers.\n\n Options:\n   - \"roundrobin\" (default) -- Distribute evenly in rotation.\n   - \"leastconn\"  -- Send to the server with fewest active connections.\n   - \"first\"      -- Send to the first healthy server (active-passive).",
          "required": false,
          "recommendedDefault": "roundrobin"
        },
        {
          "name": "StickySessions",
          "jsonName": "stickySessions",
          "protoField": "sticky_sessions",
          "type": {
            "kind": "string"
          },
          "description": "Sticky session type for maintaining client affinity.\n\n Options:\n   - \"none\" (default)  -- No session affinity.\n   - \"cookie\" -- Insert an HTTP cookie to track client sessions.\n   - \"table\"  -- Use a connection table (Layer 4, for TCP backends).\n\n Use \"cookie\" for web applications that store session state server-side.\n Use \"table\" for TCP-level session affinity.",
          "required": false
        },
        {
          "name": "StickySessionsCookieName",
          "jsonName": "stickySessionsCookieName",
          "protoField": "sticky_sessions_cookie_name",
          "type": {
            "kind": "string"
          },
          "description": "Cookie name for sticky sessions. Required when sticky_sessions = \"cookie\".\n\n The LB injects this cookie into HTTP responses to track which backend\n server a client was previously routed to.\n Example: \"SERVERID\"",
          "required": false
        },
        {
          "name": "HealthCheck",
          "jsonName": "healthCheck",
          "protoField": "health_check",
          "type": {
            "kind": "message",
            "messageType": "ScalewayLoadBalancerHealthCheck"
          },
          "description": "Health check configuration for this backend.\n\n Defines how the LB probes backend servers to detect failures. Unhealthy\n servers are automatically removed from rotation and re-added when they\n recover.\n\n If omitted, a default TCP health check on the forward_port is used\n with a 5-second interval, 3-second timeout, and 3 retries.",
          "required": false
        },
        {
          "name": "TimeoutConnect",
          "jsonName": "timeoutConnect",
          "protoField": "timeout_connect",
          "type": {
            "kind": "string"
          },
          "description": "Maximum time to wait for a connection to a backend server.\n\n Duration string (e.g., \"5s\", \"10s\"). If omitted, Scaleway's default applies.\n Increase for backends with slow connection establishment (e.g., cold starts).",
          "required": false
        },
        {
          "name": "TimeoutServer",
          "jsonName": "timeoutServer",
          "protoField": "timeout_server",
          "type": {
            "kind": "string"
          },
          "description": "Maximum time a backend server connection can be idle before being closed.\n\n Duration string (e.g., \"30s\", \"5m\"). If omitted, Scaleway's default applies.\n Increase for long-polling, WebSocket, or streaming backends.",
          "required": false
        },
        {
          "name": "OnMarkedDownAction",
          "jsonName": "onMarkedDownAction",
          "protoField": "on_marked_down_action",
          "type": {
            "kind": "string"
          },
          "description": "Action when a backend server is marked as down.\n\n Options:\n   - \"none\" (default) -- Keep existing connections open.\n   - \"shutdown_sessions\" -- Immediately close all connections to the\n     downed server. Use when fast failover is more important than\n     graceful connection draining.",
          "required": false
        },
        {
          "name": "SslBridging",
          "jsonName": "sslBridging",
          "protoField": "ssl_bridging",
          "type": {
            "kind": "bool"
          },
          "description": "Enable SSL bridging (re-encrypt traffic between the LB and backends).\n\n When true, the LB establishes a new TLS connection to backend servers.\n Use when backends require encrypted connections (e.g., for compliance).\n\n Default: false (traffic between LB and backends is unencrypted).",
          "required": false
        },
        {
          "name": "ProxyProtocol",
          "jsonName": "proxyProtocol",
          "protoField": "proxy_protocol",
          "type": {
            "kind": "string"
          },
          "description": "PROXY protocol version for passing client connection metadata to backends.\n\n Options:\n   - \"none\" (default) -- No PROXY protocol.\n   - \"v1\"      -- PROXY protocol v1 (human-readable header).\n   - \"v2\"      -- PROXY protocol v2 (binary header).\n   - \"v2_ssl\"  -- v2 with SSL information.\n   - \"v2_ssl_cn\" -- v2 with SSL and client certificate CN.\n\n Use when backend servers need the original client IP (e.g., Nginx with\n `proxy_protocol` directive, HAProxy with `accept-proxy`).",
          "required": false
        }
      ]
    },
    {
      "name": "ScalewayLoadBalancerCertificate",
      "description": "ScalewayLoadBalancerCertificate defines a TLS certificate for HTTPS frontends.\n\n Each certificate has a unique name and is either auto-provisioned via\n Let's Encrypt or provided as a custom PEM chain. Frontends reference\n certificates by name in their `certificate_names` field.\n\n Exactly one of `letsencrypt` or `custom_certificate` must be set.",
      "protoType": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1.ScalewayLoadBalancerCertificate",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "Name identifying this certificate.\n\n Must be unique within the Load Balancer spec. Frontends reference\n this name in their `certificate_names` field.\n Example: \"example-com-cert\", \"wildcard-cert\"",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "Letsencrypt",
          "jsonName": "letsencrypt",
          "protoField": "letsencrypt",
          "type": {
            "kind": "message",
            "messageType": "ScalewayLoadBalancerLetsencrypt"
          },
          "description": "Let's Encrypt auto-provisioned certificate configuration.\n\n When set, Scaleway automatically provisions and renews a TLS certificate\n for the specified domain(s) using the ACME protocol. The domain must\n resolve to the LB's public IP for validation to succeed.\n\n Exactly one of `letsencrypt` or `custom_certificate` must be set.",
          "required": false
        },
        {
          "name": "CustomCertificate",
          "jsonName": "customCertificate",
          "protoField": "custom_certificate",
          "type": {
            "kind": "message",
            "messageType": "ScalewayLoadBalancerCustomCertificate"
          },
          "description": "Custom certificate configuration (user-provided PEM).\n\n When set, the user provides a full certificate chain in PEM format.\n Use this for certificates from commercial CAs, internal PKI, or\n wildcard certificates that Let's Encrypt doesn't support.\n\n Exactly one of `letsencrypt` or `custom_certificate` must be set.",
          "required": false
        }
      ]
    },
    {
      "name": "ScalewayLoadBalancerCustomCertificate",
      "description": "ScalewayLoadBalancerCustomCertificate provides a user-managed TLS certificate.\n\n Use this for certificates from commercial CAs, internal PKI, or when\n Let's Encrypt is not suitable (e.g., EV certificates, wildcard certs\n for domains that can't point to the LB during validation).",
      "protoType": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1.ScalewayLoadBalancerCustomCertificate",
      "fields": [
        {
          "name": "CertificateChain",
          "jsonName": "certificateChain",
          "protoField": "certificate_chain",
          "type": {
            "kind": "string"
          },
          "description": "Full certificate chain in PEM format.\n\n Must include the server certificate followed by any intermediate\n certificates, in order. The private key must NOT be included (it is\n managed separately by Scaleway).\n\n Example: \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\\n\"",
          "required": true,
          "validation": {
            "required": true
          }
        }
      ]
    },
    {
      "name": "ScalewayLoadBalancerFrontend",
      "description": "ScalewayLoadBalancerFrontend defines a named listener on the Load Balancer.\n\n Each frontend listens on a specific TCP port and routes incoming traffic\n to a backend server pool. For HTTPS, frontends can reference TLS\n certificates defined in the `certificates` section.\n\n Frontend names must be unique within the Load Balancer spec.",
      "protoType": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1.ScalewayLoadBalancerFrontend",
      "fields": [
        {
          "name": "Name",
          "jsonName": "name",
          "protoField": "name",
          "type": {
            "kind": "string"
          },
          "description": "Name identifying this frontend.\n\n Must be unique within the Load Balancer spec. Use descriptive names\n like \"http\", \"https\", \"grpc\", \"api-8080\".",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "InboundPort",
          "jsonName": "inboundPort",
          "protoField": "inbound_port",
          "type": {
            "kind": "int32"
          },
          "description": "TCP port to listen on for incoming connections.\n\n Common ports: 80 (HTTP), 443 (HTTPS), 8080 (alt-HTTP), 8443 (alt-HTTPS).\n Each frontend must use a unique port within the Load Balancer.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "BackendName",
          "jsonName": "backendName",
          "protoField": "backend_name",
          "type": {
            "kind": "string"
          },
          "description": "Name of the backend to route traffic to.\n\n Must match a backend's `name` field defined in `spec.backends`.\n All traffic arriving on this frontend's port is forwarded to the\n referenced backend's server pool.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "CertificateNames",
          "jsonName": "certificateNames",
          "protoField": "certificate_names",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "string"
            }
          },
          "description": "Names of TLS certificates to attach to this frontend.\n\n Must match certificate names defined in `spec.certificates`.\n Required for HTTPS frontends. Not allowed on plaintext HTTP frontends\n (Scaleway rejects certificates on port 80).\n\n Multiple certificates can be attached for SNI-based selection (the LB\n selects the correct certificate based on the client's requested hostname).",
          "required": false
        },
        {
          "name": "TimeoutClient",
          "jsonName": "timeoutClient",
          "protoField": "timeout_client",
          "type": {
            "kind": "string"
          },
          "description": "Maximum time a client connection can be idle before being closed.\n\n Duration string (e.g., \"30s\", \"5m\"). If omitted, Scaleway's default applies.\n Increase for long-polling, WebSocket, or Server-Sent Events clients.",
          "required": false
        },
        {
          "name": "EnableHttp3",
          "jsonName": "enableHttp3",
          "protoField": "enable_http3",
          "type": {
            "kind": "bool"
          },
          "description": "Enable HTTP/3 (QUIC) support on this frontend.\n\n When true, the frontend accepts HTTP/3 connections over UDP in addition\n to HTTP/1.1 and HTTP/2 over TCP. Requires an HTTPS frontend with a\n TLS certificate.\n\n Default: false.",
          "required": false
        }
      ]
    },
    {
      "name": "ScalewayLoadBalancerHealthCheck",
      "description": "ScalewayLoadBalancerHealthCheck defines how the LB probes backend servers.\n\n Health checks run periodically against each server in the backend pool.\n Servers that fail `check_max_retries` consecutive checks are removed from\n rotation. They are automatically re-added when they start passing again.\n\n The `type` field selects the check protocol:\n   - \"tcp\"   -- Attempts a TCP connection. Simplest, works for any service.\n   - \"http\"  -- Sends an HTTP request and checks the response code.\n   - \"https\" -- Like \"http\" but over TLS.\n\n For \"http\" and \"https\" types, `uri` and `expected_code` are meaningful.\n For \"tcp\", they are ignored.",
      "protoType": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1.ScalewayLoadBalancerHealthCheck",
      "fields": [
        {
          "name": "Type",
          "jsonName": "type",
          "protoField": "type",
          "type": {
            "kind": "string"
          },
          "description": "Health check protocol.\n\n Options: \"tcp\" (default), \"http\", \"https\"\n\n Use \"tcp\" for non-HTTP services (databases, gRPC, custom protocols).\n Use \"http\" for web applications. Use \"https\" when backends require TLS.",
          "required": false,
          "recommendedDefault": "tcp"
        },
        {
          "name": "Uri",
          "jsonName": "uri",
          "protoField": "uri",
          "type": {
            "kind": "string"
          },
          "description": "URI path for HTTP/HTTPS health checks.\n\n The LB sends a GET request to this path on each backend server.\n Example: \"/health\", \"/ready\", \"/ping\"\n\n Default: \"/\" -- Only meaningful when type is \"http\" or \"https\".",
          "required": false
        },
        {
          "name": "ExpectedCode",
          "jsonName": "expectedCode",
          "protoField": "expected_code",
          "type": {
            "kind": "int32"
          },
          "description": "Expected HTTP status code for a healthy response.\n\n The health check passes if the server returns this status code.\n Default: 200 -- Only meaningful when type is \"http\" or \"https\".",
          "required": false
        },
        {
          "name": "CheckDelay",
          "jsonName": "checkDelay",
          "protoField": "check_delay",
          "type": {
            "kind": "string"
          },
          "description": "Interval between health check probes.\n\n Duration string (e.g., \"5s\", \"10s\", \"30s\").\n Lower values detect failures faster but generate more probe traffic.\n Default: \"5s\"",
          "required": false,
          "recommendedDefault": "5s"
        },
        {
          "name": "CheckTimeout",
          "jsonName": "checkTimeout",
          "protoField": "check_timeout",
          "type": {
            "kind": "string"
          },
          "description": "Maximum time to wait for a health check response.\n\n Duration string (e.g., \"3s\", \"5s\").\n Must be less than check_delay. Default: \"3s\"",
          "required": false,
          "recommendedDefault": "3s"
        },
        {
          "name": "CheckMaxRetries",
          "jsonName": "checkMaxRetries",
          "protoField": "check_max_retries",
          "type": {
            "kind": "int32"
          },
          "description": "Number of consecutive failed checks before marking a server as unhealthy.\n\n Higher values tolerate transient failures but take longer to detect\n real outages. Default: 3",
          "required": false,
          "recommendedDefault": "3"
        },
        {
          "name": "Port",
          "jsonName": "port",
          "protoField": "port",
          "type": {
            "kind": "int32"
          },
          "description": "Port to send health check probes to.\n\n If omitted or set to 0, defaults to the backend's `forward_port`.\n Set a different port when health checks run on a dedicated monitoring\n port (e.g., an application that serves traffic on 8080 but exposes\n health at 8081).",
          "required": false
        }
      ]
    },
    {
      "name": "ScalewayLoadBalancerLetsencrypt",
      "description": "ScalewayLoadBalancerLetsencrypt configures automatic TLS certificate provisioning\n via Let's Encrypt.\n\n Scaleway handles the ACME challenge, provisioning, and renewal. The domain\n must resolve to the LB's public IP for HTTP-01 validation to succeed.\n Create DNS records pointing to the LB's IP BEFORE enabling Let's Encrypt.",
      "protoType": "org.openmcf.provider.scaleway.scalewayloadbalancer.v1.ScalewayLoadBalancerLetsencrypt",
      "fields": [
        {
          "name": "CommonName",
          "jsonName": "commonName",
          "protoField": "common_name",
          "type": {
            "kind": "string"
          },
          "description": "Primary domain name for the certificate.\n\n Example: \"example.com\", \"app.example.com\"\n\n The domain must resolve to the LB's public IP. If using a new domain,\n create a DNS A record first, then add the certificate.",
          "required": true,
          "validation": {
            "required": true
          }
        },
        {
          "name": "SubjectAlternativeNames",
          "jsonName": "subjectAlternativeNames",
          "protoField": "subject_alternative_names",
          "type": {
            "kind": "array",
            "elementType": {
              "kind": "string"
            }
          },
          "description": "Subject Alternative Names (additional domains covered by this certificate).\n\n Examples: [\"www.example.com\", \"api.example.com\"]\n\n All SANs must also resolve to the LB's public IP. Let's Encrypt\n validates each domain independently.",
          "required": false
        }
      ]
    }
  ]
}
