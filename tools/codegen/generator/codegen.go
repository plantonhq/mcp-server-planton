package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// cloudResourceKindEnumType is the fully-qualified proto enum type for
// CloudResourceKind. Enum fields of this type are too large (362+ values) for
// inline validation; the backend validates them instead.
const cloudResourceKindEnumType = "org.openmcf.shared.cloudresourcekind.CloudResourceKind"

// generateCloudPackage generates all Go files for a single cloud provider
// package (e.g., gen/cloudresource/aws/). Returns registry items for the
// top-level registry.
func generateCloudPackage(outputDir, goModule, cloud string, schemas []*ProviderSchema) ([]registryItem, error) {
	pkgDir := filepath.Join(outputDir, cloud)
	if err := os.MkdirAll(pkgDir, 0o755); err != nil {
		return nil, fmt.Errorf("mkdir %s: %w", pkgDir, err)
	}

	// Collect all nested types across providers in this cloud for deduplication.
	sharedTypes := deduplicateNestedTypes(schemas)

	var items []registryItem
	for _, schema := range schemas {
		item, err := generateProviderFile(pkgDir, goModule, cloud, schema, sharedTypes)
		if err != nil {
			return nil, fmt.Errorf("generate %s: %w", schema.Kind, err)
		}
		items = append(items, item)
	}

	// Generate shared types file if there are any deduplicated types.
	if len(sharedTypes) > 0 {
		if err := generateSharedTypesFile(pkgDir, cloud, sharedTypes); err != nil {
			return nil, fmt.Errorf("generate shared types for %s: %w", cloud, err)
		}
	}

	return items, nil
}

// ---------------------------------------------------------------------------
// Nested type deduplication
// ---------------------------------------------------------------------------

// sharedType represents a nested type shared across providers within a cloud.
type sharedType struct {
	schema    TypeSchema
	generated bool // set after the type is emitted in types_gen.go
}

// deduplicateNestedTypes collects all nested types across schemas in a cloud
// and returns a map of typeName -> sharedType for types that appear in more
// than one provider OR for ALL types (since we generate shared types once to
// avoid duplication). Types are grouped by protoType for identity.
func deduplicateNestedTypes(schemas []*ProviderSchema) map[string]*sharedType {
	// protoType -> first occurrence
	byProto := make(map[string]*sharedType)
	// name -> protoType (to detect name collisions with different protos)
	nameToProto := make(map[string]string)
	// Track how many providers reference each type name
	nameRefCount := make(map[string]int)

	for _, schema := range schemas {
		seen := make(map[string]bool)
		for _, nt := range schema.NestedTypes {
			key := nt.ProtoType
			if key == "" {
				key = nt.Name
			}

			if !seen[nt.Name] {
				seen[nt.Name] = true
				nameRefCount[nt.Name]++
			}

			if _, exists := byProto[key]; exists {
				continue
			}
			if existingProto, ok := nameToProto[nt.Name]; ok && existingProto != key {
				// Name collision with different proto type — this would need
				// disambiguation. For now, log and skip the duplicate name.
				// In practice, shared proto packages use consistent naming.
				continue
			}

			byProto[key] = &sharedType{schema: nt}
			nameToProto[nt.Name] = key
		}
	}

	// Build result: only types referenced by 2+ providers go to types_gen.go.
	// Types unique to one provider stay in that provider's file.
	result := make(map[string]*sharedType)
	for _, st := range byProto {
		if nameRefCount[st.schema.Name] > 1 {
			result[st.schema.Name] = st
		}
	}
	return result
}

// ---------------------------------------------------------------------------
// Per-provider file generation
// ---------------------------------------------------------------------------

func generateProviderFile(pkgDir, goModule, cloud string, schema *ProviderSchema, sharedTypes map[string]*sharedType) (registryItem, error) {
	fileName := toSnakeFileName(schema.Kind) + "_gen.go"
	filePath := filepath.Join(pkgDir, fileName)

	var buf bytes.Buffer
	now := time.Now().Format(time.RFC3339)

	// Collect provider-local nested types (those not in sharedTypes)
	var localTypes []TypeSchema
	for _, nt := range schema.NestedTypes {
		if _, shared := sharedTypes[nt.Name]; !shared {
			localTypes = append(localTypes, nt)
		}
	}

	needsJSON := true
	needsFmt := true
	parseImport := fmt.Sprintf("%s/internal/parse", goModule)

	// Header
	fmt.Fprintf(&buf, "// Code generated by schema2go. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Generated: %s\n\n", now)
	fmt.Fprintf(&buf, "package %s\n\n", cloud)

	// Imports
	fmt.Fprintf(&buf, "import (\n")
	if needsJSON {
		fmt.Fprintf(&buf, "\t\"encoding/json\"\n")
	}
	if needsFmt {
		fmt.Fprintf(&buf, "\t\"fmt\"\n")
	}
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "\t%q\n", parseImport)
	fmt.Fprintf(&buf, "\t\"google.golang.org/protobuf/types/known/structpb\"\n")
	fmt.Fprintf(&buf, ")\n\n")

	// Ensure imports are used
	fmt.Fprintf(&buf, "var (\n")
	fmt.Fprintf(&buf, "\t_ = json.Marshal\n")
	fmt.Fprintf(&buf, "\t_ = fmt.Errorf\n")
	fmt.Fprintf(&buf, "\t_ = parse.ValidateHeader\n")
	fmt.Fprintf(&buf, "\t_ = (*structpb.Struct)(nil)\n")
	fmt.Fprintf(&buf, ")\n\n")

	// Spec input struct
	specInputName := schema.Kind + "SpecInput"
	emitStruct(&buf, specInputName, schema.Spec.Fields, schema.Description)

	// validate()
	emitValidate(&buf, specInputName, schema.Spec.Fields)

	// applyDefaults()
	emitApplyDefaults(&buf, specInputName, schema.Spec.Fields)

	// toMap()
	emitToMap(&buf, specInputName, schema.Spec.Fields)

	// Local nested types
	for _, nt := range localTypes {
		inputName := nt.Name + "Input"
		emitStruct(&buf, inputName, nt.Fields, nt.Description)
		emitValidate(&buf, inputName, nt.Fields)
		emitApplyDefaults(&buf, inputName, nt.Fields)
		emitToMap(&buf, inputName, nt.Fields)
	}

	// Parse function
	emitParseFunc(&buf, schema.Kind, specInputName, schema.APIVersion)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write unformatted for debugging
		_ = os.WriteFile(filePath, buf.Bytes(), 0o644)
		return registryItem{}, fmt.Errorf("gofmt %s: %w", filePath, err)
	}

	if err := os.WriteFile(filePath, formatted, 0o644); err != nil {
		return registryItem{}, fmt.Errorf("write %s: %w", filePath, err)
	}

	return registryItem{
		kind:     schema.Kind,
		cloud:    cloud,
		funcName: "Parse" + schema.Kind,
	}, nil
}

// ---------------------------------------------------------------------------
// Shared types file generation
// ---------------------------------------------------------------------------

func generateSharedTypesFile(pkgDir, cloud string, sharedTypes map[string]*sharedType) error {
	filePath := filepath.Join(pkgDir, "types_gen.go")

	var buf bytes.Buffer
	now := time.Now().Format(time.RFC3339)

	fmt.Fprintf(&buf, "// Code generated by schema2go. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Generated: %s\n", now)
	fmt.Fprintf(&buf, "// Shared types used by multiple providers in the %s package.\n\n", cloud)
	fmt.Fprintf(&buf, "package %s\n\n", cloud)

	// Add imports — validate() uses fmt
	fmt.Fprintf(&buf, "import \"fmt\"\n\n")
	fmt.Fprintf(&buf, "var _ = fmt.Errorf\n\n")

	// Sort for deterministic output
	names := make([]string, 0, len(sharedTypes))
	for name := range sharedTypes {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		st := sharedTypes[name]
		inputName := name + "Input"
		emitStruct(&buf, inputName, st.schema.Fields, st.schema.Description)
		emitValidate(&buf, inputName, st.schema.Fields)
		emitApplyDefaults(&buf, inputName, st.schema.Fields)
		emitToMap(&buf, inputName, st.schema.Fields)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		_ = os.WriteFile(filePath, buf.Bytes(), 0o644)
		return fmt.Errorf("gofmt %s: %w", filePath, err)
	}
	return os.WriteFile(filePath, formatted, 0o644)
}

// ---------------------------------------------------------------------------
// Struct emission
// ---------------------------------------------------------------------------

func emitStruct(buf *bytes.Buffer, name string, fields []*FieldSchema, description string) {
	if description != "" {
		for _, line := range strings.Split(description, "\n") {
			fmt.Fprintf(buf, "// %s\n", strings.TrimRight(line, " \t"))
		}
	}
	fmt.Fprintf(buf, "type %s struct {\n", name)
	for _, f := range fields {
		emitFieldDef(buf, f)
	}
	fmt.Fprintf(buf, "}\n\n")
}

func emitFieldDef(buf *bytes.Buffer, f *FieldSchema) {
	goType := goTypeForField(f)
	jsonTag := buildJSONTag(f)
	schemaTag := buildSchemaTag(f)

	if f.Description != "" {
		desc := sanitizeComment(f.Description)
		for _, line := range strings.Split(desc, "\n") {
			fmt.Fprintf(buf, "\t// %s\n", strings.TrimRight(line, " \t"))
		}
	}
	fmt.Fprintf(buf, "\t%s %s `json:%q jsonschema:%q`\n", f.Name, goType, jsonTag, schemaTag)
}

// goTypeForField returns the Go type string for a schema field.
func goTypeForField(f *FieldSchema) string {
	return goTypeForSpec(&f.Type)
}

func goTypeForSpec(ts *TypeSpec) string {
	switch ts.Kind {
	case "string":
		return "string"
	case "bool":
		return "bool"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "uint32":
		return "uint32"
	case "uint64":
		return "uint64"
	case "float":
		return "float32"
	case "double":
		return "float64"
	case "bytes":
		return "[]byte"
	case "enum":
		return "string"
	case "message":
		return "*" + ts.MessageType + "Input"
	case "array":
		if ts.ElementType == nil {
			return "[]any"
		}
		elemType := goTypeForSpec(ts.ElementType)
		return "[]" + elemType
	case "map":
		keyType := "string"
		if ts.KeyType != nil {
			keyType = goTypeForSpec(ts.KeyType)
		}
		valType := "string"
		if ts.ValueType != nil {
			valType = goTypeForSpec(ts.ValueType)
		}
		return "map[" + keyType + "]" + valType
	default:
		return "any"
	}
}

func buildJSONTag(f *FieldSchema) string {
	tag := f.ProtoField
	if !f.Required {
		tag += ",omitempty"
	}
	return tag
}

func buildSchemaTag(f *FieldSchema) string {
	var parts []string

	if f.Required {
		parts = append(parts, "required")
	}

	if f.Type.Kind == "enum" && len(f.Type.EnumValues) > 0 {
		// Skip enormous CloudResourceKind enum
		if f.Type.EnumType != cloudResourceKindEnumType {
			parts = append(parts, "enum="+strings.Join(f.Type.EnumValues, "|"))
		}
	}

	desc := sanitizeSchemaTag(f.Description)
	if desc != "" {
		parts = append(parts, desc)
	}

	return strings.Join(parts, ",")
}

// ---------------------------------------------------------------------------
// validate() emission
// ---------------------------------------------------------------------------

func emitValidate(buf *bytes.Buffer, typeName string, fields []*FieldSchema) {
	fmt.Fprintf(buf, "func (s *%s) validate() error {\n", typeName)

	for _, f := range fields {
		emitFieldValidation(buf, f)
	}

	fmt.Fprintf(buf, "\treturn nil\n")
	fmt.Fprintf(buf, "}\n\n")
}

func emitFieldValidation(buf *bytes.Buffer, f *FieldSchema) {
	isRequired := f.Required || (f.Validation != nil && f.Validation.Required)

	switch f.Type.Kind {
	case "string":
		if isRequired {
			fmt.Fprintf(buf, "\tif s.%s == \"\" {\n", f.Name)
			fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"%s is required\")\n", f.ProtoField)
			fmt.Fprintf(buf, "\t}\n")
		}
	case "enum":
		if isRequired {
			fmt.Fprintf(buf, "\tif s.%s == \"\" {\n", f.Name)
			fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"%s is required\")\n", f.ProtoField)
			fmt.Fprintf(buf, "\t}\n")
		}
		if len(f.Type.EnumValues) > 0 && f.Type.EnumType != cloudResourceKindEnumType {
			fmt.Fprintf(buf, "\tswitch s.%s {\n", f.Name)
			cases := make([]string, 0, len(f.Type.EnumValues)+1)
			if !isRequired {
				cases = append(cases, `""`)
			}
			for _, v := range f.Type.EnumValues {
				cases = append(cases, fmt.Sprintf("%q", v))
			}
			fmt.Fprintf(buf, "\tcase %s:\n", strings.Join(cases, ", "))
			fmt.Fprintf(buf, "\tdefault:\n")
			fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"invalid %s: %%q\", s.%s)\n", f.ProtoField, f.Name)
			fmt.Fprintf(buf, "\t}\n")
		}
	case "message":
		if isRequired {
			fmt.Fprintf(buf, "\tif s.%s == nil {\n", f.Name)
			fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"%s is required\")\n", f.ProtoField)
			fmt.Fprintf(buf, "\t}\n")
		}
		// Validate nested type if present
		fmt.Fprintf(buf, "\tif s.%s != nil {\n", f.Name)
		fmt.Fprintf(buf, "\t\tif err := s.%s.validate(); err != nil {\n", f.Name)
		fmt.Fprintf(buf, "\t\t\treturn fmt.Errorf(\"%s: %%w\", err)\n", f.ProtoField)
		fmt.Fprintf(buf, "\t\t}\n")
		fmt.Fprintf(buf, "\t}\n")
	case "array":
		if isRequired {
			fmt.Fprintf(buf, "\tif len(s.%s) == 0 {\n", f.Name)
			fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"%s is required\")\n", f.ProtoField)
			fmt.Fprintf(buf, "\t}\n")
		}
		if f.Validation != nil && f.Validation.MinItems > 0 {
			fmt.Fprintf(buf, "\tif len(s.%s) < %d {\n", f.Name, f.Validation.MinItems)
			fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"%s requires at least %d items, got %%d\", len(s.%s))\n",
				f.ProtoField, f.Validation.MinItems, f.Name)
			fmt.Fprintf(buf, "\t}\n")
		}
		// Validate array elements if they are messages
		if f.Type.ElementType != nil && f.Type.ElementType.Kind == "message" {
			fmt.Fprintf(buf, "\tfor i, v := range s.%s {\n", f.Name)
			fmt.Fprintf(buf, "\t\tif v != nil {\n")
			fmt.Fprintf(buf, "\t\t\tif err := v.validate(); err != nil {\n")
			fmt.Fprintf(buf, "\t\t\t\treturn fmt.Errorf(\"%s[%%d]: %%w\", i, err)\n", f.ProtoField)
			fmt.Fprintf(buf, "\t\t\t}\n")
			fmt.Fprintf(buf, "\t\t}\n")
			fmt.Fprintf(buf, "\t}\n")
		}
	case "map":
		// Validate map values if they are messages
		if f.Type.ValueType != nil && f.Type.ValueType.Kind == "message" {
			fmt.Fprintf(buf, "\tfor k, v := range s.%s {\n", f.Name)
			fmt.Fprintf(buf, "\t\tif v != nil {\n")
			fmt.Fprintf(buf, "\t\t\tif err := v.validate(); err != nil {\n")
			fmt.Fprintf(buf, "\t\t\t\treturn fmt.Errorf(\"%s[%%s]: %%w\", k, err)\n", f.ProtoField)
			fmt.Fprintf(buf, "\t\t\t}\n")
			fmt.Fprintf(buf, "\t\t}\n")
			fmt.Fprintf(buf, "\t}\n")
		}
	}
}

// ---------------------------------------------------------------------------
// applyDefaults() emission
// ---------------------------------------------------------------------------

func emitApplyDefaults(buf *bytes.Buffer, typeName string, fields []*FieldSchema) {
	// Check if any field has a default
	hasDefaults := false
	for _, f := range fields {
		if f.Default != "" {
			hasDefaults = true
			break
		}
		if f.Type.Kind == "message" {
			hasDefaults = true // nested types may have defaults
		}
	}

	fmt.Fprintf(buf, "func (s *%s) applyDefaults() {\n", typeName)

	if hasDefaults {
		for _, f := range fields {
			if f.Default != "" {
				switch f.Type.Kind {
				case "string", "enum":
					fmt.Fprintf(buf, "\tif s.%s == \"\" {\n", f.Name)
					fmt.Fprintf(buf, "\t\ts.%s = %q\n", f.Name, f.Default)
					fmt.Fprintf(buf, "\t}\n")
				case "bool":
					if f.Default == "true" {
						fmt.Fprintf(buf, "\t// default: %s = true (applied at zero-value)\n", f.Name)
					}
				case "int32", "int64", "uint32", "uint64":
					fmt.Fprintf(buf, "\tif s.%s == 0 {\n", f.Name)
					fmt.Fprintf(buf, "\t\ts.%s = %s\n", f.Name, f.Default)
					fmt.Fprintf(buf, "\t}\n")
				}
			}
			// Propagate defaults to nested types
			if f.Type.Kind == "message" {
				fmt.Fprintf(buf, "\tif s.%s != nil {\n", f.Name)
				fmt.Fprintf(buf, "\t\ts.%s.applyDefaults()\n", f.Name)
				fmt.Fprintf(buf, "\t}\n")
			}
		}
	}

	fmt.Fprintf(buf, "}\n\n")
}

// ---------------------------------------------------------------------------
// toMap() emission
// ---------------------------------------------------------------------------

func emitToMap(buf *bytes.Buffer, typeName string, fields []*FieldSchema) {
	fmt.Fprintf(buf, "func (s *%s) toMap() map[string]any {\n", typeName)
	fmt.Fprintf(buf, "\tm := make(map[string]any)\n")

	for _, f := range fields {
		emitFieldToMap(buf, f)
	}

	fmt.Fprintf(buf, "\treturn m\n")
	fmt.Fprintf(buf, "}\n\n")
}

func emitFieldToMap(buf *bytes.Buffer, f *FieldSchema) {
	key := f.ProtoField

	switch f.Type.Kind {
	case "string", "enum":
		if f.Required {
			fmt.Fprintf(buf, "\tm[%q] = s.%s\n", key, f.Name)
		} else {
			fmt.Fprintf(buf, "\tif s.%s != \"\" {\n", f.Name)
			fmt.Fprintf(buf, "\t\tm[%q] = s.%s\n", key, f.Name)
			fmt.Fprintf(buf, "\t}\n")
		}
	case "bool":
		if f.Required {
			fmt.Fprintf(buf, "\tm[%q] = s.%s\n", key, f.Name)
		} else {
			fmt.Fprintf(buf, "\tif s.%s {\n", f.Name)
			fmt.Fprintf(buf, "\t\tm[%q] = s.%s\n", key, f.Name)
			fmt.Fprintf(buf, "\t}\n")
		}
	case "int32", "int64", "uint32", "uint64", "float", "double":
		if f.Required {
			fmt.Fprintf(buf, "\tm[%q] = s.%s\n", key, f.Name)
		} else {
			fmt.Fprintf(buf, "\tif s.%s != 0 {\n", f.Name)
			fmt.Fprintf(buf, "\t\tm[%q] = s.%s\n", key, f.Name)
			fmt.Fprintf(buf, "\t}\n")
		}
	case "message":
		fmt.Fprintf(buf, "\tif s.%s != nil {\n", f.Name)
		fmt.Fprintf(buf, "\t\tm[%q] = s.%s.toMap()\n", key, f.Name)
		fmt.Fprintf(buf, "\t}\n")
	case "array":
		if f.Type.ElementType != nil && f.Type.ElementType.Kind == "message" {
			fmt.Fprintf(buf, "\tif len(s.%s) > 0 {\n", f.Name)
			fmt.Fprintf(buf, "\t\titems := make([]any, len(s.%s))\n", f.Name)
			fmt.Fprintf(buf, "\t\tfor i, v := range s.%s {\n", f.Name)
			fmt.Fprintf(buf, "\t\t\tif v != nil {\n")
			fmt.Fprintf(buf, "\t\t\t\titems[i] = v.toMap()\n")
			fmt.Fprintf(buf, "\t\t\t}\n")
			fmt.Fprintf(buf, "\t\t}\n")
			fmt.Fprintf(buf, "\t\tm[%q] = items\n", key)
			fmt.Fprintf(buf, "\t}\n")
		} else {
			// Array of scalars
			if f.Required {
				fmt.Fprintf(buf, "\tm[%q] = s.%s\n", key, f.Name)
			} else {
				fmt.Fprintf(buf, "\tif len(s.%s) > 0 {\n", f.Name)
				fmt.Fprintf(buf, "\t\tm[%q] = s.%s\n", key, f.Name)
				fmt.Fprintf(buf, "\t}\n")
			}
		}
	case "map":
		if f.Type.ValueType != nil && f.Type.ValueType.Kind == "message" {
			fmt.Fprintf(buf, "\tif len(s.%s) > 0 {\n", f.Name)
			fmt.Fprintf(buf, "\t\tresult := make(map[string]any, len(s.%s))\n", f.Name)
			fmt.Fprintf(buf, "\t\tfor k, v := range s.%s {\n", f.Name)
			fmt.Fprintf(buf, "\t\t\tif v != nil {\n")
			fmt.Fprintf(buf, "\t\t\t\tresult[k] = v.toMap()\n")
			fmt.Fprintf(buf, "\t\t\t}\n")
			fmt.Fprintf(buf, "\t\t}\n")
			fmt.Fprintf(buf, "\t\tm[%q] = result\n", key)
			fmt.Fprintf(buf, "\t}\n")
		} else {
			// Map of scalars
			fmt.Fprintf(buf, "\tif len(s.%s) > 0 {\n", f.Name)
			fmt.Fprintf(buf, "\t\tm[%q] = s.%s\n", key, f.Name)
			fmt.Fprintf(buf, "\t}\n")
		}
	case "bytes":
		fmt.Fprintf(buf, "\tif len(s.%s) > 0 {\n", f.Name)
		fmt.Fprintf(buf, "\t\tm[%q] = s.%s\n", key, f.Name)
		fmt.Fprintf(buf, "\t}\n")
	default:
		fmt.Fprintf(buf, "\t// unsupported type %q for field %s\n", f.Type.Kind, f.Name)
	}
}

// ---------------------------------------------------------------------------
// Parse function emission
// ---------------------------------------------------------------------------

func emitParseFunc(buf *bytes.Buffer, kind, specInputName, apiVersion string) {
	fmt.Fprintf(buf, "// Parse%s validates and normalizes a %s cloud_object.\n", kind, kind)
	fmt.Fprintf(buf, "func Parse%s(cloudObject map[string]any) (*structpb.Struct, error) {\n", kind)
	fmt.Fprintf(buf, "\tif err := parse.ValidateHeader(cloudObject, %q, %q); err != nil {\n", apiVersion, kind)
	fmt.Fprintf(buf, "\t\treturn nil, err\n")
	fmt.Fprintf(buf, "\t}\n\n")
	fmt.Fprintf(buf, "\tspecMap, err := parse.ExtractSpecMap(cloudObject)\n")
	fmt.Fprintf(buf, "\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\treturn nil, err\n")
	fmt.Fprintf(buf, "\t}\n\n")
	fmt.Fprintf(buf, "\tspecBytes, err := json.Marshal(specMap)\n")
	fmt.Fprintf(buf, "\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"marshal spec: %%w\", err)\n")
	fmt.Fprintf(buf, "\t}\n\n")
	fmt.Fprintf(buf, "\tvar spec %s\n", specInputName)
	fmt.Fprintf(buf, "\tif err := json.Unmarshal(specBytes, &spec); err != nil {\n")
	fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"invalid spec: %%w\", err)\n")
	fmt.Fprintf(buf, "\t}\n\n")
	fmt.Fprintf(buf, "\tif err := spec.validate(); err != nil {\n")
	fmt.Fprintf(buf, "\t\treturn nil, err\n")
	fmt.Fprintf(buf, "\t}\n\n")
	fmt.Fprintf(buf, "\tspec.applyDefaults()\n\n")
	fmt.Fprintf(buf, "\treturn parse.RebuildCloudObject(cloudObject, spec.toMap())\n")
	fmt.Fprintf(buf, "}\n")
}

// ---------------------------------------------------------------------------
// String helpers
// ---------------------------------------------------------------------------

// sanitizeComment cleans a description string for use in Go comments.
func sanitizeComment(s string) string {
	s = strings.ReplaceAll(s, "\r\n", "\n")
	s = strings.ReplaceAll(s, "\r", "\n")
	s = strings.ReplaceAll(s, "*/", "* /")
	const maxLen = 300
	if len(s) > maxLen {
		s = s[:maxLen] + "..."
	}
	return s
}

// sanitizeSchemaTag cleans a description for use in a jsonschema struct tag.
// Removes newlines and truncates to keep tags manageable.
func sanitizeSchemaTag(s string) string {
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.ReplaceAll(s, "\r", " ")
	s = strings.ReplaceAll(s, "`", "'")
	s = strings.ReplaceAll(s, "\"", "'")
	s = strings.ReplaceAll(s, ",", ";")
	// Collapse multiple spaces
	for strings.Contains(s, "  ") {
		s = strings.ReplaceAll(s, "  ", " ")
	}
	s = strings.TrimSpace(s)
	const maxLen = 200
	if len(s) > maxLen {
		s = s[:maxLen] + "..."
	}
	return s
}
