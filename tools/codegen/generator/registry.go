package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"time"
)

// generateRegistry creates gen/infrahub/cloudresource/registry_gen.go with the
// ParseFunc type, a map of kind->ParseFunc, and GetParser().
func generateRegistry(outputDir, goModule string, clouds []string, items []registryItem) error {
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		return fmt.Errorf("mkdir %s: %w", outputDir, err)
	}
	filePath := filepath.Join(outputDir, "registry_gen.go")

	// Sort items by kind for deterministic output
	sort.Slice(items, func(i, j int) bool {
		return items[i].kind < items[j].kind
	})

	// Collect unique cloud packages used
	cloudSet := make(map[string]bool)
	for _, item := range items {
		cloudSet[item.cloud] = true
	}
	usedClouds := make([]string, 0, len(cloudSet))
	for c := range cloudSet {
		usedClouds = append(usedClouds, c)
	}
	sort.Strings(usedClouds)

	var buf bytes.Buffer
	now := time.Now().Format(time.RFC3339)

	fmt.Fprintf(&buf, "// Code generated by schema2go. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Generated: %s\n\n", now)
	fmt.Fprintf(&buf, "package cloudresource\n\n")

	// Imports
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"sort\"\n\n")
	fmt.Fprintf(&buf, "\t\"google.golang.org/protobuf/types/known/structpb\"\n\n")
	for _, cloud := range usedClouds {
		importPath := fmt.Sprintf("%s/%s/%s", goModule, outputDir, cloud)
		fmt.Fprintf(&buf, "\t%q\n", importPath)
	}
	fmt.Fprintf(&buf, ")\n\n")

	// ParseFunc type
	fmt.Fprintf(&buf, "// ParseFunc validates and normalizes a cloud_object map for a specific\n")
	fmt.Fprintf(&buf, "// provider kind, returning a structpb.Struct ready for CloudResource.Spec.CloudObject.\n")
	fmt.Fprintf(&buf, "type ParseFunc func(cloudObject map[string]any) (*structpb.Struct, error)\n\n")

	// Registry map
	fmt.Fprintf(&buf, "var registry = map[string]ParseFunc{\n")
	for _, item := range items {
		fmt.Fprintf(&buf, "\t%q: %s.%s,\n", item.kind, item.cloud, item.funcName)
	}
	fmt.Fprintf(&buf, "}\n\n")

	// GetParser function
	fmt.Fprintf(&buf, "// GetParser returns the parse function for the given cloud resource kind.\n")
	fmt.Fprintf(&buf, "// Returns false if the kind is not recognized.\n")
	fmt.Fprintf(&buf, "func GetParser(kind string) (ParseFunc, bool) {\n")
	fmt.Fprintf(&buf, "\tfn, ok := registry[kind]\n")
	fmt.Fprintf(&buf, "\treturn fn, ok\n")
	fmt.Fprintf(&buf, "}\n\n")

	// KnownKinds function
	fmt.Fprintf(&buf, "// KnownKinds returns a sorted list of all supported cloud resource kinds.\n")
	fmt.Fprintf(&buf, "func KnownKinds() []string {\n")
	fmt.Fprintf(&buf, "\tkinds := make([]string, 0, len(registry))\n")
	fmt.Fprintf(&buf, "\tfor k := range registry {\n")
	fmt.Fprintf(&buf, "\t\tkinds = append(kinds, k)\n")
	fmt.Fprintf(&buf, "\t}\n")
	fmt.Fprintf(&buf, "\tsort.Strings(kinds)\n")
	fmt.Fprintf(&buf, "\treturn kinds\n")
	fmt.Fprintf(&buf, "}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		_ = os.WriteFile(filePath, buf.Bytes(), 0o644)
		return fmt.Errorf("gofmt %s: %w", filePath, err)
	}

	return os.WriteFile(filePath, formatted, 0o644)
}
