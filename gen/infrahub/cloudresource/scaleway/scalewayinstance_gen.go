// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package scaleway

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// scaleway-instance
type ScalewayInstanceSpecInput struct {
	// The Scaleway zone where the instance will be created.
	//  Examples: "fr-par-1", "nl-ams-1", "pl-waw-1"
	//
	//  Instances are zonal resources. The zone determines which physical
	//  data center the instance runs in. Choose a zone in the same region
	//  as the Private Network and other connected resources.
	//
	//  This fi...
	Zone string `json:"zone" jsonschema:"required,The Scaleway zone where the instance will be created. Examples: 'fr-par-1'; 'nl-ams-1'; 'pl-waw-1' Instances are zonal resources. The zone determines which physical data center the instance runs in. C..."`
	// Instance commercial type (required).
	//
	//  Determines CPU cores, RAM, and local storage allocation. Common types:
	//    - Development:  "DEV1-S" (2 vCPU, 2 GB), "DEV1-M" (3 vCPU, 4 GB)
	//    - General:      "GP1-S" (8 vCPU, 32 GB), "GP1-M" (16 vCPU, 64 GB)
	//    - Production:   "PRO2-S" (2 vCPU, 8 GB), "PRO2-M" ...
	Type string `json:"type" jsonschema:"required,Instance commercial type (required). Determines CPU cores; RAM; and local storage allocation. Common types: - Development: 'DEV1-S' (2 vCPU; 2 GB); 'DEV1-M' (3 vCPU; 4 GB) - General: 'GP1-S' (8 vCPU; ..."`
	// Base image UUID or label (required).
	//
	//  The image determines the operating system and initial disk contents.
	//  Can be a full UUID (e.g., "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") or
	//  a human-friendly label (e.g., "ubuntu_focal", "debian_bullseye",
	//  "ubuntu_jammy", "centos_stream_9").
	//
	//  Use labels for qu...
	Image string `json:"image" jsonschema:"required,Base image UUID or label (required). The image determines the operating system and initial disk contents. Can be a full UUID (e.g.; 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx') or a human-friendly label (e..."`
	// Public IP configuration.
	//
	//  If set, a dedicated Flexible IPv4 address is created and attached to
	//  the instance. The instance will be reachable from the internet on this
	//  IP. If omitted, the instance has **no public IP** and is reachable only
	//  via the Private Network (through a Public Gateway bastion,...
	PublicIp *ScalewayInstancePublicIpInput `json:"public_ip,omitempty" jsonschema:"Public IP configuration. If set; a dedicated Flexible IPv4 address is created and attached to the instance. The instance will be reachable from the internet on this IP. If omitted; the instance has **..."`
	// Security group to attach to the instance.
	//
	//  Controls inbound and outbound firewall rules for the instance. Can be
	//  a literal security group UUID or a reference to a
	//  ScalewayInstanceSecurityGroup resource's output.
	//
	//  If omitted, Scaleway assigns its default security group (which allows
	//  all inbound ...
	SecurityGroupId string `json:"security_group_id,omitempty" jsonschema:"Security group to attach to the instance. Controls inbound and outbound firewall rules for the instance. Can be a literal security group UUID or a reference to a ScalewayInstanceSecurityGroup resource..."`
	// Private Network to attach the instance to.
	//
	//  When set, the instance receives a private NIC on this network, enabling
	//  communication with other resources on the same network (databases,
	//  load balancers, other instances) using private IPs.
	//
	//  Can be a literal Private Network UUID or a reference to a
	//  S...
	PrivateNetworkId string `json:"private_network_id,omitempty" jsonschema:"Private Network to attach the instance to. When set; the instance receives a private NIC on this network; enabling communication with other resources on the same network (databases; load balancers; ot..."`
	// Root volume configuration.
	//
	//  Controls the boot disk's size, type, and lifecycle behavior. If omitted,
	//  the image's default root volume settings are used (typically 10-20 GB
	//  of local SSD depending on the instance type).
	//
	//  Set this when you need a larger root disk, want to use SBS (network-
	//  attached...
	RootVolume *ScalewayInstanceRootVolumeInput `json:"root_volume,omitempty" jsonschema:"Root volume configuration. Controls the boot disk's size; type; and lifecycle behavior. If omitted; the image's default root volume settings are used (typically 10-20 GB of local SSD depending on the ..."`
	// Additional local volumes to create and attach to the instance.
	//
	//  These volumes are created as part of this composite resource and have
	//  the same lifecycle as the instance -- they are destroyed when the
	//  instance is terminated. Use these for:
	//    - High-performance local caching (l_ssd)
	//    - Temporary...
	AdditionalVolumes []*ScalewayInstanceAdditionalVolumeInput `json:"additional_volumes,omitempty" jsonschema:"Additional local volumes to create and attach to the instance. These volumes are created as part of this composite resource and have the same lifecycle as the instance -- they are destroyed when the i..."`
	// Cloud-init script for instance bootstrapping.
	//
	//  A cloud-init script (typically starting with `#!/bin/bash` or
	//  `#cloud-config`) that runs when the instance first boots. Use this
	//  to install packages, configure services, set up users, or join
	//  the instance to configuration management systems.
	//
	//  Examp...
	CloudInit string `json:"cloud_init,omitempty" jsonschema:"Cloud-init script for instance bootstrapping. A cloud-init script (typically starting with '#!/bin/bash' or '#cloud-config') that runs when the instance first boots. Use this to install packages; conf..."`
	// Desired instance state after creation.
	//
	//  Options:
	//    - "started" (default) -- Instance is running. Normal operational state.
	//    - "stopped"  -- Instance is shut down. Not billed for compute but
	//                    still billed for attached volumes and IPs.
	//    - "standby"  -- Instance is suspended to ...
	State string `json:"state,omitempty" jsonschema:"Desired instance state after creation. Options: - 'started' (default) -- Instance is running. Normal operational state. - 'stopped' -- Instance is shut down. Not billed for compute but still billed fo..."`
	// Protect the instance against accidental deletion via the Scaleway API.
	//
	//  When true, the instance cannot be deleted through the API (including
	//  Terraform/Pulumi destroy) without first disabling protection. This is
	//  a safety net for critical production instances.
	//
	//  Default: false. Enable for productio...
	Protected bool `json:"protected,omitempty" jsonschema:"Protect the instance against accidental deletion via the Scaleway API. When true; the instance cannot be deleted through the API (including Terraform/Pulumi destroy) without first disabling protection..."`
}

func (s *ScalewayInstanceSpecInput) validate() error {
	if s.Zone == "" {
		return fmt.Errorf("zone is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	if s.PublicIp != nil {
		if err := s.PublicIp.validate(); err != nil {
			return fmt.Errorf("public_ip: %w", err)
		}
	}
	if s.RootVolume != nil {
		if err := s.RootVolume.validate(); err != nil {
			return fmt.Errorf("root_volume: %w", err)
		}
	}
	for i, v := range s.AdditionalVolumes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("additional_volumes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ScalewayInstanceSpecInput) applyDefaults() {
	if s.PublicIp != nil {
		s.PublicIp.applyDefaults()
	}
	if s.RootVolume != nil {
		s.RootVolume.applyDefaults()
	}
}

func (s *ScalewayInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone"] = s.Zone
	m["type"] = s.Type
	m["image"] = s.Image
	if s.PublicIp != nil {
		m["public_ip"] = s.PublicIp.toMap()
	}
	if s.SecurityGroupId != "" {
		m["security_group_id"] = s.SecurityGroupId
	}
	if s.PrivateNetworkId != "" {
		m["private_network_id"] = s.PrivateNetworkId
	}
	if s.RootVolume != nil {
		m["root_volume"] = s.RootVolume.toMap()
	}
	if len(s.AdditionalVolumes) > 0 {
		items := make([]any, len(s.AdditionalVolumes))
		for i, v := range s.AdditionalVolumes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["additional_volumes"] = items
	}
	if s.CloudInit != "" {
		m["cloud_init"] = s.CloudInit
	}
	if s.State != "" {
		m["state"] = s.State
	}
	if s.Protected {
		m["protected"] = s.Protected
	}
	return m
}

// ScalewayInstanceAdditionalVolume defines a local volume to create and
//
//	attach to the instance.
//
//	Additional volumes are created as part of this composite resource and
//	share the instance's lifecycle. They are automatically formatted and
//	attached as block devices when the instance starts.
//
//	For persistent block storage with independent lifecycle, use the
//	ScalewayBlockVolume resource kind instead.
type ScalewayInstanceAdditionalVolumeInput struct {
	// Volume name.
	//
	//  A descriptive name for the volume. Used in the Scaleway console and
	//  API for identification. If omitted, a name is auto-generated from
	//  the resource name and volume index.
	Name string `json:"name,omitempty" jsonschema:"Volume name. A descriptive name for the volume. Used in the Scaleway console and API for identification. If omitted; a name is auto-generated from the resource name and volume index."`
	// Volume type (required).
	//
	//  Options:
	//    - "l_ssd"   -- Local SSD. High performance, tied to the physical
	//                    server. Cannot be resized after creation. Destroyed
	//                    when the instance is terminated.
	//    - "scratch" -- Temporary local storage. Same performance as l_ssd
	//      ...
	VolumeType string `json:"volume_type" jsonschema:"required,Volume type (required). Options: - 'l_ssd' -- Local SSD. High performance; tied to the physical server. Cannot be resized after creation. Destroyed when the instance is terminated. - 'scratch' -- Temp..."`
	// Volume size in GB (required).
	//
	//  The available size depends on the instance type's local storage
	//  capacity. The total of all local volumes (root + additional) cannot
	//  exceed the instance type's maximum local storage.
	SizeInGb int32 `json:"size_in_gb" jsonschema:"required,Volume size in GB (required). The available size depends on the instance type's local storage capacity. The total of all local volumes (root + additional) cannot exceed the instance type's maximum loc..."`
}

func (s *ScalewayInstanceAdditionalVolumeInput) validate() error {
	if s.VolumeType == "" {
		return fmt.Errorf("volume_type is required")
	}
	return nil
}

func (s *ScalewayInstanceAdditionalVolumeInput) applyDefaults() {
}

func (s *ScalewayInstanceAdditionalVolumeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	m["volume_type"] = s.VolumeType
	m["size_in_gb"] = s.SizeInGb
	return m
}

// ScalewayInstancePublicIp configures the dedicated public IP for the instance.
//
//	When this message is present in the spec, a Flexible IPv4 address is created
//	as a separate resource and attached to the instance. The Flexible IP has an
//	independent lifecycle -- if the instance is replaced, the IP can be preserved
//	and reassigned, maintaining DNS records and firewall rules.
//
//	When absent from the spec, no public IP is created and the instance is
//	reachable only via the Private Network.
type ScalewayInstancePublicIpInput struct {
	// Reverse DNS hostname for the public IP.
	//  Example: "web-01.example.com"
	//
	//  A matching DNS A record pointing to the public IP must already exist
	//  before setting this field. Useful for email servers (SPF/DKIM compliance)
	//  and professional appearance in network logs.
	//
	//  Optional. If omitted, reverse DNS d...
	ReverseDns string `json:"reverse_dns,omitempty" jsonschema:"Reverse DNS hostname for the public IP. Example: 'web-01.example.com' A matching DNS A record pointing to the public IP must already exist before setting this field. Useful for email servers (SPF/DKIM..."`
}

func (s *ScalewayInstancePublicIpInput) validate() error {
	return nil
}

func (s *ScalewayInstancePublicIpInput) applyDefaults() {
}

func (s *ScalewayInstancePublicIpInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ReverseDns != "" {
		m["reverse_dns"] = s.ReverseDns
	}
	return m
}

// ScalewayInstanceRootVolume configures the instance's boot disk.
//
//	Every instance has a root volume that contains the operating system. By
//	default, the root volume inherits its size and type from the selected image
//	and instance type. Use this message to override those defaults.
type ScalewayInstanceRootVolumeInput struct {
	// Root volume size in GB.
	//
	//  If omitted, uses the image's default root volume size. The minimum
	//  depends on the image (typically 10 GB). Can only be increased, not
	//  decreased, after creation.
	//
	//  Set this when the default size is insufficient for your workload.
	SizeInGb int32 `json:"size_in_gb,omitempty" jsonschema:"Root volume size in GB. If omitted; uses the image's default root volume size. The minimum depends on the image (typically 10 GB). Can only be increased; not decreased; after creation. Set this when t..."`
	// Volume type for the root disk.
	//
	//  Options:
	//    - "l_ssd"      -- Local SSD. High performance, data stored on the
	//                       physical server. Cannot be resized. This is the
	//                       default for most instance types.
	//    - "sbs_volume"  -- SBS (Scaleway Block Storage). Network-atta...
	VolumeType string `json:"volume_type,omitempty" jsonschema:"Volume type for the root disk. Options: - 'l_ssd' -- Local SSD. High performance; data stored on the physical server. Cannot be resized. This is the default for most instance types. - 'sbs_volume' -- ..."`
	// Delete the root volume when the instance is terminated.
	//
	//  Default: true. Set to false to preserve the root volume after instance
	//  deletion (useful for forensics or data recovery). Only meaningful for
	//  SBS volumes -- local SSD volumes are always destroyed with the instance.
	DeleteOnTermination bool `json:"delete_on_termination,omitempty" jsonschema:"Delete the root volume when the instance is terminated. Default: true. Set to false to preserve the root volume after instance deletion (useful for forensics or data recovery). Only meaningful for SBS..."`
	// SBS IOPS allocation (only for sbs_volume type).
	//
	//  Specifies the guaranteed I/O operations per second for the root volume.
	//  Only relevant when volume_type is "sbs_volume". If omitted, Scaleway
	//  uses the default IOPS tier for the volume size.
	//
	//  Higher IOPS = higher cost. Set this only when the default...
	SbsIops int32 `json:"sbs_iops,omitempty" jsonschema:"SBS IOPS allocation (only for sbs_volume type). Specifies the guaranteed I/O operations per second for the root volume. Only relevant when volume_type is 'sbs_volume'. If omitted; Scaleway uses the de..."`
}

func (s *ScalewayInstanceRootVolumeInput) validate() error {
	return nil
}

func (s *ScalewayInstanceRootVolumeInput) applyDefaults() {
}

func (s *ScalewayInstanceRootVolumeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SizeInGb != 0 {
		m["size_in_gb"] = s.SizeInGb
	}
	if s.VolumeType != "" {
		m["volume_type"] = s.VolumeType
	}
	if s.DeleteOnTermination {
		m["delete_on_termination"] = s.DeleteOnTermination
	}
	if s.SbsIops != 0 {
		m["sbs_iops"] = s.SbsIops
	}
	return m
}

// ParseScalewayInstance validates and normalizes a ScalewayInstance cloud_object.
func ParseScalewayInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "scaleway.openmcf.org/v1", "ScalewayInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec ScalewayInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
