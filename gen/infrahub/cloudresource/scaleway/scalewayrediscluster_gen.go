// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package scaleway

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// scaleway-redis-cluster
type ScalewayRedisClusterSpecInput struct {
	// The Scaleway availability zone where the cluster will be created.
	//
	//  Examples: "fr-par-1", "nl-ams-1", "pl-waw-1"
	//
	//  Redis is a ZONAL resource (unlike RDB which is regional). The zone
	//  determines which data center hosts the cluster nodes.
	//
	//  Cannot be changed after creation.
	Zone string `json:"zone" jsonschema:"required,The Scaleway availability zone where the cluster will be created. Examples: 'fr-par-1'; 'nl-ams-1'; 'pl-waw-1' Redis is a ZONAL resource (unlike RDB which is regional). The zone determines which data ..."`
	// Redis engine version.
	//
	//  Format: semantic version (e.g., "7.2.5", "6.2.7").
	//
	//  Can be upgraded (triggers an online migration) but never downgraded.
	//  Check Scaleway documentation for currently supported versions.
	Version string `json:"version" jsonschema:"required,Redis engine version. Format: semantic version (e.g.; '7.2.5'; '6.2.7'). Can be upgraded (triggers an online migration) but never downgraded. Check Scaleway documentation for currently supported versi..."`
	// Node type determining CPU, RAM, and performance characteristics.
	//
	//  Common types:
	//    - "RED1-MICRO"  -- Smallest, for development and testing.
	//    - "RED1-S"      -- Small production workloads.
	//    - "RED1-M"      -- Medium production workloads.
	//    - "RED1-L"      -- Large production workloads.
	//    - "R...
	NodeType string `json:"node_type" jsonschema:"required,Node type determining CPU; RAM; and performance characteristics. Common types: - 'RED1-MICRO' -- Smallest; for development and testing. - 'RED1-S' -- Small production workloads. - 'RED1-M' -- Medium p..."`
	// Number of nodes in the cluster. Determines the deployment mode:
	//
	//    - 1: Standalone mode (single node, no redundancy).
	//    - 2: High Availability (1 main + 1 standby with automatic failover).
	//    - 3+: Cluster mode (data sharded across nodes, minimum 3).
	//
	//  IMPORTANT lifecycle constraints:
	//    - Standal...
	ClusterSize uint32 `json:"cluster_size,omitempty" jsonschema:"Number of nodes in the cluster. Determines the deployment mode: - 1: Standalone mode (single node; no redundancy). - 2: High Availability (1 main + 1 standby with automatic failover). - 3+: Cluster mo..."`
	// Whether to enable TLS encryption for client connections.
	//
	//  When enabled, all client connections must use TLS. The cluster's
	//  TLS certificate is exported in `status.outputs.certificate`.
	//
	//  IMPORTANT: Changing this value DESTROYS and RECREATES the cluster.
	//  Plan TLS requirements before initial deploym...
	TlsEnabled bool `json:"tls_enabled,omitempty" jsonschema:"Whether to enable TLS encryption for client connections. When enabled; all client connections must use TLS. The cluster's TLS certificate is exported in 'status.outputs.certificate'. IMPORTANT: Changi..."`
	// Username for the Redis cluster's initial user.
	//
	//  This is the only user created with the cluster. Redis on Scaleway
	//  supports a single authentication principal (unlike RDB which has
	//  multi-user support).
	UserName string `json:"user_name" jsonschema:"required,Username for the Redis cluster's initial user. This is the only user created with the cluster. Redis on Scaleway supports a single authentication principal (unlike RDB which has multi-user support)."`
	// Password for the Redis cluster user.
	//
	//  Must meet minimum complexity requirements. For production, use a
	//  strong, randomly generated password and manage it through your
	//  organization's secrets workflow.
	Password string `json:"password" jsonschema:"required,Password for the Redis cluster user. Must meet minimum complexity requirements. For production; use a strong; randomly generated password and manage it through your organization's secrets workflow."`
	// Network ACL rules restricting which IPs can connect to the cluster.
	//
	//  Each rule allows a CIDR range to connect. The complete set of rules
	//  defines who can reach the cluster over its public endpoint.
	//
	//  IMPORTANT: ACL rules CONFLICT with Private Network attachment.
	//  Scaleway does not support both simu...
	AclRules []*ScalewayRedisAclRuleInput `json:"acl_rules,omitempty" jsonschema:"Network ACL rules restricting which IPs can connect to the cluster. Each rule allows a CIDR range to connect. The complete set of rules defines who can reach the cluster over its public endpoint. IMPO..."`
	// Private Network to attach the cluster to.
	//
	//  When set, the cluster receives a private endpoint reachable only
	//  from resources on the same Private Network. No public endpoint is
	//  created.
	//
	//  IMPORTANT: Private Network CONFLICTS with ACL rules. If this
	//  field is set, `acl_rules` MUST be empty. This cons...
	PrivateNetworkId string `json:"private_network_id,omitempty" jsonschema:"Private Network to attach the cluster to. When set; the cluster receives a private endpoint reachable only from resources on the same Private Network. No public endpoint is created. IMPORTANT: Private..."`
	// Redis-specific configuration settings.
	//
	//  Key-value pairs passed to the Redis engine configuration. Applied
	//  on both creation and updates.
	//
	//  Common settings:
	//    - "maxclients" = "1000"        -- Maximum concurrent client connections
	//    - "tcp-keepalive" = "120"      -- TCP keepalive interval in secon...
	Settings map[string]string `json:"settings,omitempty" jsonschema:"Redis-specific configuration settings. Key-value pairs passed to the Redis engine configuration. Applied on both creation and updates. Common settings: - 'maxclients' = '1000' -- Maximum concurrent cl..."`
}

func (s *ScalewayRedisClusterSpecInput) validate() error {
	if s.Zone == "" {
		return fmt.Errorf("zone is required")
	}
	if s.Version == "" {
		return fmt.Errorf("version is required")
	}
	if s.NodeType == "" {
		return fmt.Errorf("node_type is required")
	}
	if s.UserName == "" {
		return fmt.Errorf("user_name is required")
	}
	if s.Password == "" {
		return fmt.Errorf("password is required")
	}
	for i, v := range s.AclRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("acl_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ScalewayRedisClusterSpecInput) applyDefaults() {
}

func (s *ScalewayRedisClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone"] = s.Zone
	m["version"] = s.Version
	m["node_type"] = s.NodeType
	if s.ClusterSize != 0 {
		m["cluster_size"] = s.ClusterSize
	}
	if s.TlsEnabled {
		m["tls_enabled"] = s.TlsEnabled
	}
	m["user_name"] = s.UserName
	m["password"] = s.Password
	if len(s.AclRules) > 0 {
		items := make([]any, len(s.AclRules))
		for i, v := range s.AclRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["acl_rules"] = items
	}
	if s.PrivateNetworkId != "" {
		m["private_network_id"] = s.PrivateNetworkId
	}
	if len(s.Settings) > 0 {
		m["settings"] = s.Settings
	}
	return m
}

// ScalewayRedisAclRule defines a network access control rule for the
//
//	Redis cluster's public endpoint.
//
//	Each rule allows connections from a specific CIDR range. The complete
//	set of rules defines who can reach the cluster over the public network.
//
//	ACL rules are only applicable when the cluster is NOT attached to a
//	Private Network (they are mutually exclusive).
type ScalewayRedisAclRuleInput struct {
	// CIDR range to allow.
	//
	//  Examples:
	//    - "10.0.0.0/24" -- Allow a /24 subnet
	//    - "1.2.3.4/32"  -- Allow a single IP
	//    - "0.0.0.0/0"   -- Allow all IPs (NOT recommended for production)
	Ip string `json:"ip" jsonschema:"required,CIDR range to allow. Examples: - '10.0.0.0/24' -- Allow a /24 subnet - '1.2.3.4/32' -- Allow a single IP - '0.0.0.0/0' -- Allow all IPs (NOT recommended for production)"`
	// Human-readable description for this rule.
	//
	//  Helps operators understand the purpose of each ACL entry.
	//  Examples: "Office IP", "VPN egress", "CI/CD pipeline"
	Description string `json:"description,omitempty" jsonschema:"Human-readable description for this rule. Helps operators understand the purpose of each ACL entry. Examples: 'Office IP'; 'VPN egress'; 'CI/CD pipeline'"`
}

func (s *ScalewayRedisAclRuleInput) validate() error {
	if s.Ip == "" {
		return fmt.Errorf("ip is required")
	}
	return nil
}

func (s *ScalewayRedisAclRuleInput) applyDefaults() {
}

func (s *ScalewayRedisAclRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["ip"] = s.Ip
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ParseScalewayRedisCluster validates and normalizes a ScalewayRedisCluster cloud_object.
func ParseScalewayRedisCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "scaleway.openmcf.org/v1", "ScalewayRedisCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec ScalewayRedisClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
