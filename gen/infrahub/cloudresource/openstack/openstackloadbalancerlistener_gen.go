// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackLoadBalancerListener is a Kubernetes Resource Model (KRM) style resource
//
//	for managing Octavia listeners in OpenStack.
//
//	A listener defines a protocol and port combination on a load balancer that accepts
//	incoming traffic. Each listener is associated with exactly one load balancer and
//	forwards traffic to a backend pool. For TLS termination, the listener references
//	a Barbican secret container holding the certificate.
type OpenStackLoadBalancerListenerSpecInput struct {
	// (Required) The load balancer to attach this listener to.
	//  ForceNew: changing this requires recreating the listener.
	//
	//  FK: OpenStackLoadBalancer.status.outputs.loadbalancer_id
	LoadbalancerId string `json:"loadbalancer_id" jsonschema:"required,(Required) The load balancer to attach this listener to. ForceNew: changing this requires recreating the listener. FK: OpenStackLoadBalancer.status.outputs.loadbalancer_id"`
	// (Required) The protocol the listener accepts.
	//  ForceNew: changing this requires recreating the listener.
	//
	//  - HTTP: Unencrypted HTTP traffic (Layer 7)
	//  - HTTPS: Pass-through encrypted traffic (Layer 4, no TLS termination)
	//  - TCP: Raw TCP traffic (Layer 4)
	//  - UDP: Raw UDP traffic (Layer 4)
	//  - TERMINAT...
	Protocol string `json:"protocol" jsonschema:"required,(Required) The protocol the listener accepts. ForceNew: changing this requires recreating the listener. - HTTP: Unencrypted HTTP traffic (Layer 7) - HTTPS: Pass-through encrypted traffic (Layer 4; no ..."`
	// (Required) The port on which the listener accepts traffic.
	//  ForceNew: changing this requires recreating the listener.
	//  Must be between 1 and 65535.
	ProtocolPort int32 `json:"protocol_port" jsonschema:"required,(Required) The port on which the listener accepts traffic. ForceNew: changing this requires recreating the listener. Must be between 1 and 65535."`
	// (Optional) Human-readable description of the listener.
	Description string `json:"description,omitempty" jsonschema:"(Optional) Human-readable description of the listener."`
	// (Optional) Maximum number of connections the listener allows.
	//  -1 means unlimited (Octavia default). Leave unset to use the Octavia default.
	ConnectionLimit int32 `json:"connection_limit,omitempty" jsonschema:"(Optional) Maximum number of connections the listener allows. -1 means unlimited (Octavia default). Leave unset to use the Octavia default."`
	// (Optional) URI of the Barbican TLS secret container for TLS termination.
	//  Required when protocol is TERMINATED_HTTPS. The container must hold the
	//  certificate, private key, and optional intermediates.
	DefaultTlsContainerRef string `json:"default_tls_container_ref,omitempty" jsonschema:"(Optional) URI of the Barbican TLS secret container for TLS termination. Required when protocol is TERMINATED_HTTPS. The container must hold the certificate; private key; and optional intermediates."`
	// (Optional) Headers to insert into HTTP requests before forwarding to backends.
	//  Common use: {"X-Forwarded-For": "true", "X-Forwarded-Proto": "true"}
	//  Only applicable to HTTP and TERMINATED_HTTPS protocols.
	InsertHeaders map[string]string `json:"insert_headers,omitempty" jsonschema:"(Optional) Headers to insert into HTTP requests before forwarding to backends. Common use: {'X-Forwarded-For': 'true'; 'X-Forwarded-Proto': 'true'} Only applicable to HTTP and TERMINATED_HTTPS protoco..."`
	// (Optional) List of CIDRs allowed to access this listener.
	//  When set, only traffic from these CIDRs reaches the listener; all other
	//  traffic is dropped. When empty, all traffic is allowed.
	AllowedCidrs []string `json:"allowed_cidrs,omitempty" jsonschema:"(Optional) List of CIDRs allowed to access this listener. When set; only traffic from these CIDRs reaches the listener; all other traffic is dropped. When empty; all traffic is allowed."`
	// (Optional) Administrative state of the listener.
	//  When false, the listener stops accepting traffic. Default: true.
	AdminStateUp bool `json:"admin_state_up,omitempty" jsonschema:"(Optional) Administrative state of the listener. When false; the listener stops accepting traffic. Default: true."`
	// (Optional) Tags applied to the listener in OpenStack.
	//  Must be unique within this resource.
	Tags []string `json:"tags,omitempty" jsonschema:"(Optional) Tags applied to the listener in OpenStack. Must be unique within this resource."`
	// (Optional) Override the region from the provider configuration.
	Region string `json:"region,omitempty" jsonschema:"(Optional) Override the region from the provider configuration."`
}

func (s *OpenStackLoadBalancerListenerSpecInput) validate() error {
	if s.LoadbalancerId == "" {
		return fmt.Errorf("loadbalancer_id is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	return nil
}

func (s *OpenStackLoadBalancerListenerSpecInput) applyDefaults() {
	// default: AdminStateUp = true (applied at zero-value)
}

func (s *OpenStackLoadBalancerListenerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["loadbalancer_id"] = s.LoadbalancerId
	m["protocol"] = s.Protocol
	m["protocol_port"] = s.ProtocolPort
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.ConnectionLimit != 0 {
		m["connection_limit"] = s.ConnectionLimit
	}
	if s.DefaultTlsContainerRef != "" {
		m["default_tls_container_ref"] = s.DefaultTlsContainerRef
	}
	if len(s.InsertHeaders) > 0 {
		m["insert_headers"] = s.InsertHeaders
	}
	if len(s.AllowedCidrs) > 0 {
		m["allowed_cidrs"] = s.AllowedCidrs
	}
	if s.AdminStateUp {
		m["admin_state_up"] = s.AdminStateUp
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackLoadBalancerListener validates and normalizes a OpenStackLoadBalancerListener cloud_object.
func ParseOpenStackLoadBalancerListener(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackLoadBalancerListener"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackLoadBalancerListenerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
