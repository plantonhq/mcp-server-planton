// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureMssqlServer is the top-level API resource for an Azure SQL Database
//
//	logical server.
//	Azure SQL Database is a fully managed PaaS database engine that runs on the
//	latest stable SQL Server engine. The logical server is an administrative
//	container for databases, firewall rules, and connection policies.
type AzureMssqlServerSpecInput struct {
	// The Azure region where the SQL Server will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the SQL Server will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the SQL Server will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the SQL Server will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the SQL Server.
	//  Must be globally unique across Azure. Used as the server hostname:
	//  `{name}.database.windows.net`
	//  Allowed characters: lowercase letters, numbers, and hyphens.
	//  Must start with a letter. Cannot start or end with a hyphen.
	//  Length: 3 to 63 characters.
	//
	//  **ForceNew**: Chan...
	Name string `json:"name" jsonschema:"required,The name of the SQL Server. Must be globally unique across Azure. Used as the server hostname: '{name}.database.windows.net' Allowed characters: lowercase letters; numbers; and hyphens. Must start wit..."`
	// The administrator login name for the server.
	//  Cannot be "admin", "administrator", "sa", "root", "dbmanager",
	//  "loginmanager", "dbo", "guest", or "public".
	//  Must start with a letter.
	AdministratorLogin string `json:"administrator_login" jsonschema:"required,The administrator login name for the server. Cannot be 'admin'; 'administrator'; 'sa'; 'root'; 'dbmanager'; 'loginmanager'; 'dbo'; 'guest'; or 'public'. Must start with a letter."`
	// The administrator password for the server.
	//  Can be a literal value or a reference to another resource's output
	//  (e.g., a generated random password or a Key Vault secret value).
	//
	//  Password requirements: 8-128 characters, must contain characters from
	//  at least three of: uppercase, lowercase, digits, s...
	AdministratorPassword string `json:"administrator_password" jsonschema:"required,The administrator password for the server. Can be a literal value or a reference to another resource's output (e.g.; a generated random password or a Key Vault secret value). Password requirements: 8-..."`
	// The version of SQL Server.
	//  Azure SQL Database supports two version identifiers:
	//  - "12.0": Current version (SQL Server 2022 / Azure SQL Database)
	//  - "2.0": Legacy (SQL Server 2005 era, virtually unused)
	//
	//  Default: "12.0" (the only version used in practice)
	Version string `json:"version,omitempty" jsonschema:"The version of SQL Server. Azure SQL Database supports two version identifiers: - '12.0': Current version (SQL Server 2022 / Azure SQL Database) - '2.0': Legacy (SQL Server 2005 era; virtually unused)..."`
	// The minimum TLS version for all client connections.
	//  Azure SQL Database enforces TLS encryption for all connections.
	//
	//  Valid values:
	//  - "1.2": TLS 1.2 (recommended, industry standard since 2018)
	//  - "1.0": TLS 1.0 (legacy, only for applications that cannot use TLS 1.2)
	//
	//  Default: "1.2"
	MinimumTlsVersion string `json:"minimum_tls_version,omitempty" jsonschema:"The minimum TLS version for all client connections. Azure SQL Database enforces TLS encryption for all connections. Valid values: - '1.2': TLS 1.2 (recommended; industry standard since 2018) - '1.0': ..."`
	// Whether the server is accessible over the public internet.
	//  When true: the server has a public endpoint and firewall rules control access.
	//  When false: the server is only reachable via AzurePrivateEndpoint.
	//
	//  Unlike PostgreSQL/MySQL Flexible Servers (which derive this from
	//  delegated_subnet_id), Azu...
	PublicNetworkAccessEnabled bool `json:"public_network_access_enabled,omitempty" jsonschema:"Whether the server is accessible over the public internet. When true: the server has a public endpoint and firewall rules control access. When false: the server is only reachable via AzurePrivateEndpo..."`
	// The connection policy for the server.
	//  Controls how clients establish connections to the Azure SQL server.
	//
	//  Valid values:
	//  - "Default": Uses Redirect for connections from within Azure, Proxy for external
	//  - "Proxy": All connections are proxied through the Azure SQL gateway (higher latency)
	//  - "Redi...
	ConnectionPolicy string `json:"connection_policy,omitempty" jsonschema:"The connection policy for the server. Controls how clients establish connections to the Azure SQL server. Valid values: - 'Default': Uses Redirect for connections from within Azure; Proxy for external..."`
	// Databases to create on the server.
	//  Each database is a separate `azurerm_mssql_database` resource with its own
	//  compute SKU, storage, and lifecycle.
	//
	//  **Important**: Unlike PostgreSQL/MySQL where the server defines compute,
	//  in Azure SQL each database carries its own compute tier (sku_name) and
	//  max...
	Databases []*AzureMssqlDatabaseInput `json:"databases,omitempty" jsonschema:"Databases to create on the server. Each database is a separate 'azurerm_mssql_database' resource with its own compute SKU; storage; and lifecycle. **Important**: Unlike PostgreSQL/MySQL where the serv..."`
	// Firewall rules for public access mode.
	//  Only effective when `public_network_access_enabled` is true.
	//  Each rule allows connections from a range of IP addresses.
	//
	//  To allow all Azure services: start_ip_address = "0.0.0.0", end_ip_address = "0.0.0.0"
	//  To allow a single IP: set both start and end to th...
	FirewallRules []*AzureMssqlFirewallRuleInput `json:"firewall_rules,omitempty" jsonschema:"Firewall rules for public access mode. Only effective when 'public_network_access_enabled' is true. Each rule allows connections from a range of IP addresses. To allow all Azure services: start_ip_add..."`
}

func (s *AzureMssqlServerSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.AdministratorLogin == "" {
		return fmt.Errorf("administrator_login is required")
	}
	if s.AdministratorPassword == "" {
		return fmt.Errorf("administrator_password is required")
	}
	for i, v := range s.Databases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("databases[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.FirewallRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("firewall_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureMssqlServerSpecInput) applyDefaults() {
	if s.Version == "" {
		s.Version = "12.0"
	}
	if s.MinimumTlsVersion == "" {
		s.MinimumTlsVersion = "1.2"
	}
	// default: PublicNetworkAccessEnabled = true (applied at zero-value)
	if s.ConnectionPolicy == "" {
		s.ConnectionPolicy = "Default"
	}
}

func (s *AzureMssqlServerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["administrator_login"] = s.AdministratorLogin
	m["administrator_password"] = s.AdministratorPassword
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.MinimumTlsVersion != "" {
		m["minimum_tls_version"] = s.MinimumTlsVersion
	}
	if s.PublicNetworkAccessEnabled {
		m["public_network_access_enabled"] = s.PublicNetworkAccessEnabled
	}
	if s.ConnectionPolicy != "" {
		m["connection_policy"] = s.ConnectionPolicy
	}
	if len(s.Databases) > 0 {
		items := make([]any, len(s.Databases))
		for i, v := range s.Databases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["databases"] = items
	}
	if len(s.FirewallRules) > 0 {
		items := make([]any, len(s.FirewallRules))
		for i, v := range s.FirewallRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["firewall_rules"] = items
	}
	return m
}

// AzureMssqlDatabase defines a database to create on the Azure SQL logical server.
//
//	Each database is a separate Azure resource with its own compute tier (SKU),
//	maximum storage, zone redundancy, and license type. This is fundamentally
//	different from PostgreSQL/MySQL Flexible Server databases, which are lightweight
//	objects (just name + charset + collation) because the server carries the compute.
//
//	**SKU naming convention**:
//	- DTU-based: "Basic", "S0"-"S12" (Standard), "P1"-"P15" (Premium)
//	- vCore-based: "{SERVICE_TIER}_Gen5_{VCORES}" where SERVICE_TIER is:
//	  - "GP" (General Purpose): e.g., "GP_Gen5_2", "GP_Gen5_4", "GP_Gen5_8"
//	  - "BC" (Business Critical): e.g., "BC_Gen5_2", "BC_Gen5_4"
//	  - "HS" (Hyperscale): e.g., "HS_Gen5_2", "HS_Gen5_4"
//	- Serverless: "GP_S_Gen5_1", "GP_S_Gen5_2" (auto-pause capable)
//	- Free: "Free" (one free database per subscription)
type AzureMssqlDatabaseInput struct {
	// The name of the database.
	//  Must be unique within the server. Cannot contain special characters
	//  `<>*%&:\/?` and cannot end with a period or space.
	//  Maximum length: 128 characters.
	Name string `json:"name" jsonschema:"required,The name of the database. Must be unique within the server. Cannot contain special characters '<>*%&:\\/?' and cannot end with a period or space. Maximum length: 128 characters."`
	// The SKU name defining the compute tier and performance level.
	//  This is the most important field -- it determines compute capacity and cost.
	//
	//  DTU-based tiers (simpler, bundled compute/IO/storage):
	//    "Basic" (~5 DTU), "S0" (10 DTU), "S1" (20 DTU), "S2" (50 DTU),
	//    "S3" (100 DTU), "P1" (125 DTU), "P...
	SkuName string `json:"sku_name" jsonschema:"required,The SKU name defining the compute tier and performance level. This is the most important field -- it determines compute capacity and cost. DTU-based tiers (simpler; bundled compute/IO/storage): 'Basic..."`
	// The maximum size of the database in gigabytes.
	//  If omitted, Azure uses the default for the chosen SKU.
	//
	//  For DTU-based: varies by tier (Basic: 2 GB, S0-S2: 250 GB, P1: 500 GB)
	//  For vCore-based: up to 4096 GB (GP), 4096 GB (BC), 100 TB (HS)
	//
	//  Fractional values (0.5 GB) are supported by Azure but this...
	MaxSizeGb int32 `json:"max_size_gb,omitempty" jsonschema:"The maximum size of the database in gigabytes. If omitted; Azure uses the default for the chosen SKU. For DTU-based: varies by tier (Basic: 2 GB; S0-S2: 250 GB; P1: 500 GB) For vCore-based: up to 4096..."`
	// The collation of the database.
	//  Determines sort order and string comparison behavior.
	//
	//  Default: "SQL_Latin1_General_CP1_CI_AS" (case-insensitive, accent-sensitive;
	//  the default for Azure SQL Database and most SQL Server deployments).
	//
	//  Common alternatives:
	//  - "SQL_Latin1_General_CP1_CS_AS" (case-se...
	Collation string `json:"collation,omitempty" jsonschema:"The collation of the database. Determines sort order and string comparison behavior. Default: 'SQL_Latin1_General_CP1_CI_AS' (case-insensitive; accent-sensitive; the default for Azure SQL Database and..."`
	// Enable zone redundancy for the database.
	//  When true, database replicas are spread across availability zones for
	//  higher availability. Supported on Premium (DTU) and Business Critical (vCore).
	//  Not supported on Basic, Standard, or General Purpose tiers.
	//
	//  Default: false
	ZoneRedundant bool `json:"zone_redundant,omitempty" jsonschema:"Enable zone redundancy for the database. When true; database replicas are spread across availability zones for higher availability. Supported on Premium (DTU) and Business Critical (vCore). Not suppor..."`
	// The license type for Azure Hybrid Benefit.
	//  Allows customers with existing SQL Server licenses (with Software Assurance)
	//  to save up to 55% on Azure SQL Database costs.
	//
	//  Valid values:
	//  - "BasePrice": Azure Hybrid Benefit applied (bring your own license, lower cost)
	//  - "LicenseIncluded": Full Azure ...
	LicenseType string `json:"license_type,omitempty" jsonschema:"The license type for Azure Hybrid Benefit. Allows customers with existing SQL Server licenses (with Software Assurance) to save up to 55% on Azure SQL Database costs. Valid values: - 'BasePrice': Azur..."`
	// The storage account type for backup redundancy.
	//  Controls where database backups are replicated for disaster recovery.
	//
	//  Valid values:
	//  - "Geo": Geo-redundant (default, backups replicated to paired region)
	//  - "GeoZone": Geo-zone-redundant (backups across zones and regions)
	//  - "Local": Locally-redund...
	StorageAccountType string `json:"storage_account_type,omitempty" jsonschema:"The storage account type for backup redundancy. Controls where database backups are replicated for disaster recovery. Valid values: - 'Geo': Geo-redundant (default; backups replicated to paired region..."`
}

func (s *AzureMssqlDatabaseInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.SkuName == "" {
		return fmt.Errorf("sku_name is required")
	}
	return nil
}

func (s *AzureMssqlDatabaseInput) applyDefaults() {
	if s.Collation == "" {
		s.Collation = "SQL_Latin1_General_CP1_CI_AS"
	}
	if s.StorageAccountType == "" {
		s.StorageAccountType = "Geo"
	}
}

func (s *AzureMssqlDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["sku_name"] = s.SkuName
	if s.MaxSizeGb != 0 {
		m["max_size_gb"] = s.MaxSizeGb
	}
	if s.Collation != "" {
		m["collation"] = s.Collation
	}
	if s.ZoneRedundant {
		m["zone_redundant"] = s.ZoneRedundant
	}
	if s.LicenseType != "" {
		m["license_type"] = s.LicenseType
	}
	if s.StorageAccountType != "" {
		m["storage_account_type"] = s.StorageAccountType
	}
	return m
}

// AzureMssqlFirewallRule defines a firewall rule for public access mode.
//
//	Each rule allows connections from a contiguous range of IPv4 addresses.
type AzureMssqlFirewallRuleInput struct {
	// The name of the firewall rule.
	//  Must be unique within the server.
	//  Examples: "allow-office", "allow-azure-services", "allow-dev-machine".
	Name string `json:"name" jsonschema:"required,The name of the firewall rule. Must be unique within the server. Examples: 'allow-office'; 'allow-azure-services'; 'allow-dev-machine'."`
	// The start of the IP address range (inclusive).
	//  Must be a valid IPv4 address.
	//  Use "0.0.0.0" with end "0.0.0.0" to allow all Azure services.
	StartIpAddress string `json:"start_ip_address" jsonschema:"required,The start of the IP address range (inclusive). Must be a valid IPv4 address. Use '0.0.0.0' with end '0.0.0.0' to allow all Azure services."`
	// The end of the IP address range (inclusive).
	//  Must be a valid IPv4 address and >= start_ip_address.
	//  Set equal to start_ip_address for a single IP rule.
	EndIpAddress string `json:"end_ip_address" jsonschema:"required,The end of the IP address range (inclusive). Must be a valid IPv4 address and >= start_ip_address. Set equal to start_ip_address for a single IP rule."`
}

func (s *AzureMssqlFirewallRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.StartIpAddress == "" {
		return fmt.Errorf("start_ip_address is required")
	}
	if s.EndIpAddress == "" {
		return fmt.Errorf("end_ip_address is required")
	}
	return nil
}

func (s *AzureMssqlFirewallRuleInput) applyDefaults() {
}

func (s *AzureMssqlFirewallRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["start_ip_address"] = s.StartIpAddress
	m["end_ip_address"] = s.EndIpAddress
	return m
}

// ParseAzureMssqlServer validates and normalizes a AzureMssqlServer cloud_object.
func ParseAzureMssqlServer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureMssqlServer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureMssqlServerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
