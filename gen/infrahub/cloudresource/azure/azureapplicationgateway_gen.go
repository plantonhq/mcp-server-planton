// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureApplicationGateway is the top-level API resource for an Azure Application Gateway.
//
//	Azure Application Gateway is a Layer 7 (HTTP/HTTPS) load balancer and reverse proxy
//	that provides SSL termination, host-based routing, cookie-based session affinity,
//	custom health probes, and optional Web Application Firewall (WAF) protection.
type AzureApplicationGatewaySpecInput struct {
	// The Azure region where the Application Gateway will be created.
	//  Must match the region of the subnet, public IP, and backend resources.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the Application Gateway will be created. Must match the region of the subnet; public IP; and backend resources. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the Application Gateway will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Application Gateway will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Application Gateway.
	//  Must be unique within the resource group.
	//  Allowed characters: alphanumeric, underscores, hyphens, and periods.
	//  Must start with alphanumeric. Length: 1 to 80 characters.
	Name string `json:"name" jsonschema:"required,The name of the Application Gateway. Must be unique within the resource group. Allowed characters: alphanumeric; underscores; hyphens; and periods. Must start with alphanumeric. Length: 1 to 80 charac..."`
	// The ID of a dedicated subnet for the Application Gateway.
	//  App Gateway v2 requires its own subnet with no other resources deployed.
	//  Recommended CIDR: /24 (supports up to 125 instances + 5 Azure-reserved).
	//
	//  Can be a literal Azure resource ID or a reference to an AzureSubnet output.
	SubnetId string `json:"subnet_id" jsonschema:"required,The ID of a dedicated subnet for the Application Gateway. App Gateway v2 requires its own subnet with no other resources deployed. Recommended CIDR: /24 (supports up to 125 instances + 5 Azure-reserve..."`
	// The ID of a public IP address for the frontend configuration.
	//  Must be Standard SKU with Static allocation (enforced by AzurePublicIp).
	//
	//  Can be a literal Azure resource ID or a reference to an AzurePublicIp output.
	PublicIpId string `json:"public_ip_id" jsonschema:"required,The ID of a public IP address for the frontend configuration. Must be Standard SKU with Static allocation (enforced by AzurePublicIp). Can be a literal Azure resource ID or a reference to an AzurePubl..."`
	// The SKU tier of the Application Gateway.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "Standard_v2" -- general L7 load balancing with autoscale, zone redundancy
	//  - "WAF_v2" -- same as Standard_v2 plus Web Application Firewall
	//
	//  V1 SKUs (Standard, WAF) are legacy and n...
	Sku string `json:"sku" jsonschema:"required,The SKU tier of the Application Gateway. Uses Azure's exact API values for provider authenticity. Valid values: - 'Standard_v2' -- general L7 load balancing with autoscale; zone redundancy - 'WAF_v2' ..."`
	// Fixed instance count for the Application Gateway.
	//  Range: 1 to 125. Mutually exclusive with `autoscale`.
	//
	//  If neither `capacity` nor `autoscale` is set, capacity defaults to 2.
	Capacity int32 `json:"capacity,omitempty" jsonschema:"Fixed instance count for the Application Gateway. Range: 1 to 125. Mutually exclusive with 'autoscale'. If neither 'capacity' nor 'autoscale' is set; capacity defaults to 2."`
	// Autoscale configuration. Mutually exclusive with `capacity`.
	//  When set, the Application Gateway automatically scales between
	//  min_capacity and max_capacity based on traffic load.
	Autoscale *AzureApplicationGatewayAutoscaleInput `json:"autoscale,omitempty" jsonschema:"Autoscale configuration. Mutually exclusive with 'capacity'. When set; the Application Gateway automatically scales between min_capacity and max_capacity based on traffic load."`
	// Backend address pools that receive routed traffic.
	//  At least one pool is required. Each pool defines a set of backend
	//  targets by FQDN and/or IP address.
	//
	//  Backend pool membership is defined at creation time (unlike the LB
	//  where membership is managed externally). FQDNs and IP addresses
	//  identify th...
	BackendAddressPools []*AzureBackendAddressPoolInput `json:"backend_address_pools,omitempty" jsonschema:"Backend address pools that receive routed traffic. At least one pool is required. Each pool defines a set of backend targets by FQDN and/or IP address. Backend pool membership is defined at creation t..."`
	// Backend HTTP settings that control how the Application Gateway
	//  communicates with backend targets. At least one is required.
	//
	//  Each setting defines the port, protocol, cookie affinity, timeout,
	//  and optional health probe for a group of backends. Routing rules
	//  reference these settings by name to det...
	BackendHttpSettings []*AzureBackendHttpSettingsInput `json:"backend_http_settings,omitempty" jsonschema:"Backend HTTP settings that control how the Application Gateway communicates with backend targets. At least one is required. Each setting defines the port; protocol; cookie affinity; timeout; and optio..."`
	// HTTP listeners that define the entry points for traffic.
	//  At least one listener is required. Each listener binds to a port
	//  and protocol (HTTP or HTTPS) and optionally matches a host name
	//  for host-based routing.
	//
	//  The IaC modules automatically derive named frontend_port objects
	//  from the listener p...
	HttpListeners []*AzureHttpListenerInput `json:"http_listeners,omitempty" jsonschema:"HTTP listeners that define the entry points for traffic. At least one listener is required. Each listener binds to a port and protocol (HTTP or HTTPS) and optionally matches a host name for host-based..."`
	// Request routing rules that connect listeners to backend pools
	//  via backend HTTP settings. At least one rule is required.
	//
	//  Each rule maps an HTTP listener to a backend address pool and
	//  backend HTTP settings, defining the complete traffic path from
	//  frontend to backend.
	//
	//  Only Basic rule type is sup...
	RequestRoutingRules []*AzureRequestRoutingRuleInput `json:"request_routing_rules,omitempty" jsonschema:"Request routing rules that connect listeners to backend pools via backend HTTP settings. At least one rule is required. Each rule maps an HTTP listener to a backend address pool and backend HTTP setti..."`
	// Custom health probes for backend health monitoring.
	//  Optional -- Azure provides default health probes that check
	//  the root path ("/") on the backend port. Custom probes allow
	//  specifying a health endpoint, interval, and failure threshold.
	//
	//  Referenced by backend_http_settings via `probe_name`.
	Probes []*AzureHealthProbeInput `json:"probes,omitempty" jsonschema:"Custom health probes for backend health monitoring. Optional -- Azure provides default health probes that check the root path ('/') on the backend port. Custom probes allow specifying a health endpoin..."`
	// SSL certificates for HTTPS listeners.
	//  Required when any HTTP listener uses protocol "Https".
	//
	//  Certificates are sourced from Azure Key Vault via `key_vault_secret_id`.
	//  This is the production-recommended approach -- no PFX data or passwords
	//  in the manifest. The Application Gateway must have a user...
	SslCertificates []*AzureSslCertificateInput `json:"ssl_certificates,omitempty" jsonschema:"SSL certificates for HTTPS listeners. Required when any HTTP listener uses protocol 'Https'. Certificates are sourced from Azure Key Vault via 'key_vault_secret_id'. This is the production-recommended..."`
	// User-assigned managed identity IDs for the Application Gateway.
	//  Required when `ssl_certificates` reference Key Vault secrets.
	//  The identity must have GET permission on the Key Vault's certificates.
	//
	//  Can be literal Azure resource IDs or references to AzureUserAssignedIdentity outputs.
	IdentityIds []string `json:"identity_ids,omitempty" jsonschema:"User-assigned managed identity IDs for the Application Gateway. Required when 'ssl_certificates' reference Key Vault secrets. The identity must have GET permission on the Key Vault's certificates. Can..."`
	// Enable Web Application Firewall (WAF).
	//  Only valid when `sku` is "WAF_v2". When enabled, the WAF inspects
	//  incoming HTTP traffic and blocks common web exploits (SQL injection,
	//  XSS, etc.) using OWASP rule sets.
	//
	//  Default: false.
	WafEnabled bool `json:"waf_enabled,omitempty" jsonschema:"Enable Web Application Firewall (WAF). Only valid when 'sku' is 'WAF_v2'. When enabled; the WAF inspects incoming HTTP traffic and blocks common web exploits (SQL injection; XSS; etc.) using OWASP rul..."`
	// WAF firewall mode. Only used when `waf_enabled` is true.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Detection" -- logs attacks but does not block them
	//  - "Prevention" -- blocks attacks and logs them
	//
	//  Default: "Prevention" (recommended for production).
	WafMode string `json:"waf_mode,omitempty" jsonschema:"WAF firewall mode. Only used when 'waf_enabled' is true. Uses Azure's exact API values. Valid values: - 'Detection' -- logs attacks but does not block them - 'Prevention' -- blocks attacks and logs th..."`
	// Enable HTTP/2 protocol support.
	//  HTTP/2 improves performance via multiplexed streams and header
	//  compression. Only applies to client-to-gateway connections;
	//  backend connections always use HTTP/1.1.
	//
	//  Default: false.
	EnableHttp2 bool `json:"enable_http2,omitempty" jsonschema:"Enable HTTP/2 protocol support. HTTP/2 improves performance via multiplexed streams and header compression. Only applies to client-to-gateway connections; backend connections always use HTTP/1.1. Defa..."`
}

func (s *AzureApplicationGatewaySpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if s.PublicIpId == "" {
		return fmt.Errorf("public_ip_id is required")
	}
	if s.Sku == "" {
		return fmt.Errorf("sku is required")
	}
	if s.Autoscale != nil {
		if err := s.Autoscale.validate(); err != nil {
			return fmt.Errorf("autoscale: %w", err)
		}
	}
	if len(s.BackendAddressPools) < 1 {
		return fmt.Errorf("backend_address_pools requires at least 1 items, got %d", len(s.BackendAddressPools))
	}
	for i, v := range s.BackendAddressPools {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backend_address_pools[%d]: %w", i, err)
			}
		}
	}
	if len(s.BackendHttpSettings) < 1 {
		return fmt.Errorf("backend_http_settings requires at least 1 items, got %d", len(s.BackendHttpSettings))
	}
	for i, v := range s.BackendHttpSettings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backend_http_settings[%d]: %w", i, err)
			}
		}
	}
	if len(s.HttpListeners) < 1 {
		return fmt.Errorf("http_listeners requires at least 1 items, got %d", len(s.HttpListeners))
	}
	for i, v := range s.HttpListeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("http_listeners[%d]: %w", i, err)
			}
		}
	}
	if len(s.RequestRoutingRules) < 1 {
		return fmt.Errorf("request_routing_rules requires at least 1 items, got %d", len(s.RequestRoutingRules))
	}
	for i, v := range s.RequestRoutingRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("request_routing_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Probes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("probes[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.SslCertificates {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ssl_certificates[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureApplicationGatewaySpecInput) applyDefaults() {
	if s.Capacity == 0 {
		s.Capacity = 2
	}
	if s.Autoscale != nil {
		s.Autoscale.applyDefaults()
	}
	if s.WafMode == "" {
		s.WafMode = "Prevention"
	}
}

func (s *AzureApplicationGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["subnet_id"] = s.SubnetId
	m["public_ip_id"] = s.PublicIpId
	m["sku"] = s.Sku
	if s.Capacity != 0 {
		m["capacity"] = s.Capacity
	}
	if s.Autoscale != nil {
		m["autoscale"] = s.Autoscale.toMap()
	}
	if len(s.BackendAddressPools) > 0 {
		items := make([]any, len(s.BackendAddressPools))
		for i, v := range s.BackendAddressPools {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backend_address_pools"] = items
	}
	if len(s.BackendHttpSettings) > 0 {
		items := make([]any, len(s.BackendHttpSettings))
		for i, v := range s.BackendHttpSettings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backend_http_settings"] = items
	}
	if len(s.HttpListeners) > 0 {
		items := make([]any, len(s.HttpListeners))
		for i, v := range s.HttpListeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["http_listeners"] = items
	}
	if len(s.RequestRoutingRules) > 0 {
		items := make([]any, len(s.RequestRoutingRules))
		for i, v := range s.RequestRoutingRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["request_routing_rules"] = items
	}
	if len(s.Probes) > 0 {
		items := make([]any, len(s.Probes))
		for i, v := range s.Probes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["probes"] = items
	}
	if len(s.SslCertificates) > 0 {
		items := make([]any, len(s.SslCertificates))
		for i, v := range s.SslCertificates {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ssl_certificates"] = items
	}
	if len(s.IdentityIds) > 0 {
		m["identity_ids"] = s.IdentityIds
	}
	if s.WafEnabled {
		m["waf_enabled"] = s.WafEnabled
	}
	if s.WafMode != "" {
		m["waf_mode"] = s.WafMode
	}
	if s.EnableHttp2 {
		m["enable_http2"] = s.EnableHttp2
	}
	return m
}

// AzureApplicationGatewayAutoscale defines autoscale capacity bounds.
//
//	When configured, the Application Gateway dynamically adjusts instance
//	count based on traffic load.
type AzureApplicationGatewayAutoscaleInput struct {
	// Minimum number of instances. The Application Gateway always runs
	//  at least this many instances.
	//  Range: 0 to 100. Use 0 for scale-to-zero in low-traffic scenarios.
	MinCapacity int32 `json:"min_capacity,omitempty" jsonschema:"Minimum number of instances. The Application Gateway always runs at least this many instances. Range: 0 to 100. Use 0 for scale-to-zero in low-traffic scenarios."`
	// Maximum number of instances. The Application Gateway will not
	//  scale beyond this count.
	//  Range: 2 to 125. Must be greater than min_capacity.
	//  Optional -- if omitted, Azure uses the subscription-level maximum.
	MaxCapacity int32 `json:"max_capacity,omitempty" jsonschema:"Maximum number of instances. The Application Gateway will not scale beyond this count. Range: 2 to 125. Must be greater than min_capacity. Optional -- if omitted; Azure uses the subscription-level max..."`
}

func (s *AzureApplicationGatewayAutoscaleInput) validate() error {
	return nil
}

func (s *AzureApplicationGatewayAutoscaleInput) applyDefaults() {
}

func (s *AzureApplicationGatewayAutoscaleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinCapacity != 0 {
		m["min_capacity"] = s.MinCapacity
	}
	if s.MaxCapacity != 0 {
		m["max_capacity"] = s.MaxCapacity
	}
	return m
}

// AzureBackendAddressPool defines a group of backend targets that
//
//	receive traffic from the Application Gateway. Backends are identified
//	by FQDN and/or IP address.
type AzureBackendAddressPoolInput struct {
	// The name of the backend pool.
	//  Must be unique within the Application Gateway. Referenced by
	//  request routing rules to target traffic.
	//  Examples: "api-backends", "web-servers", "default".
	Name string `json:"name" jsonschema:"required,The name of the backend pool. Must be unique within the Application Gateway. Referenced by request routing rules to target traffic. Examples: 'api-backends'; 'web-servers'; 'default'."`
	// Backend server FQDNs. The Application Gateway resolves these
	//  to IP addresses and routes traffic accordingly.
	//  Examples: "api.contoso.com", "10.0.1.100.nip.io".
	Fqdns []string `json:"fqdns,omitempty" jsonschema:"Backend server FQDNs. The Application Gateway resolves these to IP addresses and routes traffic accordingly. Examples: 'api.contoso.com'; '10.0.1.100.nip.io'."`
	// Backend server IP addresses.
	//  Examples: "10.0.1.4", "10.0.1.5".
	IpAddresses []string `json:"ip_addresses,omitempty" jsonschema:"Backend server IP addresses. Examples: '10.0.1.4'; '10.0.1.5'."`
}

func (s *AzureBackendAddressPoolInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureBackendAddressPoolInput) applyDefaults() {
}

func (s *AzureBackendAddressPoolInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if len(s.Fqdns) > 0 {
		m["fqdns"] = s.Fqdns
	}
	if len(s.IpAddresses) > 0 {
		m["ip_addresses"] = s.IpAddresses
	}
	return m
}

// AzureBackendHttpSettings defines how the Application Gateway
//
//	communicates with backend servers. This includes the port, protocol,
//	session affinity, timeouts, and health probe configuration.
type AzureBackendHttpSettingsInput struct {
	// The name of the backend HTTP settings.
	//  Must be unique within the Application Gateway. Referenced by
	//  request routing rules.
	//  Examples: "http-settings", "https-backend-settings".
	Name string `json:"name" jsonschema:"required,The name of the backend HTTP settings. Must be unique within the Application Gateway. Referenced by request routing rules. Examples: 'http-settings'; 'https-backend-settings'."`
	// The port number used to communicate with backend servers.
	//  Range: 1 to 65535.
	//  Examples: 80 (HTTP), 443 (HTTPS), 8080 (app server).
	Port int32 `json:"port" jsonschema:"required,The port number used to communicate with backend servers. Range: 1 to 65535. Examples: 80 (HTTP); 443 (HTTPS); 8080 (app server)."`
	// The protocol used to communicate with backend servers.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Http" -- plain HTTP to backend
	//  - "Https" -- TLS to backend (end-to-end encryption)
	Protocol string `json:"protocol" jsonschema:"required,The protocol used to communicate with backend servers. Uses Azure's exact API values. Valid values: - 'Http' -- plain HTTP to backend - 'Https' -- TLS to backend (end-to-end encryption)"`
	// Cookie-based session affinity.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Disabled" -- no session affinity (round-robin)
	//  - "Enabled" -- route requests from the same client to the same backend
	//
	//  Default: "Disabled".
	CookieBasedAffinity string `json:"cookie_based_affinity,omitempty" jsonschema:"Cookie-based session affinity. Uses Azure's exact API values. Valid values: - 'Disabled' -- no session affinity (round-robin) - 'Enabled' -- route requests from the same client to the same backend Def..."`
	// Request timeout in seconds.
	//  If the backend does not respond within this time, the request fails.
	//  Range: 1 to 86400 seconds (24 hours).
	//  Default: 30 seconds.
	RequestTimeout int32 `json:"request_timeout,omitempty" jsonschema:"Request timeout in seconds. If the backend does not respond within this time; the request fails. Range: 1 to 86400 seconds (24 hours). Default: 30 seconds."`
	// The name of a custom health probe to use for this backend.
	//  Must match a probe name defined in `probes`.
	//  If omitted, Azure uses the default health probe (GET / on the backend port).
	ProbeName string `json:"probe_name,omitempty" jsonschema:"The name of a custom health probe to use for this backend. Must match a probe name defined in 'probes'. If omitted; Azure uses the default health probe (GET / on the backend port)."`
	// Override the host header sent to the backend.
	//  Useful when backends expect a specific Host header that differs from
	//  the frontend domain.
	//  Mutually exclusive with `pick_host_name_from_backend_address`.
	HostName string `json:"host_name,omitempty" jsonschema:"Override the host header sent to the backend. Useful when backends expect a specific Host header that differs from the frontend domain. Mutually exclusive with 'pick_host_name_from_backend_address'."`
	// Automatically set the Host header to the backend server's hostname.
	//  Useful for multi-tenant backends (e.g., Azure App Service).
	//  Mutually exclusive with `host_name`.
	//  Default: false.
	PickHostNameFromBackendAddress bool `json:"pick_host_name_from_backend_address,omitempty" jsonschema:"Automatically set the Host header to the backend server's hostname. Useful for multi-tenant backends (e.g.; Azure App Service). Mutually exclusive with 'host_name'. Default: false."`
}

func (s *AzureBackendHttpSettingsInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	return nil
}

func (s *AzureBackendHttpSettingsInput) applyDefaults() {
	if s.CookieBasedAffinity == "" {
		s.CookieBasedAffinity = "Disabled"
	}
	if s.RequestTimeout == 0 {
		s.RequestTimeout = 30
	}
}

func (s *AzureBackendHttpSettingsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["port"] = s.Port
	m["protocol"] = s.Protocol
	if s.CookieBasedAffinity != "" {
		m["cookie_based_affinity"] = s.CookieBasedAffinity
	}
	if s.RequestTimeout != 0 {
		m["request_timeout"] = s.RequestTimeout
	}
	if s.ProbeName != "" {
		m["probe_name"] = s.ProbeName
	}
	if s.HostName != "" {
		m["host_name"] = s.HostName
	}
	if s.PickHostNameFromBackendAddress {
		m["pick_host_name_from_backend_address"] = s.PickHostNameFromBackendAddress
	}
	return m
}

// AzureHttpListener defines an entry point for incoming traffic.
//
//	Each listener binds to a frontend port and protocol, optionally
//	matching a specific host name for host-based routing.
type AzureHttpListenerInput struct {
	// The name of the HTTP listener.
	//  Must be unique within the Application Gateway. Referenced by
	//  request routing rules.
	//  Examples: "http-listener", "https-listener", "api-listener".
	Name string `json:"name" jsonschema:"required,The name of the HTTP listener. Must be unique within the Application Gateway. Referenced by request routing rules. Examples: 'http-listener'; 'https-listener'; 'api-listener'."`
	// The frontend port number for this listener.
	//  The IaC modules auto-derive a named frontend_port object
	//  (as "{listener_name}-port") from this value.
	//  Common values: 80 (HTTP), 443 (HTTPS), 8080 (alt HTTP).
	Port int32 `json:"port" jsonschema:"required,The frontend port number for this listener. The IaC modules auto-derive a named frontend_port object (as '{listener_name}-port') from this value. Common values: 80 (HTTP); 443 (HTTPS); 8080 (alt HTTP)..."`
	// The protocol for this listener.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Http" -- plain HTTP listener
	//  - "Https" -- HTTPS listener (requires `ssl_certificate_name`)
	Protocol string `json:"protocol" jsonschema:"required,The protocol for this listener. Uses Azure's exact API values. Valid values: - 'Http' -- plain HTTP listener - 'Https' -- HTTPS listener (requires 'ssl_certificate_name')"`
	// Optional host name for host-based routing.
	//  When set, only requests with a matching Host header are routed
	//  to this listener. Multiple listeners on the same port can each
	//  match different host names (virtual hosting).
	//  Example: "api.contoso.com".
	HostName string `json:"host_name,omitempty" jsonschema:"Optional host name for host-based routing. When set; only requests with a matching Host header are routed to this listener. Multiple listeners on the same port can each match different host names (vir..."`
	// The name of an SSL certificate for HTTPS listeners.
	//  Must match a certificate name defined in `ssl_certificates`.
	//  Required when protocol is "Https".
	SslCertificateName string `json:"ssl_certificate_name,omitempty" jsonschema:"The name of an SSL certificate for HTTPS listeners. Must match a certificate name defined in 'ssl_certificates'. Required when protocol is 'Https'."`
}

func (s *AzureHttpListenerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	return nil
}

func (s *AzureHttpListenerInput) applyDefaults() {
}

func (s *AzureHttpListenerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["port"] = s.Port
	m["protocol"] = s.Protocol
	if s.HostName != "" {
		m["host_name"] = s.HostName
	}
	if s.SslCertificateName != "" {
		m["ssl_certificate_name"] = s.SslCertificateName
	}
	return m
}

// AzureRequestRoutingRule connects an HTTP listener to a backend
//
//	address pool via backend HTTP settings, defining the complete
//	traffic routing path.
//
//	Only Basic rule type is supported. Path-based routing can be
//	added as a v2 enhancement.
type AzureRequestRoutingRuleInput struct {
	// The name of the routing rule.
	//  Must be unique within the Application Gateway.
	//  Examples: "http-rule", "https-rule", "api-routing".
	Name string `json:"name" jsonschema:"required,The name of the routing rule. Must be unique within the Application Gateway. Examples: 'http-rule'; 'https-rule'; 'api-routing'."`
	// The name of the HTTP listener that receives incoming traffic.
	//  Must match a listener name defined in `http_listeners`.
	HttpListenerName string `json:"http_listener_name" jsonschema:"required,The name of the HTTP listener that receives incoming traffic. Must match a listener name defined in 'http_listeners'."`
	// The name of the backend address pool to route traffic to.
	//  Must match a pool name defined in `backend_address_pools`.
	BackendAddressPoolName string `json:"backend_address_pool_name" jsonschema:"required,The name of the backend address pool to route traffic to. Must match a pool name defined in 'backend_address_pools'."`
	// The name of the backend HTTP settings to use.
	//  Must match a settings name defined in `backend_http_settings`.
	BackendHttpSettingsName string `json:"backend_http_settings_name" jsonschema:"required,The name of the backend HTTP settings to use. Must match a settings name defined in 'backend_http_settings'."`
	// The priority of the routing rule.
	//  Required for Application Gateway v2 (API version 2021-08-01+).
	//  Lower values have higher priority. Range: 1 to 20000.
	//  Each rule must have a unique priority value.
	Priority int32 `json:"priority" jsonschema:"required,The priority of the routing rule. Required for Application Gateway v2 (API version 2021-08-01+). Lower values have higher priority. Range: 1 to 20000. Each rule must have a unique priority value."`
}

func (s *AzureRequestRoutingRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.HttpListenerName == "" {
		return fmt.Errorf("http_listener_name is required")
	}
	if s.BackendAddressPoolName == "" {
		return fmt.Errorf("backend_address_pool_name is required")
	}
	if s.BackendHttpSettingsName == "" {
		return fmt.Errorf("backend_http_settings_name is required")
	}
	return nil
}

func (s *AzureRequestRoutingRuleInput) applyDefaults() {
}

func (s *AzureRequestRoutingRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["http_listener_name"] = s.HttpListenerName
	m["backend_address_pool_name"] = s.BackendAddressPoolName
	m["backend_http_settings_name"] = s.BackendHttpSettingsName
	m["priority"] = s.Priority
	return m
}

// AzureSslCertificate defines an SSL/TLS certificate for HTTPS listeners.
//
//	Certificates are sourced from Azure Key Vault -- the production-recommended
//	approach that avoids putting PFX data or passwords in manifests.
//
//	The Application Gateway must have a user-assigned managed identity
//	(specified via `identity_ids`) with GET permission on the Key Vault
//	certificate/secret.
type AzureSslCertificateInput struct {
	// The name of the SSL certificate.
	//  Must be unique within the Application Gateway. Referenced by
	//  HTTPS listeners via `ssl_certificate_name`.
	//  Examples: "wildcard-contoso", "api-cert", "frontend-cert".
	Name string `json:"name" jsonschema:"required,The name of the SSL certificate. Must be unique within the Application Gateway. Referenced by HTTPS listeners via 'ssl_certificate_name'. Examples: 'wildcard-contoso'; 'api-cert'; 'frontend-cert'."`
	// The Azure Key Vault secret ID for the certificate.
	//  This is the full URI to the Key Vault secret/certificate.
	//  Format: https://{vault-name}.vault.azure.net/secrets/{secret-name}
	//  or https://{vault-name}.vault.azure.net/secrets/{secret-name}/{version}
	//
	//  The certificate must be stored as a PFX in Key ...
	KeyVaultSecretId string `json:"key_vault_secret_id" jsonschema:"required,The Azure Key Vault secret ID for the certificate. This is the full URI to the Key Vault secret/certificate. Format: https://{vault-name}.vault.azure.net/secrets/{secret-name} or https://{vault-name}...."`
}

func (s *AzureSslCertificateInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.KeyVaultSecretId == "" {
		return fmt.Errorf("key_vault_secret_id is required")
	}
	return nil
}

func (s *AzureSslCertificateInput) applyDefaults() {
}

func (s *AzureSslCertificateInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["key_vault_secret_id"] = s.KeyVaultSecretId
	return m
}

// ParseAzureApplicationGateway validates and normalizes a AzureApplicationGateway cloud_object.
func ParseAzureApplicationGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureApplicationGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureApplicationGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
