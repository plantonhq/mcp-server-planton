// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// azure-vpc
type AzureVpcSpecInput struct {
	// Azure region in which to create the Virtual Network (e.g., "eastus", "westeurope").
	Region string `json:"region" jsonschema:"required,Azure region in which to create the Virtual Network (e.g.; 'eastus'; 'westeurope')."`
	// The Azure Resource Group where the Virtual Network will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Virtual Network will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The CIDR block defining the address space for the Virtual Network.
	//  Example: "10.0.0.0/16" would allow IP addresses from 10.0.0.0 to 10.0.255.255.
	AddressSpaceCidr string `json:"address_space_cidr" jsonschema:"required,The CIDR block defining the address space for the Virtual Network. Example: '10.0.0.0/16' would allow IP addresses from 10.0.0.0 to 10.0.255.255."`
	// The CIDR block for the primary subnet that AKS cluster nodes will use.
	//  This should be a subset of the address_space_cidr range.
	//  Example: "10.0.0.0/18" would allocate the first half of a /16 address space to the nodes subnet.
	NodesSubnetCidr string `json:"nodes_subnet_cidr" jsonschema:"required,The CIDR block for the primary subnet that AKS cluster nodes will use. This should be a subset of the address_space_cidr range. Example: '10.0.0.0/18' would allocate the first half of a /16 address sp..."`
	// Toggle to enable a NAT Gateway for the nodes subnet to allow outbound Internet connectivity.
	//  If set to true, a NAT Gateway resource will be created and associated with the subnet.
	//  Defaults to false (no NAT Gateway).
	IsNatGatewayEnabled bool `json:"is_nat_gateway_enabled,omitempty" jsonschema:"Toggle to enable a NAT Gateway for the nodes subnet to allow outbound Internet connectivity. If set to true; a NAT Gateway resource will be created and associated with the subnet. Defaults to false (n..."`
	// A list of Azure Private DNS zone resource IDs to link to this Virtual Network.
	//  Each entry should be the full resource ID of an existing Private DNS zone that needs to be resolved within the VNet.
	//  This field is optional and primarily for advanced scenarios.
	DnsPrivateZoneLinks []string `json:"dns_private_zone_links,omitempty" jsonschema:"A list of Azure Private DNS zone resource IDs to link to this Virtual Network. Each entry should be the full resource ID of an existing Private DNS zone that needs to be resolved within the VNet. This..."`
	// Arbitrary tags to apply to the Virtual Network (and related resources like subnets).
	//  Tags are key-value pairs for Azure resource tagging.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Arbitrary tags to apply to the Virtual Network (and related resources like subnets). Tags are key-value pairs for Azure resource tagging."`
}

func (s *AzureVpcSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.AddressSpaceCidr == "" {
		return fmt.Errorf("address_space_cidr is required")
	}
	if s.NodesSubnetCidr == "" {
		return fmt.Errorf("nodes_subnet_cidr is required")
	}
	return nil
}

func (s *AzureVpcSpecInput) applyDefaults() {
}

func (s *AzureVpcSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["address_space_cidr"] = s.AddressSpaceCidr
	m["nodes_subnet_cidr"] = s.NodesSubnetCidr
	if s.IsNatGatewayEnabled {
		m["is_nat_gateway_enabled"] = s.IsNatGatewayEnabled
	}
	if len(s.DnsPrivateZoneLinks) > 0 {
		m["dns_private_zone_links"] = s.DnsPrivateZoneLinks
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// ParseAzureVpc validates and normalizes a AzureVpc cloud_object.
func ParseAzureVpc(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureVpc"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureVpcSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
