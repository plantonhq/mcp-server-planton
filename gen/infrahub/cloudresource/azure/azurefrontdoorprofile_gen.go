// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureFrontDoorProfile is the top-level API resource for an Azure Front Door
//
//	profile. Azure Front Door is a global, scalable CDN and application delivery
//	network that combines HTTP load balancing, SSL offloading, caching, and
//	application acceleration across Microsoft's worldwide edge network.
type AzureFrontDoorProfileSpecInput struct {
	// The Azure Resource Group where the Front Door profile will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	//
	//  While Front Door is a global resource (no region), it must belong to
	//  a resource group for Azure Resource Manager organization.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Front Door profile will be created. Can be a literal string or a reference to an AzureResourceGroup output. While Front Door is a global resource (no region); it mus..."`
	// The name of the Front Door profile.
	//  Must be globally unique within Azure. Used to identify the profile
	//  in the Azure portal and API.
	//
	//  Naming rules:
	//  - 2 to 46 characters
	//  - Must start and end with a letter or number
	//  - Can contain letters, numbers, and hyphens
	//
	//  **ForceNew**: Changing this destroy...
	Name string `json:"name" jsonschema:"required,The name of the Front Door profile. Must be globally unique within Azure. Used to identify the profile in the Azure portal and API. Naming rules: - 2 to 46 characters - Must start and end with a lette..."`
	// The SKU tier for the Front Door profile.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "Standard_AzureFrontDoor" (default): Global load balancing, SSL
	//    offloading, caching, compression, URL routing. 99.99% SLA.
	//  - "Premium_AzureFrontDoor": All Standard features plus ...
	Sku string `json:"sku,omitempty" jsonschema:"The SKU tier for the Front Door profile. Uses Azure's exact API values for provider authenticity. Valid values: - 'Standard_AzureFrontDoor' (default): Global load balancing; SSL offloading; caching; c..."`
	// Response timeout in seconds for the Front Door profile.
	//  Controls how long Front Door waits for a response from the origin
	//  before returning a timeout error to the client.
	//
	//  Range: 16-240 seconds.
	//  Default: 120 seconds.
	//
	//  Increase for slow APIs or large file downloads. Decrease for
	//  latency-sensitiv...
	ResponseTimeoutSeconds int32 `json:"response_timeout_seconds,omitempty" jsonschema:"Response timeout in seconds for the Front Door profile. Controls how long Front Door waits for a response from the origin before returning a timeout error to the client. Range: 16-240 seconds. Default..."`
	// Endpoints for this Front Door profile.
	//  Each endpoint gets a unique hostname (*.azurefd.net) that serves
	//  as the entry point for client traffic. Routes connect endpoints
	//  to origin groups.
	//
	//  At least one endpoint is required for the profile to serve traffic.
	Endpoints []*AzureFrontDoorEndpointInput `json:"endpoints,omitempty" jsonschema:"Endpoints for this Front Door profile. Each endpoint gets a unique hostname (*.azurefd.net) that serves as the entry point for client traffic. Routes connect endpoints to origin groups. At least one e..."`
	// Origin groups for this Front Door profile.
	//  Each origin group is a logical grouping of origins (backends) with
	//  load balancing and health probe configuration. Origins are nested
	//  within their origin group.
	//
	//  At least one origin group with at least one origin is required.
	OriginGroups []*AzureFrontDoorOriginGroupInput `json:"origin_groups,omitempty" jsonschema:"Origin groups for this Front Door profile. Each origin group is a logical grouping of origins (backends) with load balancing and health probe configuration. Origins are nested within their origin grou..."`
	// Routes for this Front Door profile.
	//  Routes connect endpoints to origin groups by matching URL patterns
	//  to specific backend pools. Each route defines which endpoint receives
	//  traffic, which origin group serves it, and optional caching behavior.
	//
	//  At least one route is required for traffic to flow t...
	Routes []*AzureFrontDoorRouteInput `json:"routes,omitempty" jsonschema:"Routes for this Front Door profile. Routes connect endpoints to origin groups by matching URL patterns to specific backend pools. Each route defines which endpoint receives traffic; which origin group..."`
}

func (s *AzureFrontDoorProfileSpecInput) validate() error {
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.Endpoints {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("endpoints[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.OriginGroups {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("origin_groups[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Routes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("routes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureFrontDoorProfileSpecInput) applyDefaults() {
	if s.Sku == "" {
		s.Sku = "Standard_AzureFrontDoor"
	}
	if s.ResponseTimeoutSeconds == 0 {
		s.ResponseTimeoutSeconds = 120
	}
}

func (s *AzureFrontDoorProfileSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.Sku != "" {
		m["sku"] = s.Sku
	}
	if s.ResponseTimeoutSeconds != 0 {
		m["response_timeout_seconds"] = s.ResponseTimeoutSeconds
	}
	if len(s.Endpoints) > 0 {
		items := make([]any, len(s.Endpoints))
		for i, v := range s.Endpoints {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["endpoints"] = items
	}
	if len(s.OriginGroups) > 0 {
		items := make([]any, len(s.OriginGroups))
		for i, v := range s.OriginGroups {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["origin_groups"] = items
	}
	if len(s.Routes) > 0 {
		items := make([]any, len(s.Routes))
		for i, v := range s.Routes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["routes"] = items
	}
	return m
}

// AzureFrontDoorEndpoint defines an endpoint within the Front Door profile.
//
//	An endpoint is the public-facing entry point. Each endpoint gets a
//	generated hostname like `{name}-{hash}.z01.azurefd.net` that clients
//	connect to. Endpoints can be enabled/disabled without deletion.
//
//	**ForceNew fields**: `name`.
type AzureFrontDoorEndpointInput struct {
	// The endpoint name.
	//  Must be unique within the profile. Used to generate the public
	//  hostname: `{name}-{hash}.z01.azurefd.net`.
	//
	//  Naming rules:
	//  - 2 to 46 characters
	//  - Must start and end with a letter or number
	//  - Can contain letters, numbers, and hyphens
	//
	//  **ForceNew**: Changing this destroys and r...
	Name string `json:"name" jsonschema:"required,The endpoint name. Must be unique within the profile. Used to generate the public hostname: '{name}-{hash}.z01.azurefd.net'. Naming rules: - 2 to 46 characters - Must start and end with a letter or nu..."`
	// Whether the endpoint is enabled and serving traffic.
	//  When false, the endpoint stops accepting requests but is not deleted.
	//  Useful for maintenance windows or gradual rollouts.
	//
	//  Default: true
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether the endpoint is enabled and serving traffic. When false; the endpoint stops accepting requests but is not deleted. Useful for maintenance windows or gradual rollouts. Default: true"`
}

func (s *AzureFrontDoorEndpointInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureFrontDoorEndpointInput) applyDefaults() {
	// default: Enabled = true (applied at zero-value)
}

func (s *AzureFrontDoorEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	return m
}

// AzureFrontDoorHealthProbe configures periodic health checks for origins.
//
//	Front Door sends probe requests at the specified interval to each origin
//	in the group. Origins that fail to respond successfully are marked
//	unhealthy and removed from the load balancing rotation until they recover.
type AzureFrontDoorHealthProbeInput struct {
	// Protocol used for health probe requests.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Http": Probe over HTTP (port 80 by default)
	//  - "Https": Probe over HTTPS (port 443 by default)
	Protocol string `json:"protocol" jsonschema:"required,Protocol used for health probe requests. Uses Azure's exact API values. Valid values: - 'Http': Probe over HTTP (port 80 by default) - 'Https': Probe over HTTPS (port 443 by default)"`
	// URL path for the health probe request.
	//  Front Door sends the probe to `{protocol}://{origin_host}:{port}{path}`.
	//
	//  Common patterns:
	//  - "/" (default): Simple connectivity check
	//  - "/health": Dedicated health endpoint
	//  - "/api/healthz": Kubernetes-style health check
	//
	//  Default: "/"
	Path string `json:"path,omitempty" jsonschema:"URL path for the health probe request. Front Door sends the probe to '{protocol}://{origin_host}:{port}{path}'. Common patterns: - '/' (default): Simple connectivity check - '/health': Dedicated healt..."`
	// HTTP method for the health probe request.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "HEAD" (default): Sends a HEAD request (no body). More efficient,
	//    checks only that the origin responds with 200.
	//  - "GET": Sends a GET request. Use when the health endpoint needs
	//    to evaluate the respon...
	RequestType string `json:"request_type,omitempty" jsonschema:"HTTP method for the health probe request. Uses Azure's exact API values. Valid values: - 'HEAD' (default): Sends a HEAD request (no body). More efficient; checks only that the origin responds with 200..."`
	// Interval between health probe requests in seconds.
	//  Shorter intervals detect failures faster but generate more probe traffic.
	//
	//  Range: 1-255 seconds.
	//
	//  Guidelines:
	//  - 5-15 seconds: Fast detection for latency-sensitive workloads
	//  - 30-60 seconds: Balanced for most production workloads
	//  - 120-255 seco...
	IntervalInSeconds int32 `json:"interval_in_seconds" jsonschema:"required,Interval between health probe requests in seconds. Shorter intervals detect failures faster but generate more probe traffic. Range: 1-255 seconds. Guidelines: - 5-15 seconds: Fast detection for latenc..."`
}

func (s *AzureFrontDoorHealthProbeInput) validate() error {
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	return nil
}

func (s *AzureFrontDoorHealthProbeInput) applyDefaults() {
	if s.Path == "" {
		s.Path = "/"
	}
	if s.RequestType == "" {
		s.RequestType = "HEAD"
	}
}

func (s *AzureFrontDoorHealthProbeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["protocol"] = s.Protocol
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.RequestType != "" {
		m["request_type"] = s.RequestType
	}
	m["interval_in_seconds"] = s.IntervalInSeconds
	return m
}

// AzureFrontDoorLoadBalancing configures how Front Door distributes
//
//	traffic across origins within an origin group.
//
//	Front Door uses a latency-aware, weighted algorithm:
//	1. Sample a number of recent health probe results (sample_size)
//	2. Identify origins with enough successful probes (successful_samples_required)
//	3. Among healthy origins, select based on latency + additional_latency threshold
//	4. Apply priority (lower = preferred) and weight (higher = more traffic)
type AzureFrontDoorLoadBalancingInput struct {
	// Number of recent health probe samples to evaluate.
	//  Front Door considers this many of the most recent probe results
	//  when determining origin health.
	//
	//  Range: 0-255. Default: 4.
	SampleSize int32 `json:"sample_size,omitempty" jsonschema:"Number of recent health probe samples to evaluate. Front Door considers this many of the most recent probe results when determining origin health. Range: 0-255. Default: 4."`
	// Number of successful probe samples required to consider an origin healthy.
	//  Out of the `sample_size` samples, at least this many must be successful
	//  for the origin to remain in the healthy pool.
	//
	//  Range: 0-255. Default: 3.
	SuccessfulSamplesRequired int32 `json:"successful_samples_required,omitempty" jsonschema:"Number of successful probe samples required to consider an origin healthy. Out of the 'sample_size' samples; at least this many must be successful for the origin to remain in the healthy pool. Range: ..."`
	// Additional latency tolerance in milliseconds for origin selection.
	//  Origins whose latency is within this threshold of the fastest origin
	//  are considered equally fast and receive traffic based on weight.
	//
	//  Higher values = more even distribution across geographically dispersed origins.
	//  Lower values =...
	AdditionalLatencyInMilliseconds int32 `json:"additional_latency_in_milliseconds,omitempty" jsonschema:"Additional latency tolerance in milliseconds for origin selection. Origins whose latency is within this threshold of the fastest origin are considered equally fast and receive traffic based on weight...."`
}

func (s *AzureFrontDoorLoadBalancingInput) validate() error {
	return nil
}

func (s *AzureFrontDoorLoadBalancingInput) applyDefaults() {
	if s.SampleSize == 0 {
		s.SampleSize = 4
	}
	if s.SuccessfulSamplesRequired == 0 {
		s.SuccessfulSamplesRequired = 3
	}
	if s.AdditionalLatencyInMilliseconds == 0 {
		s.AdditionalLatencyInMilliseconds = 50
	}
}

func (s *AzureFrontDoorLoadBalancingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SampleSize != 0 {
		m["sample_size"] = s.SampleSize
	}
	if s.SuccessfulSamplesRequired != 0 {
		m["successful_samples_required"] = s.SuccessfulSamplesRequired
	}
	if s.AdditionalLatencyInMilliseconds != 0 {
		m["additional_latency_in_milliseconds"] = s.AdditionalLatencyInMilliseconds
	}
	return m
}

// AzureFrontDoorOrigin defines a backend origin within an origin group.
//
//	An origin is a backend server or service that Front Door routes
//	traffic to. Origins can be any publicly accessible (or privately
//	linked for Premium SKU) endpoint: App Service, Container Apps,
//	Storage Account, custom server, another CDN, etc.
//
//	**ForceNew fields**: `name`.
type AzureFrontDoorOriginInput struct {
	// The origin name.
	//  Must be unique within the origin group.
	//
	//  **ForceNew**: Changing this destroys and recreates the origin.
	Name string `json:"name" jsonschema:"required,The origin name. Must be unique within the origin group. **ForceNew**: Changing this destroys and recreates the origin."`
	// The hostname of the origin.
	//  Front Door connects to this address to retrieve content.
	//
	//  Examples:
	//  - "myapp.azurewebsites.net" (App Service)
	//  - "myapp.eastus.azurecontainerapps.io" (Container Apps)
	//  - "mystorageaccount.blob.core.windows.net" (Blob Storage)
	//  - "api.example.com" (custom server)
	//
	//  Cann...
	HostName string `json:"host_name" jsonschema:"required,The hostname of the origin. Front Door connects to this address to retrieve content. Examples: - 'myapp.azurewebsites.net' (App Service) - 'myapp.eastus.azurecontainerapps.io' (Container Apps) - 'myst..."`
	// Whether Front Door validates the origin's SSL certificate hostname.
	//  When true, Front Door verifies that the certificate CN or SAN
	//  matches the origin host header or host name.
	//
	//  **IMPORTANT**: Set to true for production workloads. Setting to false
	//  disables certificate validation and is a security ...
	CertificateNameCheckEnabled bool `json:"certificate_name_check_enabled,omitempty" jsonschema:"Whether Front Door validates the origin's SSL certificate hostname. When true; Front Door verifies that the certificate CN or SAN matches the origin host header or host name. **IMPORTANT**: Set to tru..."`
	// The Host header value sent to the origin.
	//  Overrides the default Host header (which is the origin hostname).
	//
	//  **Critical for multi-tenant backends**: Azure App Service, Function Apps,
	//  and Container Apps use the Host header to route to the correct app.
	//  Without this, origins may return 404 or route...
	OriginHostHeader string `json:"origin_host_header,omitempty" jsonschema:"The Host header value sent to the origin. Overrides the default Host header (which is the origin hostname). **Critical for multi-tenant backends**: Azure App Service; Function Apps; and Container Apps..."`
	// HTTP port for the origin.
	//  Used when Front Door connects to the origin over HTTP.
	//
	//  Range: 1-65535. Default: 80.
	HttpPort int32 `json:"http_port,omitempty" jsonschema:"HTTP port for the origin. Used when Front Door connects to the origin over HTTP. Range: 1-65535. Default: 80."`
	// HTTPS port for the origin.
	//  Used when Front Door connects to the origin over HTTPS.
	//
	//  Range: 1-65535. Default: 443.
	HttpsPort int32 `json:"https_port,omitempty" jsonschema:"HTTPS port for the origin. Used when Front Door connects to the origin over HTTPS. Range: 1-65535. Default: 443."`
	// Priority of this origin within the origin group.
	//  Lower priority origins receive traffic first. Traffic shifts to
	//  higher priority origins only when all lower priority origins are
	//  unhealthy.
	//
	//  Range: 1-5. Default: 1.
	//
	//  Use priorities to define active-passive failover:
	//  - Priority 1: Primary origins...
	Priority int32 `json:"priority,omitempty" jsonschema:"Priority of this origin within the origin group. Lower priority origins receive traffic first. Traffic shifts to higher priority origins only when all lower priority origins are unhealthy. Range: 1-5...."`
	// Traffic weight for this origin within the same priority level.
	//  Among origins with equal priority, traffic is distributed
	//  proportionally by weight.
	//
	//  Range: 1-1000. Default: 500.
	//
	//  Examples:
	//  - Equal distribution: All origins weight 500
	//  - 70/30 split: Origin A weight 700, Origin B weight 300
	//  - Ca...
	Weight int32 `json:"weight,omitempty" jsonschema:"Traffic weight for this origin within the same priority level. Among origins with equal priority; traffic is distributed proportionally by weight. Range: 1-1000. Default: 500. Examples: - Equal distri..."`
	// Whether this origin is enabled and receiving traffic.
	//  When false, Front Door skips this origin during load balancing
	//  but does not delete it.
	//
	//  Useful for draining traffic during maintenance.
	//
	//  Default: true
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether this origin is enabled and receiving traffic. When false; Front Door skips this origin during load balancing but does not delete it. Useful for draining traffic during maintenance. Default: tr..."`
	// Private link configuration for connecting to the origin privately.
	//  When configured, Front Door connects to the origin through Azure
	//  Private Link instead of over the public internet.
	//
	//  **Requires Premium_AzureFrontDoor SKU.**
	//  Also requires certificate_name_check_enabled = true.
	//
	//  After provisionin...
	PrivateLink *AzureFrontDoorPrivateLinkInput `json:"private_link,omitempty" jsonschema:"Private link configuration for connecting to the origin privately. When configured; Front Door connects to the origin through Azure Private Link instead of over the public internet. **Requires Premium..."`
}

func (s *AzureFrontDoorOriginInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.HostName == "" {
		return fmt.Errorf("host_name is required")
	}
	if s.PrivateLink != nil {
		if err := s.PrivateLink.validate(); err != nil {
			return fmt.Errorf("private_link: %w", err)
		}
	}
	return nil
}

func (s *AzureFrontDoorOriginInput) applyDefaults() {
	// default: CertificateNameCheckEnabled = true (applied at zero-value)
	if s.HttpPort == 0 {
		s.HttpPort = 80
	}
	if s.HttpsPort == 0 {
		s.HttpsPort = 443
	}
	if s.Priority == 0 {
		s.Priority = 1
	}
	if s.Weight == 0 {
		s.Weight = 500
	}
	// default: Enabled = true (applied at zero-value)
	if s.PrivateLink != nil {
		s.PrivateLink.applyDefaults()
	}
}

func (s *AzureFrontDoorOriginInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["host_name"] = s.HostName
	if s.CertificateNameCheckEnabled {
		m["certificate_name_check_enabled"] = s.CertificateNameCheckEnabled
	}
	if s.OriginHostHeader != "" {
		m["origin_host_header"] = s.OriginHostHeader
	}
	if s.HttpPort != 0 {
		m["http_port"] = s.HttpPort
	}
	if s.HttpsPort != 0 {
		m["https_port"] = s.HttpsPort
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.PrivateLink != nil {
		m["private_link"] = s.PrivateLink.toMap()
	}
	return m
}

// AzureFrontDoorOriginGroup defines an origin group within the profile.
//
//	An origin group is a collection of origins (backends) that Front Door
//	load-balances traffic across. Each group has its own load balancing
//	configuration and optional health probes to detect unhealthy origins.
//
//	Origins are nested within origin groups because an origin without
//	a group has no routing context. This matches DD03 bundling rules.
type AzureFrontDoorOriginGroupInput struct {
	// The origin group name.
	//  Must be unique within the profile. Referenced by routes to direct
	//  traffic to this group of backends.
	Name string `json:"name" jsonschema:"required,The origin group name. Must be unique within the profile. Referenced by routes to direct traffic to this group of backends."`
	// Enable session affinity (sticky sessions) for this origin group.
	//  When enabled, Front Door routes subsequent requests from the same
	//  client to cookies.
	//
	//  Important for stateful backends (e.g., session-based web apps).
	//  Disable for stateless APIs where even distribution is preferred.
	//
	//  Default: true
	SessionAffinityEnabled bool `json:"session_affinity_enabled,omitempty" jsonschema:"Enable session affinity (sticky sessions) for this origin group. When enabled; Front Door routes subsequent requests from the same client to cookies. Important for stateful backends (e.g.; session-bas..."`
	// Load balancing configuration for distributing traffic across origins.
	//  Controls how Front Door samples origin health and selects origins.
	LoadBalancing *AzureFrontDoorLoadBalancingInput `json:"load_balancing,omitempty" jsonschema:"Load balancing configuration for distributing traffic across origins. Controls how Front Door samples origin health and selects origins."`
	// Health probe configuration for detecting unhealthy origins.
	//  When configured, Front Door periodically sends requests to each origin
	//  to verify availability. Unhealthy origins are removed from rotation.
	//
	//  Omit to disable health probing (all origins assumed healthy).
	//  Recommended for production worklo...
	HealthProbe *AzureFrontDoorHealthProbeInput `json:"health_probe,omitempty" jsonschema:"Health probe configuration for detecting unhealthy origins. When configured; Front Door periodically sends requests to each origin to verify availability. Unhealthy origins are removed from rotation. ..."`
	// Origins (backends) in this origin group.
	//  Front Door distributes traffic across these origins based on
	//  priority and weight. At least one origin is required.
	Origins []*AzureFrontDoorOriginInput `json:"origins,omitempty" jsonschema:"Origins (backends) in this origin group. Front Door distributes traffic across these origins based on priority and weight. At least one origin is required."`
}

func (s *AzureFrontDoorOriginGroupInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.LoadBalancing != nil {
		if err := s.LoadBalancing.validate(); err != nil {
			return fmt.Errorf("load_balancing: %w", err)
		}
	}
	if s.HealthProbe != nil {
		if err := s.HealthProbe.validate(); err != nil {
			return fmt.Errorf("health_probe: %w", err)
		}
	}
	for i, v := range s.Origins {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("origins[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureFrontDoorOriginGroupInput) applyDefaults() {
	// default: SessionAffinityEnabled = true (applied at zero-value)
	if s.LoadBalancing != nil {
		s.LoadBalancing.applyDefaults()
	}
	if s.HealthProbe != nil {
		s.HealthProbe.applyDefaults()
	}
}

func (s *AzureFrontDoorOriginGroupInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.SessionAffinityEnabled {
		m["session_affinity_enabled"] = s.SessionAffinityEnabled
	}
	if s.LoadBalancing != nil {
		m["load_balancing"] = s.LoadBalancing.toMap()
	}
	if s.HealthProbe != nil {
		m["health_probe"] = s.HealthProbe.toMap()
	}
	if len(s.Origins) > 0 {
		items := make([]any, len(s.Origins))
		for i, v := range s.Origins {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["origins"] = items
	}
	return m
}

// AzureFrontDoorPrivateLink configures private connectivity from
//
//	Front Door to an origin through Azure Private Link.
//
//	This enables Front Door to access backend origins without exposing
//	them to the public internet. The origin can have public access
//	completely disabled while still being reachable from Front Door.
//
//	**Premium SKU only.** Standard SKU does not support private link.
//
//	After the private link is provisioned, the connection request must
//	be approved on the target resource. This is a manual step in the
//	Azure portal or via CLI.
type AzureFrontDoorPrivateLinkInput struct {
	// The Azure region where the private link target is located.
	//  Private link connections are regional -- the location must match
	//  the target resource's region.
	//
	//  Examples: "eastus", "westus2", "westeurope"
	Location string `json:"location" jsonschema:"required,The Azure region where the private link target is located. Private link connections are regional -- the location must match the target resource's region. Examples: 'eastus'; 'westus2'; 'westeurope'"`
	// The Azure Resource Manager ID of the private link target.
	//  This is the resource that Front Door will connect to privately.
	//
	//  Common targets:
	//  - App Service: /subscriptions/.../sites/{name}
	//  - Storage Account: /subscriptions/.../storageAccounts/{name}
	//  - Container Apps Environment: /subscriptions/......
	PrivateLinkTargetId string `json:"private_link_target_id" jsonschema:"required,The Azure Resource Manager ID of the private link target. This is the resource that Front Door will connect to privately. Common targets: - App Service: /subscriptions/.../sites/{name} - Storage Accou..."`
	// The approval message sent to the target resource owner.
	//  Appears in the private endpoint connection approval screen.
	//
	//  Maximum: 140 characters.
	//
	//  Default: "Access request for CDN FrontDoor Private Link Origin"
	RequestMessage string `json:"request_message,omitempty" jsonschema:"The approval message sent to the target resource owner. Appears in the private endpoint connection approval screen. Maximum: 140 characters. Default: 'Access request for CDN FrontDoor Private Link Ori..."`
	// The target sub-resource type for the private link connection.
	//  Required for most target types except Private Link Services.
	//
	//  Common values:
	//  - "sites": App Service / Function App
	//  - "blob": Storage Account Blob
	//  - "blob_secondary": Storage Account Blob (secondary)
	//  - "web": Static Web App
	//  - "web_s...
	TargetType string `json:"target_type,omitempty" jsonschema:"The target sub-resource type for the private link connection. Required for most target types except Private Link Services. Common values: - 'sites': App Service / Function App - 'blob': Storage Accoun..."`
}

func (s *AzureFrontDoorPrivateLinkInput) validate() error {
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.PrivateLinkTargetId == "" {
		return fmt.Errorf("private_link_target_id is required")
	}
	return nil
}

func (s *AzureFrontDoorPrivateLinkInput) applyDefaults() {
	if s.RequestMessage == "" {
		s.RequestMessage = "Access request for CDN FrontDoor Private Link Origin"
	}
}

func (s *AzureFrontDoorPrivateLinkInput) toMap() map[string]any {
	m := make(map[string]any)
	m["location"] = s.Location
	m["private_link_target_id"] = s.PrivateLinkTargetId
	if s.RequestMessage != "" {
		m["request_message"] = s.RequestMessage
	}
	if s.TargetType != "" {
		m["target_type"] = s.TargetType
	}
	return m
}

// AzureFrontDoorRoute defines how traffic flows from an endpoint
//
//	to an origin group based on URL pattern matching.
//
//	Routes are the glue that connects Front Door endpoints (entry points)
//	to origin groups (backends). Each route matches URL patterns and
//	forwards matching requests to the specified origin group, with
//	optional caching and protocol behavior.
//
//	**ForceNew fields**: `name`.
type AzureFrontDoorRouteInput struct {
	// The route name.
	//  Must be unique within the profile.
	//
	//  **ForceNew**: Changing this destroys and recreates the route.
	Name string `json:"name" jsonschema:"required,The route name. Must be unique within the profile. **ForceNew**: Changing this destroys and recreates the route."`
	// The endpoint name this route is associated with.
	//  Must reference an endpoint defined in `endpoints[]` by name.
	//  Traffic arriving at this endpoint matching `patterns_to_match`
	//  is routed through this route.
	EndpointName string `json:"endpoint_name" jsonschema:"required,The endpoint name this route is associated with. Must reference an endpoint defined in 'endpoints[]' by name. Traffic arriving at this endpoint matching 'patterns_to_match' is routed through this rout..."`
	// The origin group name this route forwards traffic to.
	//  Must reference an origin group defined in `origin_groups[]` by name.
	OriginGroupName string `json:"origin_group_name" jsonschema:"required,The origin group name this route forwards traffic to. Must reference an origin group defined in 'origin_groups[]' by name."`
	// URL patterns to match for this route.
	//  Front Door evaluates incoming request paths against these patterns
	//  and routes matching requests to the origin group.
	//
	//  Pattern syntax:
	//  - "/*" matches all paths (catch-all)
	//  - "/api/*" matches all paths under /api/
	//  - "/images/*" matches all paths under /image...
	PatternsToMatch []string `json:"patterns_to_match,omitempty" jsonschema:"URL patterns to match for this route. Front Door evaluates incoming request paths against these patterns and routes matching requests to the origin group. Pattern syntax: - '/*' matches all paths (cat..."`
	// Protocols supported by this route.
	//  Uses Azure's exact API values.
	//
	//  Valid values: "Http", "Https"
	//
	//  Include both "Http" and "Https" when https_redirect_enabled is true
	//  (so HTTP requests can be received and redirected to HTTPS).
	SupportedProtocols []string `json:"supported_protocols,omitempty" jsonschema:"Protocols supported by this route. Uses Azure's exact API values. Valid values: 'Http'; 'Https' Include both 'Http' and 'Https' when https_redirect_enabled is true (so HTTP requests can be received an..."`
	// Protocol used when forwarding requests from Front Door to the origin.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "MatchRequest" (default): Use the same protocol as the client request
	//  - "HttpOnly": Always forward to origin over HTTP
	//  - "HttpsOnly": Always forward to origin over HTTPS
	//
	//  Defau...
	ForwardingProtocol string `json:"forwarding_protocol,omitempty" jsonschema:"Protocol used when forwarding requests from Front Door to the origin. Uses Azure's exact API values. Valid values: - 'MatchRequest' (default): Use the same protocol as the client request - 'HttpOnly':..."`
	// Enable automatic HTTPS redirect for HTTP requests.
	//  When true, HTTP requests are automatically redirected to HTTPS
	//  with a 301 status code.
	//
	//  Requires both "Http" and "Https" in supported_protocols.
	//
	//  Default: true
	HttpsRedirectEnabled bool `json:"https_redirect_enabled,omitempty" jsonschema:"Enable automatic HTTPS redirect for HTTP requests. When true; HTTP requests are automatically redirected to HTTPS with a 301 status code. Requires both 'Http' and 'Https' in supported_protocols. Defau..."`
	// Whether to link this route to the endpoint's default domain.
	//  When true, the route is accessible via the endpoint's generated
	//  hostname (*.azurefd.net).
	//
	//  Must be true if no custom domains are associated with the route.
	//
	//  Default: true
	LinkToDefaultDomain bool `json:"link_to_default_domain,omitempty" jsonschema:"Whether to link this route to the endpoint's default domain. When true; the route is accessible via the endpoint's generated hostname (*.azurefd.net). Must be true if no custom domains are associated ..."`
	// Whether this route is enabled and processing traffic.
	//  When false, the route stops matching requests but is not deleted.
	//
	//  Default: true
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether this route is enabled and processing traffic. When false; the route stops matching requests but is not deleted. Default: true"`
	// Cache configuration for this route.
	//  When configured, Front Door caches responses from the origin at
	//  edge locations to reduce origin load and improve latency.
	//
	//  Omit to disable caching (all requests forwarded to origin).
	Cache *AzureFrontDoorRouteCacheInput `json:"cache,omitempty" jsonschema:"Cache configuration for this route. When configured; Front Door caches responses from the origin at edge locations to reduce origin load and improve latency. Omit to disable caching (all requests forw..."`
}

func (s *AzureFrontDoorRouteInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.EndpointName == "" {
		return fmt.Errorf("endpoint_name is required")
	}
	if s.OriginGroupName == "" {
		return fmt.Errorf("origin_group_name is required")
	}
	if s.Cache != nil {
		if err := s.Cache.validate(); err != nil {
			return fmt.Errorf("cache: %w", err)
		}
	}
	return nil
}

func (s *AzureFrontDoorRouteInput) applyDefaults() {
	if s.ForwardingProtocol == "" {
		s.ForwardingProtocol = "MatchRequest"
	}
	// default: HttpsRedirectEnabled = true (applied at zero-value)
	// default: LinkToDefaultDomain = true (applied at zero-value)
	// default: Enabled = true (applied at zero-value)
	if s.Cache != nil {
		s.Cache.applyDefaults()
	}
}

func (s *AzureFrontDoorRouteInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["endpoint_name"] = s.EndpointName
	m["origin_group_name"] = s.OriginGroupName
	if len(s.PatternsToMatch) > 0 {
		m["patterns_to_match"] = s.PatternsToMatch
	}
	if len(s.SupportedProtocols) > 0 {
		m["supported_protocols"] = s.SupportedProtocols
	}
	if s.ForwardingProtocol != "" {
		m["forwarding_protocol"] = s.ForwardingProtocol
	}
	if s.HttpsRedirectEnabled {
		m["https_redirect_enabled"] = s.HttpsRedirectEnabled
	}
	if s.LinkToDefaultDomain {
		m["link_to_default_domain"] = s.LinkToDefaultDomain
	}
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Cache != nil {
		m["cache"] = s.Cache.toMap()
	}
	return m
}

// AzureFrontDoorRouteCache configures caching behavior for a route.
//
//	Caching is the primary value proposition of a CDN. When enabled,
//	Front Door stores origin responses at edge locations worldwide
//	and serves subsequent requests from cache, reducing origin load
//	and improving end-user latency.
type AzureFrontDoorRouteCacheInput struct {
	// How query strings affect cache key generation.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "IgnoreQueryString" (default): All query string variations share
	//    the same cache entry. Best for static content.
	//  - "UseQueryString": Each unique query string produces a separate
	//    cache entry. Best ...
	QueryStringCachingBehavior string `json:"query_string_caching_behavior,omitempty" jsonschema:"How query strings affect cache key generation. Uses Azure's exact API values. Valid values: - 'IgnoreQueryString' (default): All query string variations share the same cache entry. Best for static con..."`
	// Query strings to include or exclude from cache keys.
	//  Behavior depends on query_string_caching_behavior:
	//  - IgnoreSpecifiedQueryStrings: These strings are excluded from cache key
	//  - IncludeSpecifiedQueryStrings: Only these strings are included in cache key
	//
	//  Ignored when behavior is IgnoreQueryStrin...
	QueryStrings []string `json:"query_strings,omitempty" jsonschema:"Query strings to include or exclude from cache keys. Behavior depends on query_string_caching_behavior: - IgnoreSpecifiedQueryStrings: These strings are excluded from cache key - IncludeSpecifiedQuery..."`
	// Enable compression for cached content.
	//  When true, Front Door compresses responses using gzip or brotli
	//  before delivering to clients, reducing bandwidth.
	//
	//  Only compresses content types listed in content_types_to_compress.
	//
	//  Default: false
	CompressionEnabled bool `json:"compression_enabled,omitempty" jsonschema:"Enable compression for cached content. When true; Front Door compresses responses using gzip or brotli before delivering to clients; reducing bandwidth. Only compresses content types listed in content..."`
	// MIME types eligible for compression.
	//  Front Door compresses responses matching these content types.
	//
	//  Only used when compression_enabled is true.
	//
	//  Common web content types:
	//  - "text/html", "text/css", "text/javascript"
	//  - "application/javascript", "application/json"
	//  - "application/xml", "image/svg...
	ContentTypesToCompress []string `json:"content_types_to_compress,omitempty" jsonschema:"MIME types eligible for compression. Front Door compresses responses matching these content types. Only used when compression_enabled is true. Common web content types: - 'text/html'; 'text/css'; 'tex..."`
}

func (s *AzureFrontDoorRouteCacheInput) validate() error {
	return nil
}

func (s *AzureFrontDoorRouteCacheInput) applyDefaults() {
	if s.QueryStringCachingBehavior == "" {
		s.QueryStringCachingBehavior = "IgnoreQueryString"
	}
}

func (s *AzureFrontDoorRouteCacheInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.QueryStringCachingBehavior != "" {
		m["query_string_caching_behavior"] = s.QueryStringCachingBehavior
	}
	if len(s.QueryStrings) > 0 {
		m["query_strings"] = s.QueryStrings
	}
	if s.CompressionEnabled {
		m["compression_enabled"] = s.CompressionEnabled
	}
	if len(s.ContentTypesToCompress) > 0 {
		m["content_types_to_compress"] = s.ContentTypesToCompress
	}
	return m
}

// ParseAzureFrontDoorProfile validates and normalizes a AzureFrontDoorProfile cloud_object.
func ParseAzureFrontDoorProfile(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureFrontDoorProfile"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureFrontDoorProfileSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
