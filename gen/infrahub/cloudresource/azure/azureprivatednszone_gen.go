// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzurePrivateDnsZone is the top-level API resource for an Azure Private DNS Zone.
//
//	Private DNS zones provide DNS resolution within a virtual network, enabling
//	Private Link connectivity for Azure PaaS services and custom internal DNS
//	for VM hostname resolution.
type AzurePrivateDnsZoneSpecInput struct {
	// The Azure Resource Group where the Private DNS Zone will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Private DNS Zone will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Private DNS Zone.
	//  Must be a valid DNS domain name. For Private Link scenarios, this must match
	//  the Azure-defined privatelink zone name for the target service.
	//
	//  Common Private Link zone names:
	//  - "privatelink.postgres.database.azure.com" -- PostgreSQL Flexible Server
	//  - "privatelin...
	Name string `json:"name" jsonschema:"required,The name of the Private DNS Zone. Must be a valid DNS domain name. For Private Link scenarios; this must match the Azure-defined privatelink zone name for the target service. Common Private Link zone ..."`
	// The Azure Resource Manager ID of the Virtual Network to link to this zone.
	//  The VNet link enables DNS resolution of records in this zone from resources
	//  within the linked VNet. Without a VNet link, the zone is unreachable.
	//  Format: /subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.Network...
	VnetId string `json:"vnet_id" jsonschema:"required,The Azure Resource Manager ID of the Virtual Network to link to this zone. The VNet link enables DNS resolution of records in this zone from resources within the linked VNet. Without a VNet link; the ..."`
	// Whether to enable auto-registration of VM DNS records in the linked VNet.
	//
	//  When true, Azure automatically creates and removes A records in this zone
	//  for virtual machines in the linked VNet. This is useful for custom internal
	//  DNS zones (e.g., "contoso.internal") where you want VMs to be automatica...
	RegistrationEnabled bool `json:"registration_enabled,omitempty" jsonschema:"Whether to enable auto-registration of VM DNS records in the linked VNet. When true; Azure automatically creates and removes A records in this zone for virtual machines in the linked VNet. This is use..."`
}

func (s *AzurePrivateDnsZoneSpecInput) validate() error {
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.VnetId == "" {
		return fmt.Errorf("vnet_id is required")
	}
	return nil
}

func (s *AzurePrivateDnsZoneSpecInput) applyDefaults() {
}

func (s *AzurePrivateDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["vnet_id"] = s.VnetId
	if s.RegistrationEnabled {
		m["registration_enabled"] = s.RegistrationEnabled
	}
	return m
}

// ParseAzurePrivateDnsZone validates and normalizes a AzurePrivateDnsZone cloud_object.
func ParseAzurePrivateDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzurePrivateDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzurePrivateDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
