// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// azure-dns-zone
type AzureDnsZoneSpecInput struct {
	// The DNS zone name (e.g., "example.com"). Do not include a trailing dot.
	ZoneName string `json:"zone_name" jsonschema:"required,The DNS zone name (e.g.; 'example.com'). Do not include a trailing dot."`
	// The Azure Resource Group where the DNS Zone will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the DNS Zone will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// (Optional) DNS records to pre-populate in the zone. Each record includes type, name, values, and TTL.
	//  If no records are provided, the zone will be created empty (common when external systems manage DNS records).
	Records []*AzureDnsRecordInput `json:"records,omitempty" jsonschema:"(Optional) DNS records to pre-populate in the zone. Each record includes type; name; values; and TTL. If no records are provided; the zone will be created empty (common when external systems manage DN..."`
}

func (s *AzureDnsZoneSpecInput) validate() error {
	if s.ZoneName == "" {
		return fmt.Errorf("zone_name is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureDnsZoneSpecInput) applyDefaults() {
}

func (s *AzureDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone_name"] = s.ZoneName
	m["resource_group"] = s.ResourceGroup
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// **AzureDnsRecord** represents a DNS record to be added to the Azure DNS Zone.
//
//	It includes the record type, the record name (usually a fully qualified domain name ending with a dot),
//	one or more record values, and an optional TTL (Time To Live) in seconds.
type AzureDnsRecordInput struct {
	// The DNS record type (e.g., A, AAAA, CNAME, TXT, MX).
	RecordType string `json:"record_type" jsonschema:"required,enum=A|AAAA|ALIAS|CNAME|MX|NS|PTR|SOA|SRV|TXT|CAA,The DNS record type (e.g.; A; AAAA; CNAME; TXT; MX)."`
	// The name of the DNS record. This can be a fully qualified domain name (ending with a dot, e.g., "www.example.com.")
	//  or a relative name within the zone (e.g., "www" for "www.example.com"). An empty name "@" denotes the zone root.
	Name string `json:"name" jsonschema:"required,The name of the DNS record. This can be a fully qualified domain name (ending with a dot; e.g.; 'www.example.com.') or a relative name within the zone (e.g.; 'www' for 'www.example.com'). An empty nam..."`
	// The list of values for the DNS record. For example, IP addresses for A/AAAA records, or hostnames for CNAME records (each CNAME value should end with a dot).
	Values []string `json:"values,omitempty" jsonschema:"The list of values for the DNS record. For example; IP addresses for A/AAAA records; or hostnames for CNAME records (each CNAME value should end with a dot)."`
	// The Time To Live (TTL) for the DNS record, in seconds.
	TtlSeconds int32 `json:"ttl_seconds,omitempty" jsonschema:"The Time To Live (TTL) for the DNS record; in seconds."`
}

func (s *AzureDnsRecordInput) validate() error {
	if s.RecordType == "" {
		return fmt.Errorf("record_type is required")
	}
	switch s.RecordType {
	case "A", "AAAA", "ALIAS", "CNAME", "MX", "NS", "PTR", "SOA", "SRV", "TXT", "CAA":
	default:
		return fmt.Errorf("invalid record_type: %q", s.RecordType)
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.Values) < 1 {
		return fmt.Errorf("values requires at least 1 items, got %d", len(s.Values))
	}
	return nil
}

func (s *AzureDnsRecordInput) applyDefaults() {
	if s.TtlSeconds == 0 {
		s.TtlSeconds = 60
	}
}

func (s *AzureDnsRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["record_type"] = s.RecordType
	m["name"] = s.Name
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	return m
}

// ParseAzureDnsZone validates and normalizes a AzureDnsZone cloud_object.
func ParseAzureDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
