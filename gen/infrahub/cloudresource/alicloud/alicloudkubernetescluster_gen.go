// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-kubernetes-cluster
type AliCloudKubernetesClusterSpecInput struct {
	// Alibaba Cloud region for the cluster.
	//  Must match the region of the VSwitches in vswitch_ids.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region for the cluster. Must match the region of the VSwitches in vswitch_ids. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// Cluster name. 1-63 characters; must start with a letter or digit.
	//  If omitted, defaults to metadata.name in the IaC modules.
	Name string `json:"name,omitempty" jsonschema:"Cluster name. 1-63 characters; must start with a letter or digit. If omitted; defaults to metadata.name in the IaC modules."`
	// Kubernetes version (e.g., "1.28", "1.30").
	//  If omitted, the provider uses the latest stable version.
	Version string `json:"version,omitempty" jsonschema:"Kubernetes version (e.g.; '1.28'; '1.30'). If omitted; the provider uses the latest stable version."`
	// Cluster specification that determines the control plane SLA and features.
	//  "ack.standard" -- free managed control plane with basic SLA.
	//  "ack.pro.small" -- professional managed cluster with enhanced SLA,
	//    managed node pools, topology-aware scheduling, and more.
	//  Supports in-place upgrade from ack....
	ClusterSpec string `json:"cluster_spec,omitempty" jsonschema:"Cluster specification that determines the control plane SLA and features. 'ack.standard' -- free managed control plane with basic SLA. 'ack.pro.small' -- professional managed cluster with enhanced SLA..."`
	// Cluster-internal domain name used for Kubernetes service discovery.
	//  Default: "cluster.local"
	//  Immutable after creation.
	ClusterDomain string `json:"cluster_domain,omitempty" jsonschema:"Cluster-internal domain name used for Kubernetes service discovery. Default: 'cluster.local' Immutable after creation."`
	// VSwitch IDs for control plane placement. 1-5 VSwitches in distinct
	//  availability zones for high availability.
	//  These VSwitches also serve as the default worker node VSwitches.
	VswitchIds []string `json:"vswitch_ids" jsonschema:"required,VSwitch IDs for control plane placement. 1-5 VSwitches in distinct availability zones for high availability. These VSwitches also serve as the default worker node VSwitches."`
	// Pod network CIDR block for Flannel CNI.
	//  Required when using the "flannel" network addon; ignored for Terway.
	//  Must not overlap the VPC CIDR, service_cidr, or node CIDR.
	//  Immutable after creation.
	//  Example: "172.20.0.0/16"
	PodCidr string `json:"pod_cidr,omitempty" jsonschema:"Pod network CIDR block for Flannel CNI. Required when using the 'flannel' network addon; ignored for Terway. Must not overlap the VPC CIDR; service_cidr; or node CIDR. Immutable after creation. Exampl..."`
	// VSwitch IDs for pod ENI allocation when using Terway CNI.
	//  Required when using the "terway-eniip" network addon; ignored for Flannel.
	//  Should be in the same AZs as vswitch_ids but use dedicated CIDR ranges
	//  to avoid IP exhaustion on the node VSwitches.
	PodVswitchIds []string `json:"pod_vswitch_ids,omitempty" jsonschema:"VSwitch IDs for pod ENI allocation when using Terway CNI. Required when using the 'terway-eniip' network addon; ignored for Flannel. Should be in the same AZs as vswitch_ids but use dedicated CIDR ran..."`
	// Service network CIDR block for Kubernetes ClusterIP services.
	//  Must not overlap the VPC CIDR, pod CIDR, or node CIDR.
	//  Immutable after creation.
	//  Example: "172.21.0.0/20"
	ServiceCidr string `json:"service_cidr" jsonschema:"required,Service network CIDR block for Kubernetes ClusterIP services. Must not overlap the VPC CIDR; pod CIDR; or node CIDR. Immutable after creation. Example: '172.21.0.0/20'"`
	// kube-proxy mode for service routing.
	//  "ipvs" (default) -- IPVS-based load balancing with O(1) connection processing.
	//  "iptables" -- legacy iptables-based routing.
	//  Immutable after creation.
	//  Default: "ipvs"
	ProxyMode string `json:"proxy_mode,omitempty" jsonschema:"kube-proxy mode for service routing. 'ipvs' (default) -- IPVS-based load balancing with O(1) connection processing. 'iptables' -- legacy iptables-based routing. Immutable after creation. Default: 'ipv..."`
	// Node CIDR mask that controls how many pods can run on each node.
	//  A /24 mask gives 256 addresses per node (~253 pods); /26 gives 64.
	//  Range: 24-28. Default: 24.
	//  Immutable after creation.
	NodeCidrMask int32 `json:"node_cidr_mask,omitempty" jsonschema:"Node CIDR mask that controls how many pods can run on each node. A /24 mask gives 256 addresses per node (~253 pods); /26 gives 64. Range: 24-28. Default: 24. Immutable after creation."`
	// Whether ACK should automatically create a NAT gateway for the cluster
	//  VPC. Set to false when you manage your own AliCloudNatGateway component
	//  to avoid creating a duplicate NAT gateway.
	//  Default: true
	NewNatGateway bool `json:"new_nat_gateway,omitempty" jsonschema:"Whether ACK should automatically create a NAT gateway for the cluster VPC. Set to false when you manage your own AliCloudNatGateway component to avoid creating a duplicate NAT gateway. Default: true"`
	// Whether to create an internet-facing SLB for the Kubernetes API server.
	//  When true, the API server is accessible from the public internet.
	//  When false, only the VPC-internal endpoint is available.
	//  Default: true
	SlbInternetEnabled bool `json:"slb_internet_enabled,omitempty" jsonschema:"Whether to create an internet-facing SLB for the Kubernetes API server. When true; the API server is accessible from the public internet. When false; only the VPC-internal endpoint is available. Defau..."`
	// Security group ID for the cluster nodes. If omitted, ACK auto-creates
	//  a security group. Conflicts with is_enterprise_security_group.
	SecurityGroupId string `json:"security_group_id,omitempty" jsonschema:"Security group ID for the cluster nodes. If omitted; ACK auto-creates a security group. Conflicts with is_enterprise_security_group."`
	// Whether ACK should auto-create an advanced (enterprise) security group.
	//  Advanced security groups support up to 65,536 rules and 100,000 ENIs.
	//  Conflicts with security_group_id.
	//  Default: false
	IsEnterpriseSecurityGroup bool `json:"is_enterprise_security_group,omitempty" jsonschema:"Whether ACK should auto-create an advanced (enterprise) security group. Advanced security groups support up to 65;536 rules and 100;000 ENIs. Conflicts with security_group_id. Default: false"`
	// Enable RRSA (RAM Roles for Service Accounts) for pod-level IAM.
	//  When enabled, Kubernetes service accounts can assume RAM roles via OIDC
	//  federation, eliminating the need for static access keys in pods.
	//  Requires Kubernetes 1.22.3+.
	//  WARNING: Once enabled, RRSA cannot be disabled.
	//  Default: false
	EnableRrsa bool `json:"enable_rrsa,omitempty" jsonschema:"Enable RRSA (RAM Roles for Service Accounts) for pod-level IAM. When enabled; Kubernetes service accounts can assume RAM roles via OIDC federation; eliminating the need for static access keys in pods...."`
	// Enable cluster deletion protection. When true, the cluster cannot be
	//  deleted through the API until deletion_protection is explicitly disabled.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"Enable cluster deletion protection. When true; the cluster cannot be deleted through the API until deletion_protection is explicitly disabled."`
	// KMS key ID for encrypting Kubernetes Secrets at rest.
	//  When set, all Secrets stored in etcd are encrypted with this key.
	//  Immutable after creation.
	EncryptionProviderKey string `json:"encryption_provider_key,omitempty" jsonschema:"KMS key ID for encrypting Kubernetes Secrets at rest. When set; all Secrets stored in etcd are encrypted with this key. Immutable after creation."`
	// Custom Subject Alternative Names for the API server TLS certificate.
	//  Comma-separated list of IP addresses or domain names that the API server
	//  certificate should be valid for, in addition to the default endpoints.
	//  Example: "10.0.0.1,api.example.com"
	CustomSan string `json:"custom_san,omitempty" jsonschema:"Custom Subject Alternative Names for the API server TLS certificate. Comma-separated list of IP addresses or domain names that the API server certificate should be valid for; in addition to the defaul..."`
	// Cluster addons to install during creation.
	//
	//  Common addons:
	//    Network: "flannel", "terway-eniip" (choose one)
	//    Storage: "csi-plugin", "csi-provisioner"
	//    Logging: "logtail-ds" (config: {"IngressDashboardEnabled":"true","sls_project_name":"..."})
	//    Ingress: "nginx-ingress-controller", "alb-ingre...
	Addons []*AliCloudKubernetesAddonInput `json:"addons,omitempty" jsonschema:"Cluster addons to install during creation. Common addons: Network: 'flannel'; 'terway-eniip' (choose one) Storage: 'csi-plugin'; 'csi-provisioner' Logging: 'logtail-ds' (config: {'IngressDashboardEnab..."`
	// Control plane and audit logging configuration.
	//  When omitted, no control plane logs or audit logs are collected.
	Logging *AliCloudKubernetesClusterLoggingInput `json:"logging,omitempty" jsonschema:"Control plane and audit logging configuration. When omitted; no control plane logs or audit logs are collected."`
	// Maintenance window for the cluster. When configured, ACK applies
	//  updates and patches only during the specified window.
	MaintenanceWindow *AliCloudKubernetesClusterMaintenanceWindowInput `json:"maintenance_window,omitempty" jsonschema:"Maintenance window for the cluster. When configured; ACK applies updates and patches only during the specified window."`
	// Automatic cluster version upgrade policy.
	//  Only takes effect when a maintenance_window is configured.
	AutoUpgrade *AliCloudKubernetesClusterAutoUpgradeInput `json:"auto_upgrade,omitempty" jsonschema:"Automatic cluster version upgrade policy. Only takes effect when a maintenance_window is configured."`
	// Tags applied to the cluster and its auto-created resources.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags applied to the cluster and its auto-created resources."`
	// Alibaba Cloud resource group ID for organizational grouping (per DD05).
	//  If omitted, the cluster is placed in the account's default resource group.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Alibaba Cloud resource group ID for organizational grouping (per DD05). If omitted; the cluster is placed in the account's default resource group."`
	// IANA timezone for the cluster nodes (e.g., "Asia/Shanghai", "UTC").
	Timezone string `json:"timezone,omitempty" jsonschema:"IANA timezone for the cluster nodes (e.g.; 'Asia/Shanghai'; 'UTC')."`
}

func (s *AliCloudKubernetesClusterSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if len(s.VswitchIds) == 0 {
		return fmt.Errorf("vswitch_ids is required")
	}
	if len(s.VswitchIds) < 1 {
		return fmt.Errorf("vswitch_ids requires at least 1 items, got %d", len(s.VswitchIds))
	}
	if s.ServiceCidr == "" {
		return fmt.Errorf("service_cidr is required")
	}
	for i, v := range s.Addons {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("addons[%d]: %w", i, err)
			}
		}
	}
	if s.Logging != nil {
		if err := s.Logging.validate(); err != nil {
			return fmt.Errorf("logging: %w", err)
		}
	}
	if s.MaintenanceWindow != nil {
		if err := s.MaintenanceWindow.validate(); err != nil {
			return fmt.Errorf("maintenance_window: %w", err)
		}
	}
	if s.AutoUpgrade != nil {
		if err := s.AutoUpgrade.validate(); err != nil {
			return fmt.Errorf("auto_upgrade: %w", err)
		}
	}
	return nil
}

func (s *AliCloudKubernetesClusterSpecInput) applyDefaults() {
	if s.ClusterSpec == "" {
		s.ClusterSpec = "ack.standard"
	}
	if s.ProxyMode == "" {
		s.ProxyMode = "ipvs"
	}
	if s.NodeCidrMask == 0 {
		s.NodeCidrMask = 24
	}
	// default: NewNatGateway = true (applied at zero-value)
	// default: SlbInternetEnabled = true (applied at zero-value)
	if s.Logging != nil {
		s.Logging.applyDefaults()
	}
	if s.MaintenanceWindow != nil {
		s.MaintenanceWindow.applyDefaults()
	}
	if s.AutoUpgrade != nil {
		s.AutoUpgrade.applyDefaults()
	}
}

func (s *AliCloudKubernetesClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.ClusterSpec != "" {
		m["cluster_spec"] = s.ClusterSpec
	}
	if s.ClusterDomain != "" {
		m["cluster_domain"] = s.ClusterDomain
	}
	m["vswitch_ids"] = s.VswitchIds
	if s.PodCidr != "" {
		m["pod_cidr"] = s.PodCidr
	}
	if len(s.PodVswitchIds) > 0 {
		m["pod_vswitch_ids"] = s.PodVswitchIds
	}
	m["service_cidr"] = s.ServiceCidr
	if s.ProxyMode != "" {
		m["proxy_mode"] = s.ProxyMode
	}
	if s.NodeCidrMask != 0 {
		m["node_cidr_mask"] = s.NodeCidrMask
	}
	if s.NewNatGateway {
		m["new_nat_gateway"] = s.NewNatGateway
	}
	if s.SlbInternetEnabled {
		m["slb_internet_enabled"] = s.SlbInternetEnabled
	}
	if s.SecurityGroupId != "" {
		m["security_group_id"] = s.SecurityGroupId
	}
	if s.IsEnterpriseSecurityGroup {
		m["is_enterprise_security_group"] = s.IsEnterpriseSecurityGroup
	}
	if s.EnableRrsa {
		m["enable_rrsa"] = s.EnableRrsa
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if s.EncryptionProviderKey != "" {
		m["encryption_provider_key"] = s.EncryptionProviderKey
	}
	if s.CustomSan != "" {
		m["custom_san"] = s.CustomSan
	}
	if len(s.Addons) > 0 {
		items := make([]any, len(s.Addons))
		for i, v := range s.Addons {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["addons"] = items
	}
	if s.Logging != nil {
		m["logging"] = s.Logging.toMap()
	}
	if s.MaintenanceWindow != nil {
		m["maintenance_window"] = s.MaintenanceWindow.toMap()
	}
	if s.AutoUpgrade != nil {
		m["auto_upgrade"] = s.AutoUpgrade.toMap()
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if s.Timezone != "" {
		m["timezone"] = s.Timezone
	}
	return m
}

// AliCloudKubernetesAddon defines a cluster addon to install during creation.
type AliCloudKubernetesAddonInput struct {
	// Addon name. Must match an ACK addon identifier.
	//  Examples: "flannel", "terway-eniip", "csi-plugin", "logtail-ds",
	//    "nginx-ingress-controller", "arms-prometheus", "metrics-server".
	Name string `json:"name" jsonschema:"required,Addon name. Must match an ACK addon identifier. Examples: 'flannel'; 'terway-eniip'; 'csi-plugin'; 'logtail-ds'; 'nginx-ingress-controller'; 'arms-prometheus'; 'metrics-server'."`
	// JSON-encoded addon configuration.
	//  Structure is addon-specific. Example for logtail-ds:
	//    {"IngressDashboardEnabled":"true","sls_project_name":"my-log-project"}
	Config string `json:"config,omitempty" jsonschema:"JSON-encoded addon configuration. Structure is addon-specific. Example for logtail-ds: {'IngressDashboardEnabled':'true';'sls_project_name':'my-log-project'}"`
	// Addon version. If omitted, ACK installs the default version for the
	//  cluster's Kubernetes version.
	Version string `json:"version,omitempty" jsonschema:"Addon version. If omitted; ACK installs the default version for the cluster's Kubernetes version."`
	// Disable automatic installation of this addon.
	//  When true, the addon is registered but not installed.
	Disabled bool `json:"disabled,omitempty" jsonschema:"Disable automatic installation of this addon. When true; the addon is registered but not installed."`
}

func (s *AliCloudKubernetesAddonInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AliCloudKubernetesAddonInput) applyDefaults() {
}

func (s *AliCloudKubernetesAddonInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Config != "" {
		m["config"] = s.Config
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.Disabled {
		m["disabled"] = s.Disabled
	}
	return m
}

// AliCloudKubernetesClusterAutoUpgrade defines the automatic cluster version
//
//	upgrade policy. Only takes effect when a maintenance window is configured.
type AliCloudKubernetesClusterAutoUpgradeInput struct {
	// Whether automatic cluster version upgrades are enabled.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether automatic cluster version upgrades are enabled."`
	// Upgrade channel that controls how aggressively versions are adopted.
	//  "patch" -- only patch version upgrades (e.g., 1.28.3 -> 1.28.5).
	//  "stable" -- minor version upgrades after stabilization period.
	//  "rapid" -- minor version upgrades as soon as available.
	Channel string `json:"channel,omitempty" jsonschema:"Upgrade channel that controls how aggressively versions are adopted. 'patch' -- only patch version upgrades (e.g.; 1.28.3 -> 1.28.5). 'stable' -- minor version upgrades after stabilization period. 'ra..."`
}

func (s *AliCloudKubernetesClusterAutoUpgradeInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesClusterAutoUpgradeInput) applyDefaults() {
}

func (s *AliCloudKubernetesClusterAutoUpgradeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Channel != "" {
		m["channel"] = s.Channel
	}
	return m
}

// AliCloudKubernetesClusterLogging groups control plane logging and
//
//	Kubernetes audit logging configuration.
type AliCloudKubernetesClusterLoggingInput struct {
	// SLS (Log Service) project for control plane component logs.
	//  If omitted, ACK auto-creates a project named "k8s-log-{cluster-id}".
	ControlPlaneLogProject string `json:"control_plane_log_project,omitempty" jsonschema:"SLS (Log Service) project for control plane component logs. If omitted; ACK auto-creates a project named 'k8s-log-{cluster-id}'."`
	// Retention period for control plane logs in days.
	//  Default: "30"
	ControlPlaneLogTtl string `json:"control_plane_log_ttl,omitempty" jsonschema:"Retention period for control plane logs in days. Default: '30'"`
	// Control plane components to enable logging for.
	//  Valid values: "apiserver", "kcm", "scheduler", "ccm",
	//    "controlplane-events", "alb", "coredns".
	ControlPlaneLogComponents []string `json:"control_plane_log_components,omitempty" jsonschema:"Control plane components to enable logging for. Valid values: 'apiserver'; 'kcm'; 'scheduler'; 'ccm'; 'controlplane-events'; 'alb'; 'coredns'."`
	// Whether Kubernetes audit logging is enabled.
	//  Audit logs record all API requests for security and compliance.
	AuditLogEnabled bool `json:"audit_log_enabled,omitempty" jsonschema:"Whether Kubernetes audit logging is enabled. Audit logs record all API requests for security and compliance."`
	// SLS project for audit logs. If omitted and audit logging is enabled,
	//  audit logs are sent to the control plane log project.
	AuditLogSlsProject string `json:"audit_log_sls_project,omitempty" jsonschema:"SLS project for audit logs. If omitted and audit logging is enabled; audit logs are sent to the control plane log project."`
}

func (s *AliCloudKubernetesClusterLoggingInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesClusterLoggingInput) applyDefaults() {
	if s.ControlPlaneLogTtl == "" {
		s.ControlPlaneLogTtl = "30"
	}
}

func (s *AliCloudKubernetesClusterLoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ControlPlaneLogProject != "" {
		m["control_plane_log_project"] = s.ControlPlaneLogProject
	}
	if s.ControlPlaneLogTtl != "" {
		m["control_plane_log_ttl"] = s.ControlPlaneLogTtl
	}
	if len(s.ControlPlaneLogComponents) > 0 {
		m["control_plane_log_components"] = s.ControlPlaneLogComponents
	}
	if s.AuditLogEnabled {
		m["audit_log_enabled"] = s.AuditLogEnabled
	}
	if s.AuditLogSlsProject != "" {
		m["audit_log_sls_project"] = s.AuditLogSlsProject
	}
	return m
}

// AliCloudKubernetesClusterMaintenanceWindow defines a recurring time window
//
//	during which ACK may apply cluster updates and patches.
type AliCloudKubernetesClusterMaintenanceWindowInput struct {
	// Whether the maintenance window is enabled.
	Enable bool `json:"enable,omitempty" jsonschema:"Whether the maintenance window is enabled."`
	// Start time of the maintenance window in RFC 3339 format.
	//  Example: "2026-03-01T03:00:00+08:00"
	MaintenanceTime string `json:"maintenance_time,omitempty" jsonschema:"Start time of the maintenance window in RFC 3339 format. Example: '2026-03-01T03:00:00+08:00'"`
	// Duration of the maintenance window (1-24 hours).
	//  Example: "3h"
	Duration string `json:"duration,omitempty" jsonschema:"Duration of the maintenance window (1-24 hours). Example: '3h'"`
	// Days of the week when maintenance is allowed.
	//  Comma-separated, e.g., "Monday,Thursday".
	//  Default: "Thursday"
	WeeklyPeriod string `json:"weekly_period,omitempty" jsonschema:"Days of the week when maintenance is allowed. Comma-separated; e.g.; 'Monday;Thursday'. Default: 'Thursday'"`
}

func (s *AliCloudKubernetesClusterMaintenanceWindowInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesClusterMaintenanceWindowInput) applyDefaults() {
}

func (s *AliCloudKubernetesClusterMaintenanceWindowInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enable {
		m["enable"] = s.Enable
	}
	if s.MaintenanceTime != "" {
		m["maintenance_time"] = s.MaintenanceTime
	}
	if s.Duration != "" {
		m["duration"] = s.Duration
	}
	if s.WeeklyPeriod != "" {
		m["weekly_period"] = s.WeeklyPeriod
	}
	return m
}

// ParseAliCloudKubernetesCluster validates and normalizes a AliCloudKubernetesCluster cloud_object.
func ParseAliCloudKubernetesCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudKubernetesCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudKubernetesClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
