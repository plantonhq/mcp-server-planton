// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-application-load-balancer
type AliCloudApplicationLoadBalancerSpecInput struct {
	// Alibaba Cloud region where the ALB will be created.
	//  Must match the region of the VPC and VSwitches.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the ALB will be created. Must match the region of the VPC and VSwitches. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// VPC ID that the ALB belongs to. The ALB, all zone-mapping VSwitches,
	//  and server groups must reside in the same VPC.
	VpcId string `json:"vpc_id" jsonschema:"required,VPC ID that the ALB belongs to. The ALB; all zone-mapping VSwitches; and server groups must reside in the same VPC."`
	// ALB name. 2-128 characters; must start with a letter; can contain
	//  digits, underscores, periods, and hyphens.
	//  If omitted, defaults to the metadata.name.
	LoadBalancerName string `json:"load_balancer_name,omitempty" jsonschema:"ALB name. 2-128 characters; must start with a letter; can contain digits; underscores; periods; and hyphens. If omitted; defaults to the metadata.name."`
	// Network type of the ALB.
	//  "Internet" creates a public-facing ALB with a DNS name resolvable
	//  from the internet. "Intranet" creates a VPC-internal ALB.
	//  Default: "Internet"
	AddressType string `json:"address_type,omitempty" jsonschema:"Network type of the ALB. 'Internet' creates a public-facing ALB with a DNS name resolvable from the internet. 'Intranet' creates a VPC-internal ALB. Default: 'Internet'"`
	// ALB edition that determines feature availability and performance.
	//  "Basic" supports basic L7 load balancing.
	//  "Standard" adds advanced features (WAF integration, custom routing).
	//  "StandardWithWaf" includes integrated WAF protection.
	//  Default: "Standard"
	LoadBalancerEdition string `json:"load_balancer_edition,omitempty" jsonschema:"ALB edition that determines feature availability and performance. 'Basic' supports basic L7 load balancing. 'Standard' adds advanced features (WAF integration; custom routing). 'StandardWithWaf' inclu..."`
	// Availability zone mappings. Each mapping places an ALB node in a zone
	//  with a VSwitch for IP allocation. ALB requires at least 2 zones for
	//  high availability.
	ZoneMappings []*AliCloudApplicationLoadBalancerZoneMappingInput `json:"zone_mappings" jsonschema:"required,Availability zone mappings. Each mapping places an ALB node in a zone with a VSwitch for IP allocation. ALB requires at least 2 zones for high availability."`
	// Alibaba Cloud resource group ID for organizational grouping (per DD05).
	//  If omitted, the ALB is placed in the account's default resource group.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Alibaba Cloud resource group ID for organizational grouping (per DD05). If omitted; the ALB is placed in the account's default resource group."`
	// Access log configuration for shipping ALB access logs to SLS (Log Service).
	//  When configured, all listener access logs are sent to the specified
	//  SLS log project and log store.
	AccessLogConfig *AliCloudApplicationLoadBalancerAccessLogConfigInput `json:"access_log_config,omitempty" jsonschema:"Access log configuration for shipping ALB access logs to SLS (Log Service). When configured; all listener access logs are sent to the specified SLS log project and log store."`
	// Tags to apply to the ALB resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the ALB resource."`
	// Server groups that define backend targets for the ALB.
	//  Each server group has its own health check, protocol, and session
	//  stickiness configuration. Listeners reference server groups by name.
	//
	//  Server groups are created empty -- backend membership is managed
	//  externally (by ACK ingress, SAE, or manu...
	ServerGroups []*AliCloudApplicationLoadBalancerServerGroupInput `json:"server_groups,omitempty" jsonschema:"Server groups that define backend targets for the ALB. Each server group has its own health check; protocol; and session stickiness configuration. Listeners reference server groups by name. Server gro..."`
	// Listeners that define how the ALB accepts incoming traffic.
	//  Each listener binds to a port and protocol and forwards traffic to a
	//  server group via default_actions. HTTPS listeners require a certificate.
	Listeners []*AliCloudApplicationLoadBalancerListenerInput `json:"listeners,omitempty" jsonschema:"Listeners that define how the ALB accepts incoming traffic. Each listener binds to a port and protocol and forwards traffic to a server group via default_actions. HTTPS listeners require a certificate..."`
}

func (s *AliCloudApplicationLoadBalancerSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if len(s.ZoneMappings) == 0 {
		return fmt.Errorf("zone_mappings is required")
	}
	if len(s.ZoneMappings) < 2 {
		return fmt.Errorf("zone_mappings requires at least 2 items, got %d", len(s.ZoneMappings))
	}
	for i, v := range s.ZoneMappings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("zone_mappings[%d]: %w", i, err)
			}
		}
	}
	if s.AccessLogConfig != nil {
		if err := s.AccessLogConfig.validate(); err != nil {
			return fmt.Errorf("access_log_config: %w", err)
		}
	}
	for i, v := range s.ServerGroups {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("server_groups[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Listeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("listeners[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudApplicationLoadBalancerSpecInput) applyDefaults() {
	if s.AddressType == "" {
		s.AddressType = "Internet"
	}
	if s.LoadBalancerEdition == "" {
		s.LoadBalancerEdition = "Standard"
	}
	if s.AccessLogConfig != nil {
		s.AccessLogConfig.applyDefaults()
	}
}

func (s *AliCloudApplicationLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["vpc_id"] = s.VpcId
	if s.LoadBalancerName != "" {
		m["load_balancer_name"] = s.LoadBalancerName
	}
	if s.AddressType != "" {
		m["address_type"] = s.AddressType
	}
	if s.LoadBalancerEdition != "" {
		m["load_balancer_edition"] = s.LoadBalancerEdition
	}
	if len(s.ZoneMappings) > 0 {
		items := make([]any, len(s.ZoneMappings))
		for i, v := range s.ZoneMappings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["zone_mappings"] = items
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if s.AccessLogConfig != nil {
		m["access_log_config"] = s.AccessLogConfig.toMap()
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if len(s.ServerGroups) > 0 {
		items := make([]any, len(s.ServerGroups))
		for i, v := range s.ServerGroups {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["server_groups"] = items
	}
	if len(s.Listeners) > 0 {
		items := make([]any, len(s.Listeners))
		for i, v := range s.Listeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["listeners"] = items
	}
	return m
}

// AliCloudApplicationLoadBalancerAccessLogConfig configures access log delivery to SLS.
type AliCloudApplicationLoadBalancerAccessLogConfigInput struct {
	// SLS log project name. Must already exist in the same region as the ALB.
	LogProject string `json:"log_project" jsonschema:"required,SLS log project name. Must already exist in the same region as the ALB."`
	// SLS log store name within the log project.
	LogStore string `json:"log_store" jsonschema:"required,SLS log store name within the log project."`
}

func (s *AliCloudApplicationLoadBalancerAccessLogConfigInput) validate() error {
	if s.LogProject == "" {
		return fmt.Errorf("log_project is required")
	}
	if s.LogStore == "" {
		return fmt.Errorf("log_store is required")
	}
	return nil
}

func (s *AliCloudApplicationLoadBalancerAccessLogConfigInput) applyDefaults() {
}

func (s *AliCloudApplicationLoadBalancerAccessLogConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["log_project"] = s.LogProject
	m["log_store"] = s.LogStore
	return m
}

// AliCloudApplicationLoadBalancerHealthCheckConfig defines how the ALB probes backend servers.
type AliCloudApplicationLoadBalancerHealthCheckConfigInput struct {
	// Whether health checks are enabled for this server group.
	//  When disabled, all servers are considered healthy.
	HealthCheckEnabled bool `json:"health_check_enabled,omitempty" jsonschema:"Whether health checks are enabled for this server group. When disabled; all servers are considered healthy."`
	// Protocol used for health check probes.
	//  Default: "HTTP"
	HealthCheckProtocol string `json:"health_check_protocol,omitempty" jsonschema:"Protocol used for health check probes. Default: 'HTTP'"`
	// URL path for HTTP/HTTPS health check probes. Must start with "/".
	//  Ignored for TCP probes.
	//  Example: "/health", "/api/healthz"
	HealthCheckPath string `json:"health_check_path,omitempty" jsonschema:"URL path for HTTP/HTTPS health check probes. Must start with '/'. Ignored for TCP probes. Example: '/health'; '/api/healthz'"`
	// Domain name used in the Host header of HTTP/HTTPS health check probes.
	//  If omitted, the server's IP address is used.
	HealthCheckHost string `json:"health_check_host,omitempty" jsonschema:"Domain name used in the Host header of HTTP/HTTPS health check probes. If omitted; the server's IP address is used."`
	// HTTP method for health check probes.
	//  Default: "HEAD"
	HealthCheckMethod string `json:"health_check_method,omitempty" jsonschema:"HTTP method for health check probes. Default: 'HEAD'"`
	// Backend port used for health checks. 0 means use the port of the
	//  backend server (the default).
	//  Range: 0-65535. Default: 0
	HealthCheckConnectPort int32 `json:"health_check_connect_port,omitempty" jsonschema:"Backend port used for health checks. 0 means use the port of the backend server (the default). Range: 0-65535. Default: 0"`
	// Interval between health check probes, in seconds.
	//  Range: 1-50. Default: 2
	HealthCheckInterval int32 `json:"health_check_interval,omitempty" jsonschema:"Interval between health check probes; in seconds. Range: 1-50. Default: 2"`
	// Maximum time to wait for a health check response, in seconds.
	//  Range: 1-300. Default: 5
	HealthCheckTimeout int32 `json:"health_check_timeout,omitempty" jsonschema:"Maximum time to wait for a health check response; in seconds. Range: 1-300. Default: 5"`
	// Number of consecutive successful probes before a server is marked healthy.
	//  Range: 2-10. Default: 3
	HealthyThreshold int32 `json:"healthy_threshold,omitempty" jsonschema:"Number of consecutive successful probes before a server is marked healthy. Range: 2-10. Default: 3"`
	// Number of consecutive failed probes before a server is marked unhealthy.
	//  Range: 2-10. Default: 3
	UnhealthyThreshold int32 `json:"unhealthy_threshold,omitempty" jsonschema:"Number of consecutive failed probes before a server is marked unhealthy. Range: 2-10. Default: 3"`
	// HTTP status codes that indicate a healthy response.
	//  Only applicable when health_check_protocol is HTTP or HTTPS.
	//  Examples: ["http_2xx"], ["http_2xx", "http_3xx"]
	HealthCheckCodes []string `json:"health_check_codes,omitempty" jsonschema:"HTTP status codes that indicate a healthy response. Only applicable when health_check_protocol is HTTP or HTTPS. Examples: ['http_2xx']; ['http_2xx'; 'http_3xx']"`
}

func (s *AliCloudApplicationLoadBalancerHealthCheckConfigInput) validate() error {
	return nil
}

func (s *AliCloudApplicationLoadBalancerHealthCheckConfigInput) applyDefaults() {
	if s.HealthCheckProtocol == "" {
		s.HealthCheckProtocol = "HTTP"
	}
	if s.HealthCheckMethod == "" {
		s.HealthCheckMethod = "HEAD"
	}
	if s.HealthCheckConnectPort == 0 {
		s.HealthCheckConnectPort = 0
	}
	if s.HealthCheckInterval == 0 {
		s.HealthCheckInterval = 2
	}
	if s.HealthCheckTimeout == 0 {
		s.HealthCheckTimeout = 5
	}
	if s.HealthyThreshold == 0 {
		s.HealthyThreshold = 3
	}
	if s.UnhealthyThreshold == 0 {
		s.UnhealthyThreshold = 3
	}
}

func (s *AliCloudApplicationLoadBalancerHealthCheckConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HealthCheckEnabled {
		m["health_check_enabled"] = s.HealthCheckEnabled
	}
	if s.HealthCheckProtocol != "" {
		m["health_check_protocol"] = s.HealthCheckProtocol
	}
	if s.HealthCheckPath != "" {
		m["health_check_path"] = s.HealthCheckPath
	}
	if s.HealthCheckHost != "" {
		m["health_check_host"] = s.HealthCheckHost
	}
	if s.HealthCheckMethod != "" {
		m["health_check_method"] = s.HealthCheckMethod
	}
	if s.HealthCheckConnectPort != 0 {
		m["health_check_connect_port"] = s.HealthCheckConnectPort
	}
	if s.HealthCheckInterval != 0 {
		m["health_check_interval"] = s.HealthCheckInterval
	}
	if s.HealthCheckTimeout != 0 {
		m["health_check_timeout"] = s.HealthCheckTimeout
	}
	if s.HealthyThreshold != 0 {
		m["healthy_threshold"] = s.HealthyThreshold
	}
	if s.UnhealthyThreshold != 0 {
		m["unhealthy_threshold"] = s.UnhealthyThreshold
	}
	if len(s.HealthCheckCodes) > 0 {
		m["health_check_codes"] = s.HealthCheckCodes
	}
	return m
}

// AliCloudApplicationLoadBalancerListener defines how the ALB accepts incoming traffic on a
//
//	specific port and protocol.
type AliCloudApplicationLoadBalancerListenerInput struct {
	// Port on which the listener accepts traffic.
	//  Range: 1-65535. Common values: 80 (HTTP), 443 (HTTPS).
	ListenerPort int32 `json:"listener_port" jsonschema:"required,Port on which the listener accepts traffic. Range: 1-65535. Common values: 80 (HTTP); 443 (HTTPS)."`
	// Protocol for this listener.
	//  "HTTP" for unencrypted HTTP traffic.
	//  "HTTPS" for TLS-encrypted traffic (requires certificate_id).
	//  "QUIC" for HTTP/3 over QUIC.
	ListenerProtocol string `json:"listener_protocol" jsonschema:"required,Protocol for this listener. 'HTTP' for unencrypted HTTP traffic. 'HTTPS' for TLS-encrypted traffic (requires certificate_id). 'QUIC' for HTTP/3 over QUIC."`
	// Name of the server group that receives traffic from this listener.
	//  Must match a name in the server_groups list. The listener creates a
	//  default ForwardGroup action routing all traffic to this server group.
	DefaultActionServerGroupName string `json:"default_action_server_group_name" jsonschema:"required,Name of the server group that receives traffic from this listener. Must match a name in the server_groups list. The listener creates a default ForwardGroup action routing all traffic to this server gr..."`
	// Human-readable description of this listener's purpose.
	//  2-256 characters.
	ListenerDescription string `json:"listener_description,omitempty" jsonschema:"Human-readable description of this listener's purpose. 2-256 characters."`
	// Server certificate ID for HTTPS and QUIC listeners.
	//  Required when listener_protocol is "HTTPS" or "QUIC".
	//  Obtain from Alibaba Cloud Certificate Management Service (CAS).
	CertificateId string `json:"certificate_id,omitempty" jsonschema:"Server certificate ID for HTTPS and QUIC listeners. Required when listener_protocol is 'HTTPS' or 'QUIC'. Obtain from Alibaba Cloud Certificate Management Service (CAS)."`
	// TLS security policy that defines the supported TLS versions and cipher
	//  suites. Only applicable for HTTPS and QUIC listeners.
	//  Examples: "tls_cipher_policy_1_0", "tls_cipher_policy_1_2_strict"
	SecurityPolicyId string `json:"security_policy_id,omitempty" jsonschema:"TLS security policy that defines the supported TLS versions and cipher suites. Only applicable for HTTPS and QUIC listeners. Examples: 'tls_cipher_policy_1_0'; 'tls_cipher_policy_1_2_strict'"`
	// Whether to enable gzip compression for HTTP responses.
	//  Default: true
	GzipEnabled bool `json:"gzip_enabled,omitempty" jsonschema:"Whether to enable gzip compression for HTTP responses. Default: true"`
	// Whether to enable HTTP/2 for this listener.
	//  Only applicable for HTTPS listeners.
	//  Default: true
	Http2Enabled bool `json:"http2_enabled,omitempty" jsonschema:"Whether to enable HTTP/2 for this listener. Only applicable for HTTPS listeners. Default: true"`
	// Connection idle timeout in seconds. Connections idle longer are closed.
	//  Range: 1-60. Default: 60
	IdleTimeout int32 `json:"idle_timeout,omitempty" jsonschema:"Connection idle timeout in seconds. Connections idle longer are closed. Range: 1-60. Default: 60"`
	// Request timeout in seconds. The ALB returns 504 if the backend does
	//  not respond within this period.
	//  Range: 1-180. Default: 60
	RequestTimeout int32 `json:"request_timeout,omitempty" jsonschema:"Request timeout in seconds. The ALB returns 504 if the backend does not respond within this period. Range: 1-180. Default: 60"`
}

func (s *AliCloudApplicationLoadBalancerListenerInput) validate() error {
	if s.ListenerProtocol == "" {
		return fmt.Errorf("listener_protocol is required")
	}
	if s.DefaultActionServerGroupName == "" {
		return fmt.Errorf("default_action_server_group_name is required")
	}
	return nil
}

func (s *AliCloudApplicationLoadBalancerListenerInput) applyDefaults() {
	// default: GzipEnabled = true (applied at zero-value)
	// default: Http2Enabled = true (applied at zero-value)
	if s.IdleTimeout == 0 {
		s.IdleTimeout = 60
	}
	if s.RequestTimeout == 0 {
		s.RequestTimeout = 60
	}
}

func (s *AliCloudApplicationLoadBalancerListenerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["listener_port"] = s.ListenerPort
	m["listener_protocol"] = s.ListenerProtocol
	m["default_action_server_group_name"] = s.DefaultActionServerGroupName
	if s.ListenerDescription != "" {
		m["listener_description"] = s.ListenerDescription
	}
	if s.CertificateId != "" {
		m["certificate_id"] = s.CertificateId
	}
	if s.SecurityPolicyId != "" {
		m["security_policy_id"] = s.SecurityPolicyId
	}
	if s.GzipEnabled {
		m["gzip_enabled"] = s.GzipEnabled
	}
	if s.Http2Enabled {
		m["http2_enabled"] = s.Http2Enabled
	}
	if s.IdleTimeout != 0 {
		m["idle_timeout"] = s.IdleTimeout
	}
	if s.RequestTimeout != 0 {
		m["request_timeout"] = s.RequestTimeout
	}
	return m
}

// AliCloudApplicationLoadBalancerServerGroup defines a backend target group with health check
//
//	and session stickiness configuration. Server groups are created empty --
//	backend membership is managed externally.
type AliCloudApplicationLoadBalancerServerGroupInput struct {
	// Server group name. 2-128 characters; must start with a letter.
	//  Used by listeners to reference this server group via
	//  default_action_server_group_name.
	Name string `json:"name" jsonschema:"required,Server group name. 2-128 characters; must start with a letter. Used by listeners to reference this server group via default_action_server_group_name."`
	// Backend protocol for communication between the ALB and servers.
	//  Default: "HTTP"
	Protocol string `json:"protocol,omitempty" jsonschema:"Backend protocol for communication between the ALB and servers. Default: 'HTTP'"`
	// Scheduling algorithm for distributing requests across servers.
	//  "Wrr" -- Weighted Round Robin (default, distributes by weight).
	//  "Wlc" -- Weighted Least Connections (routes to least-busy server).
	//  "Sch" -- Source IP Consistent Hashing (same client IP to same server).
	//  Default: "Wrr"
	Scheduler string `json:"scheduler,omitempty" jsonschema:"Scheduling algorithm for distributing requests across servers. 'Wrr' -- Weighted Round Robin (default; distributes by weight). 'Wlc' -- Weighted Least Connections (routes to least-busy server). 'Sch' ..."`
	// Health check configuration. Required for every server group.
	HealthCheckConfig *AliCloudApplicationLoadBalancerHealthCheckConfigInput `json:"health_check_config" jsonschema:"required,Health check configuration. Required for every server group."`
	// Session stickiness configuration. When enabled, requests from the same
	//  client are routed to the same backend server.
	StickySessionConfig *AliCloudApplicationLoadBalancerStickySessionConfigInput `json:"sticky_session_config,omitempty" jsonschema:"Session stickiness configuration. When enabled; requests from the same client are routed to the same backend server."`
}

func (s *AliCloudApplicationLoadBalancerServerGroupInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.HealthCheckConfig == nil {
		return fmt.Errorf("health_check_config is required")
	}
	if s.HealthCheckConfig != nil {
		if err := s.HealthCheckConfig.validate(); err != nil {
			return fmt.Errorf("health_check_config: %w", err)
		}
	}
	if s.StickySessionConfig != nil {
		if err := s.StickySessionConfig.validate(); err != nil {
			return fmt.Errorf("sticky_session_config: %w", err)
		}
	}
	return nil
}

func (s *AliCloudApplicationLoadBalancerServerGroupInput) applyDefaults() {
	if s.Protocol == "" {
		s.Protocol = "HTTP"
	}
	if s.Scheduler == "" {
		s.Scheduler = "Wrr"
	}
	if s.HealthCheckConfig != nil {
		s.HealthCheckConfig.applyDefaults()
	}
	if s.StickySessionConfig != nil {
		s.StickySessionConfig.applyDefaults()
	}
}

func (s *AliCloudApplicationLoadBalancerServerGroupInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Scheduler != "" {
		m["scheduler"] = s.Scheduler
	}
	if s.HealthCheckConfig != nil {
		m["health_check_config"] = s.HealthCheckConfig.toMap()
	}
	if s.StickySessionConfig != nil {
		m["sticky_session_config"] = s.StickySessionConfig.toMap()
	}
	return m
}

// AliCloudApplicationLoadBalancerStickySessionConfig defines session stickiness behavior.
type AliCloudApplicationLoadBalancerStickySessionConfigInput struct {
	// Whether session stickiness is enabled.
	StickySessionEnabled bool `json:"sticky_session_enabled,omitempty" jsonschema:"Whether session stickiness is enabled."`
	// Session stickiness method.
	//  "Insert" -- ALB inserts a cookie (SERVERID) into responses.
	//  "Server" -- ALB uses a cookie set by the backend server.
	StickySessionType string `json:"sticky_session_type,omitempty" jsonschema:"Session stickiness method. 'Insert' -- ALB inserts a cookie (SERVERID) into responses. 'Server' -- ALB uses a cookie set by the backend server."`
	// Cookie name when sticky_session_type is "Server".
	//  The ALB reads this cookie from backend responses to identify the server.
	Cookie string `json:"cookie,omitempty" jsonschema:"Cookie name when sticky_session_type is 'Server'. The ALB reads this cookie from backend responses to identify the server."`
	// Cookie timeout in seconds when sticky_session_type is "Insert".
	//  Range: 1-86400. Default: 1000
	CookieTimeout int32 `json:"cookie_timeout,omitempty" jsonschema:"Cookie timeout in seconds when sticky_session_type is 'Insert'. Range: 1-86400. Default: 1000"`
}

func (s *AliCloudApplicationLoadBalancerStickySessionConfigInput) validate() error {
	return nil
}

func (s *AliCloudApplicationLoadBalancerStickySessionConfigInput) applyDefaults() {
	if s.CookieTimeout == 0 {
		s.CookieTimeout = 1000
	}
}

func (s *AliCloudApplicationLoadBalancerStickySessionConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.StickySessionEnabled {
		m["sticky_session_enabled"] = s.StickySessionEnabled
	}
	if s.StickySessionType != "" {
		m["sticky_session_type"] = s.StickySessionType
	}
	if s.Cookie != "" {
		m["cookie"] = s.Cookie
	}
	if s.CookieTimeout != 0 {
		m["cookie_timeout"] = s.CookieTimeout
	}
	return m
}

// AliCloudApplicationLoadBalancerZoneMapping associates an availability zone with a VSwitch.
//
//	The ALB places a node in each mapped zone for high availability.
type AliCloudApplicationLoadBalancerZoneMappingInput struct {
	// Availability zone ID within the region.
	//  Examples: "cn-hangzhou-a", "cn-hangzhou-b", "us-west-1-a".
	ZoneId string `json:"zone_id" jsonschema:"required,Availability zone ID within the region. Examples: 'cn-hangzhou-a'; 'cn-hangzhou-b'; 'us-west-1-a'."`
	// VSwitch ID in this availability zone. The ALB allocates an IP from
	//  this VSwitch. Must belong to the same VPC as the ALB's vpc_id.
	VswitchId string `json:"vswitch_id" jsonschema:"required,VSwitch ID in this availability zone. The ALB allocates an IP from this VSwitch. Must belong to the same VPC as the ALB's vpc_id."`
}

func (s *AliCloudApplicationLoadBalancerZoneMappingInput) validate() error {
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	if s.VswitchId == "" {
		return fmt.Errorf("vswitch_id is required")
	}
	return nil
}

func (s *AliCloudApplicationLoadBalancerZoneMappingInput) applyDefaults() {
}

func (s *AliCloudApplicationLoadBalancerZoneMappingInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone_id"] = s.ZoneId
	m["vswitch_id"] = s.VswitchId
	return m
}

// ParseAliCloudApplicationLoadBalancer validates and normalizes a AliCloudApplicationLoadBalancer cloud_object.
func ParseAliCloudApplicationLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudApplicationLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudApplicationLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
