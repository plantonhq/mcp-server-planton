// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-network-load-balancer
type AliCloudNetworkLoadBalancerSpecInput struct {
	// Alibaba Cloud region where the NLB will be created.
	//  Must match the region of the VPC and VSwitches.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the NLB will be created. Must match the region of the VPC and VSwitches. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// VPC ID that the NLB belongs to. The NLB, all zone-mapping VSwitches,
	//  and server groups must reside in the same VPC.
	VpcId string `json:"vpc_id" jsonschema:"required,VPC ID that the NLB belongs to. The NLB; all zone-mapping VSwitches; and server groups must reside in the same VPC."`
	// NLB name. 2-128 characters; must start with a letter; can contain
	//  digits, underscores, periods, and hyphens.
	//  If omitted, defaults to the metadata.name.
	LoadBalancerName string `json:"load_balancer_name,omitempty" jsonschema:"NLB name. 2-128 characters; must start with a letter; can contain digits; underscores; periods; and hyphens. If omitted; defaults to the metadata.name."`
	// Network type of the NLB.
	//  "Internet" creates a public-facing NLB with a DNS name resolvable
	//  from the internet. "Intranet" creates a VPC-internal NLB.
	//  Default: "Internet"
	AddressType string `json:"address_type,omitempty" jsonschema:"Network type of the NLB. 'Internet' creates a public-facing NLB with a DNS name resolvable from the internet. 'Intranet' creates a VPC-internal NLB. Default: 'Internet'"`
	// Availability zone mappings. Each mapping places an NLB node in a zone
	//  with a VSwitch for IP allocation. NLB requires at least 2 zones for
	//  high availability.
	ZoneMappings []*AliCloudNetworkLoadBalancerZoneMappingInput `json:"zone_mappings" jsonschema:"required,Availability zone mappings. Each mapping places an NLB node in a zone with a VSwitch for IP allocation. NLB requires at least 2 zones for high availability."`
	// Alibaba Cloud resource group ID for organizational grouping (per DD05).
	//  If omitted, the NLB is placed in the account's default resource group.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Alibaba Cloud resource group ID for organizational grouping (per DD05). If omitted; the NLB is placed in the account's default resource group."`
	// Whether to enable cross-zone load balancing. When enabled, NLB
	//  distributes traffic across all healthy backends in all zones. When
	//  disabled, traffic stays within the zone where it was received.
	//  Default: true
	CrossZoneEnabled bool `json:"cross_zone_enabled,omitempty" jsonschema:"Whether to enable cross-zone load balancing. When enabled; NLB distributes traffic across all healthy backends in all zones. When disabled; traffic stays within the zone where it was received. Default..."`
	// Tags to apply to the NLB resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the NLB resource."`
	// Server groups that define backend targets for the NLB.
	//  Each server group has its own health check, protocol, and scheduling
	//  configuration. Listeners reference server groups by name.
	//
	//  Server groups are created empty -- backend membership is managed
	//  externally (by ACK service controllers, manual a...
	ServerGroups []*AliCloudNetworkLoadBalancerServerGroupInput `json:"server_groups,omitempty" jsonschema:"Server groups that define backend targets for the NLB. Each server group has its own health check; protocol; and scheduling configuration. Listeners reference server groups by name. Server groups are ..."`
	// Listeners that define how the NLB accepts incoming traffic.
	//  Each listener binds to a port and protocol and forwards traffic
	//  directly to a server group. TCPSSL listeners support TLS termination.
	Listeners []*AliCloudNetworkLoadBalancerListenerInput `json:"listeners,omitempty" jsonschema:"Listeners that define how the NLB accepts incoming traffic. Each listener binds to a port and protocol and forwards traffic directly to a server group. TCPSSL listeners support TLS termination."`
}

func (s *AliCloudNetworkLoadBalancerSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if len(s.ZoneMappings) == 0 {
		return fmt.Errorf("zone_mappings is required")
	}
	if len(s.ZoneMappings) < 2 {
		return fmt.Errorf("zone_mappings requires at least 2 items, got %d", len(s.ZoneMappings))
	}
	for i, v := range s.ZoneMappings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("zone_mappings[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ServerGroups {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("server_groups[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Listeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("listeners[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudNetworkLoadBalancerSpecInput) applyDefaults() {
	if s.AddressType == "" {
		s.AddressType = "Internet"
	}
	// default: CrossZoneEnabled = true (applied at zero-value)
}

func (s *AliCloudNetworkLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["vpc_id"] = s.VpcId
	if s.LoadBalancerName != "" {
		m["load_balancer_name"] = s.LoadBalancerName
	}
	if s.AddressType != "" {
		m["address_type"] = s.AddressType
	}
	if len(s.ZoneMappings) > 0 {
		items := make([]any, len(s.ZoneMappings))
		for i, v := range s.ZoneMappings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["zone_mappings"] = items
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if s.CrossZoneEnabled {
		m["cross_zone_enabled"] = s.CrossZoneEnabled
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if len(s.ServerGroups) > 0 {
		items := make([]any, len(s.ServerGroups))
		for i, v := range s.ServerGroups {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["server_groups"] = items
	}
	if len(s.Listeners) > 0 {
		items := make([]any, len(s.Listeners))
		for i, v := range s.Listeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["listeners"] = items
	}
	return m
}

// AliCloudNetworkLoadBalancerHealthCheckConfig defines how the NLB probes backend servers.
type AliCloudNetworkLoadBalancerHealthCheckConfigInput struct {
	// Whether health checks are enabled for this server group.
	//  When disabled, all servers are considered healthy.
	HealthCheckEnabled bool `json:"health_check_enabled,omitempty" jsonschema:"Whether health checks are enabled for this server group. When disabled; all servers are considered healthy."`
	// Protocol used for health check probes.
	//  "TCP" performs a TCP connection check.
	//  "HTTP" sends an HTTP request and checks the response code.
	//  "UDP" sends a UDP packet and expects a response.
	//  Default: "TCP"
	HealthCheckType string `json:"health_check_type,omitempty" jsonschema:"Protocol used for health check probes. 'TCP' performs a TCP connection check. 'HTTP' sends an HTTP request and checks the response code. 'UDP' sends a UDP packet and expects a response. Default: 'TCP'"`
	// Backend port used for health checks. 0 means use the port of the
	//  backend server (the default).
	//  Range: 0-65535. Default: 0
	HealthCheckConnectPort int32 `json:"health_check_connect_port,omitempty" jsonschema:"Backend port used for health checks. 0 means use the port of the backend server (the default). Range: 0-65535. Default: 0"`
	// Maximum time to wait for a health check response, in seconds.
	//  Range: 1-300. Default: 5
	HealthCheckConnectTimeout int32 `json:"health_check_connect_timeout,omitempty" jsonschema:"Maximum time to wait for a health check response; in seconds. Range: 1-300. Default: 5"`
	// Interval between health check probes, in seconds.
	//  Range: 5-50. Default: 10
	HealthCheckInterval int32 `json:"health_check_interval,omitempty" jsonschema:"Interval between health check probes; in seconds. Range: 5-50. Default: 10"`
	// Number of consecutive successful probes before a server is marked healthy.
	//  Range: 2-10. Default: 2
	HealthyThreshold int32 `json:"healthy_threshold,omitempty" jsonschema:"Number of consecutive successful probes before a server is marked healthy. Range: 2-10. Default: 2"`
	// Number of consecutive failed probes before a server is marked unhealthy.
	//  Range: 2-10. Default: 2
	UnhealthyThreshold int32 `json:"unhealthy_threshold,omitempty" jsonschema:"Number of consecutive failed probes before a server is marked unhealthy. Range: 2-10. Default: 2"`
	// URL path for HTTP health check probes. Must start with "/".
	//  Only applicable when health_check_type is "HTTP".
	//  Example: "/health", "/api/healthz"
	HealthCheckUrl string `json:"health_check_url,omitempty" jsonschema:"URL path for HTTP health check probes. Must start with '/'. Only applicable when health_check_type is 'HTTP'. Example: '/health'; '/api/healthz'"`
	// Domain name used in the Host header of HTTP health check probes.
	//  Only applicable when health_check_type is "HTTP".
	//  If omitted, the server's IP address is used.
	HealthCheckDomain string `json:"health_check_domain,omitempty" jsonschema:"Domain name used in the Host header of HTTP health check probes. Only applicable when health_check_type is 'HTTP'. If omitted; the server's IP address is used."`
	// HTTP method for health check probes.
	//  Only applicable when health_check_type is "HTTP".
	//  Default: "GET"
	HttpCheckMethod string `json:"http_check_method,omitempty" jsonschema:"HTTP method for health check probes. Only applicable when health_check_type is 'HTTP'. Default: 'GET'"`
	// HTTP status codes that indicate a healthy response.
	//  Only applicable when health_check_type is "HTTP".
	//  Examples: ["http_2xx"], ["http_2xx", "http_3xx"]
	HealthCheckHttpCodes []string `json:"health_check_http_codes,omitempty" jsonschema:"HTTP status codes that indicate a healthy response. Only applicable when health_check_type is 'HTTP'. Examples: ['http_2xx']; ['http_2xx'; 'http_3xx']"`
}

func (s *AliCloudNetworkLoadBalancerHealthCheckConfigInput) validate() error {
	return nil
}

func (s *AliCloudNetworkLoadBalancerHealthCheckConfigInput) applyDefaults() {
	if s.HealthCheckType == "" {
		s.HealthCheckType = "TCP"
	}
	if s.HealthCheckConnectPort == 0 {
		s.HealthCheckConnectPort = 0
	}
	if s.HealthCheckConnectTimeout == 0 {
		s.HealthCheckConnectTimeout = 5
	}
	if s.HealthCheckInterval == 0 {
		s.HealthCheckInterval = 10
	}
	if s.HealthyThreshold == 0 {
		s.HealthyThreshold = 2
	}
	if s.UnhealthyThreshold == 0 {
		s.UnhealthyThreshold = 2
	}
	if s.HttpCheckMethod == "" {
		s.HttpCheckMethod = "GET"
	}
}

func (s *AliCloudNetworkLoadBalancerHealthCheckConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HealthCheckEnabled {
		m["health_check_enabled"] = s.HealthCheckEnabled
	}
	if s.HealthCheckType != "" {
		m["health_check_type"] = s.HealthCheckType
	}
	if s.HealthCheckConnectPort != 0 {
		m["health_check_connect_port"] = s.HealthCheckConnectPort
	}
	if s.HealthCheckConnectTimeout != 0 {
		m["health_check_connect_timeout"] = s.HealthCheckConnectTimeout
	}
	if s.HealthCheckInterval != 0 {
		m["health_check_interval"] = s.HealthCheckInterval
	}
	if s.HealthyThreshold != 0 {
		m["healthy_threshold"] = s.HealthyThreshold
	}
	if s.UnhealthyThreshold != 0 {
		m["unhealthy_threshold"] = s.UnhealthyThreshold
	}
	if s.HealthCheckUrl != "" {
		m["health_check_url"] = s.HealthCheckUrl
	}
	if s.HealthCheckDomain != "" {
		m["health_check_domain"] = s.HealthCheckDomain
	}
	if s.HttpCheckMethod != "" {
		m["http_check_method"] = s.HttpCheckMethod
	}
	if len(s.HealthCheckHttpCodes) > 0 {
		m["health_check_http_codes"] = s.HealthCheckHttpCodes
	}
	return m
}

// AliCloudNetworkLoadBalancerListener defines how the NLB accepts incoming traffic on a
//
//	specific port and protocol.
type AliCloudNetworkLoadBalancerListenerInput struct {
	// Port on which the listener accepts traffic.
	//  Range: 1-65535. Common values: 80 (TCP), 443 (TCPSSL), 3306 (MySQL).
	ListenerPort int32 `json:"listener_port" jsonschema:"required,Port on which the listener accepts traffic. Range: 1-65535. Common values: 80 (TCP); 443 (TCPSSL); 3306 (MySQL)."`
	// Protocol for this listener.
	//  "TCP" for raw TCP traffic.
	//  "UDP" for UDP traffic.
	//  "TCPSSL" for TLS-encrypted TCP traffic (requires certificate_ids).
	ListenerProtocol string `json:"listener_protocol" jsonschema:"required,Protocol for this listener. 'TCP' for raw TCP traffic. 'UDP' for UDP traffic. 'TCPSSL' for TLS-encrypted TCP traffic (requires certificate_ids)."`
	// Name of the server group that receives traffic from this listener.
	//  Must match a name in the server_groups list.
	ServerGroupName string `json:"server_group_name" jsonschema:"required,Name of the server group that receives traffic from this listener. Must match a name in the server_groups list."`
	// Human-readable description of this listener's purpose.
	ListenerDescription string `json:"listener_description,omitempty" jsonschema:"Human-readable description of this listener's purpose."`
	// Connection idle timeout in seconds. Connections idle longer are closed.
	//  Applies to TCP and TCPSSL only; ignored for UDP.
	//  Range: 1-900. Default: 900
	IdleTimeout int32 `json:"idle_timeout,omitempty" jsonschema:"Connection idle timeout in seconds. Connections idle longer are closed. Applies to TCP and TCPSSL only; ignored for UDP. Range: 1-900. Default: 900"`
	// Whether to enable the Proxy Protocol. When enabled, the NLB inserts
	//  a Proxy Protocol header so backends can read the real client IP/port.
	//  Default: false
	ProxyProtocolEnabled bool `json:"proxy_protocol_enabled,omitempty" jsonschema:"Whether to enable the Proxy Protocol. When enabled; the NLB inserts a Proxy Protocol header so backends can read the real client IP/port. Default: false"`
	// Server certificate IDs for TCPSSL listeners. At least one is required
	//  when listener_protocol is "TCPSSL".
	//  Obtain from Alibaba Cloud Certificate Management Service (CAS).
	CertificateIds []string `json:"certificate_ids,omitempty" jsonschema:"Server certificate IDs for TCPSSL listeners. At least one is required when listener_protocol is 'TCPSSL'. Obtain from Alibaba Cloud Certificate Management Service (CAS)."`
	// TLS security policy that defines the supported TLS versions and cipher
	//  suites. Only applicable for TCPSSL listeners.
	//  Examples: "tls_cipher_policy_1_0", "tls_cipher_policy_1_2_strict"
	SecurityPolicyId string `json:"security_policy_id,omitempty" jsonschema:"TLS security policy that defines the supported TLS versions and cipher suites. Only applicable for TCPSSL listeners. Examples: 'tls_cipher_policy_1_0'; 'tls_cipher_policy_1_2_strict'"`
	// CA certificate IDs for mutual TLS authentication on TCPSSL listeners.
	//  When set along with ca_enabled, the NLB validates the client certificate
	//  against these CA certificates.
	CaCertificateIds []string `json:"ca_certificate_ids,omitempty" jsonschema:"CA certificate IDs for mutual TLS authentication on TCPSSL listeners. When set along with ca_enabled; the NLB validates the client certificate against these CA certificates."`
	// Whether to enable mutual TLS (client certificate verification)
	//  on TCPSSL listeners. Requires ca_certificate_ids to be set.
	//  Default: false
	CaEnabled bool `json:"ca_enabled,omitempty" jsonschema:"Whether to enable mutual TLS (client certificate verification) on TCPSSL listeners. Requires ca_certificate_ids to be set. Default: false"`
}

func (s *AliCloudNetworkLoadBalancerListenerInput) validate() error {
	if s.ListenerProtocol == "" {
		return fmt.Errorf("listener_protocol is required")
	}
	if s.ServerGroupName == "" {
		return fmt.Errorf("server_group_name is required")
	}
	return nil
}

func (s *AliCloudNetworkLoadBalancerListenerInput) applyDefaults() {
	if s.IdleTimeout == 0 {
		s.IdleTimeout = 900
	}
}

func (s *AliCloudNetworkLoadBalancerListenerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["listener_port"] = s.ListenerPort
	m["listener_protocol"] = s.ListenerProtocol
	m["server_group_name"] = s.ServerGroupName
	if s.ListenerDescription != "" {
		m["listener_description"] = s.ListenerDescription
	}
	if s.IdleTimeout != 0 {
		m["idle_timeout"] = s.IdleTimeout
	}
	if s.ProxyProtocolEnabled {
		m["proxy_protocol_enabled"] = s.ProxyProtocolEnabled
	}
	if len(s.CertificateIds) > 0 {
		m["certificate_ids"] = s.CertificateIds
	}
	if s.SecurityPolicyId != "" {
		m["security_policy_id"] = s.SecurityPolicyId
	}
	if len(s.CaCertificateIds) > 0 {
		m["ca_certificate_ids"] = s.CaCertificateIds
	}
	if s.CaEnabled {
		m["ca_enabled"] = s.CaEnabled
	}
	return m
}

// AliCloudNetworkLoadBalancerServerGroup defines a backend target group with health check
//
//	and connection management configuration. Server groups are created empty --
//	backend membership is managed externally.
type AliCloudNetworkLoadBalancerServerGroupInput struct {
	// Server group name. 2-128 characters; must start with a letter.
	//  Used by listeners to reference this server group via server_group_name.
	Name string `json:"name" jsonschema:"required,Server group name. 2-128 characters; must start with a letter. Used by listeners to reference this server group via server_group_name."`
	// Backend protocol for communication between the NLB and servers.
	//  Default: "TCP"
	Protocol string `json:"protocol,omitempty" jsonschema:"Backend protocol for communication between the NLB and servers. Default: 'TCP'"`
	// Scheduling algorithm for distributing connections across servers.
	//  "Wrr" -- Weighted Round Robin (default, distributes by weight).
	//  "Rr"  -- Round Robin (equal distribution).
	//  "Sch" -- Source IP Consistent Hashing (same client to same server).
	//  "Tch" -- Four-tuple Consistent Hashing (src/dst IP + po...
	Scheduler string `json:"scheduler,omitempty" jsonschema:"Scheduling algorithm for distributing connections across servers. 'Wrr' -- Weighted Round Robin (default; distributes by weight). 'Rr' -- Round Robin (equal distribution). 'Sch' -- Source IP Consisten..."`
	// Whether to enable connection draining. When enabled, existing
	//  connections to a removed backend are allowed to complete within the
	//  drain timeout before being forcibly closed.
	//  Default: false
	ConnectionDrainEnabled bool `json:"connection_drain_enabled,omitempty" jsonschema:"Whether to enable connection draining. When enabled; existing connections to a removed backend are allowed to complete within the drain timeout before being forcibly closed. Default: false"`
	// Maximum time in seconds to wait for in-flight connections to complete
	//  when a backend is removed. Only effective when connection_drain_enabled
	//  is true.
	//  Range: 10-900. Default: 10
	ConnectionDrainTimeout int32 `json:"connection_drain_timeout,omitempty" jsonschema:"Maximum time in seconds to wait for in-flight connections to complete when a backend is removed. Only effective when connection_drain_enabled is true. Range: 10-900. Default: 10"`
	// Whether to preserve the client's original IP address when forwarding
	//  traffic to backends. The backend sees the real client IP instead of
	//  the NLB's IP.
	//  Default: true
	PreserveClientIpEnabled bool `json:"preserve_client_ip_enabled,omitempty" jsonschema:"Whether to preserve the client's original IP address when forwarding traffic to backends. The backend sees the real client IP instead of the NLB's IP. Default: true"`
	// Health check configuration. Required for every server group.
	HealthCheck *AliCloudNetworkLoadBalancerHealthCheckConfigInput `json:"health_check" jsonschema:"required,Health check configuration. Required for every server group."`
}

func (s *AliCloudNetworkLoadBalancerServerGroupInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.HealthCheck == nil {
		return fmt.Errorf("health_check is required")
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	return nil
}

func (s *AliCloudNetworkLoadBalancerServerGroupInput) applyDefaults() {
	if s.Protocol == "" {
		s.Protocol = "TCP"
	}
	if s.Scheduler == "" {
		s.Scheduler = "Wrr"
	}
	if s.ConnectionDrainTimeout == 0 {
		s.ConnectionDrainTimeout = 10
	}
	// default: PreserveClientIpEnabled = true (applied at zero-value)
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *AliCloudNetworkLoadBalancerServerGroupInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Scheduler != "" {
		m["scheduler"] = s.Scheduler
	}
	if s.ConnectionDrainEnabled {
		m["connection_drain_enabled"] = s.ConnectionDrainEnabled
	}
	if s.ConnectionDrainTimeout != 0 {
		m["connection_drain_timeout"] = s.ConnectionDrainTimeout
	}
	if s.PreserveClientIpEnabled {
		m["preserve_client_ip_enabled"] = s.PreserveClientIpEnabled
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	return m
}

// AliCloudNetworkLoadBalancerZoneMapping associates an availability zone with a VSwitch.
//
//	The NLB places a node in each mapped zone for high availability.
type AliCloudNetworkLoadBalancerZoneMappingInput struct {
	// Availability zone ID within the region.
	//  Examples: "cn-hangzhou-a", "cn-hangzhou-b", "us-west-1-a".
	ZoneId string `json:"zone_id" jsonschema:"required,Availability zone ID within the region. Examples: 'cn-hangzhou-a'; 'cn-hangzhou-b'; 'us-west-1-a'."`
	// VSwitch ID in this availability zone. The NLB allocates an IP from
	//  this VSwitch. Must belong to the same VPC as the NLB's vpc_id.
	VswitchId string `json:"vswitch_id" jsonschema:"required,VSwitch ID in this availability zone. The NLB allocates an IP from this VSwitch. Must belong to the same VPC as the NLB's vpc_id."`
	// EIP allocation ID to bind a fixed public IP to this zone's NLB node.
	//  Only meaningful for internet-facing NLBs that need stable public IPs
	//  (e.g., database access, game servers, DNS A-records).
	//  If omitted, Alibaba Cloud auto-assigns IPs.
	AllocationId string `json:"allocation_id,omitempty" jsonschema:"EIP allocation ID to bind a fixed public IP to this zone's NLB node. Only meaningful for internet-facing NLBs that need stable public IPs (e.g.; database access; game servers; DNS A-records). If omitt..."`
}

func (s *AliCloudNetworkLoadBalancerZoneMappingInput) validate() error {
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	if s.VswitchId == "" {
		return fmt.Errorf("vswitch_id is required")
	}
	return nil
}

func (s *AliCloudNetworkLoadBalancerZoneMappingInput) applyDefaults() {
}

func (s *AliCloudNetworkLoadBalancerZoneMappingInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone_id"] = s.ZoneId
	m["vswitch_id"] = s.VswitchId
	if s.AllocationId != "" {
		m["allocation_id"] = s.AllocationId
	}
	return m
}

// ParseAliCloudNetworkLoadBalancer validates and normalizes a AliCloudNetworkLoadBalancer cloud_object.
func ParseAliCloudNetworkLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudNetworkLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudNetworkLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
