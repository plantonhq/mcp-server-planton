// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// *
//
//	**KubernetesSecret** defines a Kubernetes Secret resource following the Kubernetes Resource Model (KRM).
//	This resource represents a complete secret deployment with type-safe data variants for
//	Opaque, TLS, DockerConfigJson, BasicAuth, and SSHAuth secret types.
type KubernetesSecretSpecInput struct {
	// The Kubernetes cluster in which the secret should be created.
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"The Kubernetes cluster in which the secret should be created."`
	// *
	//  The name of the Kubernetes Secret.
	//  Must be a valid DNS subdomain name (lowercase alphanumeric, hyphens, and dots).
	Name string `json:"name,omitempty" jsonschema:"* The name of the Kubernetes Secret. Must be a valid DNS subdomain name (lowercase alphanumeric; hyphens; and dots)."`
	// *
	//  The namespace where the secret will be created.
	//  Default: default
	Namespace string `json:"namespace,omitempty" jsonschema:"* The namespace where the secret will be created. Default: default"`
	// *
	//  Additional labels to apply to the secret.
	//  These are merged with standard OpenMCF labels for resource tracking and governance.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"* Additional labels to apply to the secret. These are merged with standard OpenMCF labels for resource tracking and governance."`
	// *
	//  Additional annotations to apply to the secret.
	Annotations map[string]string `json:"annotations,omitempty" jsonschema:"* Additional annotations to apply to the secret."`
	// *
	//  When true, the secret data cannot be updated after creation.
	//  Immutable secrets provide protection against accidental updates and
	//  improve cluster performance by reducing watch load on the API server.
	Immutable bool `json:"immutable,omitempty" jsonschema:"* When true; the secret data cannot be updated after creation. Immutable secrets provide protection against accidental updates and improve cluster performance by reducing watch load on the API server."`
	// Opaque secret with arbitrary key-value string data.
	//  Maps to Kubernetes secret type "Opaque".
	Opaque *KubernetesSecretOpaqueDataInput `json:"opaque,omitempty" jsonschema:"Opaque secret with arbitrary key-value string data. Maps to Kubernetes secret type 'Opaque'."`
	// TLS secret containing a certificate and private key.
	//  Maps to Kubernetes secret type "kubernetes.io/tls".
	Tls *KubernetesSecretTlsDataInput `json:"tls,omitempty" jsonschema:"TLS secret containing a certificate and private key. Maps to Kubernetes secret type 'kubernetes.io/tls'."`
	// Docker registry credentials for image pulls.
	//  Maps to Kubernetes secret type "kubernetes.io/dockerconfigjson".
	DockerConfigJson *KubernetesSecretDockerConfigJsonDataInput `json:"docker_config_json,omitempty" jsonschema:"Docker registry credentials for image pulls. Maps to Kubernetes secret type 'kubernetes.io/dockerconfigjson'."`
	// Basic authentication credentials (username/password).
	//  Maps to Kubernetes secret type "kubernetes.io/basic-auth".
	BasicAuth *KubernetesSecretBasicAuthDataInput `json:"basic_auth,omitempty" jsonschema:"Basic authentication credentials (username/password). Maps to Kubernetes secret type 'kubernetes.io/basic-auth'."`
	// SSH authentication credentials (private key).
	//  Maps to Kubernetes secret type "kubernetes.io/ssh-auth".
	SshAuth *KubernetesSecretSshAuthDataInput `json:"ssh_auth,omitempty" jsonschema:"SSH authentication credentials (private key). Maps to Kubernetes secret type 'kubernetes.io/ssh-auth'."`
}

func (s *KubernetesSecretSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Opaque != nil {
		if err := s.Opaque.validate(); err != nil {
			return fmt.Errorf("opaque: %w", err)
		}
	}
	if s.Tls != nil {
		if err := s.Tls.validate(); err != nil {
			return fmt.Errorf("tls: %w", err)
		}
	}
	if s.DockerConfigJson != nil {
		if err := s.DockerConfigJson.validate(); err != nil {
			return fmt.Errorf("docker_config_json: %w", err)
		}
	}
	if s.BasicAuth != nil {
		if err := s.BasicAuth.validate(); err != nil {
			return fmt.Errorf("basic_auth: %w", err)
		}
	}
	if s.SshAuth != nil {
		if err := s.SshAuth.validate(); err != nil {
			return fmt.Errorf("ssh_auth: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSecretSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Namespace == "" {
		s.Namespace = "default"
	}
	if s.Opaque != nil {
		s.Opaque.applyDefaults()
	}
	if s.Tls != nil {
		s.Tls.applyDefaults()
	}
	if s.DockerConfigJson != nil {
		s.DockerConfigJson.applyDefaults()
	}
	if s.BasicAuth != nil {
		s.BasicAuth.applyDefaults()
	}
	if s.SshAuth != nil {
		s.SshAuth.applyDefaults()
	}
}

func (s *KubernetesSecretSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Annotations) > 0 {
		m["annotations"] = s.Annotations
	}
	if s.Immutable {
		m["immutable"] = s.Immutable
	}
	if s.Opaque != nil {
		m["opaque"] = s.Opaque.toMap()
	}
	if s.Tls != nil {
		m["tls"] = s.Tls.toMap()
	}
	if s.DockerConfigJson != nil {
		m["docker_config_json"] = s.DockerConfigJson.toMap()
	}
	if s.BasicAuth != nil {
		m["basic_auth"] = s.BasicAuth.toMap()
	}
	if s.SshAuth != nil {
		m["ssh_auth"] = s.SshAuth.toMap()
	}
	return m
}

// *
//
//	**KubernetesSecretBasicAuthData** defines data for a basic authentication secret.
//	Used for services that require username/password authentication.
type KubernetesSecretBasicAuthDataInput struct {
	// *
	//  Username for basic authentication.
	//  Stored as the "username" key in the Kubernetes Secret.
	Username string `json:"username,omitempty" jsonschema:"* Username for basic authentication. Stored as the 'username' key in the Kubernetes Secret."`
	// *
	//  Password for basic authentication.
	//  Stored as the "password" key in the Kubernetes Secret.
	Password string `json:"password,omitempty" jsonschema:"* Password for basic authentication. Stored as the 'password' key in the Kubernetes Secret."`
}

func (s *KubernetesSecretBasicAuthDataInput) validate() error {
	return nil
}

func (s *KubernetesSecretBasicAuthDataInput) applyDefaults() {
}

func (s *KubernetesSecretBasicAuthDataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	return m
}

// *
//
//	**KubernetesSecretDockerConfigJsonData** defines data for a Docker registry secret.
//	Used for authenticating with container registries during image pulls.
//	The IaC module constructs the .dockerconfigjson JSON from these fields.
type KubernetesSecretDockerConfigJsonDataInput struct {
	// *
	//  Docker registry server URL (e.g., "https://index.docker.io/v1/", "gcr.io", "ghcr.io").
	RegistryServer string `json:"registry_server,omitempty" jsonschema:"* Docker registry server URL (e.g.; 'https://index.docker.io/v1/'; 'gcr.io'; 'ghcr.io')."`
	// *
	//  Username for registry authentication.
	Username string `json:"username,omitempty" jsonschema:"* Username for registry authentication."`
	// *
	//  Password or access token for registry authentication.
	Password string `json:"password,omitempty" jsonschema:"* Password or access token for registry authentication."`
	// *
	//  Optional email associated with the registry account.
	Email string `json:"email,omitempty" jsonschema:"* Optional email associated with the registry account."`
}

func (s *KubernetesSecretDockerConfigJsonDataInput) validate() error {
	return nil
}

func (s *KubernetesSecretDockerConfigJsonDataInput) applyDefaults() {
}

func (s *KubernetesSecretDockerConfigJsonDataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RegistryServer != "" {
		m["registry_server"] = s.RegistryServer
	}
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	if s.Email != "" {
		m["email"] = s.Email
	}
	return m
}

// *
//
//	**KubernetesSecretOpaqueData** defines data for an Opaque secret.
//	This is the most common secret type, used for arbitrary key-value pairs.
type KubernetesSecretOpaqueDataInput struct {
	// *
	//  Key-value pairs of secret data.
	//  Values are plain strings (Kubernetes stringData semantics).
	//  At least one entry is required.
	Data map[string]string `json:"data,omitempty" jsonschema:"* Key-value pairs of secret data. Values are plain strings (Kubernetes stringData semantics). At least one entry is required."`
}

func (s *KubernetesSecretOpaqueDataInput) validate() error {
	return nil
}

func (s *KubernetesSecretOpaqueDataInput) applyDefaults() {
}

func (s *KubernetesSecretOpaqueDataInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Data) > 0 {
		m["data"] = s.Data
	}
	return m
}

// *
//
//	**KubernetesSecretSshAuthData** defines data for an SSH authentication secret.
//	Used for Git operations, SSH tunneling, and other SSH-based authentication.
type KubernetesSecretSshAuthDataInput struct {
	// *
	//  PEM-encoded SSH private key.
	//  Stored as the "ssh-privatekey" key in the Kubernetes Secret.
	SshPrivateKey string `json:"ssh_private_key,omitempty" jsonschema:"* PEM-encoded SSH private key. Stored as the 'ssh-privatekey' key in the Kubernetes Secret."`
}

func (s *KubernetesSecretSshAuthDataInput) validate() error {
	return nil
}

func (s *KubernetesSecretSshAuthDataInput) applyDefaults() {
}

func (s *KubernetesSecretSshAuthDataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SshPrivateKey != "" {
		m["ssh_private_key"] = s.SshPrivateKey
	}
	return m
}

// *
//
//	**KubernetesSecretTlsData** defines data for a TLS secret.
//	Used for storing TLS certificates and private keys, commonly consumed by
//	Ingress controllers and other TLS-terminating services.
type KubernetesSecretTlsDataInput struct {
	// *
	//  PEM-encoded TLS certificate (or certificate chain).
	//  Stored as the "tls.crt" key in the Kubernetes Secret.
	TlsCrt string `json:"tls_crt,omitempty" jsonschema:"* PEM-encoded TLS certificate (or certificate chain). Stored as the 'tls.crt' key in the Kubernetes Secret."`
	// *
	//  PEM-encoded TLS private key.
	//  Stored as the "tls.key" key in the Kubernetes Secret.
	TlsKey string `json:"tls_key,omitempty" jsonschema:"* PEM-encoded TLS private key. Stored as the 'tls.key' key in the Kubernetes Secret."`
}

func (s *KubernetesSecretTlsDataInput) validate() error {
	return nil
}

func (s *KubernetesSecretTlsDataInput) applyDefaults() {
}

func (s *KubernetesSecretTlsDataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TlsCrt != "" {
		m["tls_crt"] = s.TlsCrt
	}
	if s.TlsKey != "" {
		m["tls_key"] = s.TlsKey
	}
	return m
}

// ParseKubernetesSecret validates and normalizes a KubernetesSecret cloud_object.
func ParseKubernetesSecret(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesSecret"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesSecretSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
