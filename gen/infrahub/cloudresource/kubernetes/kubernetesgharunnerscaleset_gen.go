// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesGhaRunnerScaleSet is a deployment component that creates a GitHub Actions
//
//	Runner Scale Set on a Kubernetes cluster. The scale set provides self-hosted runners
//	that automatically scale based on workflow demand.
//
//	Each scale set creates an AutoScalingRunnerSet custom resource that the controller
//	watches. When GitHub Actions workflows request runners with matching labels, the
//	controller creates ephemeral runner pods to execute the jobs.
//
//	Prerequisites:
//	- KubernetesGhaRunnerScaleSetController must be deployed in the cluster
//	- Valid GitHub authentication (PAT token or GitHub App)
//
//	Example workflow configuration:
//	  jobs:
//	    build:
//	      runs-on: [self-hosted, my-runner-scale-set-name]
type KubernetesGhaRunnerScaleSetSpecInput struct {
	// Target Kubernetes Cluster where the runner scale set will be deployed.
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster where the runner scale set will be deployed."`
	// Kubernetes Namespace where the runner scale set will be installed.
	//  Multiple scale sets can be installed in different namespaces.
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace where the runner scale set will be installed. Multiple scale sets can be installed in different namespaces."`
	// Flag to indicate if the namespace should be created.
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created."`
	// Version of the Helm chart to deploy.
	//  Chart versions match the runner image versions.
	//  https://github.com/actions/actions-runner-controller/releases
	HelmChartVersion string `json:"helm_chart_version,omitempty" jsonschema:"Version of the Helm chart to deploy. Chart versions match the runner image versions. https://github.com/actions/actions-runner-controller/releases"`
	// GitHub configuration for connecting runners to GitHub.
	Github *KubernetesGhaRunnerScaleSetGitHubConfigInput `json:"github" jsonschema:"required,GitHub configuration for connecting runners to GitHub."`
	// Scaling configuration for the runner pool.
	Scaling *KubernetesGhaRunnerScaleSetScalingInput `json:"scaling,omitempty" jsonschema:"Scaling configuration for the runner pool."`
	// Runner group name in GitHub (organization or enterprise level).
	//  Defaults to "default" if not specified.
	RunnerGroup string `json:"runner_group,omitempty" jsonschema:"Runner group name in GitHub (organization or enterprise level). Defaults to 'default' if not specified."`
	// Name of the runner scale set as it appears in GitHub.
	//  Defaults to the Helm release name (metadata.name) if not specified.
	//  This name is used as the runs-on label in workflow YAML.
	RunnerScaleSetName string `json:"runner_scale_set_name,omitempty" jsonschema:"Name of the runner scale set as it appears in GitHub. Defaults to the Helm release name (metadata.name) if not specified. This name is used as the runs-on label in workflow YAML."`
	// Container mode for running workflows.
	ContainerMode *KubernetesGhaRunnerScaleSetContainerModeInput `json:"container_mode" jsonschema:"required,Container mode for running workflows."`
	// Runner container configuration.
	Runner *KubernetesGhaRunnerScaleSetRunnerInput `json:"runner,omitempty" jsonschema:"Runner container configuration."`
	// Persistent volumes to attach to runner pods.
	//  Use this to persist build caches, dependencies, or workspace data across job runs.
	//  Each volume creates a PVC and mounts it to the specified path in runner pods.
	PersistentVolumes []*KubernetesGhaRunnerScaleSetPersistentVolumeInput `json:"persistent_volumes,omitempty" jsonschema:"Persistent volumes to attach to runner pods. Use this to persist build caches; dependencies; or workspace data across job runs. Each volume creates a PVC and mounts it to the specified path in runner ..."`
	// Controller service account configuration.
	//  Required when the controller is installed with watchSingleNamespace flag
	//  or when automatic controller discovery doesn't work.
	ControllerServiceAccount *KubernetesGhaRunnerScaleSetControllerServiceAccountInput `json:"controller_service_account,omitempty" jsonschema:"Controller service account configuration. Required when the controller is installed with watchSingleNamespace flag or when automatic controller discovery doesn't work."`
	// Image pull secrets for private container registries.
	ImagePullSecrets []string `json:"image_pull_secrets,omitempty" jsonschema:"Image pull secrets for private container registries."`
	// Labels to apply to all resources created by the scale set.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"Labels to apply to all resources created by the scale set."`
	// Annotations to apply to all resources created by the scale set.
	Annotations map[string]string `json:"annotations,omitempty" jsonschema:"Annotations to apply to all resources created by the scale set."`
}

func (s *KubernetesGhaRunnerScaleSetSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Github == nil {
		return fmt.Errorf("github is required")
	}
	if s.Github != nil {
		if err := s.Github.validate(); err != nil {
			return fmt.Errorf("github: %w", err)
		}
	}
	if s.Scaling != nil {
		if err := s.Scaling.validate(); err != nil {
			return fmt.Errorf("scaling: %w", err)
		}
	}
	if s.ContainerMode == nil {
		return fmt.Errorf("container_mode is required")
	}
	if s.ContainerMode != nil {
		if err := s.ContainerMode.validate(); err != nil {
			return fmt.Errorf("container_mode: %w", err)
		}
	}
	if s.Runner != nil {
		if err := s.Runner.validate(); err != nil {
			return fmt.Errorf("runner: %w", err)
		}
	}
	for i, v := range s.PersistentVolumes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("persistent_volumes[%d]: %w", i, err)
			}
		}
	}
	if s.ControllerServiceAccount != nil {
		if err := s.ControllerServiceAccount.validate(); err != nil {
			return fmt.Errorf("controller_service_account: %w", err)
		}
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.HelmChartVersion == "" {
		s.HelmChartVersion = "0.13.1"
	}
	if s.Github != nil {
		s.Github.applyDefaults()
	}
	if s.Scaling != nil {
		s.Scaling.applyDefaults()
	}
	if s.RunnerGroup == "" {
		s.RunnerGroup = "default"
	}
	if s.ContainerMode != nil {
		s.ContainerMode.applyDefaults()
	}
	if s.Runner != nil {
		s.Runner.applyDefaults()
	}
	if s.ControllerServiceAccount != nil {
		s.ControllerServiceAccount.applyDefaults()
	}
}

func (s *KubernetesGhaRunnerScaleSetSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.HelmChartVersion != "" {
		m["helm_chart_version"] = s.HelmChartVersion
	}
	if s.Github != nil {
		m["github"] = s.Github.toMap()
	}
	if s.Scaling != nil {
		m["scaling"] = s.Scaling.toMap()
	}
	if s.RunnerGroup != "" {
		m["runner_group"] = s.RunnerGroup
	}
	if s.RunnerScaleSetName != "" {
		m["runner_scale_set_name"] = s.RunnerScaleSetName
	}
	if s.ContainerMode != nil {
		m["container_mode"] = s.ContainerMode.toMap()
	}
	if s.Runner != nil {
		m["runner"] = s.Runner.toMap()
	}
	if len(s.PersistentVolumes) > 0 {
		items := make([]any, len(s.PersistentVolumes))
		for i, v := range s.PersistentVolumes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["persistent_volumes"] = items
	}
	if s.ControllerServiceAccount != nil {
		m["controller_service_account"] = s.ControllerServiceAccount.toMap()
	}
	if len(s.ImagePullSecrets) > 0 {
		m["image_pull_secrets"] = s.ImagePullSecrets
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Annotations) > 0 {
		m["annotations"] = s.Annotations
	}
	return m
}

// KubernetesGhaRunnerScaleSetContainerMode defines how workflows are executed.
type KubernetesGhaRunnerScaleSetContainerModeInput struct {
	// The container mode type.
	Type string `json:"type" jsonschema:"required,enum=DIND|KUBERNETES|KUBERNETES_NO_VOLUME|DEFAULT,The container mode type."`
	// Work volume claim configuration for kubernetes mode.
	//  Required when type is KUBERNETES.
	//  This volume is used for the workspace where jobs run.
	WorkVolumeClaim *KubernetesGhaRunnerScaleSetWorkVolumeClaimInput `json:"work_volume_claim,omitempty" jsonschema:"Work volume claim configuration for kubernetes mode. Required when type is KUBERNETES. This volume is used for the workspace where jobs run."`
}

func (s *KubernetesGhaRunnerScaleSetContainerModeInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "DIND", "KUBERNETES", "KUBERNETES_NO_VOLUME", "DEFAULT":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.WorkVolumeClaim != nil {
		if err := s.WorkVolumeClaim.validate(); err != nil {
			return fmt.Errorf("work_volume_claim: %w", err)
		}
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetContainerModeInput) applyDefaults() {
	if s.WorkVolumeClaim != nil {
		s.WorkVolumeClaim.applyDefaults()
	}
}

func (s *KubernetesGhaRunnerScaleSetContainerModeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.WorkVolumeClaim != nil {
		m["work_volume_claim"] = s.WorkVolumeClaim.toMap()
	}
	return m
}

// KubernetesGhaRunnerScaleSetControllerServiceAccount specifies the controller's
//
//	service account for creating RBAC bindings.
type KubernetesGhaRunnerScaleSetControllerServiceAccountInput struct {
	// Namespace where the controller is installed.
	Namespace string `json:"namespace,omitempty" jsonschema:"Namespace where the controller is installed."`
	// Name of the controller's service account.
	Name string `json:"name,omitempty" jsonschema:"Name of the controller's service account."`
}

func (s *KubernetesGhaRunnerScaleSetControllerServiceAccountInput) validate() error {
	return nil
}

func (s *KubernetesGhaRunnerScaleSetControllerServiceAccountInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetControllerServiceAccountInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	return m
}

// KubernetesGhaRunnerScaleSetEnvVar defines an environment variable.
type KubernetesGhaRunnerScaleSetEnvVarInput struct {
	// Name of the environment variable.
	Name string `json:"name" jsonschema:"required,Name of the environment variable."`
	// Value of the environment variable.
	Value string `json:"value,omitempty" jsonschema:"Value of the environment variable."`
}

func (s *KubernetesGhaRunnerScaleSetEnvVarInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetEnvVarInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetEnvVarInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// KubernetesGhaRunnerScaleSetGitHubApp configures GitHub App authentication.
type KubernetesGhaRunnerScaleSetGitHubAppInput struct {
	// The GitHub App ID or Client ID.
	AppId string `json:"app_id" jsonschema:"required,The GitHub App ID or Client ID."`
	// The GitHub App Installation ID.
	InstallationId string `json:"installation_id" jsonschema:"required,The GitHub App Installation ID."`
	// The private key for the GitHub App (base64 encoded PEM format).
	//  The PEM file contents must be base64 encoded before providing here.
	//  Example: cat private-key.pem | base64
	PrivateKeyBase64 string `json:"private_key_base64" jsonschema:"required,The private key for the GitHub App (base64 encoded PEM format). The PEM file contents must be base64 encoded before providing here. Example: cat private-key.pem | base64"`
}

func (s *KubernetesGhaRunnerScaleSetGitHubAppInput) validate() error {
	if s.AppId == "" {
		return fmt.Errorf("app_id is required")
	}
	if s.InstallationId == "" {
		return fmt.Errorf("installation_id is required")
	}
	if s.PrivateKeyBase64 == "" {
		return fmt.Errorf("private_key_base64 is required")
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetGitHubAppInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetGitHubAppInput) toMap() map[string]any {
	m := make(map[string]any)
	m["app_id"] = s.AppId
	m["installation_id"] = s.InstallationId
	m["private_key_base64"] = s.PrivateKeyBase64
	return m
}

// KubernetesGhaRunnerScaleSetGitHubConfig defines GitHub connection settings.
type KubernetesGhaRunnerScaleSetGitHubConfigInput struct {
	// GitHub URL for where to configure runners.
	//  Examples:
	//  - Repository: https://github.com/myorg/myrepo
	//  - Organization: https://github.com/myorg
	//  - Enterprise: https://github.com/enterprises/myenterprise
	ConfigUrl string `json:"config_url" jsonschema:"required,GitHub URL for where to configure runners. Examples: - Repository: https://github.com/myorg/myrepo - Organization: https://github.com/myorg - Enterprise: https://github.com/enterprises/myenterprise"`
	// Personal Access Token for authentication.
	//  The token must have appropriate permissions:
	//  - For repositories: repo scope
	//  - For organizations: admin:org scope
	PatToken *KubernetesGhaRunnerScaleSetPatTokenInput `json:"pat_token,omitempty" jsonschema:"Personal Access Token for authentication. The token must have appropriate permissions: - For repositories: repo scope - For organizations: admin:org scope"`
	// GitHub App for authentication (recommended for organizations).
	GithubApp *KubernetesGhaRunnerScaleSetGitHubAppInput `json:"github_app,omitempty" jsonschema:"GitHub App for authentication (recommended for organizations)."`
	// Name of a pre-existing Kubernetes secret containing GitHub credentials.
	//  The secret must be in the same namespace as the runner scale set.
	//  For PAT: must have 'github_token' key
	//  For GitHub App: must have 'github_app_id', 'github_app_installation_id', 'github_app_private_key' keys
	ExistingSecretName string `json:"existing_secret_name,omitempty" jsonschema:"Name of a pre-existing Kubernetes secret containing GitHub credentials. The secret must be in the same namespace as the runner scale set. For PAT: must have 'github_token' key For GitHub App: must hav..."`
}

func (s *KubernetesGhaRunnerScaleSetGitHubConfigInput) validate() error {
	if s.ConfigUrl == "" {
		return fmt.Errorf("config_url is required")
	}
	if s.PatToken != nil {
		if err := s.PatToken.validate(); err != nil {
			return fmt.Errorf("pat_token: %w", err)
		}
	}
	if s.GithubApp != nil {
		if err := s.GithubApp.validate(); err != nil {
			return fmt.Errorf("github_app: %w", err)
		}
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetGitHubConfigInput) applyDefaults() {
	if s.PatToken != nil {
		s.PatToken.applyDefaults()
	}
	if s.GithubApp != nil {
		s.GithubApp.applyDefaults()
	}
}

func (s *KubernetesGhaRunnerScaleSetGitHubConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["config_url"] = s.ConfigUrl
	if s.PatToken != nil {
		m["pat_token"] = s.PatToken.toMap()
	}
	if s.GithubApp != nil {
		m["github_app"] = s.GithubApp.toMap()
	}
	if s.ExistingSecretName != "" {
		m["existing_secret_name"] = s.ExistingSecretName
	}
	return m
}

// KubernetesGhaRunnerScaleSetPatToken configures Personal Access Token authentication.
type KubernetesGhaRunnerScaleSetPatTokenInput struct {
	// The GitHub Personal Access Token.
	//  Must have appropriate permissions for the scope (repo, org, or enterprise).
	Token string `json:"token" jsonschema:"required,The GitHub Personal Access Token. Must have appropriate permissions for the scope (repo; org; or enterprise)."`
}

func (s *KubernetesGhaRunnerScaleSetPatTokenInput) validate() error {
	if s.Token == "" {
		return fmt.Errorf("token is required")
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetPatTokenInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetPatTokenInput) toMap() map[string]any {
	m := make(map[string]any)
	m["token"] = s.Token
	return m
}

// KubernetesGhaRunnerScaleSetPersistentVolume defines a PVC to create and mount.
//
//	These volumes persist across runner pod restarts and job executions,
//	making them ideal for caching build dependencies.
type KubernetesGhaRunnerScaleSetPersistentVolumeInput struct {
	// Name of the volume.
	//  Used to reference this volume in volume_mounts.
	Name string `json:"name" jsonschema:"required,Name of the volume. Used to reference this volume in volume_mounts."`
	// Storage class for the PVC.
	//  If not specified, uses the cluster's default storage class.
	StorageClass string `json:"storage_class,omitempty" jsonschema:"Storage class for the PVC. If not specified; uses the cluster's default storage class."`
	// Size of the volume (e.g., "10Gi", "100Gi").
	Size string `json:"size" jsonschema:"required,Size of the volume (e.g.; '10Gi'; '100Gi')."`
	// Access modes for the PVC.
	//  Common values: "ReadWriteOnce", "ReadOnlyMany", "ReadWriteMany"
	//  Default: ["ReadWriteOnce"]
	AccessModes []string `json:"access_modes,omitempty" jsonschema:"Access modes for the PVC. Common values: 'ReadWriteOnce'; 'ReadOnlyMany'; 'ReadWriteMany' Default: ['ReadWriteOnce']"`
	// Mount path in the runner container.
	//  Where the volume will be mounted (e.g., "/home/runner/.cache").
	MountPath string `json:"mount_path" jsonschema:"required,Mount path in the runner container. Where the volume will be mounted (e.g.; '/home/runner/.cache')."`
	// Whether to mount the volume as read-only.
	ReadOnly bool `json:"read_only,omitempty" jsonschema:"Whether to mount the volume as read-only."`
}

func (s *KubernetesGhaRunnerScaleSetPersistentVolumeInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	if s.MountPath == "" {
		return fmt.Errorf("mount_path is required")
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetPersistentVolumeInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetPersistentVolumeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.StorageClass != "" {
		m["storage_class"] = s.StorageClass
	}
	m["size"] = s.Size
	if len(s.AccessModes) > 0 {
		m["access_modes"] = s.AccessModes
	}
	m["mount_path"] = s.MountPath
	if s.ReadOnly {
		m["read_only"] = s.ReadOnly
	}
	return m
}

// KubernetesGhaRunnerScaleSetRunner configures the runner container.
type KubernetesGhaRunnerScaleSetRunnerInput struct {
	// Custom runner image configuration.
	//  When not specified, uses the default ghcr.io/actions/actions-runner image.
	Image *KubernetesGhaRunnerScaleSetRunnerImageInput `json:"image,omitempty" jsonschema:"Custom runner image configuration. When not specified; uses the default ghcr.io/actions/actions-runner image."`
	// CPU and memory resources for the runner container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"CPU and memory resources for the runner container."`
	// Environment variables to set in the runner container.
	Env []*KubernetesGhaRunnerScaleSetEnvVarInput `json:"env,omitempty" jsonschema:"Environment variables to set in the runner container."`
	// Volume mounts for the runner container.
	//  Used to mount persistent volumes to specific paths.
	VolumeMounts []*KubernetesGhaRunnerScaleSetVolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"Volume mounts for the runner container. Used to mount persistent volumes to specific paths."`
}

func (s *KubernetesGhaRunnerScaleSetRunnerInput) validate() error {
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	for i, v := range s.Env {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("env[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetRunnerInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesGhaRunnerScaleSetRunnerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if len(s.Env) > 0 {
		items := make([]any, len(s.Env))
		for i, v := range s.Env {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["env"] = items
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	return m
}

// KubernetesGhaRunnerScaleSetRunnerImage configures a custom runner image.
type KubernetesGhaRunnerScaleSetRunnerImageInput struct {
	// Container image repository.
	//  Default: ghcr.io/actions/actions-runner
	Repository string `json:"repository,omitempty" jsonschema:"Container image repository. Default: ghcr.io/actions/actions-runner"`
	// Image tag.
	//  When not specified, uses the chart appVersion (matches controller version).
	//  Default tag aligns with helm_chart_version default.
	//  https://github.com/actions/runner/pkgs/container/actions-runner
	Tag string `json:"tag,omitempty" jsonschema:"Image tag. When not specified; uses the chart appVersion (matches controller version). Default tag aligns with helm_chart_version default. https://github.com/actions/runner/pkgs/container/actions-runn..."`
	// Image pull policy: Always, IfNotPresent, or Never.
	//  Default: IfNotPresent
	PullPolicy string `json:"pull_policy,omitempty" jsonschema:"Image pull policy: Always; IfNotPresent; or Never. Default: IfNotPresent"`
}

func (s *KubernetesGhaRunnerScaleSetRunnerImageInput) validate() error {
	return nil
}

func (s *KubernetesGhaRunnerScaleSetRunnerImageInput) applyDefaults() {
	if s.Repository == "" {
		s.Repository = "ghcr.io/actions/actions-runner"
	}
	if s.Tag == "" {
		s.Tag = "2.331.0"
	}
	if s.PullPolicy == "" {
		s.PullPolicy = "IfNotPresent"
	}
}

func (s *KubernetesGhaRunnerScaleSetRunnerImageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Repository != "" {
		m["repository"] = s.Repository
	}
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	if s.PullPolicy != "" {
		m["pull_policy"] = s.PullPolicy
	}
	return m
}

// KubernetesGhaRunnerScaleSetScaling defines autoscaling behavior.
type KubernetesGhaRunnerScaleSetScalingInput struct {
	// Minimum number of idle runners to maintain.
	//  Set to 0 for scale-to-zero behavior (most cost-effective).
	//  Set higher for faster job startup at the cost of idle resources.
	MinRunners int32 `json:"min_runners,omitempty" jsonschema:"Minimum number of idle runners to maintain. Set to 0 for scale-to-zero behavior (most cost-effective). Set higher for faster job startup at the cost of idle resources."`
	// Maximum number of runners the scale set can scale up to.
	//  Limits concurrent job execution to prevent resource exhaustion.
	MaxRunners int32 `json:"max_runners,omitempty" jsonschema:"Maximum number of runners the scale set can scale up to. Limits concurrent job execution to prevent resource exhaustion."`
}

func (s *KubernetesGhaRunnerScaleSetScalingInput) validate() error {
	return nil
}

func (s *KubernetesGhaRunnerScaleSetScalingInput) applyDefaults() {
	if s.MinRunners == 0 {
		s.MinRunners = 0
	}
	if s.MaxRunners == 0 {
		s.MaxRunners = 5
	}
}

func (s *KubernetesGhaRunnerScaleSetScalingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinRunners != 0 {
		m["min_runners"] = s.MinRunners
	}
	if s.MaxRunners != 0 {
		m["max_runners"] = s.MaxRunners
	}
	return m
}

// KubernetesGhaRunnerScaleSetVolumeMount defines how to mount a volume in the runner.
type KubernetesGhaRunnerScaleSetVolumeMountInput struct {
	// Name of the volume to mount (must match a persistent_volume name).
	Name string `json:"name" jsonschema:"required,Name of the volume to mount (must match a persistent_volume name)."`
	// Path within the container where the volume should be mounted.
	MountPath string `json:"mount_path" jsonschema:"required,Path within the container where the volume should be mounted."`
	// Whether the volume should be mounted read-only.
	ReadOnly bool `json:"read_only,omitempty" jsonschema:"Whether the volume should be mounted read-only."`
	// Path within the volume to mount (subdirectory).
	SubPath string `json:"sub_path,omitempty" jsonschema:"Path within the volume to mount (subdirectory)."`
}

func (s *KubernetesGhaRunnerScaleSetVolumeMountInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.MountPath == "" {
		return fmt.Errorf("mount_path is required")
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetVolumeMountInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetVolumeMountInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["mount_path"] = s.MountPath
	if s.ReadOnly {
		m["read_only"] = s.ReadOnly
	}
	if s.SubPath != "" {
		m["sub_path"] = s.SubPath
	}
	return m
}

// KubernetesGhaRunnerScaleSetWorkVolumeClaim configures the ephemeral work volume
//
//	for kubernetes container mode.
type KubernetesGhaRunnerScaleSetWorkVolumeClaimInput struct {
	// Storage class for the work volume.
	//  If not specified, uses the cluster's default storage class.
	StorageClass string `json:"storage_class,omitempty" jsonschema:"Storage class for the work volume. If not specified; uses the cluster's default storage class."`
	// Size of the work volume (e.g., "10Gi", "100Gi").
	//  Should be large enough to hold the repository and build artifacts.
	Size string `json:"size" jsonschema:"required,Size of the work volume (e.g.; '10Gi'; '100Gi'). Should be large enough to hold the repository and build artifacts."`
	// Access modes for the volume.
	//  Default: ["ReadWriteOnce"]
	AccessModes []string `json:"access_modes,omitempty" jsonschema:"Access modes for the volume. Default: ['ReadWriteOnce']"`
}

func (s *KubernetesGhaRunnerScaleSetWorkVolumeClaimInput) validate() error {
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetWorkVolumeClaimInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetWorkVolumeClaimInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.StorageClass != "" {
		m["storage_class"] = s.StorageClass
	}
	m["size"] = s.Size
	if len(s.AccessModes) > 0 {
		m["access_modes"] = s.AccessModes
	}
	return m
}

// ParseKubernetesGhaRunnerScaleSet validates and normalizes a KubernetesGhaRunnerScaleSet cloud_object.
func ParseKubernetesGhaRunnerScaleSet(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesGhaRunnerScaleSet"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesGhaRunnerScaleSetSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
