// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesDaemonSet is a Kubernetes resource that ensures all (or some) nodes run a copy of a pod.
//
//	Common use cases include cluster storage daemons, log collection daemons, and node monitoring daemons.
type KubernetesDaemonSetSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// Flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created"`
	// The container specifications for the DaemonSet.
	//  This includes configurations for the main application container and any sidecar containers.
	Container *KubernetesDaemonSetContainerInput `json:"container" jsonschema:"required,The container specifications for the DaemonSet. This includes configurations for the main application container and any sidecar containers."`
	// Node selector for constraining the DaemonSet pods to run on specific nodes.
	//  Key-value pairs that must match labels on nodes for the pod to be scheduled.
	NodeSelector map[string]string `json:"node_selector,omitempty" jsonschema:"Node selector for constraining the DaemonSet pods to run on specific nodes. Key-value pairs that must match labels on nodes for the pod to be scheduled."`
	// Tolerations allow the DaemonSet pods to be scheduled on nodes with matching taints.
	//  This is essential for running pods on master nodes or nodes with specific taints.
	Tolerations []*KubernetesDaemonSetTolerationInput `json:"tolerations,omitempty" jsonschema:"Tolerations allow the DaemonSet pods to be scheduled on nodes with matching taints. This is essential for running pods on master nodes or nodes with specific taints."`
	// The update strategy for the DaemonSet.
	//  Controls how pods are updated when the DaemonSet specification changes.
	UpdateStrategy *KubernetesDaemonSetUpdateStrategyInput `json:"update_strategy,omitempty" jsonschema:"The update strategy for the DaemonSet. Controls how pods are updated when the DaemonSet specification changes."`
	// Minimum number of seconds for which a newly created DaemonSet pod should be ready
	//  without any of its container crashing, for it to be considered available.
	//  Defaults to 0 (pod will be considered available as soon as it is ready).
	MinReadySeconds int32 `json:"min_ready_seconds,omitempty" jsonschema:"Minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing; for it to be considered available. Defaults to 0 (pod will be considered availa..."`
	// *
	//  Flag to indicate if a ServiceAccount should be created for this DaemonSet.
	//  If true, a ServiceAccount with the name specified in service_account_name
	//  (or the DaemonSet name if not specified) will be created.
	//  The DaemonSet pods will use this ServiceAccount.
	CreateServiceAccount bool `json:"create_service_account,omitempty" jsonschema:"* Flag to indicate if a ServiceAccount should be created for this DaemonSet. If true; a ServiceAccount with the name specified in service_account_name (or the DaemonSet name if not specified) will be ..."`
	// *
	//  Name of the ServiceAccount to use for the DaemonSet pods.
	//  If create_service_account is true, a ServiceAccount with this name will be created.
	//  If create_service_account is false, this references an existing ServiceAccount.
	//  If not specified and create_service_account is true, uses the DaemonSet ...
	ServiceAccountName string `json:"service_account_name,omitempty" jsonschema:"* Name of the ServiceAccount to use for the DaemonSet pods. If create_service_account is true; a ServiceAccount with this name will be created. If create_service_account is false; this references an e..."`
	// *
	//  ConfigMaps to create alongside the DaemonSet.
	//  Key is the ConfigMap name, value is the content.
	//  These ConfigMaps can be referenced in volume mounts.
	//
	//  Example:
	//    config_maps:
	//      vector-config: |
	//        data_dir: /var/lib/vector
	//        sources:
	//          kubernetes_logs:
	//            type: kubern...
	ConfigMaps map[string]string `json:"config_maps,omitempty" jsonschema:"* ConfigMaps to create alongside the DaemonSet. Key is the ConfigMap name; value is the content. These ConfigMaps can be referenced in volume mounts. Example: config_maps: vector-config: | data_dir: /..."`
	// *
	//  RBAC configuration for the DaemonSet ServiceAccount.
	//  Allows defining ClusterRole and Role permissions.
	//  Only used if create_service_account is true.
	Rbac *KubernetesDaemonSetRbacInput `json:"rbac,omitempty" jsonschema:"* RBAC configuration for the DaemonSet ServiceAccount. Allows defining ClusterRole and Role permissions. Only used if create_service_account is true."`
}

func (s *KubernetesDaemonSetSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	for i, v := range s.Tolerations {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("tolerations[%d]: %w", i, err)
			}
		}
	}
	if s.UpdateStrategy != nil {
		if err := s.UpdateStrategy.validate(); err != nil {
			return fmt.Errorf("update_strategy: %w", err)
		}
	}
	if s.Rbac != nil {
		if err := s.Rbac.validate(); err != nil {
			return fmt.Errorf("rbac: %w", err)
		}
	}
	return nil
}

func (s *KubernetesDaemonSetSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.UpdateStrategy != nil {
		s.UpdateStrategy.applyDefaults()
	}
	if s.Rbac != nil {
		s.Rbac.applyDefaults()
	}
}

func (s *KubernetesDaemonSetSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if len(s.NodeSelector) > 0 {
		m["node_selector"] = s.NodeSelector
	}
	if len(s.Tolerations) > 0 {
		items := make([]any, len(s.Tolerations))
		for i, v := range s.Tolerations {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["tolerations"] = items
	}
	if s.UpdateStrategy != nil {
		m["update_strategy"] = s.UpdateStrategy.toMap()
	}
	if s.MinReadySeconds != 0 {
		m["min_ready_seconds"] = s.MinReadySeconds
	}
	if s.CreateServiceAccount {
		m["create_service_account"] = s.CreateServiceAccount
	}
	if s.ServiceAccountName != "" {
		m["service_account_name"] = s.ServiceAccountName
	}
	if len(s.ConfigMaps) > 0 {
		m["config_maps"] = s.ConfigMaps
	}
	if s.Rbac != nil {
		m["rbac"] = s.Rbac.toMap()
	}
	return m
}

// *
//
//	**KubernetesDaemonSetCapabilities** defines Linux capabilities to add or drop.
type KubernetesDaemonSetCapabilitiesInput struct {
	// List of capabilities to add.
	Add []string `json:"add,omitempty" jsonschema:"List of capabilities to add."`
	// List of capabilities to drop.
	Drop []string `json:"drop,omitempty" jsonschema:"List of capabilities to drop."`
}

func (s *KubernetesDaemonSetCapabilitiesInput) validate() error {
	return nil
}

func (s *KubernetesDaemonSetCapabilitiesInput) applyDefaults() {
}

func (s *KubernetesDaemonSetCapabilitiesInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Add) > 0 {
		m["add"] = s.Add
	}
	if len(s.Drop) > 0 {
		m["drop"] = s.Drop
	}
	return m
}

// *
//
//	**KubernetesDaemonSetContainer** specifies the container configuration for the DaemonSet.
//	It includes the main application container and any sidecar containers that need to run alongside it.
type KubernetesDaemonSetContainerInput struct {
	// The main application container specifications.
	App *KubernetesDaemonSetContainerAppInput `json:"app" jsonschema:"required,The main application container specifications."`
	// A list of sidecar containers to be deployed alongside the main application container.
	Sidecars []*ContainerInput `json:"sidecars,omitempty" jsonschema:"A list of sidecar containers to be deployed alongside the main application container."`
}

func (s *KubernetesDaemonSetContainerInput) validate() error {
	if s.App == nil {
		return fmt.Errorf("app is required")
	}
	if s.App != nil {
		if err := s.App.validate(); err != nil {
			return fmt.Errorf("app: %w", err)
		}
	}
	for i, v := range s.Sidecars {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("sidecars[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesDaemonSetContainerInput) applyDefaults() {
	if s.App != nil {
		s.App.applyDefaults()
	}
}

func (s *KubernetesDaemonSetContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.App != nil {
		m["app"] = s.App.toMap()
	}
	if len(s.Sidecars) > 0 {
		items := make([]any, len(s.Sidecars))
		for i, v := range s.Sidecars {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["sidecars"] = items
	}
	return m
}

// *
//
//	**KubernetesDaemonSetContainerApp** specifies the configuration for the main application container.
//	It includes the container image, resource allocations, environment variables, and health probes.
type KubernetesDaemonSetContainerAppInput struct {
	// *
	//  The container image to be used for the application.
	//  The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes DaemonSet resource.
	Image *ContainerImageInput `json:"image" jsonschema:"required,* The container image to be used for the application. The 'pull_secret_name' is the name of the image pull secret to be configured in the Kubernetes DaemonSet resource."`
	// The CPU and memory resources allocated to the application container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the application container."`
	// *
	//  The environment variables and secrets for the application container.
	Env *KubernetesDaemonSetContainerAppEnvInput `json:"env,omitempty" jsonschema:"* The environment variables and secrets for the application container."`
	// *
	//  A list of ports to be configured for the application container.
	Ports []*KubernetesDaemonSetContainerAppPortInput `json:"ports,omitempty" jsonschema:"* A list of ports to be configured for the application container."`
	// *
	//  Volume mounts for the container.
	//  Supports ConfigMap, Secret, HostPath, EmptyDir, and PVC volumes.
	//  DaemonSets commonly need HostPath mounts for log collection, node monitoring, etc.
	VolumeMounts []*VolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"* Volume mounts for the container. Supports ConfigMap; Secret; HostPath; EmptyDir; and PVC volumes. DaemonSets commonly need HostPath mounts for log collection; node monitoring; etc."`
	// *
	//  Liveness probe configuration.
	//  Periodic probe of container liveness. Container will be restarted if the probe fails.
	LivenessProbe *ProbeInput `json:"liveness_probe,omitempty" jsonschema:"* Liveness probe configuration. Periodic probe of container liveness. Container will be restarted if the probe fails."`
	// *
	//  Readiness probe configuration.
	//  Periodic probe of container service readiness.
	ReadinessProbe *ProbeInput `json:"readiness_probe,omitempty" jsonschema:"* Readiness probe configuration. Periodic probe of container service readiness."`
	// *
	//  Startup probe configuration.
	//  Indicates whether the application within the container is started.
	StartupProbe *ProbeInput `json:"startup_probe,omitempty" jsonschema:"* Startup probe configuration. Indicates whether the application within the container is started."`
	// *
	//  Command to run in the container (overrides the container image's ENTRYPOINT).
	Command []string `json:"command,omitempty" jsonschema:"* Command to run in the container (overrides the container image's ENTRYPOINT)."`
	// *
	//  Arguments to pass to the command (overrides the container image's CMD).
	Args []string `json:"args,omitempty" jsonschema:"* Arguments to pass to the command (overrides the container image's CMD)."`
	// *
	//  Security context for the container.
	//  DaemonSets often need privileged access for node-level operations.
	SecurityContext *KubernetesDaemonSetSecurityContextInput `json:"security_context,omitempty" jsonschema:"* Security context for the container. DaemonSets often need privileged access for node-level operations."`
}

func (s *KubernetesDaemonSetContainerAppInput) validate() error {
	if s.Image == nil {
		return fmt.Errorf("image is required")
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	for i, v := range s.Ports {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ports[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	if s.LivenessProbe != nil {
		if err := s.LivenessProbe.validate(); err != nil {
			return fmt.Errorf("liveness_probe: %w", err)
		}
	}
	if s.ReadinessProbe != nil {
		if err := s.ReadinessProbe.validate(); err != nil {
			return fmt.Errorf("readiness_probe: %w", err)
		}
	}
	if s.StartupProbe != nil {
		if err := s.StartupProbe.validate(); err != nil {
			return fmt.Errorf("startup_probe: %w", err)
		}
	}
	if s.SecurityContext != nil {
		if err := s.SecurityContext.validate(); err != nil {
			return fmt.Errorf("security_context: %w", err)
		}
	}
	return nil
}

func (s *KubernetesDaemonSetContainerAppInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.LivenessProbe != nil {
		s.LivenessProbe.applyDefaults()
	}
	if s.ReadinessProbe != nil {
		s.ReadinessProbe.applyDefaults()
	}
	if s.StartupProbe != nil {
		s.StartupProbe.applyDefaults()
	}
	if s.SecurityContext != nil {
		s.SecurityContext.applyDefaults()
	}
}

func (s *KubernetesDaemonSetContainerAppInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	if len(s.Ports) > 0 {
		items := make([]any, len(s.Ports))
		for i, v := range s.Ports {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ports"] = items
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	if s.LivenessProbe != nil {
		m["liveness_probe"] = s.LivenessProbe.toMap()
	}
	if s.ReadinessProbe != nil {
		m["readiness_probe"] = s.ReadinessProbe.toMap()
	}
	if s.StartupProbe != nil {
		m["startup_probe"] = s.StartupProbe.toMap()
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	if s.SecurityContext != nil {
		m["security_context"] = s.SecurityContext.toMap()
	}
	return m
}

// *
//
//	**KubernetesDaemonSetContainerAppEnv** defines the environment variables and secrets for the application container.
type KubernetesDaemonSetContainerAppEnvInput struct {
	// *
	//  A map of environment variable names to their values.
	//  Each variable can be provided either as a literal string value or as a reference
	//  to another OpenMCF resource's field.
	//
	//  **Option 1: Direct string value**
	//  ```yaml
	//  variables:
	//    LOG_LEVEL:
	//      value: "info"
	//  ```
	//
	//  **Option 2: Reference to an...
	Variables map[string]string `json:"variables,omitempty" jsonschema:"* A map of environment variable names to their values. Each variable can be provided either as a literal string value or as a reference to another OpenMCF resource's field. **Option 1: Direct string v..."`
	// *
	//  A map of secret environment variable names to their values.
	//  Each secret can be provided either as a literal string value or as a reference
	//  to an existing Kubernetes Secret.
	//
	//  Using secret references is recommended for production deployments.
	Secrets map[string]*KubernetesSensitiveValueInput `json:"secrets,omitempty" jsonschema:"* A map of secret environment variable names to their values. Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret. Using secret references i..."`
}

func (s *KubernetesDaemonSetContainerAppEnvInput) validate() error {
	for k, v := range s.Secrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secrets[%s]: %w", k, err)
			}
		}
	}
	return nil
}

func (s *KubernetesDaemonSetContainerAppEnvInput) applyDefaults() {
}

func (s *KubernetesDaemonSetContainerAppEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		result := make(map[string]any, len(s.Secrets))
		for k, v := range s.Secrets {
			if v != nil {
				result[k] = v.toMap()
			}
		}
		m["secrets"] = result
	}
	return m
}

// *
//
//	**KubernetesDaemonSetContainerAppPort** specifies the port configuration for the application container.
type KubernetesDaemonSetContainerAppPortInput struct {
	// The name of the port (e.g., "metrics", "health").
	//  The name must only contain lowercase alphanumeric characters and hyphens.
	Name string `json:"name" jsonschema:"required,The name of the port (e.g.; 'metrics'; 'health'). The name must only contain lowercase alphanumeric characters and hyphens."`
	// The port number on the container.
	ContainerPort int32 `json:"container_port" jsonschema:"required,The port number on the container."`
	// The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
	NetworkProtocol string `json:"network_protocol" jsonschema:"required,The network protocol used by the port (e.g.; 'TCP'; 'UDP'; 'SCTP')."`
	// Host port to expose the container port on.
	//  Use with caution as it limits where pods can be scheduled.
	HostPort int32 `json:"host_port,omitempty" jsonschema:"Host port to expose the container port on. Use with caution as it limits where pods can be scheduled."`
}

func (s *KubernetesDaemonSetContainerAppPortInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.NetworkProtocol == "" {
		return fmt.Errorf("network_protocol is required")
	}
	return nil
}

func (s *KubernetesDaemonSetContainerAppPortInput) applyDefaults() {
}

func (s *KubernetesDaemonSetContainerAppPortInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["container_port"] = s.ContainerPort
	m["network_protocol"] = s.NetworkProtocol
	if s.HostPort != 0 {
		m["host_port"] = s.HostPort
	}
	return m
}

// *
//
//	KubernetesDaemonSetRbac defines RBAC permissions for the DaemonSet ServiceAccount.
//	Creates ClusterRole/ClusterRoleBinding for cluster-wide permissions
//	and Role/RoleBinding for namespace-scoped permissions.
type KubernetesDaemonSetRbacInput struct {
	// *
	//  Cluster-wide RBAC rules.
	//  Creates a ClusterRole and ClusterRoleBinding.
	//  Use for permissions that span across namespaces (e.g., reading all pods).
	ClusterRules []*KubernetesDaemonSetRbacRuleInput `json:"cluster_rules,omitempty" jsonschema:"* Cluster-wide RBAC rules. Creates a ClusterRole and ClusterRoleBinding. Use for permissions that span across namespaces (e.g.; reading all pods)."`
	// *
	//  Namespace-scoped RBAC rules.
	//  Creates a Role and RoleBinding in the DaemonSet's namespace.
	//  Use for permissions limited to the deployment namespace.
	NamespaceRules []*KubernetesDaemonSetRbacRuleInput `json:"namespace_rules,omitempty" jsonschema:"* Namespace-scoped RBAC rules. Creates a Role and RoleBinding in the DaemonSet's namespace. Use for permissions limited to the deployment namespace."`
}

func (s *KubernetesDaemonSetRbacInput) validate() error {
	for i, v := range s.ClusterRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("cluster_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.NamespaceRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("namespace_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesDaemonSetRbacInput) applyDefaults() {
}

func (s *KubernetesDaemonSetRbacInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.ClusterRules) > 0 {
		items := make([]any, len(s.ClusterRules))
		for i, v := range s.ClusterRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["cluster_rules"] = items
	}
	if len(s.NamespaceRules) > 0 {
		items := make([]any, len(s.NamespaceRules))
		for i, v := range s.NamespaceRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["namespace_rules"] = items
	}
	return m
}

// *
//
//	KubernetesDaemonSetRbacRule defines a single RBAC policy rule.
//	Maps directly to Kubernetes RBAC PolicyRule.
type KubernetesDaemonSetRbacRuleInput struct {
	// *
	//  API groups containing the resources.
	//  Use "" for core API group.
	//  Example: [""], ["apps"], ["batch"]
	ApiGroups []string `json:"api_groups,omitempty" jsonschema:"* API groups containing the resources. Use '' for core API group. Example: ['']; ['apps']; ['batch']"`
	// *
	//  Resources this rule applies to.
	//  Example: ["pods", "services"], ["deployments"], ["configmaps", "secrets"]
	Resources []string `json:"resources,omitempty" jsonschema:"* Resources this rule applies to. Example: ['pods'; 'services']; ['deployments']; ['configmaps'; 'secrets']"`
	// *
	//  Verbs specifying the actions allowed.
	//  Example: ["get", "list", "watch"], ["create", "update", "delete"]
	Verbs []string `json:"verbs,omitempty" jsonschema:"* Verbs specifying the actions allowed. Example: ['get'; 'list'; 'watch']; ['create'; 'update'; 'delete']"`
	// *
	//  Resource names to limit the rule to specific resources.
	//  If empty, the rule applies to all resources of the specified type.
	//  Example: ["my-configmap", "my-secret"]
	ResourceNames []string `json:"resource_names,omitempty" jsonschema:"* Resource names to limit the rule to specific resources. If empty; the rule applies to all resources of the specified type. Example: ['my-configmap'; 'my-secret']"`
}

func (s *KubernetesDaemonSetRbacRuleInput) validate() error {
	if len(s.ApiGroups) < 1 {
		return fmt.Errorf("api_groups requires at least 1 items, got %d", len(s.ApiGroups))
	}
	if len(s.Resources) < 1 {
		return fmt.Errorf("resources requires at least 1 items, got %d", len(s.Resources))
	}
	if len(s.Verbs) < 1 {
		return fmt.Errorf("verbs requires at least 1 items, got %d", len(s.Verbs))
	}
	return nil
}

func (s *KubernetesDaemonSetRbacRuleInput) applyDefaults() {
}

func (s *KubernetesDaemonSetRbacRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.ApiGroups) > 0 {
		m["api_groups"] = s.ApiGroups
	}
	if len(s.Resources) > 0 {
		m["resources"] = s.Resources
	}
	if len(s.Verbs) > 0 {
		m["verbs"] = s.Verbs
	}
	if len(s.ResourceNames) > 0 {
		m["resource_names"] = s.ResourceNames
	}
	return m
}

// *
//
//	**KubernetesDaemonSetRollingUpdate** defines the parameters for rolling update strategy.
type KubernetesDaemonSetRollingUpdateInput struct {
	// The maximum number of DaemonSet pods that can be unavailable during the update.
	//  Can be an absolute number or a percentage (e.g., "1" or "10%").
	//  This cannot be 0 if maxSurge is 0.
	//  Defaults to 1.
	MaxUnavailable string `json:"max_unavailable,omitempty" jsonschema:"The maximum number of DaemonSet pods that can be unavailable during the update. Can be an absolute number or a percentage (e.g.; '1' or '10%'). This cannot be 0 if maxSurge is 0. Defaults to 1."`
	// The maximum number of nodes with an existing available DaemonSet pod that can have
	//  an updated DaemonSet pod during an update.
	//  Can be an absolute number or a percentage (e.g., "1" or "10%").
	//  Defaults to 0.
	MaxSurge string `json:"max_surge,omitempty" jsonschema:"The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during an update. Can be an absolute number or a percentage (e.g.; '1' or '10%'). Defaults t..."`
}

func (s *KubernetesDaemonSetRollingUpdateInput) validate() error {
	return nil
}

func (s *KubernetesDaemonSetRollingUpdateInput) applyDefaults() {
}

func (s *KubernetesDaemonSetRollingUpdateInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MaxUnavailable != "" {
		m["max_unavailable"] = s.MaxUnavailable
	}
	if s.MaxSurge != "" {
		m["max_surge"] = s.MaxSurge
	}
	return m
}

// *
//
//	**KubernetesDaemonSetSecurityContext** defines the security context for the container.
type KubernetesDaemonSetSecurityContextInput struct {
	// Run as privileged container.
	//  DaemonSets often need privileged access for node-level operations.
	Privileged bool `json:"privileged,omitempty" jsonschema:"Run as privileged container. DaemonSets often need privileged access for node-level operations."`
	// Run as a specific user ID.
	RunAsUser int64 `json:"run_as_user,omitempty" jsonschema:"Run as a specific user ID."`
	// Run as a specific group ID.
	RunAsGroup int64 `json:"run_as_group,omitempty" jsonschema:"Run as a specific group ID."`
	// Run as non-root user.
	RunAsNonRoot bool `json:"run_as_non_root,omitempty" jsonschema:"Run as non-root user."`
	// Make the root filesystem read-only.
	ReadOnlyRootFilesystem bool `json:"read_only_root_filesystem,omitempty" jsonschema:"Make the root filesystem read-only."`
	// Capabilities to add or drop.
	Capabilities *KubernetesDaemonSetCapabilitiesInput `json:"capabilities,omitempty" jsonschema:"Capabilities to add or drop."`
}

func (s *KubernetesDaemonSetSecurityContextInput) validate() error {
	if s.Capabilities != nil {
		if err := s.Capabilities.validate(); err != nil {
			return fmt.Errorf("capabilities: %w", err)
		}
	}
	return nil
}

func (s *KubernetesDaemonSetSecurityContextInput) applyDefaults() {
	if s.Capabilities != nil {
		s.Capabilities.applyDefaults()
	}
}

func (s *KubernetesDaemonSetSecurityContextInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Privileged {
		m["privileged"] = s.Privileged
	}
	if s.RunAsUser != 0 {
		m["run_as_user"] = s.RunAsUser
	}
	if s.RunAsGroup != 0 {
		m["run_as_group"] = s.RunAsGroup
	}
	if s.RunAsNonRoot {
		m["run_as_non_root"] = s.RunAsNonRoot
	}
	if s.ReadOnlyRootFilesystem {
		m["read_only_root_filesystem"] = s.ReadOnlyRootFilesystem
	}
	if s.Capabilities != nil {
		m["capabilities"] = s.Capabilities.toMap()
	}
	return m
}

// *
//
//	**KubernetesDaemonSetToleration** defines a toleration for the DaemonSet pods.
type KubernetesDaemonSetTolerationInput struct {
	// Key is the taint key that the toleration applies to.
	Key string `json:"key,omitempty" jsonschema:"Key is the taint key that the toleration applies to."`
	// Operator represents a key's relationship to the value.
	//  Valid operators are Exists and Equal. Defaults to Equal.
	Operator string `json:"operator,omitempty" jsonschema:"Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal."`
	// Value is the taint value the toleration matches to.
	Value string `json:"value,omitempty" jsonschema:"Value is the taint value the toleration matches to."`
	// Effect indicates the taint effect to match.
	//  Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
	Effect string `json:"effect,omitempty" jsonschema:"Effect indicates the taint effect to match. Valid effects are NoSchedule; PreferNoSchedule and NoExecute."`
	// TolerationSeconds represents the period of time the toleration tolerates the taint.
	//  Only applicable when effect is NoExecute.
	TolerationSeconds int64 `json:"toleration_seconds,omitempty" jsonschema:"TolerationSeconds represents the period of time the toleration tolerates the taint. Only applicable when effect is NoExecute."`
}

func (s *KubernetesDaemonSetTolerationInput) validate() error {
	return nil
}

func (s *KubernetesDaemonSetTolerationInput) applyDefaults() {
}

func (s *KubernetesDaemonSetTolerationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.Operator != "" {
		m["operator"] = s.Operator
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.Effect != "" {
		m["effect"] = s.Effect
	}
	if s.TolerationSeconds != 0 {
		m["toleration_seconds"] = s.TolerationSeconds
	}
	return m
}

// *
//
//	**KubernetesDaemonSetUpdateStrategy** defines the update strategy for the DaemonSet.
type KubernetesDaemonSetUpdateStrategyInput struct {
	// Type of update strategy.
	//  Can be "RollingUpdate" or "OnDelete".
	//  RollingUpdate: The DaemonSet controller creates new pods and deletes old ones progressively.
	//  OnDelete: Pods are only updated when they are manually deleted.
	Type string `json:"type,omitempty" jsonschema:"Type of update strategy. Can be 'RollingUpdate' or 'OnDelete'. RollingUpdate: The DaemonSet controller creates new pods and deletes old ones progressively. OnDelete: Pods are only updated when they ar..."`
	// Rolling update config params. Present only if type = "RollingUpdate".
	RollingUpdate *KubernetesDaemonSetRollingUpdateInput `json:"rolling_update,omitempty" jsonschema:"Rolling update config params. Present only if type = 'RollingUpdate'."`
}

func (s *KubernetesDaemonSetUpdateStrategyInput) validate() error {
	if s.RollingUpdate != nil {
		if err := s.RollingUpdate.validate(); err != nil {
			return fmt.Errorf("rolling_update: %w", err)
		}
	}
	return nil
}

func (s *KubernetesDaemonSetUpdateStrategyInput) applyDefaults() {
	if s.RollingUpdate != nil {
		s.RollingUpdate.applyDefaults()
	}
}

func (s *KubernetesDaemonSetUpdateStrategyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.RollingUpdate != nil {
		m["rolling_update"] = s.RollingUpdate.toMap()
	}
	return m
}

// ParseKubernetesDaemonSet validates and normalizes a KubernetesDaemonSet cloud_object.
func ParseKubernetesDaemonSet(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesDaemonSet"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesDaemonSetSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
