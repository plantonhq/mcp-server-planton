// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// kubernetes-ingress-nginx
type KubernetesIngressNginxSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// Upstream Helm chart version tag (e.g. "4.11.1").
	ChartVersion string `json:"chart_version,omitempty" jsonschema:"Upstream Helm chart version tag (e.g. '4.11.1')."`
	// Deploy the controller with an **internal** load balancer.
	//  The default (false) produces an external LB where the provider supports it.
	Internal bool                                  `json:"internal,omitempty" jsonschema:"Deploy the controller with an **internal** load balancer. The default (false) produces an external LB where the provider supports it."`
	Gke      *KubernetesIngressNginxGkeConfigInput `json:"gke,omitempty" jsonschema:""`
	Eks      *KubernetesIngressNginxEksConfigInput `json:"eks,omitempty" jsonschema:""`
	Aks      *KubernetesIngressNginxAksConfigInput `json:"aks,omitempty" jsonschema:""`
}

func (s *KubernetesIngressNginxSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Gke != nil {
		if err := s.Gke.validate(); err != nil {
			return fmt.Errorf("gke: %w", err)
		}
	}
	if s.Eks != nil {
		if err := s.Eks.validate(); err != nil {
			return fmt.Errorf("eks: %w", err)
		}
	}
	if s.Aks != nil {
		if err := s.Aks.validate(); err != nil {
			return fmt.Errorf("aks: %w", err)
		}
	}
	return nil
}

func (s *KubernetesIngressNginxSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Gke != nil {
		s.Gke.applyDefaults()
	}
	if s.Eks != nil {
		s.Eks.applyDefaults()
	}
	if s.Aks != nil {
		s.Aks.applyDefaults()
	}
}

func (s *KubernetesIngressNginxSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.ChartVersion != "" {
		m["chart_version"] = s.ChartVersion
	}
	if s.Internal {
		m["internal"] = s.Internal
	}
	if s.Gke != nil {
		m["gke"] = s.Gke.toMap()
	}
	if s.Eks != nil {
		m["eks"] = s.Eks.toMap()
	}
	if s.Aks != nil {
		m["aks"] = s.Aks.toMap()
	}
	return m
}

// -----------------------------------------------------------------------------
//
//	Microsoft AKS – Azure Load Balancer options
//	-----------------------------------------------------------------------------
type KubernetesIngressNginxAksConfigInput struct {
	// Client ID of a user‑assigned managed identity that should be bound to the
	//  controller’s ServiceAccount (via Azure Workload Identity).
	ManagedIdentityClientId string `json:"managed_identity_client_id,omitempty" jsonschema:"Client ID of a user‑assigned managed identity that should be bound to the controller’s ServiceAccount (via Azure Workload Identity)."`
	// Name of a pre‑existing public IP resource to reuse for the load balancer.
	PublicIpName string `json:"public_ip_name,omitempty" jsonschema:"Name of a pre‑existing public IP resource to reuse for the load balancer."`
}

func (s *KubernetesIngressNginxAksConfigInput) validate() error {
	return nil
}

func (s *KubernetesIngressNginxAksConfigInput) applyDefaults() {
}

func (s *KubernetesIngressNginxAksConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ManagedIdentityClientId != "" {
		m["managed_identity_client_id"] = s.ManagedIdentityClientId
	}
	if s.PublicIpName != "" {
		m["public_ip_name"] = s.PublicIpName
	}
	return m
}

// -----------------------------------------------------------------------------
//
//	Amazon EKS – Classic ELB/NLB options
//	-----------------------------------------------------------------------------
type KubernetesIngressNginxEksConfigInput struct {
	// Security‑group IDs to attach to the load balancer (adds to the
	//  controller‑managed SG).
	AdditionalSecurityGroupIds []string `json:"additional_security_group_ids,omitempty" jsonschema:"Security‑group IDs to attach to the load balancer (adds to the controller‑managed SG)."`
	// Subnet IDs where the ELB/NLB should be placed.  Leave empty to let AWS
	//  pick all subnets of the selected scheme (public/private).
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs where the ELB/NLB should be placed. Leave empty to let AWS pick all subnets of the selected scheme (public/private)."`
	// Optional existing IAM role ARN for IRSA.  If empty the stack can
	//  auto‑create and wire up a role.
	IrsaRoleArnOverride string `json:"irsa_role_arn_override,omitempty" jsonschema:"Optional existing IAM role ARN for IRSA. If empty the stack can auto‑create and wire up a role."`
}

func (s *KubernetesIngressNginxEksConfigInput) validate() error {
	return nil
}

func (s *KubernetesIngressNginxEksConfigInput) applyDefaults() {
}

func (s *KubernetesIngressNginxEksConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AdditionalSecurityGroupIds) > 0 {
		m["additional_security_group_ids"] = s.AdditionalSecurityGroupIds
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if s.IrsaRoleArnOverride != "" {
		m["irsa_role_arn_override"] = s.IrsaRoleArnOverride
	}
	return m
}

// -----------------------------------------------------------------------------
//
//	Google Kubernetes Engine (GKE) – Cloud Load Balancer options
//	-----------------------------------------------------------------------------
type KubernetesIngressNginxGkeConfigInput struct {
	// Name of an existing reserved static IP address (global or regional)
	//  to be assigned to the load balancer.
	StaticIpName string `json:"static_ip_name,omitempty" jsonschema:"Name of an existing reserved static IP address (global or regional) to be assigned to the load balancer."`
	// Sub‑network self‑link to use when `internal = true`.
	SubnetworkSelfLink string `json:"subnetwork_self_link,omitempty" jsonschema:"Sub‑network self‑link to use when 'internal = true'."`
}

func (s *KubernetesIngressNginxGkeConfigInput) validate() error {
	return nil
}

func (s *KubernetesIngressNginxGkeConfigInput) applyDefaults() {
}

func (s *KubernetesIngressNginxGkeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.StaticIpName != "" {
		m["static_ip_name"] = s.StaticIpName
	}
	if s.SubnetworkSelfLink != "" {
		m["subnetwork_self_link"] = s.SubnetworkSelfLink
	}
	return m
}

// ParseKubernetesIngressNginx validates and normalizes a KubernetesIngressNginx cloud_object.
func ParseKubernetesIngressNginx(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesIngressNginx"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesIngressNginxSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
