// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// click-house-kubernetes
type KubernetesClickHouseSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// *
	//  The name of the ClickHouse cluster.
	//  This is used as the identifier for the ClickHouseInstallation custom resource.
	//  Must be a valid DNS subdomain name (lowercase alphanumeric with hyphens).
	//  Defaults to the resource metadata name if not specified.
	ClusterName string `json:"cluster_name,omitempty" jsonschema:"* The name of the ClickHouse cluster. This is used as the identifier for the ClickHouseInstallation custom resource. Must be a valid DNS subdomain name (lowercase alphanumeric with hyphens). Defaults ..."`
	// The container specifications for the ClickHouse deployment.
	Container *KubernetesClickHouseContainerInput `json:"container,omitempty" jsonschema:"The container specifications for the ClickHouse deployment."`
	// The ingress configuration for the ClickHouse deployment.
	Ingress *KubernetesClickHouseIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the ClickHouse deployment."`
	// The cluster configuration for ClickHouse sharding and replication.
	Cluster *KubernetesClickHouseClusterConfigInput `json:"cluster,omitempty" jsonschema:"The cluster configuration for ClickHouse sharding and replication."`
	// *
	//  The ClickHouse version to deploy (e.g., "24.3", "23.8").
	//  If not specified, the operator's default stable version will be used.
	//  It's recommended to specify a version for production deployments to ensure consistency.
	Version string `json:"version,omitempty" jsonschema:"* The ClickHouse version to deploy (e.g.; '24.3'; '23.8'). If not specified; the operator's default stable version will be used. It's recommended to specify a version for production deployments to ens..."`
	// *
	//  Coordination configuration for cluster operations.
	//  Required when cluster.is_enabled = true.
	//
	//  Recommended: Leave unspecified to use auto-managed ClickHouse Keeper (default).
	//  This is more efficient than ZooKeeper and easier to manage.
	//
	//  Advanced: Configure external Keeper or ZooKeeper for shared...
	Coordination *KubernetesClickHouseCoordinationConfigInput `json:"coordination,omitempty" jsonschema:"* Coordination configuration for cluster operations. Required when cluster.is_enabled = true. Recommended: Leave unspecified to use auto-managed ClickHouse Keeper (default). This is more efficient tha..."`
	// *
	//  ZooKeeper configuration for cluster coordination.
	//
	//  DEPRECATED: Use 'coordination' field instead.
	//  This field is kept for backward compatibility and will be removed in v2.
	//
	//  If both 'coordination' and 'zookeeper' are specified, 'coordination' takes precedence.
	Zookeeper *KubernetesClickHouseZookeeperConfigInput `json:"zookeeper,omitempty" jsonschema:"* ZooKeeper configuration for cluster coordination. DEPRECATED: Use 'coordination' field instead. This field is kept for backward compatibility and will be removed in v2. If both 'coordination' and 'z..."`
	// *
	//  Logging configuration for ClickHouse server.
	//  Controls the verbosity of ClickHouse server logs.
	//
	//  Required field. Defaults to 'information' level (recommended for production).
	//  Use 'debug' or 'trace' levels only for troubleshooting as they generate significant log volume.
	Logging *KubernetesClickHouseLoggingConfigInput `json:"logging" jsonschema:"required,* Logging configuration for ClickHouse server. Controls the verbosity of ClickHouse server logs. Required field. Defaults to 'information' level (recommended for production). Use 'debug' or 'trace' le..."`
}

func (s *KubernetesClickHouseSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.Cluster != nil {
		if err := s.Cluster.validate(); err != nil {
			return fmt.Errorf("cluster: %w", err)
		}
	}
	if s.Coordination != nil {
		if err := s.Coordination.validate(); err != nil {
			return fmt.Errorf("coordination: %w", err)
		}
	}
	if s.Zookeeper != nil {
		if err := s.Zookeeper.validate(); err != nil {
			return fmt.Errorf("zookeeper: %w", err)
		}
	}
	if s.Logging == nil {
		return fmt.Errorf("logging is required")
	}
	if s.Logging != nil {
		if err := s.Logging.validate(); err != nil {
			return fmt.Errorf("logging: %w", err)
		}
	}
	return nil
}

func (s *KubernetesClickHouseSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.Cluster != nil {
		s.Cluster.applyDefaults()
	}
	if s.Coordination != nil {
		s.Coordination.applyDefaults()
	}
	if s.Zookeeper != nil {
		s.Zookeeper.applyDefaults()
	}
	if s.Logging != nil {
		s.Logging.applyDefaults()
	}
}

func (s *KubernetesClickHouseSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.ClusterName != "" {
		m["cluster_name"] = s.ClusterName
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.Cluster != nil {
		m["cluster"] = s.Cluster.toMap()
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.Coordination != nil {
		m["coordination"] = s.Coordination.toMap()
	}
	if s.Zookeeper != nil {
		m["zookeeper"] = s.Zookeeper.toMap()
	}
	if s.Logging != nil {
		m["logging"] = s.Logging.toMap()
	}
	return m
}

// *
//
//	**KubernetesClickHouseClusterConfig** defines the clustering configuration for ClickHouse.
//	This includes settings for sharding and replication to enable distributed ClickHouse deployments.
//
//	Clustering provides horizontal scaling and high availability. When clustering is enabled:
//	- Data is distributed across shards for parallel processing
//	- Each shard can have multiple replicas for redundancy
//	- ZooKeeper is used for cluster coordination (automatically managed by the operator)
type KubernetesClickHouseClusterConfigInput struct {
	// *
	//  A flag to enable or disable clustering mode for ClickHouse.
	//  When enabled, ClickHouse will be deployed in a distributed cluster configuration with sharding and replication.
	//  When disabled, a single standalone ClickHouse instance is deployed.
	//  Defaults to `false` (standalone mode suitable for deve...
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"* A flag to enable or disable clustering mode for ClickHouse. When enabled; ClickHouse will be deployed in a distributed cluster configuration with sharding and replication. When disabled; a single st..."`
	// *
	//  The number of shards in the ClickHouse cluster.
	//  Sharding distributes data across multiple nodes for horizontal scaling and improved query performance.
	//  Each shard processes queries in parallel, allowing for massive throughput.
	//  This value is ignored if clustering is not enabled.
	//  Typical values:...
	ShardCount int32 `json:"shard_count,omitempty" jsonschema:"* The number of shards in the ClickHouse cluster. Sharding distributes data across multiple nodes for horizontal scaling and improved query performance. Each shard processes queries in parallel; allow..."`
	// *
	//  The number of replicas for each shard.
	//  Replication provides data redundancy and high availability.
	//  If one replica fails, queries can be served by other replicas in the same shard.
	//  This value is ignored if clustering is not enabled.
	//  Typical values: 2-3 (more than 3 replicas is rarely needed).
	ReplicaCount int32 `json:"replica_count,omitempty" jsonschema:"* The number of replicas for each shard. Replication provides data redundancy and high availability. If one replica fails; queries can be served by other replicas in the same shard. This value is igno..."`
}

func (s *KubernetesClickHouseClusterConfigInput) validate() error {
	return nil
}

func (s *KubernetesClickHouseClusterConfigInput) applyDefaults() {
}

func (s *KubernetesClickHouseClusterConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.ShardCount != 0 {
		m["shard_count"] = s.ShardCount
	}
	if s.ReplicaCount != 0 {
		m["replica_count"] = s.ReplicaCount
	}
	return m
}

// *
//
//	**KubernetesClickHouseContainer** specifies the container configuration for the ClickHouse application.
//	It includes resource allocations, data persistence options, and disk size.
//	Proper configuration ensures optimal performance and data reliability for your ClickHouse deployment.
type KubernetesClickHouseContainerInput struct {
	// *
	//  The number of ClickHouse replicas (pods) to deploy.
	//  For non-clustered deployments, this is the total number of ClickHouse pods.
	//  For clustered deployments, this value is ignored in favor of shard_count * replica_count.
	//  Must be at least 1.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"* The number of ClickHouse replicas (pods) to deploy. For non-clustered deployments; this is the total number of ClickHouse pods. For clustered deployments; this value is ignored in favor of shard_cou..."`
	// The CPU and memory resources allocated to each ClickHouse container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to each ClickHouse container."`
	// *
	//  A flag to enable or disable data persistence for ClickHouse.
	//  When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	//  Defaults to `true`. Strongly recommended for production use.
	PersistenceEnabled bool `json:"persistence_enabled,omitempty" jsonschema:"* A flag to enable or disable data persistence for ClickHouse. When enabled; data is persisted to a storage volume; allowing data to survive pod restarts. Defaults to 'true'. Strongly recommended for ..."`
	// *
	//  The size of the persistent volume attached to each ClickHouse pod (e.g., "50Gi", "100Gi").
	//  If the client does not provide a value, a default value is configured.
	//  This attribute is ignored when persistence is not enabled.
	//  **Note:** This value cannot be easily modified after creation due to Kube...
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The size of the persistent volume attached to each ClickHouse pod (e.g.; '50Gi'; '100Gi'). If the client does not provide a value; a default value is configured. This attribute is ignored when persi..."`
}

func (s *KubernetesClickHouseContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesClickHouseContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesClickHouseContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.PersistenceEnabled {
		m["persistence_enabled"] = s.PersistenceEnabled
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// *
//
//	**KubernetesClickHouseCoordinationConfig** defines coordination service configuration for ClickHouse cluster.
//	ClickHouse requires coordination for distributed operations (DDL execution, replication management).
//
//	For most use cases, auto-managed ClickHouse Keeper (default) is recommended.
//	It's more efficient than ZooKeeper (75% less resources) and managed by the same operator.
//
//	Use external coordination when:
//	- Sharing infrastructure across multiple ClickHouse clusters
//	- Using existing ZooKeeper for other services (Kafka, etc.)
//	- Migrating from ZooKeeper to ClickHouse Keeper
type KubernetesClickHouseCoordinationConfigInput struct {
	// *
	//  Type of coordination service to use.
	//  Defaults to 'keeper' (auto-managed ClickHouse Keeper).
	Type string `json:"type,omitempty" jsonschema:"enum=keeper|external_keeper|external_zookeeper,* Type of coordination service to use. Defaults to 'keeper' (auto-managed ClickHouse Keeper)."`
	// *
	//  Configuration for auto-managed ClickHouse Keeper.
	//  Only used when type = 'keeper'.
	//  If not specified, sensible defaults are used (1 replica for dev, 3 for prod).
	KeeperConfig *KubernetesClickHouseKeeperConfigInput `json:"keeper_config,omitempty" jsonschema:"* Configuration for auto-managed ClickHouse Keeper. Only used when type = 'keeper'. If not specified; sensible defaults are used (1 replica for dev; 3 for prod)."`
	// *
	//  Configuration for external coordination service.
	//  Only used when type = 'external_keeper' or 'external_zookeeper'.
	//  Must specify at least one node.
	ExternalConfig *KubernetesClickHouseExternalCoordinationConfigInput `json:"external_config,omitempty" jsonschema:"* Configuration for external coordination service. Only used when type = 'external_keeper' or 'external_zookeeper'. Must specify at least one node."`
}

func (s *KubernetesClickHouseCoordinationConfigInput) validate() error {
	switch s.Type {
	case "", "keeper", "external_keeper", "external_zookeeper":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.KeeperConfig != nil {
		if err := s.KeeperConfig.validate(); err != nil {
			return fmt.Errorf("keeper_config: %w", err)
		}
	}
	if s.ExternalConfig != nil {
		if err := s.ExternalConfig.validate(); err != nil {
			return fmt.Errorf("external_config: %w", err)
		}
	}
	return nil
}

func (s *KubernetesClickHouseCoordinationConfigInput) applyDefaults() {
	if s.KeeperConfig != nil {
		s.KeeperConfig.applyDefaults()
	}
	if s.ExternalConfig != nil {
		s.ExternalConfig.applyDefaults()
	}
}

func (s *KubernetesClickHouseCoordinationConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.KeeperConfig != nil {
		m["keeper_config"] = s.KeeperConfig.toMap()
	}
	if s.ExternalConfig != nil {
		m["external_config"] = s.ExternalConfig.toMap()
	}
	return m
}

// *
//
//	**KubernetesClickHouseExternalCoordinationConfig** defines external coordination service configuration.
//	Use when connecting to existing ClickHouse Keeper or ZooKeeper infrastructure.
//
//	Common scenarios:
//	- Shared ZooKeeper used by Kafka, Solr, and ClickHouse
//	- Centrally managed Keeper infrastructure
//	- Multi-cluster coordination through shared Keeper
type KubernetesClickHouseExternalCoordinationConfigInput struct {
	// *
	//  List of coordination service nodes in "host:port" format.
	//
	//  For production, specify all nodes in the ensemble for redundancy.
	//
	//  Examples:
	//  - ClickHouse Keeper: ["keeper-prod:2181"]
	//  - ClickHouse Keeper HA: ["keeper-0.keeper-svc:2181", "keeper-1.keeper-svc:2181", "keeper-2.keeper-svc:2181"]
	//  - Zoo...
	Nodes []string `json:"nodes,omitempty" jsonschema:"* List of coordination service nodes in 'host:port' format. For production; specify all nodes in the ensemble for redundancy. Examples: - ClickHouse Keeper: ['keeper-prod:2181'] - ClickHouse Keeper HA..."`
}

func (s *KubernetesClickHouseExternalCoordinationConfigInput) validate() error {
	if len(s.Nodes) < 1 {
		return fmt.Errorf("nodes requires at least 1 items, got %d", len(s.Nodes))
	}
	return nil
}

func (s *KubernetesClickHouseExternalCoordinationConfigInput) applyDefaults() {
}

func (s *KubernetesClickHouseExternalCoordinationConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Nodes) > 0 {
		m["nodes"] = s.Nodes
	}
	return m
}

// *
//
//	**KubernetesClickHouseIngress** defines the ingress configuration for ClickHouse deployment.
//	Controls external access to the ClickHouse cluster via LoadBalancer with automatic DNS configuration.
type KubernetesClickHouseIngressInput struct {
	// *
	//  Flag to enable or disable ingress.
	//  When enabled, creates a LoadBalancer service with external-dns annotations.
	Enabled bool `json:"enabled,omitempty" jsonschema:"* Flag to enable or disable ingress. When enabled; creates a LoadBalancer service with external-dns annotations."`
	// *
	//  The full hostname for external access (e.g., "clickhouse.example.com").
	//  This hostname will be configured automatically via external-dns.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"* The full hostname for external access (e.g.; 'clickhouse.example.com'). This hostname will be configured automatically via external-dns. Required when enabled is true."`
}

func (s *KubernetesClickHouseIngressInput) validate() error {
	return nil
}

func (s *KubernetesClickHouseIngressInput) applyDefaults() {
}

func (s *KubernetesClickHouseIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	**KubernetesClickHouseKeeperConfig** defines configuration for auto-managed ClickHouse Keeper.
//	The operator creates a ClickHouseKeeperInstallation resource with these settings.
//
//	ClickHouse Keeper is a ZooKeeper alternative written in C++ specifically for ClickHouse.
//	Benefits: 75% less CPU/memory usage, no JVM overhead, protocol-compatible with ZooKeeper.
type KubernetesClickHouseKeeperConfigInput struct {
	// *
	//  Number of ClickHouse Keeper replicas.
	//  Must be an odd number for quorum (1, 3, or 5).
	//
	//  Recommendations:
	//  - Development/Testing: 1 (no fault tolerance)
	//  - Production: 3 (survives 1 node failure)
	//  - Large Production: 5 (survives 2 node failures)
	//
	//  Defaults to 1 if not specified.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"* Number of ClickHouse Keeper replicas. Must be an odd number for quorum (1; 3; or 5). Recommendations: - Development/Testing: 1 (no fault tolerance) - Production: 3 (survives 1 node failure) - Large ..."`
	// *
	//  Resources for each Keeper pod.
	//
	//  Recommended defaults (applied if not specified):
	//  - Requests: 100m CPU, 256Mi memory
	//  - Limits: 500m CPU, 1Gi memory
	//
	//  ClickHouse Keeper is very efficient; these defaults work for most deployments.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"* Resources for each Keeper pod. Recommended defaults (applied if not specified): - Requests: 100m CPU; 256Mi memory - Limits: 500m CPU; 1Gi memory ClickHouse Keeper is very efficient; these defaults ..."`
	// *
	//  Persistent volume size for each Keeper pod.
	//  Defaults to "10Gi" if not specified.
	//
	//  Keeper stores coordination metadata (not data), so 10Gi is sufficient for most use cases.
	//  Consider larger sizes (20-50Gi) for very large clusters (100+ nodes).
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* Persistent volume size for each Keeper pod. Defaults to '10Gi' if not specified. Keeper stores coordination metadata (not data); so 10Gi is sufficient for most use cases. Consider larger sizes (20-5..."`
}

func (s *KubernetesClickHouseKeeperConfigInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesClickHouseKeeperConfigInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesClickHouseKeeperConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// *
//
//	**KubernetesClickHouseLoggingConfig** defines logging configuration for ClickHouse server.
//	Controls the verbosity and behavior of ClickHouse server logs.
//
//	ClickHouse logging can significantly impact I/O performance and disk usage.
//	Choose the appropriate level based on your operational needs.
type KubernetesClickHouseLoggingConfigInput struct {
	// *
	//  The log level for ClickHouse server logs.
	//  Defaults to 'information' if not specified.
	//
	//  Production recommendation: Use 'information' for normal operations.
	//  Temporarily switch to 'debug' or 'trace' when troubleshooting specific issues,
	//  then revert to 'information' to avoid excessive log volume.
	Level string `json:"level,omitempty" jsonschema:"enum=debug|trace,* The log level for ClickHouse server logs. Defaults to 'information' if not specified. Production recommendation: Use 'information' for normal operations. Temporarily switch to 'debug' or 'trace' whe..."`
}

func (s *KubernetesClickHouseLoggingConfigInput) validate() error {
	switch s.Level {
	case "", "debug", "trace":
	default:
		return fmt.Errorf("invalid level: %q", s.Level)
	}
	return nil
}

func (s *KubernetesClickHouseLoggingConfigInput) applyDefaults() {
}

func (s *KubernetesClickHouseLoggingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Level != "" {
		m["level"] = s.Level
	}
	return m
}

// *
//
//	**KubernetesClickHouseZookeeperConfig** defines the ZooKeeper configuration for ClickHouse cluster coordination.
//
//	DEPRECATED: This message is deprecated in favor of KubernetesClickHouseCoordinationConfig.
//	Use the 'coordination' field in KubernetesClickHouseSpec instead.
//
//	This is kept for backward compatibility and will be removed in v2.
type KubernetesClickHouseZookeeperConfigInput struct {
	// *
	//  A flag to use external ZooKeeper instead of operator-managed ZooKeeper.
	//  When false (default), the operator automatically provisions and manages ZooKeeper pods.
	//  When true, you must provide external ZooKeeper nodes.
	UseExternal bool `json:"use_external,omitempty" jsonschema:"* A flag to use external ZooKeeper instead of operator-managed ZooKeeper. When false (default); the operator automatically provisions and manages ZooKeeper pods. When true; you must provide external Z..."`
	// *
	//  List of external ZooKeeper nodes in the format "host:port".
	//  This is only used when use_external is true.
	//  Example: ["zk-0.zk-headless.default.svc.cluster.local:2181", "zk-1.zk-headless.default.svc.cluster.local:2181"]
	Nodes []string `json:"nodes,omitempty" jsonschema:"* List of external ZooKeeper nodes in the format 'host:port'. This is only used when use_external is true. Example: ['zk-0.zk-headless.default.svc.cluster.local:2181'; 'zk-1.zk-headless.default.svc.cl..."`
}

func (s *KubernetesClickHouseZookeeperConfigInput) validate() error {
	return nil
}

func (s *KubernetesClickHouseZookeeperConfigInput) applyDefaults() {
}

func (s *KubernetesClickHouseZookeeperConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.UseExternal {
		m["use_external"] = s.UseExternal
	}
	if len(s.Nodes) > 0 {
		m["nodes"] = s.Nodes
	}
	return m
}

// ParseKubernetesClickHouse validates and normalizes a KubernetesClickHouse cloud_object.
func ParseKubernetesClickHouse(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesClickHouse"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesClickHouseSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
