// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-fsx-openzfs-file-system
type AwsFsxOpenzfsFileSystemSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Deployment type controlling availability and performance characteristics.
	//  ForceNew — cannot be changed after creation.
	//
	//  - "SINGLE_AZ_1": first-generation single-AZ. Lower throughput ceiling.
	//    Supported throughput: 64, 128, 256, 512, 1024, 2048, 3072, 4096 MB/s.
	//  - "SINGLE_AZ_2": latest single-...
	DeploymentType string `json:"deployment_type,omitempty" jsonschema:"Deployment type controlling availability and performance characteristics. ForceNew — cannot be changed after creation. - 'SINGLE_AZ_1': first-generation single-AZ. Lower throughput ceiling. Supporte..."`
	// Storage capacity in GiB. Required.
	//
	//  Valid range: 64–524288 GiB. Choose based on data size and throughput needs.
	//  Storage can be increased after creation but never decreased.
	StorageCapacityGib int32 `json:"storage_capacity_gib,omitempty" jsonschema:"Storage capacity in GiB. Required. Valid range: 64–524288 GiB. Choose based on data size and throughput needs. Storage can be increased after creation but never decreased."`
	// Throughput capacity in MB/s. Required.
	//
	//  Valid values depend on deployment type:
	//  - SINGLE_AZ_1: 64, 128, 256, 512, 1024, 2048, 3072, 4096
	//  - SINGLE_AZ_2 / MULTI_AZ_1: 160, 320, 640, 1280, 2560, 3840, 5120, 7680, 10240
	//
	//  Can be changed after creation to scale performance up or down.
	ThroughputCapacity int32 `json:"throughput_capacity,omitempty" jsonschema:"Throughput capacity in MB/s. Required. Valid values depend on deployment type: - SINGLE_AZ_1: 64; 128; 256; 512; 1024; 2048; 3072; 4096 - SINGLE_AZ_2 / MULTI_AZ_1: 160; 320; 640; 1280; 2560; 3840; 512..."`
	// Subnet IDs for the file system's network interfaces. Required. ForceNew.
	//
	//  - SINGLE_AZ_1 / SINGLE_AZ_2: exactly one subnet.
	//  - MULTI_AZ_1: exactly two subnets in different availability zones.
	//
	//  All compute resources mounting this file system must have network
	//  connectivity to these subnets.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs for the file system's network interfaces. Required. ForceNew. - SINGLE_AZ_1 / SINGLE_AZ_2: exactly one subnet. - MULTI_AZ_1: exactly two subnets in different availability zones. All compute..."`
	// Security groups for the file system's network interfaces. ForceNew.
	//
	//  Must allow NFS traffic between the file system and its clients:
	//  - TCP port 111 (portmapper)
	//  - TCP port 2049 (NFS)
	//  - TCP ports 20001-20003 (NFS mount)
	//
	//  Up to 50 security groups.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security groups for the file system's network interfaces. ForceNew. Must allow NFS traffic between the file system and its clients: - TCP port 111 (portmapper) - TCP port 2049 (NFS) - TCP ports 20001-..."`
	// Preferred subnet for the active file server in a MULTI_AZ_1 deployment.
	//  ForceNew. Required when deployment_type is MULTI_AZ_1. Must be one of the
	//  subnets specified in subnet_ids.
	//
	//  In a failover event, the standby file server in the other subnet takes over.
	//  Ignored for SINGLE_AZ deployments.
	PreferredSubnetId string `json:"preferred_subnet_id,omitempty" jsonschema:"Preferred subnet for the active file server in a MULTI_AZ_1 deployment. ForceNew. Required when deployment_type is MULTI_AZ_1. Must be one of the subnets specified in subnet_ids. In a failover event; ..."`
	// IP address range for the file system endpoints in a MULTI_AZ_1 deployment.
	//  ForceNew. Must be a CIDR block within the VPC's CIDR range that does not
	//  overlap with any existing subnets. AWS assigns floating IPs from this range
	//  for seamless failover.
	//
	//  Ignored for SINGLE_AZ deployments.
	EndpointIpAddressRange string `json:"endpoint_ip_address_range,omitempty" jsonschema:"IP address range for the file system endpoints in a MULTI_AZ_1 deployment. ForceNew. Must be a CIDR block within the VPC's CIDR range that does not overlap with any existing subnets. AWS assigns float..."`
	// Route table IDs that need routes to the file system in a MULTI_AZ_1
	//  deployment. AWS automatically manages the routes. Up to 50 route tables.
	//
	//  Ignored for SINGLE_AZ deployments.
	RouteTableIds []string `json:"route_table_ids,omitempty" jsonschema:"Route table IDs that need routes to the file system in a MULTI_AZ_1 deployment. AWS automatically manages the routes. Up to 50 route tables. Ignored for SINGLE_AZ deployments."`
	// Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key
	//  cannot be changed after creation. When omitted, the file system uses the
	//  AWS-managed FSx key. All OpenZFS file systems are encrypted at rest by
	//  default; this field upgrades to a customer-managed key.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key cannot be changed after creation. When omitted; the file system uses the AWS-managed FSx key. All OpenZFS file systems are..."`
	// SSD IOPS configuration for the file system. Controls the total provisioned
	//  IOPS. When omitted, AWS uses AUTOMATIC mode which scales IOPS with storage.
	DiskIopsConfiguration *AwsFsxOpenzfsFileSystemDiskIopsConfigurationInput `json:"disk_iops_configuration,omitempty" jsonschema:"SSD IOPS configuration for the file system. Controls the total provisioned IOPS. When omitted; AWS uses AUTOMATIC mode which scales IOPS with storage."`
	// Configuration for the file system's root volume. The root volume is
	//  automatically created with the file system and serves as the default NFS
	//  mount target. Settings here control compression, NFS access, quotas, and
	//  record size for the root volume.
	//
	//  When omitted, the root volume uses defaults: no ...
	RootVolumeConfiguration *AwsFsxOpenzfsFileSystemRootVolumeConfigurationInput `json:"root_volume_configuration,omitempty" jsonschema:"Configuration for the file system's root volume. The root volume is automatically created with the file system and serves as the default NFS mount target. Settings here control compression; NFS access..."`
	// Number of days to retain automatic backups. Range: 0-90. Set to 0 to
	//  disable automatic backups.
	//
	//  Default: 0 (no automatic backups)
	AutomaticBackupRetentionDays int32 `json:"automatic_backup_retention_days,omitempty" jsonschema:"Number of days to retain automatic backups. Range: 0-90. Set to 0 to disable automatic backups. Default: 0 (no automatic backups)"`
	// Daily UTC time to start automatic backups, in HH:MM format (e.g., "05:00").
	//  If not specified and backups are enabled, AWS chooses a default window.
	DailyAutomaticBackupStartTime string `json:"daily_automatic_backup_start_time,omitempty" jsonschema:"Daily UTC time to start automatic backups; in HH:MM format (e.g.; '05:00'). If not specified and backups are enabled; AWS chooses a default window."`
	// Copy tags from the file system to backups.
	CopyTagsToBackups bool `json:"copy_tags_to_backups,omitempty" jsonschema:"Copy tags from the file system to backups."`
	// Copy tags from the file system to volumes. When true, tags are propagated
	//  to the root volume and any child volumes created on this file system.
	CopyTagsToVolumes bool `json:"copy_tags_to_volumes,omitempty" jsonschema:"Copy tags from the file system to volumes. When true; tags are propagated to the root volume and any child volumes created on this file system."`
	// Skip creating a final backup when the file system is deleted.
	//
	//  Default: true
	SkipFinalBackup bool `json:"skip_final_backup,omitempty" jsonschema:"Skip creating a final backup when the file system is deleted. Default: true"`
	// Weekly UTC maintenance window in the format "d:HH:MM" where d is the day of
	//  the week (1=Monday, 7=Sunday). Example: "1:05:00" for Monday at 05:00 UTC.
	//  If not specified, AWS chooses a default window.
	WeeklyMaintenanceStartTime string `json:"weekly_maintenance_start_time,omitempty" jsonschema:"Weekly UTC maintenance window in the format 'd:HH:MM' where d is the day of the week (1=Monday; 7=Sunday). Example: '1:05:00' for Monday at 05:00 UTC. If not specified; AWS chooses a default window."`
}

func (s *AwsFsxOpenzfsFileSystemSpecInput) validate() error {
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	if s.DiskIopsConfiguration != nil {
		if err := s.DiskIopsConfiguration.validate(); err != nil {
			return fmt.Errorf("disk_iops_configuration: %w", err)
		}
	}
	if s.RootVolumeConfiguration != nil {
		if err := s.RootVolumeConfiguration.validate(); err != nil {
			return fmt.Errorf("root_volume_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxOpenzfsFileSystemSpecInput) applyDefaults() {
	if s.DeploymentType == "" {
		s.DeploymentType = "SINGLE_AZ_2"
	}
	if s.DiskIopsConfiguration != nil {
		s.DiskIopsConfiguration.applyDefaults()
	}
	if s.RootVolumeConfiguration != nil {
		s.RootVolumeConfiguration.applyDefaults()
	}
	if s.AutomaticBackupRetentionDays == 0 {
		s.AutomaticBackupRetentionDays = 0
	}
	// default: SkipFinalBackup = true (applied at zero-value)
}

func (s *AwsFsxOpenzfsFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.DeploymentType != "" {
		m["deployment_type"] = s.DeploymentType
	}
	if s.StorageCapacityGib != 0 {
		m["storage_capacity_gib"] = s.StorageCapacityGib
	}
	if s.ThroughputCapacity != 0 {
		m["throughput_capacity"] = s.ThroughputCapacity
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.PreferredSubnetId != "" {
		m["preferred_subnet_id"] = s.PreferredSubnetId
	}
	if s.EndpointIpAddressRange != "" {
		m["endpoint_ip_address_range"] = s.EndpointIpAddressRange
	}
	if len(s.RouteTableIds) > 0 {
		m["route_table_ids"] = s.RouteTableIds
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.DiskIopsConfiguration != nil {
		m["disk_iops_configuration"] = s.DiskIopsConfiguration.toMap()
	}
	if s.RootVolumeConfiguration != nil {
		m["root_volume_configuration"] = s.RootVolumeConfiguration.toMap()
	}
	if s.AutomaticBackupRetentionDays != 0 {
		m["automatic_backup_retention_days"] = s.AutomaticBackupRetentionDays
	}
	if s.DailyAutomaticBackupStartTime != "" {
		m["daily_automatic_backup_start_time"] = s.DailyAutomaticBackupStartTime
	}
	if s.CopyTagsToBackups {
		m["copy_tags_to_backups"] = s.CopyTagsToBackups
	}
	if s.CopyTagsToVolumes {
		m["copy_tags_to_volumes"] = s.CopyTagsToVolumes
	}
	if s.SkipFinalBackup {
		m["skip_final_backup"] = s.SkipFinalBackup
	}
	if s.WeeklyMaintenanceStartTime != "" {
		m["weekly_maintenance_start_time"] = s.WeeklyMaintenanceStartTime
	}
	return m
}

// AwsFsxOpenzfsFileSystemDiskIopsConfiguration controls the SSD IOPS provisioned
//
//	for the file system. In AUTOMATIC mode, IOPS scale with storage capacity. In
//	USER_PROVISIONED mode, you specify the exact IOPS independently of storage.
type AwsFsxOpenzfsFileSystemDiskIopsConfigurationInput struct {
	// IOPS provisioning mode.
	//
	//  - "AUTOMATIC": IOPS scale automatically based on storage capacity.
	//    Provides 3 IOPS per GiB of storage, up to the deployment type limit.
	//  - "USER_PROVISIONED": you specify the exact IOPS via the `iops` field.
	//    Allows higher performance independent of storage size but at...
	Mode string `json:"mode,omitempty" jsonschema:"IOPS provisioning mode. - 'AUTOMATIC': IOPS scale automatically based on storage capacity. Provides 3 IOPS per GiB of storage; up to the deployment type limit. - 'USER_PROVISIONED': you specify the ex..."`
	// Total SSD IOPS provisioned. Only valid when mode is "USER_PROVISIONED".
	//
	//  Valid ranges depend on deployment type:
	//  - SINGLE_AZ_1: up to 160,000
	//  - SINGLE_AZ_2 / MULTI_AZ_1: up to 400,000
	Iops int32 `json:"iops,omitempty" jsonschema:"Total SSD IOPS provisioned. Only valid when mode is 'USER_PROVISIONED'. Valid ranges depend on deployment type: - SINGLE_AZ_1: up to 160;000 - SINGLE_AZ_2 / MULTI_AZ_1: up to 400;000"`
}

func (s *AwsFsxOpenzfsFileSystemDiskIopsConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxOpenzfsFileSystemDiskIopsConfigurationInput) applyDefaults() {
	if s.Mode == "" {
		s.Mode = "AUTOMATIC"
	}
}

func (s *AwsFsxOpenzfsFileSystemDiskIopsConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Mode != "" {
		m["mode"] = s.Mode
	}
	if s.Iops != 0 {
		m["iops"] = s.Iops
	}
	return m
}

// AwsFsxOpenzfsFileSystemNfsClientConfiguration defines NFS access control for
//
//	a specific set of clients identified by IP address, CIDR range, or wildcard.
type AwsFsxOpenzfsFileSystemNfsClientConfigurationInput struct {
	// Client specification: an IP address, CIDR block, or wildcard (*).
	//
	//  Examples: "*" (all clients), "10.0.0.0/16", "192.168.1.100"
	Clients string `json:"clients,omitempty" jsonschema:"Client specification: an IP address; CIDR block; or wildcard (*). Examples: '*' (all clients); '10.0.0.0/16'; '192.168.1.100'"`
	// NFS mount options for the specified clients. At least one option is required.
	//
	//  Common options:
	//  - "rw" (read-write) or "ro" (read-only)
	//  - "crossmnt" (allow traversal into child volumes)
	//  - "root_squash" (map root to anonymous) or "no_root_squash"
	//  - "sync" or "async"
	//
	//  Up to 20 options.
	Options []string `json:"options,omitempty" jsonschema:"NFS mount options for the specified clients. At least one option is required. Common options: - 'rw' (read-write) or 'ro' (read-only) - 'crossmnt' (allow traversal into child volumes) - 'root_squash' ..."`
}

func (s *AwsFsxOpenzfsFileSystemNfsClientConfigurationInput) validate() error {
	if len(s.Options) < 1 {
		return fmt.Errorf("options requires at least 1 items, got %d", len(s.Options))
	}
	return nil
}

func (s *AwsFsxOpenzfsFileSystemNfsClientConfigurationInput) applyDefaults() {
}

func (s *AwsFsxOpenzfsFileSystemNfsClientConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Clients != "" {
		m["clients"] = s.Clients
	}
	if len(s.Options) > 0 {
		m["options"] = s.Options
	}
	return m
}

// AwsFsxOpenzfsFileSystemNfsExports defines the NFS export configuration for a
//
//	volume. Each client configuration specifies an IP range and the NFS mount
//	options for that range.
type AwsFsxOpenzfsFileSystemNfsExportsInput struct {
	// NFS client configurations. Each entry defines which clients can access the
	//  volume and with what mount options. Up to 25 client configurations.
	ClientConfigurations []*AwsFsxOpenzfsFileSystemNfsClientConfigurationInput `json:"client_configurations,omitempty" jsonschema:"NFS client configurations. Each entry defines which clients can access the volume and with what mount options. Up to 25 client configurations."`
}

func (s *AwsFsxOpenzfsFileSystemNfsExportsInput) validate() error {
	for i, v := range s.ClientConfigurations {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("client_configurations[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsFsxOpenzfsFileSystemNfsExportsInput) applyDefaults() {
}

func (s *AwsFsxOpenzfsFileSystemNfsExportsInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.ClientConfigurations) > 0 {
		items := make([]any, len(s.ClientConfigurations))
		for i, v := range s.ClientConfigurations {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["client_configurations"] = items
	}
	return m
}

// AwsFsxOpenzfsFileSystemRootVolumeConfiguration defines the configuration for
//
//	the file system's root volume. The root volume is the default NFS mount target
//	and is always created with the file system. These settings control data
//	compression, NFS exports, access control, and storage quotas.
type AwsFsxOpenzfsFileSystemRootVolumeConfigurationInput struct {
	// Data compression type applied to all data on the root volume. Reduces
	//  storage consumption and can improve throughput for compressible data.
	//
	//  - "NONE": no compression (default).
	//  - "ZSTD": Zstandard compression. Best compression ratio.
	//  - "LZ4": LZ4 compression. Faster with lower CPU overhead.
	//
	//  De...
	DataCompressionType string `json:"data_compression_type,omitempty" jsonschema:"Data compression type applied to all data on the root volume. Reduces storage consumption and can improve throughput for compressible data. - 'NONE': no compression (default). - 'ZSTD': Zstandard comp..."`
	// NFS export configuration for the root volume. Controls which clients can
	//  mount the volume and with what permissions. When omitted, the volume uses
	//  default NFS settings (accessible from within the VPC).
	NfsExports *AwsFsxOpenzfsFileSystemNfsExportsInput `json:"nfs_exports,omitempty" jsonschema:"NFS export configuration for the root volume. Controls which clients can mount the volume and with what permissions. When omitted; the volume uses default NFS settings (accessible from within the VPC)..."`
	// Whether the root volume is read-only. When true, clients can mount the
	//  volume but cannot write to it. Useful for shared reference data.
	ReadOnly bool `json:"read_only,omitempty" jsonschema:"Whether the root volume is read-only. When true; clients can mount the volume but cannot write to it. Useful for shared reference data."`
	// ZFS record size in KiB. Affects read/write performance characteristics.
	//  Larger record sizes are better for sequential I/O (analytics, streaming).
	//  Smaller record sizes are better for random I/O (databases, OLTP).
	//
	//  Valid values: 4, 8, 16, 32, 64, 128, 256, 512, 1024.
	//
	//  Default: 128
	RecordSizeKib int32 `json:"record_size_kib,omitempty" jsonschema:"ZFS record size in KiB. Affects read/write performance characteristics. Larger record sizes are better for sequential I/O (analytics; streaming). Smaller record sizes are better for random I/O (databa..."`
	// Per-user and per-group storage quotas for the root volume. Limits how much
	//  storage individual users or groups can consume. Up to 100 quota entries.
	UserAndGroupQuotas []*AwsFsxOpenzfsFileSystemUserAndGroupQuotaInput `json:"user_and_group_quotas,omitempty" jsonschema:"Per-user and per-group storage quotas for the root volume. Limits how much storage individual users or groups can consume. Up to 100 quota entries."`
	// Copy tags from the root volume to snapshots created from it.
	CopyTagsToSnapshots bool `json:"copy_tags_to_snapshots,omitempty" jsonschema:"Copy tags from the root volume to snapshots created from it."`
}

func (s *AwsFsxOpenzfsFileSystemRootVolumeConfigurationInput) validate() error {
	if s.NfsExports != nil {
		if err := s.NfsExports.validate(); err != nil {
			return fmt.Errorf("nfs_exports: %w", err)
		}
	}
	for i, v := range s.UserAndGroupQuotas {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("user_and_group_quotas[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsFsxOpenzfsFileSystemRootVolumeConfigurationInput) applyDefaults() {
	if s.DataCompressionType == "" {
		s.DataCompressionType = "NONE"
	}
	if s.NfsExports != nil {
		s.NfsExports.applyDefaults()
	}
	if s.RecordSizeKib == 0 {
		s.RecordSizeKib = 128
	}
}

func (s *AwsFsxOpenzfsFileSystemRootVolumeConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DataCompressionType != "" {
		m["data_compression_type"] = s.DataCompressionType
	}
	if s.NfsExports != nil {
		m["nfs_exports"] = s.NfsExports.toMap()
	}
	if s.ReadOnly {
		m["read_only"] = s.ReadOnly
	}
	if s.RecordSizeKib != 0 {
		m["record_size_kib"] = s.RecordSizeKib
	}
	if len(s.UserAndGroupQuotas) > 0 {
		items := make([]any, len(s.UserAndGroupQuotas))
		for i, v := range s.UserAndGroupQuotas {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["user_and_group_quotas"] = items
	}
	if s.CopyTagsToSnapshots {
		m["copy_tags_to_snapshots"] = s.CopyTagsToSnapshots
	}
	return m
}

// AwsFsxOpenzfsFileSystemUserAndGroupQuota defines a storage quota for a
//
//	specific user or group on the volume. Quotas limit how much storage
//	individual users or groups can consume.
type AwsFsxOpenzfsFileSystemUserAndGroupQuotaInput struct {
	// The numeric user ID (UID) or group ID (GID). Range: 0-2147483647.
	//
	//  Common values: 0 (root), 1000+ (regular users/groups).
	Id int32 `json:"id,omitempty" jsonschema:"The numeric user ID (UID) or group ID (GID). Range: 0-2147483647. Common values: 0 (root); 1000+ (regular users/groups)."`
	// Storage capacity quota in GiB. The maximum amount of storage this user or
	//  group can consume on the volume. Range: 0-2147483647.
	//
	//  Set to 0 to remove quota restrictions for this user/group.
	StorageCapacityQuotaGib int32 `json:"storage_capacity_quota_gib,omitempty" jsonschema:"Storage capacity quota in GiB. The maximum amount of storage this user or group can consume on the volume. Range: 0-2147483647. Set to 0 to remove quota restrictions for this user/group."`
	// Quota type: "USER" for per-user quota, "GROUP" for per-group quota.
	Type string `json:"type,omitempty" jsonschema:"Quota type: 'USER' for per-user quota; 'GROUP' for per-group quota."`
}

func (s *AwsFsxOpenzfsFileSystemUserAndGroupQuotaInput) validate() error {
	return nil
}

func (s *AwsFsxOpenzfsFileSystemUserAndGroupQuotaInput) applyDefaults() {
}

func (s *AwsFsxOpenzfsFileSystemUserAndGroupQuotaInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Id != 0 {
		m["id"] = s.Id
	}
	if s.StorageCapacityQuotaGib != 0 {
		m["storage_capacity_quota_gib"] = s.StorageCapacityQuotaGib
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	return m
}

// ParseAwsFsxOpenzfsFileSystem validates and normalizes a AwsFsxOpenzfsFileSystem cloud_object.
func ParseAwsFsxOpenzfsFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsFsxOpenzfsFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsFsxOpenzfsFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
