// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-route53-zone
type AwsRoute53ZoneSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Flag to indicate if this is a private hosted zone.
	//  Private zones are used for split-horizon DNS and only resolve within associated VPCs.
	//  Public zones (is_private=false) resolve globally on the internet.
	//  Default: false (public zone)
	IsPrivate bool `json:"is_private,omitempty" jsonschema:"Flag to indicate if this is a private hosted zone. Private zones are used for split-horizon DNS and only resolve within associated VPCs. Public zones (is_private=false) resolve globally on the interne..."`
	// VPC associations for private hosted zones.
	//  Only applicable when is_private is true.
	//  Each association allows the private zone to resolve DNS queries from the specified VPC.
	//  You must enable enableDnsHostnames and enableDnsSupport in your VPC settings.
	VpcAssociations []*Route53VpcAssociationInput `json:"vpc_associations,omitempty" jsonschema:"VPC associations for private hosted zones. Only applicable when is_private is true. Each association allows the private zone to resolve DNS queries from the specified VPC. You must enable enableDnsHos..."`
	// Enable query logging for this hosted zone.
	//  Query logs are sent to CloudWatch Logs and can be used for debugging,
	//  security monitoring, and understanding query patterns.
	//  Warning: High-traffic domains generate large log volumes.
	EnableQueryLogging bool `json:"enable_query_logging,omitempty" jsonschema:"Enable query logging for this hosted zone. Query logs are sent to CloudWatch Logs and can be used for debugging; security monitoring; and understanding query patterns. Warning: High-traffic domains ge..."`
	// CloudWatch Log Group name for query logs (required if enable_query_logging is true).
	//  The log group must exist before enabling query logging.
	QueryLogGroupName string `json:"query_log_group_name,omitempty" jsonschema:"CloudWatch Log Group name for query logs (required if enable_query_logging is true). The log group must exist before enabling query logging."`
	// Enable DNSSEC for the hosted zone.
	//  DNSSEC adds cryptographic signatures to DNS records to prevent spoofing attacks.
	//  Note: Requires additional configuration at domain registrar level.
	EnableDnssec bool `json:"enable_dnssec,omitempty" jsonschema:"Enable DNSSEC for the hosted zone. DNSSEC adds cryptographic signatures to DNS records to prevent spoofing attacks. Note: Requires additional configuration at domain registrar level."`
	// The DNS records that are added to the zone.
	//  Each record represents a DNS resource record with support for basic records (A, AAAA, CNAME, MX, TXT),
	//  alias records (pointing to AWS resources), and advanced routing policies.
	//  These records define how your domain or subdomains are routed to your resour...
	Records []*Route53DnsRecordInput `json:"records,omitempty" jsonschema:"The DNS records that are added to the zone. Each record represents a DNS resource record with support for basic records (A; AAAA; CNAME; MX; TXT); alias records (pointing to AWS resources); and advanc..."`
}

func (s *AwsRoute53ZoneSpecInput) validate() error {
	for i, v := range s.VpcAssociations {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("vpc_associations[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsRoute53ZoneSpecInput) applyDefaults() {
}

func (s *AwsRoute53ZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.IsPrivate {
		m["is_private"] = s.IsPrivate
	}
	if len(s.VpcAssociations) > 0 {
		items := make([]any, len(s.VpcAssociations))
		for i, v := range s.VpcAssociations {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["vpc_associations"] = items
	}
	if s.EnableQueryLogging {
		m["enable_query_logging"] = s.EnableQueryLogging
	}
	if s.QueryLogGroupName != "" {
		m["query_log_group_name"] = s.QueryLogGroupName
	}
	if s.EnableDnssec {
		m["enable_dnssec"] = s.EnableDnssec
	}
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// Route53AliasTarget defines an alias record target.
//
//	Alias records are a Route53-specific extension to DNS that allows you to route traffic
//	to AWS resources without the limitations of CNAME records.
//
//	Key benefits:
//	  - Works at zone apex (example.com) where CNAME is not allowed
//	  - No query charges for alias queries to AWS resources
//	  - Automatic updates when target resource's IP changes
//
//	Common use cases:
//	  - Point apex domain to CloudFront distribution
//	  - Point domain to Application/Network Load Balancer
//	  - Point domain to S3 website endpoint
//	  - Point domain to API Gateway
//	  - Point domain to another Route53 record in same zone
type Route53AliasTargetInput struct {
	// The DNS name of the target resource.
	//  Examples:
	//    - CloudFront: "d1234abcd.cloudfront.net"
	//    - ALB: "my-alb-1234567890.us-east-1.elb.amazonaws.com"
	//    - S3 website: "my-bucket.s3-website-us-east-1.amazonaws.com"
	//    - API Gateway: "abc123.execute-api.us-east-1.amazonaws.com"
	DnsName string `json:"dns_name" jsonschema:"required,The DNS name of the target resource. Examples: - CloudFront: 'd1234abcd.cloudfront.net' - ALB: 'my-alb-1234567890.us-east-1.elb.amazonaws.com' - S3 website: 'my-bucket.s3-website-us-east-1.amazonaws.c..."`
	// The hosted zone ID of the target resource.
	//  Each AWS service has a specific hosted zone ID per region.
	//  Common hosted zone IDs:
	//    - CloudFront: "Z2FDTNDATAQYW2" (global)
	//    - ALB (us-east-1): "Z35SXDOTRQ7X7K"
	//    - S3 website (us-east-1): "Z3AQBSTGFYJSTF"
	//
	//  Note: This is NOT your Route53 zone ID - i...
	HostedZoneId string `json:"hosted_zone_id" jsonschema:"required,The hosted zone ID of the target resource. Each AWS service has a specific hosted zone ID per region. Common hosted zone IDs: - CloudFront: 'Z2FDTNDATAQYW2' (global) - ALB (us-east-1): 'Z35SXDOTRQ7X7K..."`
	// Evaluate target health.
	//  If true, Route53 checks the health of the target resource before responding to queries.
	//  Useful for automatic failover when combined with health checks.
	//  Default: false
	EvaluateTargetHealth bool `json:"evaluate_target_health,omitempty" jsonschema:"Evaluate target health. If true; Route53 checks the health of the target resource before responding to queries. Useful for automatic failover when combined with health checks. Default: false"`
}

func (s *Route53AliasTargetInput) validate() error {
	if s.DnsName == "" {
		return fmt.Errorf("dns_name is required")
	}
	if s.HostedZoneId == "" {
		return fmt.Errorf("hosted_zone_id is required")
	}
	return nil
}

func (s *Route53AliasTargetInput) applyDefaults() {
}

func (s *Route53AliasTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["dns_name"] = s.DnsName
	m["hosted_zone_id"] = s.HostedZoneId
	if s.EvaluateTargetHealth {
		m["evaluate_target_health"] = s.EvaluateTargetHealth
	}
	return m
}

// Route53DnsRecord represents a DNS resource record in the Route53 zone.
//
//	It supports basic DNS records, alias records (Route53's killer feature), and advanced routing policies
//	for traffic management (weighted, latency-based, failover, geolocation).
//
//	This message allows you to specify detailed DNS configurations for your domain,
//	enabling fine-grained control over how your domain name resolves and how traffic is routed.
type Route53DnsRecordInput struct {
	// The DNS record type.
	//  This specifies the type of DNS record, such as A, AAAA, CNAME, MX, TXT, etc.
	//  The record type determines how the DNS query is processed and what kind of data is returned.
	RecordType string `json:"record_type" jsonschema:"required,enum=A|AAAA|ALIAS|CNAME|MX|NS|PTR|SOA|SRV|TXT|CAA,The DNS record type. This specifies the type of DNS record; such as A; AAAA; CNAME; MX; TXT; etc. The record type determines how the DNS query is processed and what kind of data is returned."`
	// The name of the DNS record, e.g., "example.com" or "dev.example.com".
	//  This is the domain name or subdomain for which the DNS record applies.
	//  Route53 will automatically append a trailing dot if not provided.
	//  Supports wildcard records: "*.example.com" for catch-all subdomains.
	Name string `json:"name" jsonschema:"required,The name of the DNS record; e.g.; 'example.com' or 'dev.example.com'. This is the domain name or subdomain for which the DNS record applies. Route53 will automatically append a trailing dot if not pro..."`
	// The Time To Live (TTL) for the DNS record, in seconds.
	//  TTL specifies how long DNS resolvers should cache the DNS record before querying again.
	//  Default: 300 seconds (5 minutes) - balances caching efficiency with change propagation speed.
	//  Common values:
	//    - 60 seconds: For records you might change...
	TtlSeconds int32 `json:"ttl_seconds,omitempty" jsonschema:"The Time To Live (TTL) for the DNS record; in seconds. TTL specifies how long DNS resolvers should cache the DNS record before querying again. Default: 300 seconds (5 minutes) - balances caching effic..."`
	// The values for the DNS record.
	//  This field contains the data associated with the DNS record type.
	//  Examples:
	//    - A record: ["192.0.2.1", "192.0.2.2"]
	//    - AAAA record: ["2001:0db8::1"]
	//    - CNAME record: ["target.example.com."]
	//    - MX record: ["10 mail1.example.com.", "20 mail2.example.com."]
	//    -...
	Values []string `json:"values,omitempty" jsonschema:"The values for the DNS record. This field contains the data associated with the DNS record type. Examples: - A record: ['192.0.2.1'; '192.0.2.2'] - AAAA record: ['2001:0db8::1'] - CNAME record: ['targ..."`
	// Alias target configuration for Route53 alias records.
	//  Alias records are Route53's killer feature - they allow you to:
	//    1. Point your zone apex (example.com) to AWS resources without CNAME restrictions
	//    2. Route traffic to CloudFront, ALB/NLB, S3 website, API Gateway, etc.
	//    3. Get free queries...
	AliasTarget *Route53AliasTargetInput `json:"alias_target,omitempty" jsonschema:"Alias target configuration for Route53 alias records. Alias records are Route53's killer feature - they allow you to: 1. Point your zone apex (example.com) to AWS resources without CNAME restrictions ..."`
	// Routing policy configuration.
	//  Route53 supports multiple routing policies for advanced traffic management:
	//    - Simple: Default single-value response
	//    - Weighted: Split traffic across multiple resources (blue/green, canary deployments)
	//    - Latency: Route users to the lowest-latency endpoint (glob...
	RoutingPolicy *Route53RoutingPolicyInput `json:"routing_policy,omitempty" jsonschema:"Routing policy configuration. Route53 supports multiple routing policies for advanced traffic management: - Simple: Default single-value response - Weighted: Split traffic across multiple resources (b..."`
	// Health check ID for failover routing.
	//  Attach a Route53 health check to monitor endpoint availability.
	//  When the primary resource fails the health check, Route53 automatically returns the failover record.
	//
	//  Health checks monitor:
	//    - HTTP/HTTPS endpoints (status code, response body)
	//    - TCP connec...
	HealthCheckId string `json:"health_check_id,omitempty" jsonschema:"Health check ID for failover routing. Attach a Route53 health check to monitor endpoint availability. When the primary resource fails the health check; Route53 automatically returns the failover recor..."`
	// Set identifier for routing policies.
	//  Required for weighted, latency, failover, and geolocation routing.
	//  Must be unique among records with the same name and type.
	//  Example: "primary", "secondary", "us-east-1", "weight-70"
	SetIdentifier string `json:"set_identifier,omitempty" jsonschema:"Set identifier for routing policies. Required for weighted; latency; failover; and geolocation routing. Must be unique among records with the same name and type. Example: 'primary'; 'secondary'; 'us-e..."`
}

func (s *Route53DnsRecordInput) validate() error {
	if s.RecordType == "" {
		return fmt.Errorf("record_type is required")
	}
	switch s.RecordType {
	case "A", "AAAA", "ALIAS", "CNAME", "MX", "NS", "PTR", "SOA", "SRV", "TXT", "CAA":
	default:
		return fmt.Errorf("invalid record_type: %q", s.RecordType)
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.AliasTarget != nil {
		if err := s.AliasTarget.validate(); err != nil {
			return fmt.Errorf("alias_target: %w", err)
		}
	}
	if s.RoutingPolicy != nil {
		if err := s.RoutingPolicy.validate(); err != nil {
			return fmt.Errorf("routing_policy: %w", err)
		}
	}
	return nil
}

func (s *Route53DnsRecordInput) applyDefaults() {
	if s.AliasTarget != nil {
		s.AliasTarget.applyDefaults()
	}
	if s.RoutingPolicy != nil {
		s.RoutingPolicy.applyDefaults()
	}
}

func (s *Route53DnsRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["record_type"] = s.RecordType
	m["name"] = s.Name
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.AliasTarget != nil {
		m["alias_target"] = s.AliasTarget.toMap()
	}
	if s.RoutingPolicy != nil {
		m["routing_policy"] = s.RoutingPolicy.toMap()
	}
	if s.HealthCheckId != "" {
		m["health_check_id"] = s.HealthCheckId
	}
	if s.SetIdentifier != "" {
		m["set_identifier"] = s.SetIdentifier
	}
	return m
}

// Route53FailoverRoutingPolicy enables active-passive failover.
//
//	Primary resource serves traffic when healthy. If health check fails,
//	Route53 automatically routes traffic to the secondary resource.
type Route53FailoverRoutingPolicyInput struct {
	// Failover record type.
	//  Must have exactly one PRIMARY and one SECONDARY record with the same name and type.
	Type string `json:"type" jsonschema:"required,enum=PRIMARY|SECONDARY,Failover record type. Must have exactly one PRIMARY and one SECONDARY record with the same name and type."`
}

func (s *Route53FailoverRoutingPolicyInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "PRIMARY", "SECONDARY":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *Route53FailoverRoutingPolicyInput) applyDefaults() {
}

func (s *Route53FailoverRoutingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	return m
}

// Route53GeolocationRoutingPolicy routes traffic based on user's geographic location.
//
//	You can specify routing at the continent, country, or state level (US states only).
//	Route53 selects the most specific match.
type Route53GeolocationRoutingPolicyInput struct {
	// Continent code (two-letter).
	//  Examples: "NA" (North America), "EU" (Europe), "AS" (Asia)
	//  Note: Use continent OR country, not both. Country is more specific.
	Continent string `json:"continent,omitempty" jsonschema:"Continent code (two-letter). Examples: 'NA' (North America); 'EU' (Europe); 'AS' (Asia) Note: Use continent OR country; not both. Country is more specific."`
	// Country code (two-letter ISO 3166-1 alpha-2).
	//  Examples: "US" (United States), "GB" (United Kingdom), "DE" (Germany)
	//  More specific than continent.
	Country string `json:"country,omitempty" jsonschema:"Country code (two-letter ISO 3166-1 alpha-2). Examples: 'US' (United States); 'GB' (United Kingdom); 'DE' (Germany) More specific than continent."`
	// Subdivision code (US state).
	//  Only valid when country is "US".
	//  Examples: "CA" (California), "NY" (New York), "TX" (Texas)
	//  Most specific geolocation routing option.
	Subdivision string `json:"subdivision,omitempty" jsonschema:"Subdivision code (US state). Only valid when country is 'US'. Examples: 'CA' (California); 'NY' (New York); 'TX' (Texas) Most specific geolocation routing option."`
}

func (s *Route53GeolocationRoutingPolicyInput) validate() error {
	return nil
}

func (s *Route53GeolocationRoutingPolicyInput) applyDefaults() {
}

func (s *Route53GeolocationRoutingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Continent != "" {
		m["continent"] = s.Continent
	}
	if s.Country != "" {
		m["country"] = s.Country
	}
	if s.Subdivision != "" {
		m["subdivision"] = s.Subdivision
	}
	return m
}

// Route53LatencyRoutingPolicy routes users to the resource with the lowest latency.
//
//	Route53 measures latency from different AWS regions and automatically routes users
//	to the endpoint that provides the best performance.
type Route53LatencyRoutingPolicyInput struct {
	// The AWS region where this resource is located.
	//  Route53 uses this to measure latency from user locations.
	//  Example: "us-east-1", "eu-west-1", "ap-southeast-1"
	Region string `json:"region" jsonschema:"required,The AWS region where this resource is located. Route53 uses this to measure latency from user locations. Example: 'us-east-1'; 'eu-west-1'; 'ap-southeast-1'"`
}

func (s *Route53LatencyRoutingPolicyInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	return nil
}

func (s *Route53LatencyRoutingPolicyInput) applyDefaults() {
}

func (s *Route53LatencyRoutingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	return m
}

// Route53RoutingPolicy defines traffic routing policies for DNS records.
//
//	Route53 supports multiple routing strategies beyond simple DNS resolution,
//	enabling advanced traffic management, high availability, and performance optimization.
type Route53RoutingPolicyInput struct {
	// Weighted routing policy.
	//  Distributes traffic across multiple resources based on assigned weights.
	//  Use cases:
	//    - Blue/green deployments (90% old, 10% new)
	//    - A/B testing
	//    - Load distribution across regions
	Weighted *Route53WeightedRoutingPolicyInput `json:"weighted,omitempty" jsonschema:"Weighted routing policy. Distributes traffic across multiple resources based on assigned weights. Use cases: - Blue/green deployments (90% old; 10% new) - A/B testing - Load distribution across region..."`
	// Latency-based routing policy.
	//  Routes users to the resource with the lowest network latency.
	//  Use cases:
	//    - Global applications serving users from multiple regions
	//    - Automatic selection of nearest endpoint
	Latency *Route53LatencyRoutingPolicyInput `json:"latency,omitempty" jsonschema:"Latency-based routing policy. Routes users to the resource with the lowest network latency. Use cases: - Global applications serving users from multiple regions - Automatic selection of nearest endpoi..."`
	// Failover routing policy.
	//  Routes to primary resource, automatically fails over to secondary when health check fails.
	//  Use cases:
	//    - Active-passive disaster recovery
	//    - Automatic failover during incidents
	Failover *Route53FailoverRoutingPolicyInput `json:"failover,omitempty" jsonschema:"Failover routing policy. Routes to primary resource; automatically fails over to secondary when health check fails. Use cases: - Active-passive disaster recovery - Automatic failover during incidents"`
	// Geolocation routing policy.
	//  Routes traffic based on the geographic location of the user.
	//  Use cases:
	//    - GDPR compliance (EU users to EU endpoints)
	//    - Localized content
	//    - Geographic restrictions
	Geolocation *Route53GeolocationRoutingPolicyInput `json:"geolocation,omitempty" jsonschema:"Geolocation routing policy. Routes traffic based on the geographic location of the user. Use cases: - GDPR compliance (EU users to EU endpoints) - Localized content - Geographic restrictions"`
}

func (s *Route53RoutingPolicyInput) validate() error {
	if s.Weighted != nil {
		if err := s.Weighted.validate(); err != nil {
			return fmt.Errorf("weighted: %w", err)
		}
	}
	if s.Latency != nil {
		if err := s.Latency.validate(); err != nil {
			return fmt.Errorf("latency: %w", err)
		}
	}
	if s.Failover != nil {
		if err := s.Failover.validate(); err != nil {
			return fmt.Errorf("failover: %w", err)
		}
	}
	if s.Geolocation != nil {
		if err := s.Geolocation.validate(); err != nil {
			return fmt.Errorf("geolocation: %w", err)
		}
	}
	return nil
}

func (s *Route53RoutingPolicyInput) applyDefaults() {
	if s.Weighted != nil {
		s.Weighted.applyDefaults()
	}
	if s.Latency != nil {
		s.Latency.applyDefaults()
	}
	if s.Failover != nil {
		s.Failover.applyDefaults()
	}
	if s.Geolocation != nil {
		s.Geolocation.applyDefaults()
	}
}

func (s *Route53RoutingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Weighted != nil {
		m["weighted"] = s.Weighted.toMap()
	}
	if s.Latency != nil {
		m["latency"] = s.Latency.toMap()
	}
	if s.Failover != nil {
		m["failover"] = s.Failover.toMap()
	}
	if s.Geolocation != nil {
		m["geolocation"] = s.Geolocation.toMap()
	}
	return m
}

// Route53VpcAssociation represents a VPC association for a private hosted zone.
//
//	Private zones can be associated with multiple VPCs, allowing DNS resolution across VPCs.
type Route53VpcAssociationInput struct {
	// The VPC ID to associate with the private hosted zone.
	//  Example: "vpc-12345678"
	//  Can reference an AwsVpc resource.
	VpcId string `json:"vpc_id" jsonschema:"required,The VPC ID to associate with the private hosted zone. Example: 'vpc-12345678' Can reference an AwsVpc resource."`
	// The AWS region where the VPC is located.
	//  Example: "us-east-1"
	VpcRegion string `json:"vpc_region" jsonschema:"required,The AWS region where the VPC is located. Example: 'us-east-1'"`
}

func (s *Route53VpcAssociationInput) validate() error {
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if s.VpcRegion == "" {
		return fmt.Errorf("vpc_region is required")
	}
	return nil
}

func (s *Route53VpcAssociationInput) applyDefaults() {
}

func (s *Route53VpcAssociationInput) toMap() map[string]any {
	m := make(map[string]any)
	m["vpc_id"] = s.VpcId
	m["vpc_region"] = s.VpcRegion
	return m
}

// Route53WeightedRoutingPolicy enables traffic splitting across multiple resources.
//
//	Weights are relative - Route53 calculates the percentage based on the sum of all weights.
//	Example: Records with weights 70 and 30 get 70% and 30% of traffic respectively.
type Route53WeightedRoutingPolicyInput struct {
	// Weight value (0-255).
	//  Higher weight means more traffic.
	//  Weight of 0 stops traffic to this record (useful for quick traffic draining).
	Weight int32 `json:"weight,omitempty" jsonschema:"Weight value (0-255). Higher weight means more traffic. Weight of 0 stops traffic to this record (useful for quick traffic draining)."`
}

func (s *Route53WeightedRoutingPolicyInput) validate() error {
	return nil
}

func (s *Route53WeightedRoutingPolicyInput) applyDefaults() {
}

func (s *Route53WeightedRoutingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	return m
}

// ParseAwsRoute53Zone validates and normalizes a AwsRoute53Zone cloud_object.
func ParseAwsRoute53Zone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsRoute53Zone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsRoute53ZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
