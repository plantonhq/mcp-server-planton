// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-vpc
type AwsVpcSpecInput struct {
	// The AWS region where the VPC will be created.
	//  Example: "us-west-2", "eu-west-1", "ap-southeast-1"
	//  For a list of AWS regions, see: https://aws.amazon.com/about-aws/global-infrastructure/regions_az/
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the VPC will be created. Example: 'us-west-2'; 'eu-west-1'; 'ap-southeast-1' For a list of AWS regions; see: https://aws.amazon.com/about-aws/global-infrastructure/regions_az/"`
	// The CIDR (Classless Inter-Domain Routing) block for the VPC.
	//  This defines the IP address range for the VPC.
	//  Example: "10.0.0.0/16" allows IP addresses from 10.0.0.0 to 10.0.255.255.
	VpcCidr string `json:"vpc_cidr" jsonschema:"required,The CIDR (Classless Inter-Domain Routing) block for the VPC. This defines the IP address range for the VPC. Example: '10.0.0.0/16' allows IP addresses from 10.0.0.0 to 10.0.255.255."`
	// The list of availability zones where the VPC will be spanned.
	//  AWS regions are divided into multiple availability zones (AZs) for high availability.
	//  Example: ["us-west-2a", "us-west-2b"] indicates that resources will be spread across these two AZs.
	AvailabilityZones []string `json:"availability_zones,omitempty" jsonschema:"The list of availability zones where the VPC will be spanned. AWS regions are divided into multiple availability zones (AZs) for high availability. Example: ['us-west-2a'; 'us-west-2b'] indicates that..."`
	// The number of subnets to be created in each availability zone.
	//  Subnets are segments of the VPC's IP address range where you can place groups of isolated resources.
	SubnetsPerAvailabilityZone int32 `json:"subnets_per_availability_zone" jsonschema:"required,The number of subnets to be created in each availability zone. Subnets are segments of the VPC's IP address range where you can place groups of isolated resources."`
	// The number of hosts (IP addresses) in each subnet.
	//  This determines the size of each subnet's CIDR block.
	SubnetSize int32 `json:"subnet_size" jsonschema:"required,The number of hosts (IP addresses) in each subnet. This determines the size of each subnet's CIDR block."`
	// Toggle to enable or disable a NAT (Network Address Translation) gateway for private subnets created in the VPC.
	//  A NAT gateway allows instances in a private subnet to connect to the internet or other AWS services, but prevents
	//  the internet from initiating a connection with those instances.
	IsNatGatewayEnabled bool `json:"is_nat_gateway_enabled,omitempty" jsonschema:"Toggle to enable or disable a NAT (Network Address Translation) gateway for private subnets created in the VPC. A NAT gateway allows instances in a private subnet to connect to the internet or other A..."`
	// Toggle to enable or disable DNS hostnames in the VPC.
	//  When enabled, instances with public IP addresses receive corresponding public DNS hostnames.
	//  See AWS documentation: https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-hostnames
	IsDnsHostnamesEnabled bool `json:"is_dns_hostnames_enabled,omitempty" jsonschema:"Toggle to enable or disable DNS hostnames in the VPC. When enabled; instances with public IP addresses receive corresponding public DNS hostnames. See AWS documentation: https://docs.aws.amazon.com/vp..."`
	// Toggle to enable or disable DNS resolution in the VPC through the Amazon-provided DNS server.
	//  When enabled, the Amazon DNS server resolves DNS hostnames for your instances.
	IsDnsSupportEnabled bool `json:"is_dns_support_enabled,omitempty" jsonschema:"Toggle to enable or disable DNS resolution in the VPC through the Amazon-provided DNS server. When enabled; the Amazon DNS server resolves DNS hostnames for your instances."`
}

func (s *AwsVpcSpecInput) validate() error {
	if s.VpcCidr == "" {
		return fmt.Errorf("vpc_cidr is required")
	}
	return nil
}

func (s *AwsVpcSpecInput) applyDefaults() {
}

func (s *AwsVpcSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["vpc_cidr"] = s.VpcCidr
	if len(s.AvailabilityZones) > 0 {
		m["availability_zones"] = s.AvailabilityZones
	}
	m["subnets_per_availability_zone"] = s.SubnetsPerAvailabilityZone
	m["subnet_size"] = s.SubnetSize
	if s.IsNatGatewayEnabled {
		m["is_nat_gateway_enabled"] = s.IsNatGatewayEnabled
	}
	if s.IsDnsHostnamesEnabled {
		m["is_dns_hostnames_enabled"] = s.IsDnsHostnamesEnabled
	}
	if s.IsDnsSupportEnabled {
		m["is_dns_support_enabled"] = s.IsDnsSupportEnabled
	}
	return m
}

// ParseAwsVpc validates and normalizes a AwsVpc cloud_object.
func ParseAwsVpc(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsVpc"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsVpcSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
