// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsLambda is the API envelope for an AWS Lambda function resource.
type AwsLambdaSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Human-readable function name shown in the AWS Console and APIs.
	//  Must be unique per account/region. If omitted, the platform may derive a
	//  stable name from the resource metadata (e.g., org, environment, resource name).
	//  Allowed characters and length are enforced by AWS; keep it concise and DNS-like.
	FunctionName string `json:"function_name,omitempty" jsonschema:"Human-readable function name shown in the AWS Console and APIs. Must be unique per account/region. If omitted; the platform may derive a stable name from the resource metadata (e.g.; org; environment;..."`
	// Free-form description visible in the AWS Console to document the purpose
	//  and behavior of the function. Useful for operational context and search.
	Description string `json:"description,omitempty" jsonschema:"Free-form description visible in the AWS Console to document the purpose and behavior of the function. Useful for operational context and search."`
	// Execution role for the function. Accepts a direct role ARN (value) or a reference
	//  to another resource that surfaces a role ARN in its outputs (e.g., AwsIamRole).
	RoleArn string `json:"role_arn" jsonschema:"required,Execution role for the function. Accepts a direct role ARN (value) or a reference to another resource that surfaces a role ARN in its outputs (e.g.; AwsIamRole)."`
	// Language/runtime for zip/S3 deployments. Ignored for container image code.
	//  Examples: "nodejs18.x", "python3.11", "java21", "go1.x", "dotnet8", "ruby3.3", "provided.al2".
	//  Use "provided.al2" for custom runtimes or native binaries packaged in the zip.
	Runtime string `json:"runtime,omitempty" jsonschema:"Language/runtime for zip/S3 deployments. Ignored for container image code. Examples: 'nodejs18.x'; 'python3.11'; 'java21'; 'go1.x'; 'dotnet8'; 'ruby3.3'; 'provided.al2'. Use 'provided.al2' for custom ..."`
	// Entrypoint for zip/S3 deployments. Format is language-specific, e.g.:
	//  - Node.js:    "index.handler"
	//  - Python:     "module.function"
	//  - Java:       "package.Class::method"
	//  - .NET:       "Assembly::Namespace.Class::Method"
	//  - Go/custom:  usually "bootstrap" when using a custom runtime
	//  Ignored for ...
	Handler string `json:"handler,omitempty" jsonschema:"Entrypoint for zip/S3 deployments. Format is language-specific; e.g.: - Node.js: 'index.handler' - Python: 'module.function' - Java: 'package.Class::method' - .NET: 'Assembly::Namespace.Class::Method'..."`
	// Memory allocation in megabytes. CPU, network, and some I/O scale with this
	//  value. Choose the smallest value that meets performance goals to control cost.
	//  Typical AWS-supported range is 128–10240 MB.
	MemoryMb int32 `json:"memory_mb,omitempty" jsonschema:"Memory allocation in megabytes. CPU; network; and some I/O scale with this value. Choose the smallest value that meets performance goals to control cost. Typical AWS-supported range is 128–10240 MB."`
	// Maximum execution time per invocation in seconds. Set slightly higher than
	//  the worst-case expected runtime. Typical AWS-supported range is 1–900 seconds.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Maximum execution time per invocation in seconds. Set slightly higher than the worst-case expected runtime. Typical AWS-supported range is 1–900 seconds."`
	// Hard limit on concurrent executions for this function. Behavior:
	//  - Omit or set to -1 to use the unreserved account pool (no dedicated cap).
	//  - Set to 0 to effectively disable invocations (useful for maintenance).
	//  - Set to a positive integer to reserve that many concurrent executions.
	ReservedConcurrency int32 `json:"reserved_concurrency,omitempty" jsonschema:"Hard limit on concurrent executions for this function. Behavior: - Omit or set to -1 to use the unreserved account pool (no dedicated cap). - Set to 0 to effectively disable invocations (useful for ma..."`
	// Key/value environment variables available to the function at runtime.
	//  Avoid embedding sensitive values directly; prefer external secret sources.
	//  When `kms_key_arn` is set, AWS encrypts these at rest using the specified key.
	Environment map[string]string `json:"environment,omitempty" jsonschema:"Key/value environment variables available to the function at runtime. Avoid embedding sensitive values directly; prefer external secret sources. When 'kms_key_arn' is set; AWS encrypts these at rest u..."`
	// Subnets in which the Lambda function will create network interfaces.
	//  Typically private subnets. Provide at least two across different AZs for HA.
	//  Accepts either literal subnet IDs (value) or references to other resources
	//  that expose subnet IDs via their status/outputs.
	Subnets []string `json:"subnets,omitempty" jsonschema:"Subnets in which the Lambda function will create network interfaces. Typically private subnets. Provide at least two across different AZs for HA. Accepts either literal subnet IDs (value) or reference..."`
	// Security groups attached to the Lambda ENIs. Ensure outbound rules allow
	//  access to required services (e.g., databases, AWS endpoints, the Internet
	//  via NAT if needed). Accepts either literal security group IDs (value) or
	//  references to a resource that provides a security group ID output.
	SecurityGroups []string `json:"security_groups,omitempty" jsonschema:"Security groups attached to the Lambda ENIs. Ensure outbound rules allow access to required services (e.g.; databases; AWS endpoints; the Internet via NAT if needed). Accepts either literal security g..."`
	// Processor architecture of the execution environment. Use ARM64 for better
	//  price/performance when your language/runtime supports it; use X86_64 for
	//  legacy dependencies or runtimes not available on ARM64.
	Architecture string `json:"architecture,omitempty" jsonschema:"enum=X86_64|ARM64,Processor architecture of the execution environment. Use ARM64 for better price/performance when your language/runtime supports it; use X86_64 for legacy dependencies or runtimes not available on ARM6..."`
	// Layer ARNs to include. Accepts direct ARNs (value) or references to resources
	//  that provide layer ARNs as outputs. Up to five layers may be attached; order matters.
	LayerArns []string `json:"layer_arns,omitempty" jsonschema:"Layer ARNs to include. Accepts direct ARNs (value) or references to resources that provide layer ARNs as outputs. Up to five layers may be attached; order matters."`
	// Customer-managed KMS key used to encrypt environment variables at rest.
	//  Accepts a direct key ARN (value) or a reference to a KMS key resource output.
	KmsKeyArn string `json:"kms_key_arn,omitempty" jsonschema:"Customer-managed KMS key used to encrypt environment variables at rest. Accepts a direct key ARN (value) or a reference to a KMS key resource output."`
	// Source of the function code. Select the type and populate the corresponding
	//  fields below. Validation is applied downstream to ensure consistency.
	CodeSourceType string `json:"code_source_type,omitempty" jsonschema:"enum=CODE_SOURCE_TYPE_S3|CODE_SOURCE_TYPE_IMAGE,Source of the function code. Select the type and populate the corresponding fields below. Validation is applied downstream to ensure consistency."`
	// S3 location of the deployment package (zip archive) for zip-based code.
	//  The archive should contain your compiled artifacts and the handler.
	//  Prefer a bucket in the same region as the function to avoid cross-region copies.
	S3 *S3CodeInput `json:"s3,omitempty" jsonschema:"S3 location of the deployment package (zip archive) for zip-based code. The archive should contain your compiled artifacts and the handler. Prefer a bucket in the same region as the function to avoid ..."`
	// Reference to an image stored in ECR for container-based code. The image
	//  defines the runtime and handler via its entrypoint/CMD. Example:
	//  "123456789012.dkr.ecr.us-east-1.amazonaws.com/repo:tag".
	ImageUri string `json:"image_uri,omitempty" jsonschema:"Reference to an image stored in ECR for container-based code. The image defines the runtime and handler via its entrypoint/CMD. Example: '123456789012.dkr.ecr.us-east-1.amazonaws.com/repo:tag'."`
}

func (s *AwsLambdaSpecInput) validate() error {
	if s.RoleArn == "" {
		return fmt.Errorf("role_arn is required")
	}
	switch s.Architecture {
	case "", "X86_64", "ARM64":
	default:
		return fmt.Errorf("invalid architecture: %q", s.Architecture)
	}
	switch s.CodeSourceType {
	case "", "CODE_SOURCE_TYPE_S3", "CODE_SOURCE_TYPE_IMAGE":
	default:
		return fmt.Errorf("invalid code_source_type: %q", s.CodeSourceType)
	}
	if s.S3 != nil {
		if err := s.S3.validate(); err != nil {
			return fmt.Errorf("s3: %w", err)
		}
	}
	return nil
}

func (s *AwsLambdaSpecInput) applyDefaults() {
	if s.S3 != nil {
		s.S3.applyDefaults()
	}
}

func (s *AwsLambdaSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.FunctionName != "" {
		m["function_name"] = s.FunctionName
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	m["role_arn"] = s.RoleArn
	if s.Runtime != "" {
		m["runtime"] = s.Runtime
	}
	if s.Handler != "" {
		m["handler"] = s.Handler
	}
	if s.MemoryMb != 0 {
		m["memory_mb"] = s.MemoryMb
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.ReservedConcurrency != 0 {
		m["reserved_concurrency"] = s.ReservedConcurrency
	}
	if len(s.Environment) > 0 {
		m["environment"] = s.Environment
	}
	if len(s.Subnets) > 0 {
		m["subnets"] = s.Subnets
	}
	if len(s.SecurityGroups) > 0 {
		m["security_groups"] = s.SecurityGroups
	}
	if s.Architecture != "" {
		m["architecture"] = s.Architecture
	}
	if len(s.LayerArns) > 0 {
		m["layer_arns"] = s.LayerArns
	}
	if s.KmsKeyArn != "" {
		m["kms_key_arn"] = s.KmsKeyArn
	}
	if s.CodeSourceType != "" {
		m["code_source_type"] = s.CodeSourceType
	}
	if s.S3 != nil {
		m["s3"] = s.S3.toMap()
	}
	if s.ImageUri != "" {
		m["image_uri"] = s.ImageUri
	}
	return m
}

// S3Code describes the S3 location for a zip-based deployment package.
//
//	Use this when publishing code as an archive rather than a container image.
type S3CodeInput struct {
	// S3 bucket name that contains the deployment package. Prefer a bucket in
	//  the same AWS region as the Lambda function for faster, cheaper deployments.
	Bucket string `json:"bucket,omitempty" jsonschema:"S3 bucket name that contains the deployment package. Prefer a bucket in the same AWS region as the Lambda function for faster; cheaper deployments."`
	// S3 object key (path) to the deployment package zip.
	Key string `json:"key,omitempty" jsonschema:"S3 object key (path) to the deployment package zip."`
	// Optional object version to pin a specific artifact when versioning is enabled.
	ObjectVersion string `json:"object_version,omitempty" jsonschema:"Optional object version to pin a specific artifact when versioning is enabled."`
}

func (s *S3CodeInput) validate() error {
	return nil
}

func (s *S3CodeInput) applyDefaults() {
}

func (s *S3CodeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Bucket != "" {
		m["bucket"] = s.Bucket
	}
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.ObjectVersion != "" {
		m["object_version"] = s.ObjectVersion
	}
	return m
}

// ParseAwsLambda validates and normalizes a AwsLambda cloud_object.
func ParseAwsLambda(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsLambda"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsLambdaSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
