// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsCertManagerCert represents a containerized application deployed on AWS ECS.
//
//	This resource manages ECS services that can run on either Fargate or EC2.
type AwsCertManagerCertSpecInput struct {
	// The AWS region where the ACM certificate will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the ACM certificate will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// primaryDomainName is a required field representing the main (apex or wildcard) domain name.
	//  Examples include "example.com" or "*.example.com" (wildcard).
	//  This domain will be set as the 'DomainName' in the AWS ACM certificate.
	//
	//  The pattern enforces a domain-like structure, allowing an optional wil...
	PrimaryDomainName string `json:"primary_domain_name" jsonschema:"required,primaryDomainName is a required field representing the main (apex or wildcard) domain name. Examples include 'example.com' or '*.example.com' (wildcard). This domain will be set as the 'DomainName' in..."`
	// alternateDomainNames is an optional list of Subject Alternative Names (SANs) for the certificate.
	//  Each entry must follow the same pattern as primary_domain_name and cannot contain duplicates.
	//  Primary domain should not be added to this list.
	AlternateDomainNames []string `json:"alternate_domain_names,omitempty" jsonschema:"alternateDomainNames is an optional list of Subject Alternative Names (SANs) for the certificate. Each entry must follow the same pattern as primary_domain_name and cannot contain duplicates. Primary ..."`
	// route53_hosted_zone_id is the identifier of the Route53 hosted zone
	//  where DNS validation records will be created automatically.
	//  Must be a public hosted zone matching the domain names.
	//  Example: "Z123456ABCXYZ".
	Route53HostedZoneId string `json:"route53_hosted_zone_id" jsonschema:"required,route53_hosted_zone_id is the identifier of the Route53 hosted zone where DNS validation records will be created automatically. Must be a public hosted zone matching the domain names. Example: 'Z12345..."`
	// validation_method indicates how ACM verifies domain ownership.
	//  By default, DNS is recommended.
	ValidationMethod string `json:"validation_method,omitempty" jsonschema:"validation_method indicates how ACM verifies domain ownership. By default; DNS is recommended."`
}

func (s *AwsCertManagerCertSpecInput) validate() error {
	if s.PrimaryDomainName == "" {
		return fmt.Errorf("primary_domain_name is required")
	}
	if s.Route53HostedZoneId == "" {
		return fmt.Errorf("route53_hosted_zone_id is required")
	}
	return nil
}

func (s *AwsCertManagerCertSpecInput) applyDefaults() {
	if s.ValidationMethod == "" {
		s.ValidationMethod = "DNS"
	}
}

func (s *AwsCertManagerCertSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["primary_domain_name"] = s.PrimaryDomainName
	if len(s.AlternateDomainNames) > 0 {
		m["alternate_domain_names"] = s.AlternateDomainNames
	}
	m["route53_hosted_zone_id"] = s.Route53HostedZoneId
	if s.ValidationMethod != "" {
		m["validation_method"] = s.ValidationMethod
	}
	return m
}

// ParseAwsCertManagerCert validates and normalizes a AwsCertManagerCert cloud_object.
func ParseAwsCertManagerCert(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsCertManagerCert"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsCertManagerCertSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
