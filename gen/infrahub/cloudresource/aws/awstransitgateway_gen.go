// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsTransitGateway represents a managed AWS Transit Gateway deployed via
//
//	OpenMCF. This resource provisions a regional networking hub with one or
//	more VPC attachments, enabling hub-and-spoke or full-mesh connectivity
//	between VPCs.
type AwsTransitGatewaySpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Human-readable description for the Transit Gateway. Appears in the AWS
	//  console and CLI output.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description for the Transit Gateway. Appears in the AWS console and CLI output."`
	// Private Autonomous System Number (ASN) for the Amazon side of BGP
	//  sessions. Used when connecting VPNs or Direct Connect gateways.
	//
	//  Valid ranges: 64512-65534 (16-bit private) or 4200000000-4294967294
	//  (32-bit private). Default: 64512.
	AmazonSideAsn int64 `json:"amazon_side_asn,omitempty" jsonschema:"Private Autonomous System Number (ASN) for the Amazon side of BGP sessions. Used when connecting VPNs or Direct Connect gateways. Valid ranges: 64512-65534 (16-bit private) or 4200000000-4294967294 (3..."`
	// Automatically associate new attachments with the default route table.
	//  When enabled (default), every new VPC attachment is associated with the
	//  TGW's default route table without manual intervention.
	//
	//  Disable this for hub-and-spoke topologies where you manage route table
	//  associations explicitly via...
	DefaultRouteTableAssociation bool `json:"default_route_table_association,omitempty" jsonschema:"Automatically associate new attachments with the default route table. When enabled (default); every new VPC attachment is associated with the TGW's default route table without manual intervention. Dis..."`
	// Automatically propagate routes from new attachments to the default route
	//  table. When enabled (default), every attached VPC's CIDR blocks are
	//  propagated, creating a full-mesh connectivity pattern.
	//
	//  Disable this for isolated routing domains where not all VPCs should
	//  reach each other.
	DefaultRouteTablePropagation bool `json:"default_route_table_propagation,omitempty" jsonschema:"Automatically propagate routes from new attachments to the default route table. When enabled (default); every attached VPC's CIDR blocks are propagated; creating a full-mesh connectivity pattern. Disa..."`
	// Enable DNS resolution for instances in attached VPCs. When enabled,
	//  queries to public DNS hostnames of instances in other attached VPCs
	//  resolve to their private IP addresses.
	DnsSupport bool `json:"dns_support,omitempty" jsonschema:"Enable DNS resolution for instances in attached VPCs. When enabled; queries to public DNS hostnames of instances in other attached VPCs resolve to their private IP addresses."`
	// Enable Equal Cost Multi-Path (ECMP) routing for VPN connections. When
	//  enabled and multiple VPN tunnels advertise the same routes, traffic is
	//  distributed across all tunnels for higher aggregate throughput.
	VpnEcmpSupport bool `json:"vpn_ecmp_support,omitempty" jsonschema:"Enable Equal Cost Multi-Path (ECMP) routing for VPN connections. When enabled and multiple VPN tunnels advertise the same routes; traffic is distributed across all tunnels for higher aggregate through..."`
	// Automatically accept cross-account attachment requests shared via AWS
	//  Resource Access Manager (RAM). When disabled (default), shared
	//  attachments require manual acceptance.
	AutoAcceptSharedAttachments bool `json:"auto_accept_shared_attachments,omitempty" jsonschema:"Automatically accept cross-account attachment requests shared via AWS Resource Access Manager (RAM). When disabled (default); shared attachments require manual acceptance."`
	// Enable cross-VPC security group referencing. When enabled, security
	//  group rules in one VPC can reference security groups in another VPC
	//  connected through this Transit Gateway, simplifying firewall management
	//  across VPCs.
	SecurityGroupReferencingSupport bool `json:"security_group_referencing_support,omitempty" jsonschema:"Enable cross-VPC security group referencing. When enabled; security group rules in one VPC can reference security groups in another VPC connected through this Transit Gateway; simplifying firewall man..."`
	// Enable multicast traffic routing through the Transit Gateway. This is
	//  a ForceNew field in the underlying provider -- changing it requires
	//  replacing the entire Transit Gateway. Only enable if you have a clear
	//  multicast use case (e.g., financial market data, media streaming).
	MulticastSupport bool `json:"multicast_support,omitempty" jsonschema:"Enable multicast traffic routing through the Transit Gateway. This is a ForceNew field in the underlying provider -- changing it requires replacing the entire Transit Gateway. Only enable if you have ..."`
	// CIDR blocks to associate with the Transit Gateway. Used for advanced
	//  features like TGW Connect (SD-WAN/third-party appliance integration)
	//  and GRE-based attachments.
	//
	//  Most deployments do not need TGW CIDR blocks. Leave empty unless you
	//  are using TGW Connect or need the TGW itself to have routable...
	TransitGatewayCidrBlocks []string `json:"transit_gateway_cidr_blocks,omitempty" jsonschema:"CIDR blocks to associate with the Transit Gateway. Used for advanced features like TGW Connect (SD-WAN/third-party appliance integration) and GRE-based attachments. Most deployments do not need TGW CI..."`
	// VPC attachments that connect VPCs to this Transit Gateway. At least one
	//  attachment is required -- a Transit Gateway without attachments serves
	//  no purpose.
	//
	//  Each attachment corresponds to one `aws_ec2_transit_gateway_vpc_attachment`
	//  resource. Modifications to one attachment do not affect others.
	VpcAttachments []*AwsTransitGatewayVpcAttachmentInput `json:"vpc_attachments" jsonschema:"required,VPC attachments that connect VPCs to this Transit Gateway. At least one attachment is required -- a Transit Gateway without attachments serves no purpose. Each attachment corresponds to one 'aws_ec2_t..."`
}

func (s *AwsTransitGatewaySpecInput) validate() error {
	if len(s.VpcAttachments) == 0 {
		return fmt.Errorf("vpc_attachments is required")
	}
	if len(s.VpcAttachments) < 1 {
		return fmt.Errorf("vpc_attachments requires at least 1 items, got %d", len(s.VpcAttachments))
	}
	for i, v := range s.VpcAttachments {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("vpc_attachments[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsTransitGatewaySpecInput) applyDefaults() {
}

func (s *AwsTransitGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.AmazonSideAsn != 0 {
		m["amazon_side_asn"] = s.AmazonSideAsn
	}
	if s.DefaultRouteTableAssociation {
		m["default_route_table_association"] = s.DefaultRouteTableAssociation
	}
	if s.DefaultRouteTablePropagation {
		m["default_route_table_propagation"] = s.DefaultRouteTablePropagation
	}
	if s.DnsSupport {
		m["dns_support"] = s.DnsSupport
	}
	if s.VpnEcmpSupport {
		m["vpn_ecmp_support"] = s.VpnEcmpSupport
	}
	if s.AutoAcceptSharedAttachments {
		m["auto_accept_shared_attachments"] = s.AutoAcceptSharedAttachments
	}
	if s.SecurityGroupReferencingSupport {
		m["security_group_referencing_support"] = s.SecurityGroupReferencingSupport
	}
	if s.MulticastSupport {
		m["multicast_support"] = s.MulticastSupport
	}
	if len(s.TransitGatewayCidrBlocks) > 0 {
		m["transit_gateway_cidr_blocks"] = s.TransitGatewayCidrBlocks
	}
	if len(s.VpcAttachments) > 0 {
		items := make([]any, len(s.VpcAttachments))
		for i, v := range s.VpcAttachments {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["vpc_attachments"] = items
	}
	return m
}

// AwsTransitGatewayVpcAttachment defines a VPC attachment to the Transit
//
//	Gateway. Each attachment connects one VPC to the TGW through one or more
//	subnets (one per Availability Zone recommended).
//
//	Underlying resource: `aws_ec2_transit_gateway_vpc_attachment`. Both
//	`vpc_id` and the TGW ID are ForceNew -- changing the VPC requires
//	replacing the attachment. Subnets can be updated in place.
type AwsTransitGatewayVpcAttachmentInput struct {
	// User-assigned name for this attachment. Used as the key in the
	//  vpc_attachment_ids output map, allowing downstream resources to
	//  reference specific attachment IDs via valueFrom.
	//
	//  Must be unique within the TGW's attachments. Lowercase alphanumeric
	//  and hyphens only, starting with a letter (max 63 ch...
	Name string `json:"name" jsonschema:"required,User-assigned name for this attachment. Used as the key in the vpc_attachment_ids output map; allowing downstream resources to reference specific attachment IDs via valueFrom. Must be unique within th..."`
	// VPC ID to attach to the Transit Gateway. References an AwsVpc resource's
	//  vpc_id output. This field is ForceNew: changing it replaces the
	//  attachment.
	VpcId string `json:"vpc_id" jsonschema:"required,VPC ID to attach to the Transit Gateway. References an AwsVpc resource's vpc_id output. This field is ForceNew: changing it replaces the attachment."`
	// Subnet IDs in the VPC to use for the attachment. The TGW creates an
	//  elastic network interface in each specified subnet. Provide one subnet
	//  per Availability Zone for high availability.
	//
	//  At least one subnet is required. All subnets must belong to the VPC
	//  specified in vpc_id.
	SubnetIds []string `json:"subnet_ids" jsonschema:"required,Subnet IDs in the VPC to use for the attachment. The TGW creates an elastic network interface in each specified subnet. Provide one subnet per Availability Zone for high availability. At least one sub..."`
	// Enable DNS resolution for this attachment. When enabled, DNS queries
	//  from the attached VPC to public hostnames of instances in other
	//  attached VPCs resolve to private IPs. Overrides the TGW-level setting.
	DnsSupport bool `json:"dns_support,omitempty" jsonschema:"Enable DNS resolution for this attachment. When enabled; DNS queries from the attached VPC to public hostnames of instances in other attached VPCs resolve to private IPs. Overrides the TGW-level setti..."`
	// Enable IPv6 support for this attachment. When enabled, the TGW routes
	//  IPv6 traffic between this VPC and other attached VPCs/connections.
	Ipv6Support bool `json:"ipv6_support,omitempty" jsonschema:"Enable IPv6 support for this attachment. When enabled; the TGW routes IPv6 traffic between this VPC and other attached VPCs/connections."`
	// Enable appliance mode for this attachment. Required when routing
	//  traffic through a virtual appliance (firewall, IDS/IPS) hosted in
	//  the attached VPC. Appliance mode ensures return traffic is routed
	//  to the same Availability Zone as the original flow, maintaining
	//  symmetric routing for stateful insp...
	ApplianceModeSupport bool `json:"appliance_mode_support,omitempty" jsonschema:"Enable appliance mode for this attachment. Required when routing traffic through a virtual appliance (firewall; IDS/IPS) hosted in the attached VPC. Appliance mode ensures return traffic is routed to ..."`
	// Associate this attachment with the TGW's default route table. When
	//  true (default), the attachment is automatically associated. Set to
	//  false for custom route table management.
	DefaultRouteTableAssociation bool `json:"default_route_table_association,omitempty" jsonschema:"Associate this attachment with the TGW's default route table. When true (default); the attachment is automatically associated. Set to false for custom route table management."`
	// Propagate this attachment's routes to the TGW's default route table.
	//  When true (default), the VPC's CIDR blocks are automatically
	//  propagated. Set to false for isolated routing.
	DefaultRouteTablePropagation bool `json:"default_route_table_propagation,omitempty" jsonschema:"Propagate this attachment's routes to the TGW's default route table. When true (default); the VPC's CIDR blocks are automatically propagated. Set to false for isolated routing."`
}

func (s *AwsTransitGatewayVpcAttachmentInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if len(s.SubnetIds) == 0 {
		return fmt.Errorf("subnet_ids is required")
	}
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	return nil
}

func (s *AwsTransitGatewayVpcAttachmentInput) applyDefaults() {
}

func (s *AwsTransitGatewayVpcAttachmentInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["vpc_id"] = s.VpcId
	m["subnet_ids"] = s.SubnetIds
	if s.DnsSupport {
		m["dns_support"] = s.DnsSupport
	}
	if s.Ipv6Support {
		m["ipv6_support"] = s.Ipv6Support
	}
	if s.ApplianceModeSupport {
		m["appliance_mode_support"] = s.ApplianceModeSupport
	}
	if s.DefaultRouteTableAssociation {
		m["default_route_table_association"] = s.DefaultRouteTableAssociation
	}
	if s.DefaultRouteTablePropagation {
		m["default_route_table_propagation"] = s.DefaultRouteTablePropagation
	}
	return m
}

// ParseAwsTransitGateway validates and normalizes a AwsTransitGateway cloud_object.
func ParseAwsTransitGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsTransitGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsTransitGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
