// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-gke-node-pool
type GcpGkeNodePoolSpecInput struct {
	// Reference to the parent GKE cluster (by name).
	//  Must refer to an existing GcpGkeCluster resource in the same environment.
	ClusterProjectId string `json:"cluster_project_id" jsonschema:"required,Reference to the parent GKE cluster (by name). Must refer to an existing GcpGkeCluster resource in the same environment."`
	// Reference to the parent GKE cluster (by name).
	//  Must refer to an existing GcpGkeCluster resource in the same environment.
	ClusterName string `json:"cluster_name" jsonschema:"required,Reference to the parent GKE cluster (by name). Must refer to an existing GcpGkeCluster resource in the same environment."`
	// Location of the parent GKE cluster (region or zone).
	//  Must refer to an existing GcpGkeCluster resource in the same environment.
	//  Example: "us-central1" (regional) or "us-central1-a" (zonal)
	ClusterLocation string `json:"cluster_location" jsonschema:"required,Location of the parent GKE cluster (region or zone). Must refer to an existing GcpGkeCluster resource in the same environment. Example: 'us-central1' (regional) or 'us-central1-a' (zonal)"`
	// Machine type for node VMs (e.g., "e2-medium", "n1-standard-4").
	//  If unspecified, defaults to "e2-medium" (2 vCPU, 4 GB RAM).
	MachineType string `json:"machine_type,omitempty" jsonschema:"Machine type for node VMs (e.g.; 'e2-medium'; 'n1-standard-4'). If unspecified; defaults to 'e2-medium' (2 vCPU; 4 GB RAM)."`
	// Size of boot disk (GB) for each node. Min 10 GB. Defaults to 100 GB if unset.
	//  Default 100 implied if not provided (handled in provisioning code or via options.default if supported).
	DiskSizeGb uint32 `json:"disk_size_gb,omitempty" jsonschema:"Size of boot disk (GB) for each node. Min 10 GB. Defaults to 100 GB if unset. Default 100 implied if not provided (handled in provisioning code or via options.default if supported)."`
	// Type of boot disk: "pd-standard", "pd-ssd", or "pd-balanced".
	//  Defaults to "pd-standard" for unspecified.
	DiskType string `json:"disk_type,omitempty" jsonschema:"Type of boot disk: 'pd-standard'; 'pd-ssd'; or 'pd-balanced'. Defaults to 'pd-standard' for unspecified."`
	// Node image type (OS image). Default is "COS_CONTAINERD" (Container-Optimized OS with containerd).
	ImageType string `json:"image_type,omitempty" jsonschema:"Node image type (OS image). Default is 'COS_CONTAINERD' (Container-Optimized OS with containerd)."`
	// Service account email for nodes. If not provided, the GKE default node service account is used.
	ServiceAccount string `json:"service_account,omitempty" jsonschema:"Service account email for nodes. If not provided; the GKE default node service account is used."`
	// Auto-upgrade and Auto-repair settings for node management.
	Management *GcpGkeClusterNodePoolNodeManagementInput `json:"management,omitempty" jsonschema:"Auto-upgrade and Auto-repair settings for node management."`
	// Whether to use Spot (preemptible) VMs for this node pool.
	Spot bool `json:"spot,omitempty" jsonschema:"Whether to use Spot (preemptible) VMs for this node pool."`
	// Kubernetes labels to apply to all nodes in this pool.
	NodeLabels map[string]string `json:"node_labels,omitempty" jsonschema:"Kubernetes labels to apply to all nodes in this pool."`
	// Fixed number of nodes (no autoscaling).
	NodeCount uint32 `json:"node_count,omitempty" jsonschema:"Fixed number of nodes (no autoscaling)."`
	// Autoscaling config for this node pool.
	Autoscaling *GcpGkeNodePoolAutoscalingInput `json:"autoscaling,omitempty" jsonschema:"Autoscaling config for this node pool."`
	// Name of the node pool to create in the GKE cluster.
	//  Must be 1-40 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a lowercase letter or number.
	//  Example: "default-pool", "high-memory-pool"
	NodePoolName string `json:"node_pool_name" jsonschema:"required,Name of the node pool to create in the GKE cluster. Must be 1-40 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a lowercase letter or number. Examp..."`
}

func (s *GcpGkeNodePoolSpecInput) validate() error {
	if s.ClusterProjectId == "" {
		return fmt.Errorf("cluster_project_id is required")
	}
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	if s.ClusterLocation == "" {
		return fmt.Errorf("cluster_location is required")
	}
	if s.Management != nil {
		if err := s.Management.validate(); err != nil {
			return fmt.Errorf("management: %w", err)
		}
	}
	if s.Autoscaling != nil {
		if err := s.Autoscaling.validate(); err != nil {
			return fmt.Errorf("autoscaling: %w", err)
		}
	}
	if s.NodePoolName == "" {
		return fmt.Errorf("node_pool_name is required")
	}
	return nil
}

func (s *GcpGkeNodePoolSpecInput) applyDefaults() {
	if s.MachineType == "" {
		s.MachineType = "e2-medium"
	}
	if s.DiskType == "" {
		s.DiskType = "pd-standard"
	}
	if s.ImageType == "" {
		s.ImageType = "COS_CONTAINERD"
	}
	if s.Management != nil {
		s.Management.applyDefaults()
	}
	if s.Autoscaling != nil {
		s.Autoscaling.applyDefaults()
	}
}

func (s *GcpGkeNodePoolSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cluster_project_id"] = s.ClusterProjectId
	m["cluster_name"] = s.ClusterName
	m["cluster_location"] = s.ClusterLocation
	if s.MachineType != "" {
		m["machine_type"] = s.MachineType
	}
	if s.DiskSizeGb != 0 {
		m["disk_size_gb"] = s.DiskSizeGb
	}
	if s.DiskType != "" {
		m["disk_type"] = s.DiskType
	}
	if s.ImageType != "" {
		m["image_type"] = s.ImageType
	}
	if s.ServiceAccount != "" {
		m["service_account"] = s.ServiceAccount
	}
	if s.Management != nil {
		m["management"] = s.Management.toMap()
	}
	if s.Spot {
		m["spot"] = s.Spot
	}
	if len(s.NodeLabels) > 0 {
		m["node_labels"] = s.NodeLabels
	}
	if s.NodeCount != 0 {
		m["node_count"] = s.NodeCount
	}
	if s.Autoscaling != nil {
		m["autoscaling"] = s.Autoscaling.toMap()
	}
	m["node_pool_name"] = s.NodePoolName
	return m
}

// Node management settings for auto-upgrade/repair.
type GcpGkeClusterNodePoolNodeManagementInput struct {
	// Whether to enable automatic upgrades for nodes in this pool.
	DisableAutoUpgrade bool `json:"disable_auto_upgrade,omitempty" jsonschema:"Whether to enable automatic upgrades for nodes in this pool."`
	// Whether to enable automatic repair of unhealthy nodes in this pool.
	DisableAutoRepair bool `json:"disable_auto_repair,omitempty" jsonschema:"Whether to enable automatic repair of unhealthy nodes in this pool."`
}

func (s *GcpGkeClusterNodePoolNodeManagementInput) validate() error {
	return nil
}

func (s *GcpGkeClusterNodePoolNodeManagementInput) applyDefaults() {
}

func (s *GcpGkeClusterNodePoolNodeManagementInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisableAutoUpgrade {
		m["disable_auto_upgrade"] = s.DisableAutoUpgrade
	}
	if s.DisableAutoRepair {
		m["disable_auto_repair"] = s.DisableAutoRepair
	}
	return m
}

// Nested message for autoscaler settings.
type GcpGkeNodePoolAutoscalingInput struct {
	// Minimum nodes (per zone) when autoscaling. 0 allows scale-to-zero.
	MinNodes uint32 `json:"min_nodes,omitempty" jsonschema:"Minimum nodes (per zone) when autoscaling. 0 allows scale-to-zero."`
	// Maximum nodes (per zone) when autoscaling.
	MaxNodes uint32 `json:"max_nodes,omitempty" jsonschema:"Maximum nodes (per zone) when autoscaling."`
	// (Optional) Location policy for scaling ("BALANCED" or "ANY").
	LocationPolicy string `json:"location_policy,omitempty" jsonschema:"(Optional) Location policy for scaling ('BALANCED' or 'ANY')."`
}

func (s *GcpGkeNodePoolAutoscalingInput) validate() error {
	return nil
}

func (s *GcpGkeNodePoolAutoscalingInput) applyDefaults() {
	if s.LocationPolicy == "" {
		s.LocationPolicy = "BALANCED"
	}
}

func (s *GcpGkeNodePoolAutoscalingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinNodes != 0 {
		m["min_nodes"] = s.MinNodes
	}
	if s.MaxNodes != 0 {
		m["max_nodes"] = s.MaxNodes
	}
	if s.LocationPolicy != "" {
		m["location_policy"] = s.LocationPolicy
	}
	return m
}

// ParseGcpGkeNodePool validates and normalizes a GcpGkeNodePool cloud_object.
func ParseGcpGkeNodePool(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpGkeNodePool"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpGkeNodePoolSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
