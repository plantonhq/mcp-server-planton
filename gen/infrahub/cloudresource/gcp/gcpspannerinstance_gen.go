// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-spanner-instance
type GcpSpannerInstanceSpecInput struct {
	// GCP project where the Spanner instance will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the Spanner instance will be created."`
	// Unique name for the Spanner instance. This becomes the GCP resource name.
	//  Must start with a lowercase letter, can contain lowercase letters, numbers,
	//  and hyphens, and must end with a lowercase letter or number.
	//  6-30 characters. Immutable after creation.
	InstanceName string `json:"instance_name" jsonschema:"required,Unique name for the Spanner instance. This becomes the GCP resource name. Must start with a lowercase letter; can contain lowercase letters; numbers; and hyphens; and must end with a lowercase letter ..."`
	// Instance configuration defining geographic placement and replication
	//  topology. Examples: "regional-us-central1", "nam-eur-asia1", "nam6".
	//  Regional configs provide lower latency; multi-region configs provide
	//  higher availability across geographic failures.
	//  Immutable after creation.
	Config string `json:"config" jsonschema:"required,Instance configuration defining geographic placement and replication topology. Examples: 'regional-us-central1'; 'nam-eur-asia1'; 'nam6'. Regional configs provide lower latency; multi-region configs p..."`
	// Human-readable display name for the instance.
	//  Must be 4-30 characters and unique within the project.
	DisplayName string `json:"display_name" jsonschema:"required,Human-readable display name for the instance. Must be 4-30 characters and unique within the project."`
	// Number of nodes allocated to the instance. Each node provides
	//  approximately 10,000 QPS of reads or 2,000 QPS of writes.
	//  Mutually exclusive with processing_units and autoscaling_config.
	//  Must not be set for FREE_INSTANCE.
	NumNodes int32 `json:"num_nodes,omitempty" jsonschema:"Number of nodes allocated to the instance. Each node provides approximately 10;000 QPS of reads or 2;000 QPS of writes. Mutually exclusive with processing_units and autoscaling_config. Must not be set..."`
	// Number of processing units allocated to the instance.
	//  Finer-grained than nodes: 1 node = 1000 processing units.
	//  For values < 1000, must be multiples of 100. For >= 1000, multiples of 1000.
	//  Mutually exclusive with num_nodes and autoscaling_config.
	//  Must not be set for FREE_INSTANCE.
	ProcessingUnits int32 `json:"processing_units,omitempty" jsonschema:"Number of processing units allocated to the instance. Finer-grained than nodes: 1 node = 1000 processing units. For values < 1000; must be multiples of 100. For >= 1000; multiples of 1000. Mutually ex..."`
	// Autoscaling configuration. When set, Spanner automatically adjusts
	//  compute capacity based on utilization thresholds.
	//  Mutually exclusive with num_nodes and processing_units.
	//  Must not be set for FREE_INSTANCE.
	AutoscalingConfig *GcpSpannerInstanceAutoscalingConfigInput `json:"autoscaling_config,omitempty" jsonschema:"Autoscaling configuration. When set; Spanner automatically adjusts compute capacity based on utilization thresholds. Mutually exclusive with num_nodes and processing_units. Must not be set for FREE_IN..."`
	// Instance type. PROVISIONED (default) requires explicit capacity
	//  allocation. FREE_INSTANCE provides a zero-cost instance with limited
	//  capacity for development and testing.
	InstanceType string `json:"instance_type,omitempty" jsonschema:"Instance type. PROVISIONED (default) requires explicit capacity allocation. FREE_INSTANCE provides a zero-cost instance with limited capacity for development and testing."`
	// Edition controlling available features and SLA level.
	//  STANDARD: cost-optimized, good for most workloads.
	//  ENTERPRISE: granular instance sizing, advanced features.
	//  ENTERPRISE_PLUS: 99.999% multi-region SLA, advanced compliance.
	//  Cannot be set when instance_type is FREE_INSTANCE.
	Edition string `json:"edition,omitempty" jsonschema:"Edition controlling available features and SLA level. STANDARD: cost-optimized; good for most workloads. ENTERPRISE: granular instance sizing; advanced features. ENTERPRISE_PLUS: 99.999% multi-region ..."`
	// Default backup schedule type for new databases created in this instance.
	//  NONE: no automatic backups (default).
	//  AUTOMATIC: GCP automatically creates backup schedules for new databases.
	//  Cannot be AUTOMATIC when instance_type is FREE_INSTANCE.
	DefaultBackupScheduleType string `json:"default_backup_schedule_type,omitempty" jsonschema:"Default backup schedule type for new databases created in this instance. NONE: no automatic backups (default). AUTOMATIC: GCP automatically creates backup schedules for new databases. Cannot be AUTOMA..."`
	// Whether to delete all backups of this instance when destroying it.
	//  When false (default), the destroy operation will fail if any databases
	//  in the instance have backups. Set to true to force destruction.
	ForceDestroy bool `json:"force_destroy,omitempty" jsonschema:"Whether to delete all backups of this instance when destroying it. When false (default); the destroy operation will fail if any databases in the instance have backups. Set to true to force destruction..."`
}

func (s *GcpSpannerInstanceSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.InstanceName == "" {
		return fmt.Errorf("instance_name is required")
	}
	if s.Config == "" {
		return fmt.Errorf("config is required")
	}
	if s.DisplayName == "" {
		return fmt.Errorf("display_name is required")
	}
	if s.AutoscalingConfig != nil {
		if err := s.AutoscalingConfig.validate(); err != nil {
			return fmt.Errorf("autoscaling_config: %w", err)
		}
	}
	return nil
}

func (s *GcpSpannerInstanceSpecInput) applyDefaults() {
	if s.AutoscalingConfig != nil {
		s.AutoscalingConfig.applyDefaults()
	}
}

func (s *GcpSpannerInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["instance_name"] = s.InstanceName
	m["config"] = s.Config
	m["display_name"] = s.DisplayName
	if s.NumNodes != 0 {
		m["num_nodes"] = s.NumNodes
	}
	if s.ProcessingUnits != 0 {
		m["processing_units"] = s.ProcessingUnits
	}
	if s.AutoscalingConfig != nil {
		m["autoscaling_config"] = s.AutoscalingConfig.toMap()
	}
	if s.InstanceType != "" {
		m["instance_type"] = s.InstanceType
	}
	if s.Edition != "" {
		m["edition"] = s.Edition
	}
	if s.DefaultBackupScheduleType != "" {
		m["default_backup_schedule_type"] = s.DefaultBackupScheduleType
	}
	if s.ForceDestroy {
		m["force_destroy"] = s.ForceDestroy
	}
	return m
}

// GcpSpannerInstanceAutoscalingConfig enables automatic scaling of compute
//
//	capacity based on utilization thresholds. When autoscaling is enabled,
//	num_nodes and processing_units become read-only outputs reflecting the
//	current allocation.
type GcpSpannerInstanceAutoscalingConfigInput struct {
	// Required. Minimum and maximum compute capacity bounds.
	AutoscalingLimits *GcpSpannerInstanceAutoscalingLimitsInput `json:"autoscaling_limits" jsonschema:"required,Required. Minimum and maximum compute capacity bounds."`
	// Optional. Utilization targets that trigger scaling decisions.
	//  If not set, GCP uses default targets.
	AutoscalingTargets *GcpSpannerInstanceAutoscalingTargetsInput `json:"autoscaling_targets,omitempty" jsonschema:"Optional. Utilization targets that trigger scaling decisions. If not set; GCP uses default targets."`
}

func (s *GcpSpannerInstanceAutoscalingConfigInput) validate() error {
	if s.AutoscalingLimits == nil {
		return fmt.Errorf("autoscaling_limits is required")
	}
	if s.AutoscalingLimits != nil {
		if err := s.AutoscalingLimits.validate(); err != nil {
			return fmt.Errorf("autoscaling_limits: %w", err)
		}
	}
	if s.AutoscalingTargets != nil {
		if err := s.AutoscalingTargets.validate(); err != nil {
			return fmt.Errorf("autoscaling_targets: %w", err)
		}
	}
	return nil
}

func (s *GcpSpannerInstanceAutoscalingConfigInput) applyDefaults() {
	if s.AutoscalingLimits != nil {
		s.AutoscalingLimits.applyDefaults()
	}
	if s.AutoscalingTargets != nil {
		s.AutoscalingTargets.applyDefaults()
	}
}

func (s *GcpSpannerInstanceAutoscalingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AutoscalingLimits != nil {
		m["autoscaling_limits"] = s.AutoscalingLimits.toMap()
	}
	if s.AutoscalingTargets != nil {
		m["autoscaling_targets"] = s.AutoscalingTargets.toMap()
	}
	return m
}

// GcpSpannerInstanceAutoscalingLimits defines the minimum and maximum compute
//
//	capacity for autoscaling. Limits must use the same unit -- either nodes
//	(min_nodes + max_nodes) or processing units (min_processing_units +
//	max_processing_units). Mixing units is not allowed.
type GcpSpannerInstanceAutoscalingLimitsInput struct {
	// Minimum number of nodes. Use with max_nodes.
	//  Each node provides approximately 10,000 QPS of read throughput.
	MinNodes int32 `json:"min_nodes,omitempty" jsonschema:"Minimum number of nodes. Use with max_nodes. Each node provides approximately 10;000 QPS of read throughput."`
	// Maximum number of nodes. Must be >= min_nodes.
	MaxNodes int32 `json:"max_nodes,omitempty" jsonschema:"Maximum number of nodes. Must be >= min_nodes."`
	// Minimum number of processing units. Use with max_processing_units.
	//  Must be a multiple of 1000 (for values >= 1000) or 100 (for values < 1000).
	MinProcessingUnits int32 `json:"min_processing_units,omitempty" jsonschema:"Minimum number of processing units. Use with max_processing_units. Must be a multiple of 1000 (for values >= 1000) or 100 (for values < 1000)."`
	// Maximum number of processing units. Must be >= min_processing_units.
	MaxProcessingUnits int32 `json:"max_processing_units,omitempty" jsonschema:"Maximum number of processing units. Must be >= min_processing_units."`
}

func (s *GcpSpannerInstanceAutoscalingLimitsInput) validate() error {
	return nil
}

func (s *GcpSpannerInstanceAutoscalingLimitsInput) applyDefaults() {
}

func (s *GcpSpannerInstanceAutoscalingLimitsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinNodes != 0 {
		m["min_nodes"] = s.MinNodes
	}
	if s.MaxNodes != 0 {
		m["max_nodes"] = s.MaxNodes
	}
	if s.MinProcessingUnits != 0 {
		m["min_processing_units"] = s.MinProcessingUnits
	}
	if s.MaxProcessingUnits != 0 {
		m["max_processing_units"] = s.MaxProcessingUnits
	}
	return m
}

// GcpSpannerInstanceAutoscalingTargets defines the utilization thresholds
//
//	that trigger autoscaling. When a target is exceeded, Spanner scales up;
//	when utilization drops below, it scales down (respecting the limits).
type GcpSpannerInstanceAutoscalingTargetsInput struct {
	// Target percentage for high-priority CPU utilization (0-100).
	//  High-priority tasks include reads and writes from user queries.
	//  Recommended: 65 for most workloads.
	HighPriorityCpuUtilizationPercent int32 `json:"high_priority_cpu_utilization_percent,omitempty" jsonschema:"Target percentage for high-priority CPU utilization (0-100). High-priority tasks include reads and writes from user queries. Recommended: 65 for most workloads."`
	// Target percentage for storage utilization (0-100).
	//  Recommended: 80 to leave headroom for growth.
	StorageUtilizationPercent int32 `json:"storage_utilization_percent,omitempty" jsonschema:"Target percentage for storage utilization (0-100). Recommended: 80 to leave headroom for growth."`
}

func (s *GcpSpannerInstanceAutoscalingTargetsInput) validate() error {
	return nil
}

func (s *GcpSpannerInstanceAutoscalingTargetsInput) applyDefaults() {
}

func (s *GcpSpannerInstanceAutoscalingTargetsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HighPriorityCpuUtilizationPercent != 0 {
		m["high_priority_cpu_utilization_percent"] = s.HighPriorityCpuUtilizationPercent
	}
	if s.StorageUtilizationPercent != 0 {
		m["storage_utilization_percent"] = s.StorageUtilizationPercent
	}
	return m
}

// ParseGcpSpannerInstance validates and normalizes a GcpSpannerInstance cloud_object.
func ParseGcpSpannerInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpSpannerInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpSpannerInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
