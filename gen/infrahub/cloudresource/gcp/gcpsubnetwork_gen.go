// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-subnetwork
type GcpSubnetworkSpecInput struct {
	// The GCP project ID in which to create this subnetwork.
	ProjectId string `json:"project_id" jsonschema:"required,The GCP project ID in which to create this subnetwork."`
	// Reference to the parent VPC network (must be an existing GcpVpc).
	//  This should point to the VPC's selfLink for the network:contentReference[oaicite:8]{index=8}.
	VpcSelfLink string `json:"vpc_self_link" jsonschema:"required,Reference to the parent VPC network (must be an existing GcpVpc). This should point to the VPC's selfLink for the network:contentReference[oaicite:8]{index=8}."`
	// Region in which to create this subnet (e.g. "us-west1").
	//  Must be a valid GCP region code (ends with a digit) and cannot be changed after creation.
	Region string `json:"region" jsonschema:"required,Region in which to create this subnet (e.g. 'us-west1'). Must be a valid GCP region code (ends with a digit) and cannot be changed after creation."`
	// Primary IPv4 CIDR range for the subnet. Example: "10.0.0.0/16".
	//  Must be unique and non-overlapping within the VPC. Only IPv4 ranges are supported:contentReference[oaicite:9]{index=9}.
	IpCidrRange string `json:"ip_cidr_range" jsonschema:"required,Primary IPv4 CIDR range for the subnet. Example: '10.0.0.0/16'. Must be unique and non-overlapping within the VPC. Only IPv4 ranges are supported:contentReference[oaicite:9]{index=9}."`
	// Secondary IP ranges for alias IPs (e.g., for GKE Pod or Service IPs). Optional.
	//  Each secondary range has a name (1-63 chars, lowercase alphanumeric or '-') and an IPv4 CIDR.
	//  Up to 170 secondary ranges can be defined per subnet:contentReference[oaicite:10]{index=10} (typical usage is one or two).
	SecondaryIpRanges []*GcpSubnetworkSecondaryRangeInput `json:"secondary_ip_ranges,omitempty" jsonschema:"Secondary IP ranges for alias IPs (e.g.; for GKE Pod or Service IPs). Optional. Each secondary range has a name (1-63 chars; lowercase alphanumeric or '-') and an IPv4 CIDR. Up to 170 secondary ranges..."`
	// Whether to enable Private Google Access on this subnet.
	//  If true, VMs without external IPs in this subnet can access Google APIs internally:contentReference[oaicite:11]{index=11}.
	PrivateIpGoogleAccess bool `json:"private_ip_google_access,omitempty" jsonschema:"Whether to enable Private Google Access on this subnet. If true; VMs without external IPs in this subnet can access Google APIs internally:contentReference[oaicite:11]{index=11}."`
	// Name of the subnetwork to create in GCP.
	//  Must be 1-63 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a lowercase letter or number.
	//  Example: "my-subnet", "prod-uswest1-subnet"
	SubnetworkName string `json:"subnetwork_name" jsonschema:"required,Name of the subnetwork to create in GCP. Must be 1-63 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a lowercase letter or number. Example: 'my-sub..."`
}

func (s *GcpSubnetworkSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.VpcSelfLink == "" {
		return fmt.Errorf("vpc_self_link is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.IpCidrRange == "" {
		return fmt.Errorf("ip_cidr_range is required")
	}
	for i, v := range s.SecondaryIpRanges {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secondary_ip_ranges[%d]: %w", i, err)
			}
		}
	}
	if s.SubnetworkName == "" {
		return fmt.Errorf("subnetwork_name is required")
	}
	return nil
}

func (s *GcpSubnetworkSpecInput) applyDefaults() {
}

func (s *GcpSubnetworkSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["vpc_self_link"] = s.VpcSelfLink
	m["region"] = s.Region
	m["ip_cidr_range"] = s.IpCidrRange
	if len(s.SecondaryIpRanges) > 0 {
		items := make([]any, len(s.SecondaryIpRanges))
		for i, v := range s.SecondaryIpRanges {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["secondary_ip_ranges"] = items
	}
	if s.PrivateIpGoogleAccess {
		m["private_ip_google_access"] = s.PrivateIpGoogleAccess
	}
	m["subnetwork_name"] = s.SubnetworkName
	return m
}

// Define the structure for a secondary IP range.
type GcpSubnetworkSecondaryRangeInput struct {
	// Name for this secondary range (unique within the subnet).
	//  1-63 characters, must start with a letter and end with a letter or digit (RFC1035):contentReference[oaicite:12]{index=12}.
	RangeName string `json:"range_name" jsonschema:"required,Name for this secondary range (unique within the subnet). 1-63 characters; must start with a letter and end with a letter or digit (RFC1035):contentReference[oaicite:12]{index=12}."`
	// The IPv4 CIDR for this secondary range (non-overlapping within the VPC).
	IpCidrRange string `json:"ip_cidr_range" jsonschema:"required,The IPv4 CIDR for this secondary range (non-overlapping within the VPC)."`
}

func (s *GcpSubnetworkSecondaryRangeInput) validate() error {
	if s.RangeName == "" {
		return fmt.Errorf("range_name is required")
	}
	if s.IpCidrRange == "" {
		return fmt.Errorf("ip_cidr_range is required")
	}
	return nil
}

func (s *GcpSubnetworkSecondaryRangeInput) applyDefaults() {
}

func (s *GcpSubnetworkSecondaryRangeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["range_name"] = s.RangeName
	m["ip_cidr_range"] = s.IpCidrRange
	return m
}

// ParseGcpSubnetwork validates and normalizes a GcpSubnetwork cloud_object.
func ParseGcpSubnetwork(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpSubnetwork"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpSubnetworkSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
