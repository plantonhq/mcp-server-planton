// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-alloydb-cluster
type GcpAlloydbClusterSpecInput struct {
	// GCP project where the AlloyDB cluster will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the AlloyDB cluster will be created."`
	// Name of the AlloyDB cluster. This becomes the GCP resource cluster_id.
	//  Must start with a lowercase letter, can contain lowercase letters,
	//  numbers, and hyphens, and must end with a lowercase letter or number.
	//  Maximum 63 characters. Immutable after creation.
	ClusterName string `json:"cluster_name" jsonschema:"required,Name of the AlloyDB cluster. This becomes the GCP resource cluster_id. Must start with a lowercase letter; can contain lowercase letters; numbers; and hyphens; and must end with a lowercase letter or ..."`
	// GCP region where the cluster will be deployed (e.g., "us-central1").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,GCP region where the cluster will be deployed (e.g.; 'us-central1'). Immutable after creation."`
	// VPC network for the cluster's private connectivity. The VPC must have
	//  Private Service Access configured. Expects a VPC network self-link or
	//  resource reference.
	//  Immutable after creation.
	Network string `json:"network" jsonschema:"required,VPC network for the cluster's private connectivity. The VPC must have Private Service Access configured. Expects a VPC network self-link or resource reference. Immutable after creation."`
	// Name of the allocated IP range for Private Service Access.
	//  When set, the cluster uses this specific IP range for its private
	//  connectivity instead of an auto-allocated range. This is common in
	//  enterprise setups where IP ranges are pre-planned.
	AllocatedIpRange string `json:"allocated_ip_range,omitempty" jsonschema:"Name of the allocated IP range for Private Service Access. When set; the cluster uses this specific IP range for its private connectivity instead of an auto-allocated range. This is common in enterpri..."`
	// PostgreSQL major version for the cluster.
	//  Supported values: "POSTGRES_14", "POSTGRES_15", "POSTGRES_16".
	//  If not specified, GCP selects the latest stable version.
	DatabaseVersion string `json:"database_version,omitempty" jsonschema:"PostgreSQL major version for the cluster. Supported values: 'POSTGRES_14'; 'POSTGRES_15'; 'POSTGRES_16'. If not specified; GCP selects the latest stable version."`
	// Human-readable display name for the cluster.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable display name for the cluster."`
	// Initial database user created during cluster provisioning.
	//  If not specified, no initial user is created. Access must then be
	//  configured via AlloyDB Auth Proxy with IAM authentication.
	InitialUser *GcpAlloydbClusterInitialUserInput `json:"initial_user,omitempty" jsonschema:"Initial database user created during cluster provisioning. If not specified; no initial user is created. Access must then be configured via AlloyDB Auth Proxy with IAM authentication."`
	// Automated backup policy for periodic snapshot backups.
	//  When not specified, GCP uses its default policy (enabled, daily, 14-day retention).
	AutomatedBackupPolicy *GcpAlloydbClusterAutomatedBackupPolicyInput `json:"automated_backup_policy,omitempty" jsonschema:"Automated backup policy for periodic snapshot backups. When not specified; GCP uses its default policy (enabled; daily; 14-day retention)."`
	// Continuous backup configuration for point-in-time recovery (PITR).
	//  Enabled by default with a 14-day recovery window.
	ContinuousBackupConfig *GcpAlloydbClusterContinuousBackupConfigInput `json:"continuous_backup_config,omitempty" jsonschema:"Continuous backup configuration for point-in-time recovery (PITR). Enabled by default with a 14-day recovery window."`
	// Cloud KMS key for encrypting the cluster's data at rest (CMEK).
	//  Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
	//  If not specified, data is encrypted with Google-managed keys.
	//  Immutable after creation.
	KmsKeyName string `json:"kms_key_name,omitempty" jsonschema:"Cloud KMS key for encrypting the cluster's data at rest (CMEK). Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key} If not specified; data is encrypted with Google-mana..."`
	// Preferred maintenance window for system updates.
	MaintenanceWindow *GcpAlloydbClusterMaintenanceWindowInput `json:"maintenance_window,omitempty" jsonschema:"Preferred maintenance window for system updates."`
	// Whether deletion protection is enabled. When true (the default),
	//  the cluster cannot be destroyed without first setting this to false.
	//  Strongly recommended for production clusters.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"Whether deletion protection is enabled. When true (the default); the cluster cannot be destroyed without first setting this to false. Strongly recommended for production clusters."`
	// Primary instance configuration. Required -- a cluster without a
	//  primary instance cannot serve queries.
	PrimaryInstance *GcpAlloydbClusterPrimaryInstanceInput `json:"primary_instance" jsonschema:"required,Primary instance configuration. Required -- a cluster without a primary instance cannot serve queries."`
}

func (s *GcpAlloydbClusterSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.Network == "" {
		return fmt.Errorf("network is required")
	}
	if s.InitialUser != nil {
		if err := s.InitialUser.validate(); err != nil {
			return fmt.Errorf("initial_user: %w", err)
		}
	}
	if s.AutomatedBackupPolicy != nil {
		if err := s.AutomatedBackupPolicy.validate(); err != nil {
			return fmt.Errorf("automated_backup_policy: %w", err)
		}
	}
	if s.ContinuousBackupConfig != nil {
		if err := s.ContinuousBackupConfig.validate(); err != nil {
			return fmt.Errorf("continuous_backup_config: %w", err)
		}
	}
	if s.MaintenanceWindow != nil {
		if err := s.MaintenanceWindow.validate(); err != nil {
			return fmt.Errorf("maintenance_window: %w", err)
		}
	}
	if s.PrimaryInstance == nil {
		return fmt.Errorf("primary_instance is required")
	}
	if s.PrimaryInstance != nil {
		if err := s.PrimaryInstance.validate(); err != nil {
			return fmt.Errorf("primary_instance: %w", err)
		}
	}
	return nil
}

func (s *GcpAlloydbClusterSpecInput) applyDefaults() {
	if s.InitialUser != nil {
		s.InitialUser.applyDefaults()
	}
	if s.AutomatedBackupPolicy != nil {
		s.AutomatedBackupPolicy.applyDefaults()
	}
	if s.ContinuousBackupConfig != nil {
		s.ContinuousBackupConfig.applyDefaults()
	}
	if s.MaintenanceWindow != nil {
		s.MaintenanceWindow.applyDefaults()
	}
	if s.PrimaryInstance != nil {
		s.PrimaryInstance.applyDefaults()
	}
}

func (s *GcpAlloydbClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["cluster_name"] = s.ClusterName
	m["location"] = s.Location
	m["network"] = s.Network
	if s.AllocatedIpRange != "" {
		m["allocated_ip_range"] = s.AllocatedIpRange
	}
	if s.DatabaseVersion != "" {
		m["database_version"] = s.DatabaseVersion
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.InitialUser != nil {
		m["initial_user"] = s.InitialUser.toMap()
	}
	if s.AutomatedBackupPolicy != nil {
		m["automated_backup_policy"] = s.AutomatedBackupPolicy.toMap()
	}
	if s.ContinuousBackupConfig != nil {
		m["continuous_backup_config"] = s.ContinuousBackupConfig.toMap()
	}
	if s.KmsKeyName != "" {
		m["kms_key_name"] = s.KmsKeyName
	}
	if s.MaintenanceWindow != nil {
		m["maintenance_window"] = s.MaintenanceWindow.toMap()
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if s.PrimaryInstance != nil {
		m["primary_instance"] = s.PrimaryInstance.toMap()
	}
	return m
}

// GcpAlloydbClusterAutomatedBackupPolicy configures periodic snapshot backups
//
//	for the AlloyDB cluster. These are point-in-time full backups stored in
//	the specified (or default) location.
//
//	When this block is not specified, GCP uses its default automated backup
//	policy (enabled, daily, 14-day time-based retention).
//
//	Retention can be either quantity-based (keep N backups) or time-based
//	(keep backups for N seconds). These are mutually exclusive.
type GcpAlloydbClusterAutomatedBackupPolicyInput struct {
	// Whether automated backups are enabled. Set to false to explicitly
	//  disable automated backups.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether automated backups are enabled. Set to false to explicitly disable automated backups."`
	// Length of the time window during which a backup can be taken.
	//  Duration in seconds with 's' suffix, e.g., "3600s" (1 hour).
	//  Default: "3600s".
	BackupWindow string `json:"backup_window,omitempty" jsonschema:"Length of the time window during which a backup can be taken. Duration in seconds with 's' suffix; e.g.; '3600s' (1 hour). Default: '3600s'."`
	// GCP region where backups will be stored. If not specified,
	//  backups are stored in the same region as the cluster.
	Location string `json:"location,omitempty" jsonschema:"GCP region where backups will be stored. If not specified; backups are stored in the same region as the cluster."`
	// Number of backups to retain. Mutually exclusive with
	//  time_based_retention_period.
	QuantityBasedRetentionCount int32 `json:"quantity_based_retention_count,omitempty" jsonschema:"Number of backups to retain. Mutually exclusive with time_based_retention_period."`
	// How long to retain backups. Duration in seconds with 's' suffix,
	//  e.g., "1209600s" (14 days). Mutually exclusive with
	//  quantity_based_retention_count.
	TimeBasedRetentionPeriod string `json:"time_based_retention_period,omitempty" jsonschema:"How long to retain backups. Duration in seconds with 's' suffix; e.g.; '1209600s' (14 days). Mutually exclusive with quantity_based_retention_count."`
	// Weekly schedule defining when backups are taken.
	WeeklySchedule *GcpAlloydbClusterBackupScheduleInput `json:"weekly_schedule,omitempty" jsonschema:"Weekly schedule defining when backups are taken."`
	// Cloud KMS key for encrypting automated backups. If not specified,
	//  backups use Google-managed encryption. When using a different key
	//  from the cluster's encryption, this enables independent backup
	//  encryption lifecycle management.
	EncryptionKmsKeyName string `json:"encryption_kms_key_name,omitempty" jsonschema:"Cloud KMS key for encrypting automated backups. If not specified; backups use Google-managed encryption. When using a different key from the cluster's encryption; this enables independent backup encry..."`
}

func (s *GcpAlloydbClusterAutomatedBackupPolicyInput) validate() error {
	if s.WeeklySchedule != nil {
		if err := s.WeeklySchedule.validate(); err != nil {
			return fmt.Errorf("weekly_schedule: %w", err)
		}
	}
	return nil
}

func (s *GcpAlloydbClusterAutomatedBackupPolicyInput) applyDefaults() {
	if s.WeeklySchedule != nil {
		s.WeeklySchedule.applyDefaults()
	}
}

func (s *GcpAlloydbClusterAutomatedBackupPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.BackupWindow != "" {
		m["backup_window"] = s.BackupWindow
	}
	if s.Location != "" {
		m["location"] = s.Location
	}
	if s.QuantityBasedRetentionCount != 0 {
		m["quantity_based_retention_count"] = s.QuantityBasedRetentionCount
	}
	if s.TimeBasedRetentionPeriod != "" {
		m["time_based_retention_period"] = s.TimeBasedRetentionPeriod
	}
	if s.WeeklySchedule != nil {
		m["weekly_schedule"] = s.WeeklySchedule.toMap()
	}
	if s.EncryptionKmsKeyName != "" {
		m["encryption_kms_key_name"] = s.EncryptionKmsKeyName
	}
	return m
}

// GcpAlloydbClusterBackupSchedule defines when automated backups are taken.
//
//	AlloyDB supports weekly schedules with configurable start times.
type GcpAlloydbClusterBackupScheduleInput struct {
	// Days of the week to take backups.
	//  If not specified, GCP defaults to daily backups.
	DaysOfWeek []string `json:"days_of_week,omitempty" jsonschema:"Days of the week to take backups. If not specified; GCP defaults to daily backups."`
	// Hour of day (0-23 UTC) to start backups. GCP's TimeOfDay structure
	//  is simplified here since minutes/seconds/nanos are always zero for
	//  AlloyDB backup schedules.
	StartHour int32 `json:"start_hour,omitempty" jsonschema:"Hour of day (0-23 UTC) to start backups. GCP's TimeOfDay structure is simplified here since minutes/seconds/nanos are always zero for AlloyDB backup schedules."`
}

func (s *GcpAlloydbClusterBackupScheduleInput) validate() error {
	return nil
}

func (s *GcpAlloydbClusterBackupScheduleInput) applyDefaults() {
}

func (s *GcpAlloydbClusterBackupScheduleInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.DaysOfWeek) > 0 {
		m["days_of_week"] = s.DaysOfWeek
	}
	if s.StartHour != 0 {
		m["start_hour"] = s.StartHour
	}
	return m
}

// GcpAlloydbClusterContinuousBackupConfig configures continuous backup
//
//	(write-ahead log streaming) that enables point-in-time recovery (PITR).
//
//	Continuous backup is enabled by default with a 14-day recovery window.
//	This is separate from automated backups: automated backups are periodic
//	snapshots, while continuous backups capture every write for PITR.
type GcpAlloydbClusterContinuousBackupConfigInput struct {
	// Whether continuous backup is enabled. Defaults to true.
	//  Set to false only if you do not need point-in-time recovery.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether continuous backup is enabled. Defaults to true. Set to false only if you do not need point-in-time recovery."`
	// Number of days for which continuous backup data is retained,
	//  enabling PITR within this window. Range: 1-35. Default: 14.
	RecoveryWindowDays int32 `json:"recovery_window_days,omitempty" jsonschema:"Number of days for which continuous backup data is retained; enabling PITR within this window. Range: 1-35. Default: 14."`
	// Cloud KMS key for encrypting continuous backup data. If not specified,
	//  continuous backups use Google-managed encryption.
	EncryptionKmsKeyName string `json:"encryption_kms_key_name,omitempty" jsonschema:"Cloud KMS key for encrypting continuous backup data. If not specified; continuous backups use Google-managed encryption."`
}

func (s *GcpAlloydbClusterContinuousBackupConfigInput) validate() error {
	return nil
}

func (s *GcpAlloydbClusterContinuousBackupConfigInput) applyDefaults() {
}

func (s *GcpAlloydbClusterContinuousBackupConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.RecoveryWindowDays != 0 {
		m["recovery_window_days"] = s.RecoveryWindowDays
	}
	if s.EncryptionKmsKeyName != "" {
		m["encryption_kms_key_name"] = s.EncryptionKmsKeyName
	}
	return m
}

// GcpAlloydbClusterInitialUser defines the initial database superuser
//
//	created during cluster provisioning. AlloyDB is PostgreSQL-compatible,
//	so this user has full superuser privileges in the cluster.
//
//	If not specified, no initial user is created and access must be configured
//	manually after provisioning (e.g., via AlloyDB Auth Proxy + IAM).
type GcpAlloydbClusterInitialUserInput struct {
	// Password for the initial user. Must be at least 8 characters.
	//  This value is sensitive and should be handled accordingly.
	Password string `json:"password" jsonschema:"required,Password for the initial user. Must be at least 8 characters. This value is sensitive and should be handled accordingly."`
	// Username for the initial user. If not specified, defaults to "postgres"
	//  per GCP AlloyDB conventions.
	User string `json:"user,omitempty" jsonschema:"Username for the initial user. If not specified; defaults to 'postgres' per GCP AlloyDB conventions."`
}

func (s *GcpAlloydbClusterInitialUserInput) validate() error {
	if s.Password == "" {
		return fmt.Errorf("password is required")
	}
	return nil
}

func (s *GcpAlloydbClusterInitialUserInput) applyDefaults() {
}

func (s *GcpAlloydbClusterInitialUserInput) toMap() map[string]any {
	m := make(map[string]any)
	m["password"] = s.Password
	if s.User != "" {
		m["user"] = s.User
	}
	return m
}

// GcpAlloydbClusterMaintenanceWindow defines the preferred time for
//
//	GCP to apply system updates and patches to the AlloyDB cluster.
//	Currently AlloyDB supports a single maintenance window per cluster.
type GcpAlloydbClusterMaintenanceWindowInput struct {
	// Day of the week for maintenance.
	Day string `json:"day" jsonschema:"required,Day of the week for maintenance."`
	// Hour of day (0-23, UTC) when the maintenance window starts.
	StartHour int32 `json:"start_hour,omitempty" jsonschema:"Hour of day (0-23; UTC) when the maintenance window starts."`
}

func (s *GcpAlloydbClusterMaintenanceWindowInput) validate() error {
	if s.Day == "" {
		return fmt.Errorf("day is required")
	}
	return nil
}

func (s *GcpAlloydbClusterMaintenanceWindowInput) applyDefaults() {
}

func (s *GcpAlloydbClusterMaintenanceWindowInput) toMap() map[string]any {
	m := make(map[string]any)
	m["day"] = s.Day
	if s.StartHour != 0 {
		m["start_hour"] = s.StartHour
	}
	return m
}

// GcpAlloydbClusterPrimaryInstance defines the configuration for the
//
//	primary compute instance bundled with the AlloyDB cluster.
//
//	A cluster without a primary instance cannot serve queries. This is why
//	the primary instance is bundled rather than being a separate component.
//	Read pool instances have independent scaling lifecycles and are NOT
//	included here.
//
//	Machine configuration can be specified via either cpu_count (simpler,
//	lets GCP choose the machine family) or machine_type (explicit machine
//	family selection). These are mutually exclusive.
type GcpAlloydbClusterPrimaryInstanceInput struct {
	// ID for the primary instance. This becomes the GCP resource name.
	//  Must start with a lowercase letter, can contain lowercase letters,
	//  numbers, and hyphens, and must end with a lowercase letter or number.
	//  Maximum 63 characters. Immutable after creation.
	InstanceId string `json:"instance_id" jsonschema:"required,ID for the primary instance. This becomes the GCP resource name. Must start with a lowercase letter; can contain lowercase letters; numbers; and hyphens; and must end with a lowercase letter or number..."`
	// Number of CPUs for the instance. Valid values: 2, 4, 8, 16, 32, 64, 96, 128.
	//  GCP selects the appropriate machine family automatically.
	//  Mutually exclusive with machine_type.
	CpuCount int32 `json:"cpu_count,omitempty" jsonschema:"Number of CPUs for the instance. Valid values: 2; 4; 8; 16; 32; 64; 96; 128. GCP selects the appropriate machine family automatically. Mutually exclusive with machine_type."`
	// Explicit machine type (e.g., "n2-highmem-4", "c4a-highmem-4-lssd").
	//  Use this for advanced scenarios where you need a specific machine family.
	//  Mutually exclusive with cpu_count.
	MachineType string `json:"machine_type,omitempty" jsonschema:"Explicit machine type (e.g.; 'n2-highmem-4'; 'c4a-highmem-4-lssd'). Use this for advanced scenarios where you need a specific machine family. Mutually exclusive with cpu_count."`
	// Availability type controlling the placement of the instance.
	//  ZONAL: single-zone deployment (lower cost, single zone of failure).
	//  REGIONAL: multi-zone deployment with automatic failover (recommended
	//  for production). Default: determined by GCP.
	AvailabilityType string `json:"availability_type,omitempty" jsonschema:"Availability type controlling the placement of the instance. ZONAL: single-zone deployment (lower cost; single zone of failure). REGIONAL: multi-zone deployment with automatic failover (recommended fo..."`
	// PostgreSQL database flags as key-value pairs.
	//  These correspond to PostgreSQL server parameters (e.g.,
	//  "max_connections", "work_mem", "shared_buffers").
	//  See GCP AlloyDB documentation for supported flags.
	DatabaseFlags map[string]string `json:"database_flags,omitempty" jsonschema:"PostgreSQL database flags as key-value pairs. These correspond to PostgreSQL server parameters (e.g.; 'max_connections'; 'work_mem'; 'shared_buffers'). See GCP AlloyDB documentation for supported flag..."`
	// Human-readable display name for the primary instance.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable display name for the primary instance."`
	// Query insights configuration for performance monitoring.
	//  If not specified, GCP uses default query insights settings
	//  (enabled with sensible defaults).
	QueryInsightsConfig *GcpAlloydbClusterQueryInsightsConfigInput `json:"query_insights_config,omitempty" jsonschema:"Query insights configuration for performance monitoring. If not specified; GCP uses default query insights settings (enabled with sensible defaults)."`
	// Whether to require the AlloyDB Auth Proxy or AlloyDB Language Connectors
	//  for all connections. When true, direct IP connections are rejected.
	//  This enforces IAM-based authentication for all database access.
	RequireConnectors bool `json:"require_connectors,omitempty" jsonschema:"Whether to require the AlloyDB Auth Proxy or AlloyDB Language Connectors for all connections. When true; direct IP connections are rejected. This enforces IAM-based authentication for all database acc..."`
	// SSL mode for client connections.
	//  ENCRYPTED_ONLY: all connections must use TLS (recommended for production).
	//  ALLOW_UNENCRYPTED_AND_ENCRYPTED: both TLS and plaintext allowed.
	SslMode string `json:"ssl_mode,omitempty" jsonschema:"SSL mode for client connections. ENCRYPTED_ONLY: all connections must use TLS (recommended for production). ALLOW_UNENCRYPTED_AND_ENCRYPTED: both TLS and plaintext allowed."`
}

func (s *GcpAlloydbClusterPrimaryInstanceInput) validate() error {
	if s.InstanceId == "" {
		return fmt.Errorf("instance_id is required")
	}
	if s.QueryInsightsConfig != nil {
		if err := s.QueryInsightsConfig.validate(); err != nil {
			return fmt.Errorf("query_insights_config: %w", err)
		}
	}
	return nil
}

func (s *GcpAlloydbClusterPrimaryInstanceInput) applyDefaults() {
	if s.QueryInsightsConfig != nil {
		s.QueryInsightsConfig.applyDefaults()
	}
}

func (s *GcpAlloydbClusterPrimaryInstanceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["instance_id"] = s.InstanceId
	if s.CpuCount != 0 {
		m["cpu_count"] = s.CpuCount
	}
	if s.MachineType != "" {
		m["machine_type"] = s.MachineType
	}
	if s.AvailabilityType != "" {
		m["availability_type"] = s.AvailabilityType
	}
	if len(s.DatabaseFlags) > 0 {
		m["database_flags"] = s.DatabaseFlags
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.QueryInsightsConfig != nil {
		m["query_insights_config"] = s.QueryInsightsConfig.toMap()
	}
	if s.RequireConnectors {
		m["require_connectors"] = s.RequireConnectors
	}
	if s.SslMode != "" {
		m["ssl_mode"] = s.SslMode
	}
	return m
}

// GcpAlloydbClusterQueryInsightsConfig configures query performance
//
//	monitoring for the primary instance. Query insights captures execution
//	plans, application context, and client information to help diagnose
//	slow queries and performance issues.
type GcpAlloydbClusterQueryInsightsConfigInput struct {
	// Number of query execution plans captured per minute.
	//  Range: 0-20. Default: 5. Set to 0 to disable plan capture.
	QueryPlansPerMinute int32 `json:"query_plans_per_minute,omitempty" jsonschema:"Number of query execution plans captured per minute. Range: 0-20. Default: 5. Set to 0 to disable plan capture."`
	// Maximum length of the query string stored in insights.
	//  Range: 256-4500. Default: 1024. Longer strings help debug
	//  complex queries but use more storage.
	QueryStringLength int32 `json:"query_string_length,omitempty" jsonschema:"Maximum length of the query string stored in insights. Range: 256-4500. Default: 1024. Longer strings help debug complex queries but use more storage."`
	// Whether to record application tags set via
	//  pg_stat_statements.track_activity_query_size.
	//  Useful for tagging queries by application or feature.
	RecordApplicationTags bool `json:"record_application_tags,omitempty" jsonschema:"Whether to record application tags set via pg_stat_statements.track_activity_query_size. Useful for tagging queries by application or feature."`
	// Whether to record the client IP address for each query.
	//  Useful for identifying which application instances generate load.
	RecordClientAddress bool `json:"record_client_address,omitempty" jsonschema:"Whether to record the client IP address for each query. Useful for identifying which application instances generate load."`
}

func (s *GcpAlloydbClusterQueryInsightsConfigInput) validate() error {
	return nil
}

func (s *GcpAlloydbClusterQueryInsightsConfigInput) applyDefaults() {
}

func (s *GcpAlloydbClusterQueryInsightsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.QueryPlansPerMinute != 0 {
		m["query_plans_per_minute"] = s.QueryPlansPerMinute
	}
	if s.QueryStringLength != 0 {
		m["query_string_length"] = s.QueryStringLength
	}
	if s.RecordApplicationTags {
		m["record_application_tags"] = s.RecordApplicationTags
	}
	if s.RecordClientAddress {
		m["record_client_address"] = s.RecordClientAddress
	}
	return m
}

// ParseGcpAlloydbCluster validates and normalizes a GcpAlloydbCluster cloud_object.
func ParseGcpAlloydbCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpAlloydbCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpAlloydbClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
