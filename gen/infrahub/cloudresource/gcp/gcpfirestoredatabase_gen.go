// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-firestore-database
type GcpFirestoreDatabaseSpecInput struct {
	// GCP project where the Firestore database will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the Firestore database will be created."`
	// Location of the Firestore database. This determines where data is stored
	//  and affects latency and availability. Immutable after creation.
	//
	//  Multi-region locations: "nam5" (United States), "eur3" (Europe).
	//  Single-region locations: any supported GCP region (e.g., "us-east1",
	//  "europe-west1").
	//
	//  Multi...
	LocationId string `json:"location_id" jsonschema:"required,Location of the Firestore database. This determines where data is stored and affects latency and availability. Immutable after creation. Multi-region locations: 'nam5' (United States); 'eur3' (Europe)..."`
	// Name for the Firestore database. Must be 4-63 characters, start with a
	//  lowercase letter, contain only lowercase letters, digits, and hyphens,
	//  and end with a letter or digit.
	//
	//  The special value "(default)" creates the project's default database.
	//  Only one default database can exist per project. Cl...
	DatabaseName string `json:"database_name" jsonschema:"required,Name for the Firestore database. Must be 4-63 characters; start with a lowercase letter; contain only lowercase letters; digits; and hyphens; and end with a letter or digit. The special value '(defaul..."`
	// Firestore database type. Determines the data model and API surface.
	//
	//  FIRESTORE_NATIVE: Modern Firestore with real-time listeners, offline
	//  support, and the Firestore client library API. Recommended for new
	//  applications.
	//
	//  DATASTORE_MODE: Legacy Datastore-compatible mode with the Datastore
	//  client ...
	Type string `json:"type" jsonschema:"required,Firestore database type. Determines the data model and API surface. FIRESTORE_NATIVE: Modern Firestore with real-time listeners; offline support; and the Firestore client library API. Recommended for ..."`
	// Concurrency control mode for the database. Determines how conflicts
	//  between concurrent reads and writes are resolved.
	//
	//  OPTIMISTIC: Uses optimistic concurrency control. Reads do not block
	//  writes, and writes are validated at commit time. Default for
	//  FIRESTORE_NATIVE databases.
	//
	//  PESSIMISTIC: Uses ...
	ConcurrencyMode string `json:"concurrency_mode,omitempty" jsonschema:"Concurrency control mode for the database. Determines how conflicts between concurrent reads and writes are resolved. OPTIMISTIC: Uses optimistic concurrency control. Reads do not block writes; and wr..."`
	// Whether to enable point-in-time recovery (PITR) for this database.
	//
	//  POINT_IN_TIME_RECOVERY_ENABLED: Retains 7 days of version history.
	//  Reads can target any timestamp within the past hour or any 1-minute
	//  snapshot within the past 7 days.
	//
	//  POINT_IN_TIME_RECOVERY_DISABLED: Retains 1 hour of version ...
	PointInTimeRecoveryEnablement string `json:"point_in_time_recovery_enablement,omitempty" jsonschema:"Whether to enable point-in-time recovery (PITR) for this database. POINT_IN_TIME_RECOVERY_ENABLED: Retains 7 days of version history. Reads can target any timestamp within the past hour or any 1-minut..."`
	// Delete protection for the database. When enabled, the database cannot
	//  be deleted through any interface (Console, gcloud, API, IaC tools)
	//  until protection is disabled.
	//
	//  Defaults to DELETE_PROTECTION_DISABLED.
	DeleteProtectionState string `json:"delete_protection_state,omitempty" jsonschema:"Delete protection for the database. When enabled; the database cannot be deleted through any interface (Console; gcloud; API; IaC tools) until protection is disabled. Defaults to DELETE_PROTECTION_DIS..."`
	// Database edition. Determines the feature set and SLA tier.
	//
	//  STANDARD: Default edition suitable for most workloads. Provides
	//  standard Firestore features and SLA.
	//
	//  ENTERPRISE: Enhanced edition with higher availability SLA, advanced
	//  security features, and support for additional data access modes.
	//  ...
	DatabaseEdition string `json:"database_edition,omitempty" jsonschema:"Database edition. Determines the feature set and SLA tier. STANDARD: Default edition suitable for most workloads. Provides standard Firestore features and SLA. ENTERPRISE: Enhanced edition with higher..."`
	// Fully qualified name of the KMS key to use for customer-managed
	//  encryption (CMEK). The key must exist in the same location as the
	//  database. Immutable after creation.
	//
	//  For multi-region databases: nam5 requires a Cloud KMS key in the
	//  "us" multi-region; eur3 requires a key in the "europe" multi-reg...
	KmsKeyName string `json:"kms_key_name,omitempty" jsonschema:"Fully qualified name of the KMS key to use for customer-managed encryption (CMEK). The key must exist in the same location as the database. Immutable after creation. For multi-region databases: nam5 r..."`
}

func (s *GcpFirestoreDatabaseSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.LocationId == "" {
		return fmt.Errorf("location_id is required")
	}
	if s.DatabaseName == "" {
		return fmt.Errorf("database_name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *GcpFirestoreDatabaseSpecInput) applyDefaults() {
	if s.DeleteProtectionState == "" {
		s.DeleteProtectionState = "DELETE_PROTECTION_DISABLED"
	}
}

func (s *GcpFirestoreDatabaseSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["location_id"] = s.LocationId
	m["database_name"] = s.DatabaseName
	m["type"] = s.Type
	if s.ConcurrencyMode != "" {
		m["concurrency_mode"] = s.ConcurrencyMode
	}
	if s.PointInTimeRecoveryEnablement != "" {
		m["point_in_time_recovery_enablement"] = s.PointInTimeRecoveryEnablement
	}
	if s.DeleteProtectionState != "" {
		m["delete_protection_state"] = s.DeleteProtectionState
	}
	if s.DatabaseEdition != "" {
		m["database_edition"] = s.DatabaseEdition
	}
	if s.KmsKeyName != "" {
		m["kms_key_name"] = s.KmsKeyName
	}
	return m
}

// ParseGcpFirestoreDatabase validates and normalizes a GcpFirestoreDatabase cloud_object.
func ParseGcpFirestoreDatabase(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpFirestoreDatabase"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpFirestoreDatabaseSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
