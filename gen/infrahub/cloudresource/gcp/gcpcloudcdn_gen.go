// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-cdn
type GcpCloudCdnSpecInput struct {
	// The ID of the GCP project where the Cloud CDN resources will be created.
	//  This field supports cross-resource references using ValueFrom to dynamically
	//  retrieve the project ID from a GcpProject resource.
	//  Required field.
	GcpProjectId string `json:"gcp_project_id" jsonschema:"required,The ID of the GCP project where the Cloud CDN resources will be created. This field supports cross-resource references using ValueFrom to dynamically retrieve the project ID from a GcpProject resource..."`
	// Backend configuration defines the origin server that Cloud CDN will cache content from.
	//  This can be a GCS bucket, Compute Engine service, Cloud Run, or external origin.
	//  Required field.
	Backend *GcpCloudCdnBackendInput `json:"backend" jsonschema:"required,Backend configuration defines the origin server that Cloud CDN will cache content from. This can be a GCS bucket; Compute Engine service; Cloud Run; or external origin. Required field."`
	// Cache mode determines what content gets cached and when to trust origin headers.
	//  CACHE_ALL_STATIC (default): Automatically caches common static file types and respects Cache-Control headers.
	//  USE_ORIGIN_HEADERS: Only caches content with valid Cache-Control or Expires headers from origin.
	//  FORCE_CAC...
	CacheMode string `json:"cache_mode,omitempty" jsonschema:"enum=CACHE_ALL_STATIC|USE_ORIGIN_HEADERS|FORCE_CACHE_ALL,Cache mode determines what content gets cached and when to trust origin headers. CACHE_ALL_STATIC (default): Automatically caches common static file types and respects Cache-Control headers. USE_ORIGI..."`
	// Default Time-To-Live (TTL) in seconds for cached content when origin doesn't specify Cache-Control.
	//  Recommended: 3600 (1 hour) for most use cases.
	//  Optional field. If not set, GCP uses default of 3600 seconds.
	DefaultTtlSeconds int32 `json:"default_ttl_seconds,omitempty" jsonschema:"Default Time-To-Live (TTL) in seconds for cached content when origin doesn't specify Cache-Control. Recommended: 3600 (1 hour) for most use cases. Optional field. If not set; GCP uses default of 3600 ..."`
	// Maximum TTL in seconds. This is a hard ceiling that overrides origin Cache-Control headers.
	//  Recommended: 86400 (1 day) to balance freshness and cache hit ratio.
	//  Optional field. If not set, GCP uses default of 86400 seconds.
	MaxTtlSeconds int32 `json:"max_ttl_seconds,omitempty" jsonschema:"Maximum TTL in seconds. This is a hard ceiling that overrides origin Cache-Control headers. Recommended: 86400 (1 day) to balance freshness and cache hit ratio. Optional field. If not set; GCP uses de..."`
	// Client TTL in seconds. Overrides max-age directive for browser caches.
	//  Use this to set different cache duration for browsers vs edge caches.
	//  Optional field. If not set, uses max_ttl_seconds.
	ClientTtlSeconds int32 `json:"client_ttl_seconds,omitempty" jsonschema:"Client TTL in seconds. Overrides max-age directive for browser caches. Use this to set different cache duration for browsers vs edge caches. Optional field. If not set; uses max_ttl_seconds."`
	// Enable caching of HTTP 4xx/5xx error responses to prevent origin overload during failures.
	//  Recommended: true (best practice to cache 404s and 5xx errors).
	//  Default: false.
	EnableNegativeCaching bool `json:"enable_negative_caching,omitempty" jsonschema:"Enable caching of HTTP 4xx/5xx error responses to prevent origin overload during failures. Recommended: true (best practice to cache 404s and 5xx errors). Default: false."`
	// Advanced cache configuration (20% of use cases).
	//  Configure cache keys, signed URLs, and granular caching policies.
	AdvancedConfig *GcpCloudCdnAdvancedConfigInput `json:"advanced_config,omitempty" jsonschema:"Advanced cache configuration (20% of use cases). Configure cache keys; signed URLs; and granular caching policies."`
	// Load balancer frontend configuration (SSL certificates, domains, Cloud Armor).
	//  If not specified, creates a basic load balancer with auto-generated HTTPS setup.
	FrontendConfig *GcpCloudCdnFrontendConfigInput `json:"frontend_config,omitempty" jsonschema:"Load balancer frontend configuration (SSL certificates; domains; Cloud Armor). If not specified; creates a basic load balancer with auto-generated HTTPS setup."`
}

func (s *GcpCloudCdnSpecInput) validate() error {
	if s.GcpProjectId == "" {
		return fmt.Errorf("gcp_project_id is required")
	}
	if s.Backend == nil {
		return fmt.Errorf("backend is required")
	}
	if s.Backend != nil {
		if err := s.Backend.validate(); err != nil {
			return fmt.Errorf("backend: %w", err)
		}
	}
	switch s.CacheMode {
	case "", "CACHE_ALL_STATIC", "USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL":
	default:
		return fmt.Errorf("invalid cache_mode: %q", s.CacheMode)
	}
	if s.AdvancedConfig != nil {
		if err := s.AdvancedConfig.validate(); err != nil {
			return fmt.Errorf("advanced_config: %w", err)
		}
	}
	if s.FrontendConfig != nil {
		if err := s.FrontendConfig.validate(); err != nil {
			return fmt.Errorf("frontend_config: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudCdnSpecInput) applyDefaults() {
	if s.Backend != nil {
		s.Backend.applyDefaults()
	}
	if s.AdvancedConfig != nil {
		s.AdvancedConfig.applyDefaults()
	}
	if s.FrontendConfig != nil {
		s.FrontendConfig.applyDefaults()
	}
}

func (s *GcpCloudCdnSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["gcp_project_id"] = s.GcpProjectId
	if s.Backend != nil {
		m["backend"] = s.Backend.toMap()
	}
	if s.CacheMode != "" {
		m["cache_mode"] = s.CacheMode
	}
	if s.DefaultTtlSeconds != 0 {
		m["default_ttl_seconds"] = s.DefaultTtlSeconds
	}
	if s.MaxTtlSeconds != 0 {
		m["max_ttl_seconds"] = s.MaxTtlSeconds
	}
	if s.ClientTtlSeconds != 0 {
		m["client_ttl_seconds"] = s.ClientTtlSeconds
	}
	if s.EnableNegativeCaching {
		m["enable_negative_caching"] = s.EnableNegativeCaching
	}
	if s.AdvancedConfig != nil {
		m["advanced_config"] = s.AdvancedConfig.toMap()
	}
	if s.FrontendConfig != nil {
		m["frontend_config"] = s.FrontendConfig.toMap()
	}
	return m
}

// **CacheKeyPolicy** controls what attributes are included in the cache key.
//
//	The cache key determines whether two requests share the same cached response.
//	Default: Protocol + Host + Path + Query String.
type CacheKeyPolicyInput struct {
	// Include URL query string in cache key.
	//  Set to false if query parameters don't affect response content (e.g., analytics parameters).
	//  Default: true.
	IncludeQueryString bool `json:"include_query_string,omitempty" jsonschema:"Include URL query string in cache key. Set to false if query parameters don't affect response content (e.g.; analytics parameters). Default: true."`
	// Whitelist of query parameters to include in cache key.
	//  All other query parameters are ignored, preventing cache shattering.
	//  Example: ["version", "lang", "page"] - only these params affect caching.
	//  If empty, includes all query parameters (when include_query_string = true).
	QueryStringWhitelist []string `json:"query_string_whitelist,omitempty" jsonschema:"Whitelist of query parameters to include in cache key. All other query parameters are ignored; preventing cache shattering. Example: ['version'; 'lang'; 'page'] - only these params affect caching. If ..."`
	// Include request protocol (HTTP vs HTTPS) in cache key.
	//  Default: true (recommended to keep separate caches for HTTP and HTTPS).
	IncludeProtocol bool `json:"include_protocol,omitempty" jsonschema:"Include request protocol (HTTP vs HTTPS) in cache key. Default: true (recommended to keep separate caches for HTTP and HTTPS)."`
	// Include Host header in cache key.
	//  Set to false if serving the same content for multiple hostnames.
	//  Default: true.
	IncludeHost bool `json:"include_host,omitempty" jsonschema:"Include Host header in cache key. Set to false if serving the same content for multiple hostnames. Default: true."`
	// Include specific request headers in the cache key.
	//  Use sparingly - too many headers in cache key leads to cache shattering.
	//  Cloud CDN only supports: Accept, Accept-Encoding, Origin.
	IncludedHeaders []string `json:"included_headers,omitempty" jsonschema:"Include specific request headers in the cache key. Use sparingly - too many headers in cache key leads to cache shattering. Cloud CDN only supports: Accept; Accept-Encoding; Origin."`
}

func (s *CacheKeyPolicyInput) validate() error {
	return nil
}

func (s *CacheKeyPolicyInput) applyDefaults() {
}

func (s *CacheKeyPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IncludeQueryString {
		m["include_query_string"] = s.IncludeQueryString
	}
	if len(s.QueryStringWhitelist) > 0 {
		m["query_string_whitelist"] = s.QueryStringWhitelist
	}
	if s.IncludeProtocol {
		m["include_protocol"] = s.IncludeProtocol
	}
	if s.IncludeHost {
		m["include_host"] = s.IncludeHost
	}
	if len(s.IncludedHeaders) > 0 {
		m["included_headers"] = s.IncludedHeaders
	}
	return m
}

// **CloudArmorConfig** enables Google Cloud Armor (WAF and DDoS protection).
type CloudArmorConfigInput struct {
	// Enable Cloud Armor protection.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable Cloud Armor protection."`
	// Name of existing Cloud Armor security policy to attach.
	//  The policy must exist in the same GCP project.
	//  Required when enabled = true.
	SecurityPolicyName string `json:"security_policy_name,omitempty" jsonschema:"Name of existing Cloud Armor security policy to attach. The policy must exist in the same GCP project. Required when enabled = true."`
}

func (s *CloudArmorConfigInput) validate() error {
	return nil
}

func (s *CloudArmorConfigInput) applyDefaults() {
}

func (s *CloudArmorConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.SecurityPolicyName != "" {
		m["security_policy_name"] = s.SecurityPolicyName
	}
	return m
}

// **CloudRunBackendConfig** configures Cloud Run as the CDN origin.
//
//	Automatically creates a Serverless Network Endpoint Group for the Cloud Run service.
type CloudRunBackendConfigInput struct {
	// Name of the Cloud Run service to use as backend.
	//  The service must be deployed in the same GCP project.
	//  Required field.
	ServiceName string `json:"service_name" jsonschema:"required,Name of the Cloud Run service to use as backend. The service must be deployed in the same GCP project. Required field."`
	// GCP region where the Cloud Run service is deployed.
	//  Required field.
	Region string `json:"region" jsonschema:"required,GCP region where the Cloud Run service is deployed. Required field."`
}

func (s *CloudRunBackendConfigInput) validate() error {
	if s.ServiceName == "" {
		return fmt.Errorf("service_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	return nil
}

func (s *CloudRunBackendConfigInput) applyDefaults() {
}

func (s *CloudRunBackendConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_name"] = s.ServiceName
	m["region"] = s.Region
	return m
}

// **ComputeBackendConfig** configures Compute Engine as the CDN origin.
//
//	Use this for VM-based web applications and APIs.
type ComputeBackendConfigInput struct {
	// Name of the Managed Instance Group to use as backend.
	//  Required field.
	InstanceGroupName string `json:"instance_group_name" jsonschema:"required,Name of the Managed Instance Group to use as backend. Required field."`
	// Health check configuration for the backend instances.
	//  If not specified, creates a default HTTP health check.
	HealthCheck *HealthCheckConfigInput `json:"health_check,omitempty" jsonschema:"Health check configuration for the backend instances. If not specified; creates a default HTTP health check."`
	// Backend protocol (HTTP or HTTPS).
	//  Default: HTTP.
	Protocol string `json:"protocol,omitempty" jsonschema:"enum=HTTP|HTTPS,Backend protocol (HTTP or HTTPS). Default: HTTP."`
	// Port number where backend instances serve traffic.
	//  Default: 80 for HTTP, 443 for HTTPS.
	Port int32 `json:"port,omitempty" jsonschema:"Port number where backend instances serve traffic. Default: 80 for HTTP; 443 for HTTPS."`
}

func (s *ComputeBackendConfigInput) validate() error {
	if s.InstanceGroupName == "" {
		return fmt.Errorf("instance_group_name is required")
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	switch s.Protocol {
	case "", "HTTP", "HTTPS":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	return nil
}

func (s *ComputeBackendConfigInput) applyDefaults() {
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *ComputeBackendConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["instance_group_name"] = s.InstanceGroupName
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	return m
}

// **ExternalBackendConfig** configures an external origin (outside GCP).
//
//	Use this for hybrid/multi-cloud deployments or gradual migration to GCP.
type ExternalBackendConfigInput struct {
	// Fully qualified domain name (FQDN) or IP address of the external origin.
	//  Required field.
	Hostname string `json:"hostname" jsonschema:"required,Fully qualified domain name (FQDN) or IP address of the external origin. Required field."`
	// Port number where the external origin serves traffic.
	//  Default: 443 for HTTPS, 80 for HTTP.
	Port int32 `json:"port,omitempty" jsonschema:"Port number where the external origin serves traffic. Default: 443 for HTTPS; 80 for HTTP."`
	// Protocol for connecting to external origin.
	//  Default: HTTPS (recommended for security).
	Protocol string `json:"protocol,omitempty" jsonschema:"enum=HTTP|HTTPS,Protocol for connecting to external origin. Default: HTTPS (recommended for security)."`
}

func (s *ExternalBackendConfigInput) validate() error {
	if s.Hostname == "" {
		return fmt.Errorf("hostname is required")
	}
	switch s.Protocol {
	case "", "HTTP", "HTTPS":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	return nil
}

func (s *ExternalBackendConfigInput) applyDefaults() {
}

func (s *ExternalBackendConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["hostname"] = s.Hostname
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	return m
}

// **GcpCloudCdnAdvancedConfig** contains advanced CDN configuration options (20% use cases).
//
//	These settings provide fine-grained control over caching behavior, security, and optimization.
type GcpCloudCdnAdvancedConfigInput struct {
	// Cache key policy controls what request attributes are included in the cache key.
	//  Tune this to avoid "cache shattering" (too many unique cache keys with low hit ratio).
	CacheKeyPolicy *CacheKeyPolicyInput `json:"cache_key_policy,omitempty" jsonschema:"Cache key policy controls what request attributes are included in the cache key. Tune this to avoid 'cache shattering' (too many unique cache keys with low hit ratio)."`
	// Signed URL configuration for serving private/paid content via Cloud CDN.
	//  Enables time-limited, cryptographically signed URLs for access control.
	SignedUrlConfig *SignedUrlConfigInput `json:"signed_url_config,omitempty" jsonschema:"Signed URL configuration for serving private/paid content via Cloud CDN. Enables time-limited; cryptographically signed URLs for access control."`
	// Negative caching policies per HTTP status code.
	//  Allows granular control over error response caching (e.g., cache 404 for 10 minutes, 503 for 1 minute).
	NegativeCachingPolicies []*NegativeCachingPolicyInput `json:"negative_caching_policies,omitempty" jsonschema:"Negative caching policies per HTTP status code. Allows granular control over error response caching (e.g.; cache 404 for 10 minutes; 503 for 1 minute)."`
	// Serve stale content while revalidating with origin (RFC 5861 stale-while-revalidate).
	//  Improves performance by serving cached content immediately while fetching fresh content in background.
	//  Value in seconds. Default: 0 (disabled).
	ServeWhileStaleSeconds int32 `json:"serve_while_stale_seconds,omitempty" jsonschema:"Serve stale content while revalidating with origin (RFC 5861 stale-while-revalidate). Improves performance by serving cached content immediately while fetching fresh content in background. Value in se..."`
	// Request coalescing combines multiple identical requests into one origin fetch.
	//  Reduces origin load during cache misses. Recommended: true.
	//  Default: true.
	EnableRequestCoalescing bool `json:"enable_request_coalescing,omitempty" jsonschema:"Request coalescing combines multiple identical requests into one origin fetch. Reduces origin load during cache misses. Recommended: true. Default: true."`
}

func (s *GcpCloudCdnAdvancedConfigInput) validate() error {
	if s.CacheKeyPolicy != nil {
		if err := s.CacheKeyPolicy.validate(); err != nil {
			return fmt.Errorf("cache_key_policy: %w", err)
		}
	}
	if s.SignedUrlConfig != nil {
		if err := s.SignedUrlConfig.validate(); err != nil {
			return fmt.Errorf("signed_url_config: %w", err)
		}
	}
	for i, v := range s.NegativeCachingPolicies {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("negative_caching_policies[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpCloudCdnAdvancedConfigInput) applyDefaults() {
	if s.CacheKeyPolicy != nil {
		s.CacheKeyPolicy.applyDefaults()
	}
	if s.SignedUrlConfig != nil {
		s.SignedUrlConfig.applyDefaults()
	}
}

func (s *GcpCloudCdnAdvancedConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CacheKeyPolicy != nil {
		m["cache_key_policy"] = s.CacheKeyPolicy.toMap()
	}
	if s.SignedUrlConfig != nil {
		m["signed_url_config"] = s.SignedUrlConfig.toMap()
	}
	if len(s.NegativeCachingPolicies) > 0 {
		items := make([]any, len(s.NegativeCachingPolicies))
		for i, v := range s.NegativeCachingPolicies {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["negative_caching_policies"] = items
	}
	if s.ServeWhileStaleSeconds != 0 {
		m["serve_while_stale_seconds"] = s.ServeWhileStaleSeconds
	}
	if s.EnableRequestCoalescing {
		m["enable_request_coalescing"] = s.EnableRequestCoalescing
	}
	return m
}

// **GcpCloudCdnBackend** defines the origin server configuration for Cloud CDN.
//
//	Cloud CDN supports multiple backend types: GCS buckets (static content),
//	Compute Engine (VMs), Cloud Run (serverless), and external origins.
type GcpCloudCdnBackendInput struct {
	// Google Cloud Storage bucket backend for static website hosting and file downloads.
	//  Most common use case (~80% of deployments).
	GcsBucket *GcsBackendConfigInput `json:"gcs_bucket,omitempty" jsonschema:"Google Cloud Storage bucket backend for static website hosting and file downloads. Most common use case (~80% of deployments)."`
	// Compute Engine backend service for VMs (Managed Instance Groups).
	//  Use for traditional web applications and APIs.
	ComputeService *ComputeBackendConfigInput `json:"compute_service,omitempty" jsonschema:"Compute Engine backend service for VMs (Managed Instance Groups). Use for traditional web applications and APIs."`
	// Cloud Run backend for serverless container workloads.
	//  Automatically creates Serverless Network Endpoint Group (NEG).
	CloudRunService *CloudRunBackendConfigInput `json:"cloud_run_service,omitempty" jsonschema:"Cloud Run backend for serverless container workloads. Automatically creates Serverless Network Endpoint Group (NEG)."`
	// External/hybrid backend for origins outside GCP (AWS S3, on-prem servers).
	//  Uses Internet Network Endpoint Group.
	ExternalOrigin *ExternalBackendConfigInput `json:"external_origin,omitempty" jsonschema:"External/hybrid backend for origins outside GCP (AWS S3; on-prem servers). Uses Internet Network Endpoint Group."`
}

func (s *GcpCloudCdnBackendInput) validate() error {
	if s.GcsBucket != nil {
		if err := s.GcsBucket.validate(); err != nil {
			return fmt.Errorf("gcs_bucket: %w", err)
		}
	}
	if s.ComputeService != nil {
		if err := s.ComputeService.validate(); err != nil {
			return fmt.Errorf("compute_service: %w", err)
		}
	}
	if s.CloudRunService != nil {
		if err := s.CloudRunService.validate(); err != nil {
			return fmt.Errorf("cloud_run_service: %w", err)
		}
	}
	if s.ExternalOrigin != nil {
		if err := s.ExternalOrigin.validate(); err != nil {
			return fmt.Errorf("external_origin: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudCdnBackendInput) applyDefaults() {
	if s.GcsBucket != nil {
		s.GcsBucket.applyDefaults()
	}
	if s.ComputeService != nil {
		s.ComputeService.applyDefaults()
	}
	if s.CloudRunService != nil {
		s.CloudRunService.applyDefaults()
	}
	if s.ExternalOrigin != nil {
		s.ExternalOrigin.applyDefaults()
	}
}

func (s *GcpCloudCdnBackendInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.GcsBucket != nil {
		m["gcs_bucket"] = s.GcsBucket.toMap()
	}
	if s.ComputeService != nil {
		m["compute_service"] = s.ComputeService.toMap()
	}
	if s.CloudRunService != nil {
		m["cloud_run_service"] = s.CloudRunService.toMap()
	}
	if s.ExternalOrigin != nil {
		m["external_origin"] = s.ExternalOrigin.toMap()
	}
	return m
}

// **GcpCloudCdnFrontendConfig** configures the load balancer frontend (SSL, domains, security).
//
//	If not specified, creates a basic HTTPS load balancer with auto-managed certificate.
type GcpCloudCdnFrontendConfigInput struct {
	// Custom domains for the CDN endpoint.
	//  If not specified, uses the default GCP load balancer domain (*.globalgcp.net).
	CustomDomains []string `json:"custom_domains,omitempty" jsonschema:"Custom domains for the CDN endpoint. If not specified; uses the default GCP load balancer domain (*.globalgcp.net)."`
	// SSL certificate configuration.
	//  If not specified, uses Google-managed certificate for custom_domains.
	SslCertificate *SslCertificateConfigInput `json:"ssl_certificate,omitempty" jsonschema:"SSL certificate configuration. If not specified; uses Google-managed certificate for custom_domains."`
	// Enable Cloud Armor (WAF/DDoS protection).
	//  Requires specifying a Cloud Armor security policy.
	CloudArmor *CloudArmorConfigInput `json:"cloud_armor,omitempty" jsonschema:"Enable Cloud Armor (WAF/DDoS protection). Requires specifying a Cloud Armor security policy."`
	// Enable HTTP to HTTPS redirect.
	//  Recommended: true for production deployments.
	//  Default: true.
	EnableHttpsRedirect bool `json:"enable_https_redirect,omitempty" jsonschema:"Enable HTTP to HTTPS redirect. Recommended: true for production deployments. Default: true."`
}

func (s *GcpCloudCdnFrontendConfigInput) validate() error {
	if s.SslCertificate != nil {
		if err := s.SslCertificate.validate(); err != nil {
			return fmt.Errorf("ssl_certificate: %w", err)
		}
	}
	if s.CloudArmor != nil {
		if err := s.CloudArmor.validate(); err != nil {
			return fmt.Errorf("cloud_armor: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudCdnFrontendConfigInput) applyDefaults() {
	if s.SslCertificate != nil {
		s.SslCertificate.applyDefaults()
	}
	if s.CloudArmor != nil {
		s.CloudArmor.applyDefaults()
	}
}

func (s *GcpCloudCdnFrontendConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.CustomDomains) > 0 {
		m["custom_domains"] = s.CustomDomains
	}
	if s.SslCertificate != nil {
		m["ssl_certificate"] = s.SslCertificate.toMap()
	}
	if s.CloudArmor != nil {
		m["cloud_armor"] = s.CloudArmor.toMap()
	}
	if s.EnableHttpsRedirect {
		m["enable_https_redirect"] = s.EnableHttpsRedirect
	}
	return m
}

// **GcsBackendConfig** configures a Google Cloud Storage bucket as the CDN origin.
//
//	Use this for static websites, media files, and downloadable content.
type GcsBackendConfigInput struct {
	// Name of the GCS bucket to use as origin.
	//  The bucket must already exist in the same GCP project.
	//  Required field.
	BucketName string `json:"bucket_name" jsonschema:"required,Name of the GCS bucket to use as origin. The bucket must already exist in the same GCP project. Required field."`
	// Enable uniform bucket-level access (recommended for security).
	//  When true, uses IAM for all access control (no legacy ACLs).
	//  Default: true.
	EnableUniformAccess bool `json:"enable_uniform_access,omitempty" jsonschema:"Enable uniform bucket-level access (recommended for security). When true; uses IAM for all access control (no legacy ACLs). Default: true."`
}

func (s *GcsBackendConfigInput) validate() error {
	if s.BucketName == "" {
		return fmt.Errorf("bucket_name is required")
	}
	return nil
}

func (s *GcsBackendConfigInput) applyDefaults() {
}

func (s *GcsBackendConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket_name"] = s.BucketName
	if s.EnableUniformAccess {
		m["enable_uniform_access"] = s.EnableUniformAccess
	}
	return m
}

// **GoogleManagedCertificateConfig** uses Google-managed SSL certificates.
//
//	Google automatically provisions and renews certificates via Let's Encrypt.
type GoogleManagedCertificateConfigInput struct {
	// Domains to include in the certificate.
	//  Must match or be subset of frontend_config.custom_domains.
	//  Required field.
	Domains []string `json:"domains" jsonschema:"required,Domains to include in the certificate. Must match or be subset of frontend_config.custom_domains. Required field."`
}

func (s *GoogleManagedCertificateConfigInput) validate() error {
	if len(s.Domains) == 0 {
		return fmt.Errorf("domains is required")
	}
	if len(s.Domains) < 1 {
		return fmt.Errorf("domains requires at least 1 items, got %d", len(s.Domains))
	}
	return nil
}

func (s *GoogleManagedCertificateConfigInput) applyDefaults() {
}

func (s *GoogleManagedCertificateConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domains"] = s.Domains
	return m
}

// **HealthCheckConfig** defines health check configuration for backend instances.
type HealthCheckConfigInput struct {
	// Path to use for health check requests.
	//  Default: / (root path).
	Path string `json:"path,omitempty" jsonschema:"Path to use for health check requests. Default: / (root path)."`
	// Port to use for health checks.
	//  If not specified, uses the backend port.
	Port int32 `json:"port,omitempty" jsonschema:"Port to use for health checks. If not specified; uses the backend port."`
	// Interval between health checks in seconds.
	//  Default: 5 seconds.
	CheckIntervalSeconds int32 `json:"check_interval_seconds,omitempty" jsonschema:"Interval between health checks in seconds. Default: 5 seconds."`
	// Timeout for each health check in seconds.
	//  Default: 5 seconds.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Timeout for each health check in seconds. Default: 5 seconds."`
	// Number of consecutive successes required to mark backend healthy.
	//  Default: 2.
	HealthyThreshold int32 `json:"healthy_threshold,omitempty" jsonschema:"Number of consecutive successes required to mark backend healthy. Default: 2."`
	// Number of consecutive failures required to mark backend unhealthy.
	//  Default: 2.
	UnhealthyThreshold int32 `json:"unhealthy_threshold,omitempty" jsonschema:"Number of consecutive failures required to mark backend unhealthy. Default: 2."`
}

func (s *HealthCheckConfigInput) validate() error {
	return nil
}

func (s *HealthCheckConfigInput) applyDefaults() {
}

func (s *HealthCheckConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.CheckIntervalSeconds != 0 {
		m["check_interval_seconds"] = s.CheckIntervalSeconds
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.HealthyThreshold != 0 {
		m["healthy_threshold"] = s.HealthyThreshold
	}
	if s.UnhealthyThreshold != 0 {
		m["unhealthy_threshold"] = s.UnhealthyThreshold
	}
	return m
}

// **NegativeCachingPolicy** defines caching behavior for specific HTTP error codes.
//
//	Prevents origin overload by caching error responses at the edge.
type NegativeCachingPolicyInput struct {
	// HTTP status code to cache (e.g., 404, 503).
	//  Required field.
	Code int32 `json:"code" jsonschema:"required,HTTP status code to cache (e.g.; 404; 503). Required field."`
	// TTL in seconds for caching this error response.
	//  Recommended: 600 (10 minutes) for 404, 60 (1 minute) for 5xx errors.
	//  Required field.
	TtlSeconds int32 `json:"ttl_seconds" jsonschema:"required,TTL in seconds for caching this error response. Recommended: 600 (10 minutes) for 404; 60 (1 minute) for 5xx errors. Required field."`
}

func (s *NegativeCachingPolicyInput) validate() error {
	return nil
}

func (s *NegativeCachingPolicyInput) applyDefaults() {
}

func (s *NegativeCachingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["code"] = s.Code
	m["ttl_seconds"] = s.TtlSeconds
	return m
}

// **SelfManagedCertificateConfig** uses user-provided SSL certificates.
type SelfManagedCertificateConfigInput struct {
	// PEM-encoded SSL certificate chain.
	//  Required field.
	CertificatePem string `json:"certificate_pem" jsonschema:"required,PEM-encoded SSL certificate chain. Required field."`
	// PEM-encoded private key.
	//  Required field.
	PrivateKeyPem string `json:"private_key_pem" jsonschema:"required,PEM-encoded private key. Required field."`
}

func (s *SelfManagedCertificateConfigInput) validate() error {
	if s.CertificatePem == "" {
		return fmt.Errorf("certificate_pem is required")
	}
	if s.PrivateKeyPem == "" {
		return fmt.Errorf("private_key_pem is required")
	}
	return nil
}

func (s *SelfManagedCertificateConfigInput) applyDefaults() {
}

func (s *SelfManagedCertificateConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["certificate_pem"] = s.CertificatePem
	m["private_key_pem"] = s.PrivateKeyPem
	return m
}

// **SignedUrlConfig** enables signed URLs for private content delivery via Cloud CDN.
//
//	Generate time-limited URLs with cryptographic signatures to control access to cached content.
type SignedUrlConfigInput struct {
	// Enable signed URL validation.
	//  Required: true to activate signed URL feature.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable signed URL validation. Required: true to activate signed URL feature."`
	// List of signing keys for URL validation.
	//  Multiple keys enable key rotation without downtime.
	//  Required when enabled = true.
	Keys []*SignedUrlKeyInput `json:"keys,omitempty" jsonschema:"List of signing keys for URL validation. Multiple keys enable key rotation without downtime. Required when enabled = true."`
}

func (s *SignedUrlConfigInput) validate() error {
	if len(s.Keys) < 1 {
		return fmt.Errorf("keys requires at least 1 items, got %d", len(s.Keys))
	}
	for i, v := range s.Keys {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("keys[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *SignedUrlConfigInput) applyDefaults() {
}

func (s *SignedUrlConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if len(s.Keys) > 0 {
		items := make([]any, len(s.Keys))
		for i, v := range s.Keys {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["keys"] = items
	}
	return m
}

// **SignedUrlKey** defines a cryptographic key for signing and validating URLs.
type SignedUrlKeyInput struct {
	// Unique name for this signing key.
	//  Used to identify which key signed a URL.
	//  Required field.
	KeyName string `json:"key_name" jsonschema:"required,Unique name for this signing key. Used to identify which key signed a URL. Required field."`
	// Base64-encoded key value (128-bit recommended).
	//  Generate with: openssl rand -base64 16
	//  Required field.
	KeyValue string `json:"key_value" jsonschema:"required,Base64-encoded key value (128-bit recommended). Generate with: openssl rand -base64 16 Required field."`
}

func (s *SignedUrlKeyInput) validate() error {
	if s.KeyName == "" {
		return fmt.Errorf("key_name is required")
	}
	if s.KeyValue == "" {
		return fmt.Errorf("key_value is required")
	}
	return nil
}

func (s *SignedUrlKeyInput) applyDefaults() {
}

func (s *SignedUrlKeyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["key_name"] = s.KeyName
	m["key_value"] = s.KeyValue
	return m
}

// **SslCertificateConfig** defines SSL/TLS certificate configuration for HTTPS.
type SslCertificateConfigInput struct {
	// Use Google-managed certificate (automatic issuance and renewal).
	//  Recommended for most use cases.
	GoogleManaged *GoogleManagedCertificateConfigInput `json:"google_managed,omitempty" jsonschema:"Use Google-managed certificate (automatic issuance and renewal). Recommended for most use cases."`
	// Use self-managed certificate (bring your own certificate).
	//  Use when you have specific certificate requirements or existing certificates.
	SelfManaged *SelfManagedCertificateConfigInput `json:"self_managed,omitempty" jsonschema:"Use self-managed certificate (bring your own certificate). Use when you have specific certificate requirements or existing certificates."`
}

func (s *SslCertificateConfigInput) validate() error {
	if s.GoogleManaged != nil {
		if err := s.GoogleManaged.validate(); err != nil {
			return fmt.Errorf("google_managed: %w", err)
		}
	}
	if s.SelfManaged != nil {
		if err := s.SelfManaged.validate(); err != nil {
			return fmt.Errorf("self_managed: %w", err)
		}
	}
	return nil
}

func (s *SslCertificateConfigInput) applyDefaults() {
	if s.GoogleManaged != nil {
		s.GoogleManaged.applyDefaults()
	}
	if s.SelfManaged != nil {
		s.SelfManaged.applyDefaults()
	}
}

func (s *SslCertificateConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.GoogleManaged != nil {
		m["google_managed"] = s.GoogleManaged.toMap()
	}
	if s.SelfManaged != nil {
		m["self_managed"] = s.SelfManaged.toMap()
	}
	return m
}

// ParseGcpCloudCdn validates and normalizes a GcpCloudCdn cloud_object.
func ParseGcpCloudCdn(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudCdn"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudCdnSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
