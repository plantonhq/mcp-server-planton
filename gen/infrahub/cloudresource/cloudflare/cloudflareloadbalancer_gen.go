// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cloudflare-load-balancer
type CloudflareLoadBalancerSpecInput struct {
	Hostname string `json:"hostname" jsonschema:"required"`
	// Foreign key reference to a Cloudflare DNS zone that contains the hostname.
	ZoneId string `json:"zone_id" jsonschema:"required,Foreign key reference to a Cloudflare DNS zone that contains the hostname."`
	// List of origin servers behind this load balancer. At least one origin is required.
	Origins []*CloudflareLoadBalancerOriginInput `json:"origins" jsonschema:"required,List of origin servers behind this load balancer. At least one origin is required."`
	// Whether Cloudflare's proxy is enabled for this hostname (orange cloud). Defaults to true.
	Proxied bool `json:"proxied,omitempty" jsonschema:"Whether Cloudflare's proxy is enabled for this hostname (orange cloud). Defaults to true."`
	// HTTP path to use for health monitoring of origins. Defaults to "/".
	HealthProbePath string `json:"health_probe_path,omitempty" jsonschema:"HTTP path to use for health monitoring of origins. Defaults to '/'."`
	// Session affinity setting (e.g., "cookie" to bind clients to an origin). Defaults to none.
	SessionAffinity string `json:"session_affinity,omitempty" jsonschema:"enum=cookie,Session affinity setting (e.g.; 'cookie' to bind clients to an origin). Defaults to none."`
	// Traffic steering policy. "off" for static/failover (default), "geo" for geo-routing, "random" for weighted distribution.
	SteeringPolicy string `json:"steering_policy,omitempty" jsonschema:"enum=geo|random,Traffic steering policy. 'off' for static/failover (default); 'geo' for geo-routing; 'random' for weighted distribution."`
}

func (s *CloudflareLoadBalancerSpecInput) validate() error {
	if s.Hostname == "" {
		return fmt.Errorf("hostname is required")
	}
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	if len(s.Origins) == 0 {
		return fmt.Errorf("origins is required")
	}
	if len(s.Origins) < 1 {
		return fmt.Errorf("origins requires at least 1 items, got %d", len(s.Origins))
	}
	for i, v := range s.Origins {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("origins[%d]: %w", i, err)
			}
		}
	}
	switch s.SessionAffinity {
	case "", "cookie":
	default:
		return fmt.Errorf("invalid session_affinity: %q", s.SessionAffinity)
	}
	switch s.SteeringPolicy {
	case "", "geo", "random":
	default:
		return fmt.Errorf("invalid steering_policy: %q", s.SteeringPolicy)
	}
	return nil
}

func (s *CloudflareLoadBalancerSpecInput) applyDefaults() {
}

func (s *CloudflareLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["hostname"] = s.Hostname
	m["zone_id"] = s.ZoneId
	if len(s.Origins) > 0 {
		items := make([]any, len(s.Origins))
		for i, v := range s.Origins {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["origins"] = items
	}
	if s.Proxied {
		m["proxied"] = s.Proxied
	}
	if s.HealthProbePath != "" {
		m["health_probe_path"] = s.HealthProbePath
	}
	if s.SessionAffinity != "" {
		m["session_affinity"] = s.SessionAffinity
	}
	if s.SteeringPolicy != "" {
		m["steering_policy"] = s.SteeringPolicy
	}
	return m
}

// Definition of an origin server in the Cloudflare load balancer.
type CloudflareLoadBalancerOriginInput struct {
	// A name to identify the origin.
	Name string `json:"name" jsonschema:"required,A name to identify the origin."`
	// The origin address (IP or DNS hostname) reachable via HTTP(S).
	Address string `json:"address" jsonschema:"required,The origin address (IP or DNS hostname) reachable via HTTP(S)."`
	// Weight for this origin (relative traffic share). Defaults to 1.
	Weight int32 `json:"weight,omitempty" jsonschema:"Weight for this origin (relative traffic share). Defaults to 1."`
}

func (s *CloudflareLoadBalancerOriginInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Address == "" {
		return fmt.Errorf("address is required")
	}
	return nil
}

func (s *CloudflareLoadBalancerOriginInput) applyDefaults() {
}

func (s *CloudflareLoadBalancerOriginInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["address"] = s.Address
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	return m
}

// ParseCloudflareLoadBalancer validates and normalizes a CloudflareLoadBalancer cloud_object.
func ParseCloudflareLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
