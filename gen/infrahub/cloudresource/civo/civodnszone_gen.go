// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package civo

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// civo-dns-zone
type CivoDnsZoneSpecInput struct {
	// The domain name for the DNS zone.
	//  Must be a valid fully-qualified domain name (e.g., "example.com").
	DomainName string `json:"domain_name" jsonschema:"required,The domain name for the DNS zone. Must be a valid fully-qualified domain name (e.g.; 'example.com')."`
	// A list of DNS records to create within the zone (optional).
	//  Each record includes its type, name, value(s), and TTL.
	Records []*CivoDnsZoneRecordInput `json:"records,omitempty" jsonschema:"A list of DNS records to create within the zone (optional). Each record includes its type; name; value(s); and TTL."`
}

func (s *CivoDnsZoneSpecInput) validate() error {
	if s.DomainName == "" {
		return fmt.Errorf("domain_name is required")
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *CivoDnsZoneSpecInput) applyDefaults() {
}

func (s *CivoDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domain_name"] = s.DomainName
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// CivoDnsZoneRecord represents a DNS record entry to be created in the zone.
type CivoDnsZoneRecordInput struct {
	// The host/name for the DNS record, relative to the zone.
	//  For root (apex) records, use "@" to denote the zone itself.
	Name string `json:"name" jsonschema:"required,The host/name for the DNS record; relative to the zone. For root (apex) records; use '@' to denote the zone itself."`
	// The value or values for the DNS record.
	//  - For A/AAAA: one or more IP addresses.
	//  - For CNAME: the target domain name.
	//  - For TXT: the text data (if multiple strings, they will be concatenated by DNS).
	//  - For MX: one or more entries like "<priority> <mail-server-domain>".
	//  Each value can be a litera...
	Values []string `json:"values" jsonschema:"required,The value or values for the DNS record. - For A/AAAA: one or more IP addresses. - For CNAME: the target domain name. - For TXT: the text data (if multiple strings; they will be concatenated by DNS). -..."`
	// The time-to-live (TTL) for this DNS record, in seconds.
	//  Determines how long resolvers cache the record. Defaults to 3600 seconds (1 hour) if not set.
	TtlSeconds uint32 `json:"ttl_seconds,omitempty" jsonschema:"The time-to-live (TTL) for this DNS record; in seconds. Determines how long resolvers cache the record. Defaults to 3600 seconds (1 hour) if not set."`
	// The DNS record type.
	//  This field is required and must be one of the supported record types (A, AAAA, CNAME, MX, TXT, etc.).
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|ALIAS|CNAME|MX|NS|PTR|SOA|SRV|TXT|CAA,The DNS record type. This field is required and must be one of the supported record types (A; AAAA; CNAME; MX; TXT; etc.)."`
}

func (s *CivoDnsZoneRecordInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.Values) == 0 {
		return fmt.Errorf("values is required")
	}
	if len(s.Values) < 1 {
		return fmt.Errorf("values requires at least 1 items, got %d", len(s.Values))
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "ALIAS", "CNAME", "MX", "NS", "PTR", "SOA", "SRV", "TXT", "CAA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *CivoDnsZoneRecordInput) applyDefaults() {
}

func (s *CivoDnsZoneRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["values"] = s.Values
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	m["type"] = s.Type
	return m
}

// ParseCivoDnsZone validates and normalizes a CivoDnsZone cloud_object.
func ParseCivoDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "civo.openmcf.org/v1", "CivoDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CivoDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
