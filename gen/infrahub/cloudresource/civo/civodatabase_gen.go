// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package civo

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// civo-database
type CivoDatabaseSpecInput struct {
	// A human-readable name for the database instance.
	//  This name must be unique within the chosen Civo region.
	DbInstanceName string `json:"db_instance_name" jsonschema:"required,A human-readable name for the database instance. This name must be unique within the chosen Civo region."`
	// The database engine for the instance (MySQL or PostgreSQL).
	Engine string `json:"engine" jsonschema:"required,enum=mysql|postgres,The database engine for the instance (MySQL or PostgreSQL)."`
	// The engine version for the database.
	//  For example: "8.0" for MySQL 8.0, "14" for PostgreSQL 14.
	//  Only major (and optionally minor) version numbers are expected.
	EngineVersion string `json:"engine_version" jsonschema:"required,The engine version for the database. For example: '8.0' for MySQL 8.0; '14' for PostgreSQL 14. Only major (and optionally minor) version numbers are expected."`
	// The Civo region where the database will be created.
	Region string `json:"region" jsonschema:"required,enum=lon1|lon2|fra1|nyc1|phx1|mum1,The Civo region where the database will be created."`
	// The plan or size identifier for the database instance (e.g., "g3.db.small").
	//  This defines CPU, memory, and base storage for the instance.
	SizeSlug string `json:"size_slug" jsonschema:"required,The plan or size identifier for the database instance (e.g.; 'g3.db.small'). This defines CPU; memory; and base storage for the instance."`
	// The number of replica nodes to add to the database (0 means no replicas, just the primary).
	//  Typically use 0, 2, or 4 for a total of 1, 3, or 5 nodes in the cluster.
	Replicas uint32 `json:"replicas,omitempty" jsonschema:"The number of replica nodes to add to the database (0 means no replicas; just the primary). Typically use 0; 2; or 4 for a total of 1; 3; or 5 nodes in the cluster."`
	// The target private network for the database instance.
	//  Provide a literal network UUID or a reference to a CivoNetwork resource.
	NetworkId string `json:"network_id" jsonschema:"required,The target private network for the database instance. Provide a literal network UUID or a reference to a CivoNetwork resource."`
	// (Optional) Firewall rules to attach to this database instance.
	//  Provide one or more firewall IDs or references to CivoFirewall resources for access control.
	FirewallIds []string `json:"firewall_ids,omitempty" jsonschema:"(Optional) Firewall rules to attach to this database instance. Provide one or more firewall IDs or references to CivoFirewall resources for access control."`
	// (Optional) Custom storage size in GiB for the database, if different from the default provided by size_slug.
	StorageGib uint32 `json:"storage_gib,omitempty" jsonschema:"(Optional) Custom storage size in GiB for the database; if different from the default provided by size_slug."`
	// (Optional) Tags to assign to the database instance for organizational purposes.
	Tags []string `json:"tags,omitempty" jsonschema:"(Optional) Tags to assign to the database instance for organizational purposes."`
}

func (s *CivoDatabaseSpecInput) validate() error {
	if s.DbInstanceName == "" {
		return fmt.Errorf("db_instance_name is required")
	}
	if s.Engine == "" {
		return fmt.Errorf("engine is required")
	}
	switch s.Engine {
	case "mysql", "postgres":
	default:
		return fmt.Errorf("invalid engine: %q", s.Engine)
	}
	if s.EngineVersion == "" {
		return fmt.Errorf("engine_version is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "lon1", "lon2", "fra1", "nyc1", "phx1", "mum1":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.SizeSlug == "" {
		return fmt.Errorf("size_slug is required")
	}
	if s.NetworkId == "" {
		return fmt.Errorf("network_id is required")
	}
	return nil
}

func (s *CivoDatabaseSpecInput) applyDefaults() {
}

func (s *CivoDatabaseSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["db_instance_name"] = s.DbInstanceName
	m["engine"] = s.Engine
	m["engine_version"] = s.EngineVersion
	m["region"] = s.Region
	m["size_slug"] = s.SizeSlug
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	m["network_id"] = s.NetworkId
	if len(s.FirewallIds) > 0 {
		m["firewall_ids"] = s.FirewallIds
	}
	if s.StorageGib != 0 {
		m["storage_gib"] = s.StorageGib
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// ParseCivoDatabase validates and normalizes a CivoDatabase cloud_object.
func ParseCivoDatabase(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "civo.openmcf.org/v1", "CivoDatabase"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CivoDatabaseSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
