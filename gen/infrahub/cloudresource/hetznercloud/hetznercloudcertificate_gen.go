// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-certificate
type HetznerCloudCertificateSpecInput struct {
	// Upload your own TLS certificate and private key.
	Uploaded *UploadedCertificateConfigInput `json:"uploaded,omitempty" jsonschema:"Upload your own TLS certificate and private key."`
	// Let Hetzner Cloud obtain and manage a Let's Encrypt certificate.
	Managed *ManagedCertificateConfigInput `json:"managed,omitempty" jsonschema:"Let Hetzner Cloud obtain and manage a Let's Encrypt certificate."`
}

func (s *HetznerCloudCertificateSpecInput) validate() error {
	if s.Uploaded != nil {
		if err := s.Uploaded.validate(); err != nil {
			return fmt.Errorf("uploaded: %w", err)
		}
	}
	if s.Managed != nil {
		if err := s.Managed.validate(); err != nil {
			return fmt.Errorf("managed: %w", err)
		}
	}
	return nil
}

func (s *HetznerCloudCertificateSpecInput) applyDefaults() {
	if s.Uploaded != nil {
		s.Uploaded.applyDefaults()
	}
	if s.Managed != nil {
		s.Managed.applyDefaults()
	}
}

func (s *HetznerCloudCertificateSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Uploaded != nil {
		m["uploaded"] = s.Uploaded.toMap()
	}
	if s.Managed != nil {
		m["managed"] = s.Managed.toMap()
	}
	return m
}

// ManagedCertificateConfig specifies domain names for which Hetzner Cloud
//
//	automatically obtains and renews a Let's Encrypt TLS certificate.
//
//	Prerequisites for successful provisioning:
//	  - Each domain must have a DNS A/AAAA record pointing to a Hetzner Cloud
//	    load balancer so the ACME HTTP-01 challenge can be completed.
//	  - The load balancer must have an HTTPS service configured that references
//	    this certificate.
//
//	Changing the domain list forces replacement of the certificate resource
//	(ForceNew).
type ManagedCertificateConfigInput struct {
	// Domain names for which a certificate should be obtained.
	//
	//  At least one domain is required. Hetzner Cloud issues a single certificate
	//  covering all listed domains (SAN certificate). Changing this list forces
	//  replacement of the certificate resource.
	DomainNames []string `json:"domain_names,omitempty" jsonschema:"Domain names for which a certificate should be obtained. At least one domain is required. Hetzner Cloud issues a single certificate covering all listed domains (SAN certificate). Changing this list fo..."`
}

func (s *ManagedCertificateConfigInput) validate() error {
	if len(s.DomainNames) < 1 {
		return fmt.Errorf("domain_names requires at least 1 items, got %d", len(s.DomainNames))
	}
	return nil
}

func (s *ManagedCertificateConfigInput) applyDefaults() {
}

func (s *ManagedCertificateConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.DomainNames) > 0 {
		m["domain_names"] = s.DomainNames
	}
	return m
}

// UploadedCertificateConfig holds the PEM-encoded certificate chain and
//
//	private key for a user-provided TLS certificate.
//
//	Both fields are required and immutable — changing either forces replacement
//	of the certificate resource in Hetzner Cloud (ForceNew).
//
//	The private_key field contains sensitive cryptographic material. IaC modules
//	treat it as a secret (Pulumi marks it with pulumi.ToSecret; Terraform marks
//	the corresponding variable as sensitive).
type UploadedCertificateConfigInput struct {
	// PEM-encoded TLS certificate chain.
	//
	//  Must include the server certificate and, if applicable, intermediate CA
	//  certificates in order (server cert first, root last). Changing this value
	//  forces replacement of the certificate resource.
	Certificate string `json:"certificate,omitempty" jsonschema:"PEM-encoded TLS certificate chain. Must include the server certificate and; if applicable; intermediate CA certificates in order (server cert first; root last). Changing this value forces replacement ..."`
	// PEM-encoded private key belonging to the certificate.
	//
	//  SENSITIVE — this field contains secret cryptographic material.
	//  Changing this value forces replacement of the certificate resource.
	PrivateKey string `json:"private_key,omitempty" jsonschema:"PEM-encoded private key belonging to the certificate. SENSITIVE — this field contains secret cryptographic material. Changing this value forces replacement of the certificate resource."`
}

func (s *UploadedCertificateConfigInput) validate() error {
	return nil
}

func (s *UploadedCertificateConfigInput) applyDefaults() {
}

func (s *UploadedCertificateConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Certificate != "" {
		m["certificate"] = s.Certificate
	}
	if s.PrivateKey != "" {
		m["private_key"] = s.PrivateKey
	}
	return m
}

// ParseHetznerCloudCertificate validates and normalizes a HetznerCloudCertificate cloud_object.
func ParseHetznerCloudCertificate(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudCertificate"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudCertificateSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
