// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-server
type HetznerCloudServerSpecInput struct {
	// Server type that determines vCPU, RAM, and disk resources.
	//
	//  Examples: "cx22" (2 vCPU / 4 GB), "cpx11" (2 vCPU / 2 GB, AMD),
	//  "cax11" (2 vCPU / 4 GB, ARM64).
	//
	//  Changing this value triggers a server resize. The server is temporarily
	//  stopped during the resize. Use keep_disk to prevent irreversible di...
	ServerType string `json:"server_type,omitempty" jsonschema:"Server type that determines vCPU; RAM; and disk resources. Examples: 'cx22' (2 vCPU / 4 GB); 'cpx11' (2 vCPU / 2 GB; AMD); 'cax11' (2 vCPU / 4 GB; ARM64). Changing this value triggers a server resize...."`
	// OS image name or ID to provision the server with.
	//
	//  Examples: "ubuntu-24.04", "debian-12", "rocky-9", "45346857".
	//
	//  Changing this value forces replacement of the server.
	Image string `json:"image,omitempty" jsonschema:"OS image name or ID to provision the server with. Examples: 'ubuntu-24.04'; 'debian-12'; 'rocky-9'; '45346857'. Changing this value forces replacement of the server."`
	// Hetzner Cloud location for the server (e.g., "fsn1", "nbg1", "hel1",
	//  "ash", "hil", "sin"). Determines the physical datacenter.
	//
	//  Primary IPs and Floating IPs assigned to the server must be in the
	//  same location.
	//
	//  Changing this value forces replacement of the server.
	Location string `json:"location,omitempty" jsonschema:"Hetzner Cloud location for the server (e.g.; 'fsn1'; 'nbg1'; 'hel1'; 'ash'; 'hil'; 'sin'). Determines the physical datacenter. Primary IPs and Floating IPs assigned to the server must be in the same l..."`
	// SSH keys to inject into the server at creation time.
	//
	//  Each entry accepts a literal SSH key name or numeric ID (as a string),
	//  or a reference to a HetznerCloudSshKey resource's output via valueFrom.
	//
	//  SSH keys are only injected during initial server creation. Changing this
	//  list after creation force...
	SshKeys []string `json:"ssh_keys,omitempty" jsonschema:"SSH keys to inject into the server at creation time. Each entry accepts a literal SSH key name or numeric ID (as a string); or a reference to a HetznerCloudSshKey resource's output via valueFrom. SSH ..."`
	// Cloud-init user data script or configuration to execute on first boot.
	//
	//  Accepts raw shell scripts (starting with #!/bin/bash) or cloud-config
	//  YAML (starting with #cloud-config). Maximum size is 32 KB.
	//
	//  Changing this value forces replacement of the server.
	UserData string `json:"user_data,omitempty" jsonschema:"Cloud-init user data script or configuration to execute on first boot. Accepts raw shell scripts (starting with #!/bin/bash) or cloud-config YAML (starting with #cloud-config). Maximum size is 32 KB. ..."`
	// Placement group to assign the server to for anti-affinity scheduling.
	//
	//  Accepts a literal Hetzner Cloud placement group ID (as a string) or a
	//  reference to a HetznerCloudPlacementGroup resource's output via
	//  valueFrom. Servers in a "spread" placement group are guaranteed to run
	//  on different physica...
	PlacementGroupId string `json:"placement_group_id,omitempty" jsonschema:"Placement group to assign the server to for anti-affinity scheduling. Accepts a literal Hetzner Cloud placement group ID (as a string) or a reference to a HetznerCloudPlacementGroup resource's output ..."`
	// Firewalls to apply to the server at creation time.
	//
	//  Each entry accepts a literal Hetzner Cloud firewall ID (as a string) or
	//  a reference to a HetznerCloudFirewall resource's output via valueFrom.
	//
	//  Example (reference):
	//    firewallIds:
	//      - valueFrom:
	//          kind: HetznerCloudFirewall
	//          n...
	FirewallIds []string `json:"firewall_ids,omitempty" jsonschema:"Firewalls to apply to the server at creation time. Each entry accepts a literal Hetzner Cloud firewall ID (as a string) or a reference to a HetznerCloudFirewall resource's output via valueFrom. Exampl..."`
	// Public network configuration for the server.
	//
	//  If omitted, the server receives auto-assigned public IPv4 and IPv6
	//  addresses (provider default). Set this block to disable public
	//  networking or to attach existing Primary IPs.
	PublicNet *PublicNetInput `json:"public_net,omitempty" jsonschema:"Public network configuration for the server. If omitted; the server receives auto-assigned public IPv4 and IPv6 addresses (provider default). Set this block to disable public networking or to attach e..."`
	// Private networks to attach the server to.
	//
	//  Each entry creates an inline network attachment on the server resource.
	//  The server receives an IP from the network's subnet range (either
	//  auto-assigned or explicitly specified via the ip field).
	Networks []*NetworkAttachmentInput `json:"networks,omitempty" jsonschema:"Private networks to attach the server to. Each entry creates an inline network attachment on the server resource. The server receives an IP from the network's subnet range (either auto-assigned or exp..."`
	// Enable automatic daily backups for the server.
	//
	//  Backups are stored for 14 days and can be used to restore the server.
	//  Incurs an additional 20% of the server price.
	Backups bool `json:"backups,omitempty" jsonschema:"Enable automatic daily backups for the server. Backups are stored for 14 days and can be used to restore the server. Incurs an additional 20% of the server price."`
	// Preserve the existing disk size when changing server_type.
	//
	//  When false (default), a server_type upgrade also upgrades the disk,
	//  which is irreversible -- you cannot later downgrade to a smaller
	//  server_type. Set to true to only change vCPU and RAM, keeping the
	//  disk at its current size.
	KeepDisk bool `json:"keep_disk,omitempty" jsonschema:"Preserve the existing disk size when changing server_type. When false (default); a server_type upgrade also upgrades the disk; which is irreversible -- you cannot later downgrade to a smaller server_t..."`
	// Prevent accidental deletion of the server via the Hetzner Cloud API.
	//  When enabled, the server cannot be deleted until protection is removed.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"Prevent accidental deletion of the server via the Hetzner Cloud API. When enabled; the server cannot be deleted until protection is removed."`
	// Prevent accidental rebuild (re-image) of the server via the Hetzner
	//  Cloud API. When enabled, the server cannot be rebuilt until protection
	//  is removed.
	RebuildProtection bool `json:"rebuild_protection,omitempty" jsonschema:"Prevent accidental rebuild (re-image) of the server via the Hetzner Cloud API. When enabled; the server cannot be rebuilt until protection is removed."`
	// Attempt a graceful shutdown of the server before Terraform destroys it.
	//
	//  When true, Terraform sends an ACPI shutdown signal and waits for the
	//  server to power off before deletion. When false (default), the server
	//  is deleted immediately.
	ShutdownBeforeDeletion bool `json:"shutdown_before_deletion,omitempty" jsonschema:"Attempt a graceful shutdown of the server before Terraform destroys it. When true; Terraform sends an ACPI shutdown signal and waits for the server to power off before deletion. When false (default); ..."`
	// Reverse DNS pointer record for the server's auto-assigned public IPv4
	//  address. If set, an hcloud_rdns resource is created mapping the
	//  server's IPv4 to this hostname.
	//
	//  Only use this when the server has auto-assigned public IPv4 (default
	//  behavior or public_net with ipv4_enabled=true and no ipv4 Pr...
	DnsPtr string `json:"dns_ptr,omitempty" jsonschema:"Reverse DNS pointer record for the server's auto-assigned public IPv4 address. If set; an hcloud_rdns resource is created mapping the server's IPv4 to this hostname. Only use this when the server has ..."`
}

func (s *HetznerCloudServerSpecInput) validate() error {
	if s.PublicNet != nil {
		if err := s.PublicNet.validate(); err != nil {
			return fmt.Errorf("public_net: %w", err)
		}
	}
	for i, v := range s.Networks {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("networks[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *HetznerCloudServerSpecInput) applyDefaults() {
	if s.PublicNet != nil {
		s.PublicNet.applyDefaults()
	}
}

func (s *HetznerCloudServerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ServerType != "" {
		m["server_type"] = s.ServerType
	}
	if s.Image != "" {
		m["image"] = s.Image
	}
	if s.Location != "" {
		m["location"] = s.Location
	}
	if len(s.SshKeys) > 0 {
		m["ssh_keys"] = s.SshKeys
	}
	if s.UserData != "" {
		m["user_data"] = s.UserData
	}
	if s.PlacementGroupId != "" {
		m["placement_group_id"] = s.PlacementGroupId
	}
	if len(s.FirewallIds) > 0 {
		m["firewall_ids"] = s.FirewallIds
	}
	if s.PublicNet != nil {
		m["public_net"] = s.PublicNet.toMap()
	}
	if len(s.Networks) > 0 {
		items := make([]any, len(s.Networks))
		for i, v := range s.Networks {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["networks"] = items
	}
	if s.Backups {
		m["backups"] = s.Backups
	}
	if s.KeepDisk {
		m["keep_disk"] = s.KeepDisk
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	if s.RebuildProtection {
		m["rebuild_protection"] = s.RebuildProtection
	}
	if s.ShutdownBeforeDeletion {
		m["shutdown_before_deletion"] = s.ShutdownBeforeDeletion
	}
	if s.DnsPtr != "" {
		m["dns_ptr"] = s.DnsPtr
	}
	return m
}

// PublicNet controls the server's public network interfaces.
//
//	If this message is omitted entirely, the server gets auto-assigned
//	public IPv4 and IPv6 addresses (provider default). When set, each
//	field defaults to its documented value, giving fine-grained control
//	over public networking.
//
//	Note: proto3 bool defaults to false, so an empty PublicNet message
//	would disable both IPv4 and IPv6. To avoid this footgun, ipv4_enabled
//	and ipv6_enabled use optional bool with a default of true.
type PublicNetInput struct {
	// Enable public IPv4 for the server.
	//
	//  Default: true
	Ipv4Enabled bool `json:"ipv4_enabled,omitempty" jsonschema:"Enable public IPv4 for the server. Default: true"`
	// Enable public IPv6 for the server.
	//
	//  Default: true
	Ipv6Enabled bool `json:"ipv6_enabled,omitempty" jsonschema:"Enable public IPv6 for the server. Default: true"`
	// Existing Primary IP (IPv4) to attach to the server instead of
	//  auto-assigning. Accepts a literal Hetzner Cloud Primary IP ID (as a
	//  string) or a reference to a HetznerCloudPrimaryIp output via
	//  valueFrom.
	//
	//  The Primary IP must be IPv4 type and in the same location as the
	//  server.
	//
	//  Example (referenc...
	Ipv4 string `json:"ipv4,omitempty" jsonschema:"Existing Primary IP (IPv4) to attach to the server instead of auto-assigning. Accepts a literal Hetzner Cloud Primary IP ID (as a string) or a reference to a HetznerCloudPrimaryIp output via valueFrom..."`
	// Existing Primary IP (IPv6) to attach to the server instead of
	//  auto-assigning. Same semantics as ipv4 above, but for IPv6.
	Ipv6 string `json:"ipv6,omitempty" jsonschema:"Existing Primary IP (IPv6) to attach to the server instead of auto-assigning. Same semantics as ipv4 above; but for IPv6."`
}

func (s *PublicNetInput) validate() error {
	return nil
}

func (s *PublicNetInput) applyDefaults() {
	// default: Ipv4Enabled = true (applied at zero-value)
	// default: Ipv6Enabled = true (applied at zero-value)
}

func (s *PublicNetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Ipv4Enabled {
		m["ipv4_enabled"] = s.Ipv4Enabled
	}
	if s.Ipv6Enabled {
		m["ipv6_enabled"] = s.Ipv6Enabled
	}
	if s.Ipv4 != "" {
		m["ipv4"] = s.Ipv4
	}
	if s.Ipv6 != "" {
		m["ipv6"] = s.Ipv6
	}
	return m
}

// ParseHetznerCloudServer validates and normalizes a HetznerCloudServer cloud_object.
func ParseHetznerCloudServer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudServer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudServerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
