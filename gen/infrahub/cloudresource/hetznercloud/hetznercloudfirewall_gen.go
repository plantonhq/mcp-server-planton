// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-firewall
type HetznerCloudFirewallSpecInput struct {
	// Firewall rules that define allowed traffic.
	//
	//  Hetzner Cloud firewalls are deny-by-default for inbound traffic: when a
	//  firewall is applied to a server, all inbound packets not matching a rule
	//  are dropped. Outbound traffic is allowed by default unless explicitly
	//  restricted by outbound rules.
	//
	//  An e...
	Rules []*RuleInput `json:"rules,omitempty" jsonschema:"Firewall rules that define allowed traffic. Hetzner Cloud firewalls are deny-by-default for inbound traffic: when a firewall is applied to a server; all inbound packets not matching a rule are dropped..."`
}

func (s *HetznerCloudFirewallSpecInput) validate() error {
	for i, v := range s.Rules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *HetznerCloudFirewallSpecInput) applyDefaults() {
}

func (s *HetznerCloudFirewallSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Rules) > 0 {
		items := make([]any, len(s.Rules))
		for i, v := range s.Rules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rules"] = items
	}
	return m
}

// Rule defines a single firewall rule controlling traffic in one direction.
type RuleInput struct {
	// Traffic direction this rule applies to.
	Direction string `json:"direction" jsonschema:"required,enum=in|out,Traffic direction this rule applies to."`
	// IP protocol this rule matches.
	Protocol string `json:"protocol" jsonschema:"required,enum=icmp|tcp|udp|esp|gre,IP protocol this rule matches."`
	// Port or port range for TCP and UDP rules.
	//
	//  Accepts a single port ("80"), a range ("80-443"), or "any" for all ports.
	//  Required when protocol is tcp or udp. Must not be set for icmp, esp, or gre.
	Port string `json:"port,omitempty" jsonschema:"Port or port range for TCP and UDP rules. Accepts a single port ('80'); a range ('80-443'); or 'any' for all ports. Required when protocol is tcp or udp. Must not be set for icmp; esp; or gre."`
	// CIDR blocks allowed as traffic sources for inbound rules (direction = in).
	//
	//  Use ["0.0.0.0/0", "::/0"] to allow all IPv4 and IPv6 traffic.
	//  Required when direction is in.
	SourceIps []string `json:"source_ips,omitempty" jsonschema:"CIDR blocks allowed as traffic sources for inbound rules (direction = in). Use ['0.0.0.0/0'; '::/0'] to allow all IPv4 and IPv6 traffic. Required when direction is in."`
	// CIDR blocks allowed as traffic destinations for outbound rules (direction = out).
	//
	//  Use ["0.0.0.0/0", "::/0"] to allow all IPv4 and IPv6 traffic.
	//  Required when direction is out.
	DestinationIps []string `json:"destination_ips,omitempty" jsonschema:"CIDR blocks allowed as traffic destinations for outbound rules (direction = out). Use ['0.0.0.0/0'; '::/0'] to allow all IPv4 and IPv6 traffic. Required when direction is out."`
	// Human-readable description of what this rule allows.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of what this rule allows."`
}

func (s *RuleInput) validate() error {
	if s.Direction == "" {
		return fmt.Errorf("direction is required")
	}
	switch s.Direction {
	case "in", "out":
	default:
		return fmt.Errorf("invalid direction: %q", s.Direction)
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	switch s.Protocol {
	case "icmp", "tcp", "udp", "esp", "gre":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	return nil
}

func (s *RuleInput) applyDefaults() {
}

func (s *RuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["direction"] = s.Direction
	m["protocol"] = s.Protocol
	if s.Port != "" {
		m["port"] = s.Port
	}
	if len(s.SourceIps) > 0 {
		m["source_ips"] = s.SourceIps
	}
	if len(s.DestinationIps) > 0 {
		m["destination_ips"] = s.DestinationIps
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ParseHetznerCloudFirewall validates and normalizes a HetznerCloudFirewall cloud_object.
func ParseHetznerCloudFirewall(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudFirewall"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudFirewallSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
