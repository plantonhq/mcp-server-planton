// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-app-platform-service
type DigitalOceanAppPlatformServiceSpecInput struct {
	// name of the app (must be unique within the user's DigitalOcean account).
	//  Constraints: should be DNS-friendly (e.g., lowercase alphanumeric and hyphens), maximum 63 characters.
	ServiceName string `json:"service_name" jsonschema:"required,name of the app (must be unique within the user's DigitalOcean account). Constraints: should be DNS-friendly (e.g.; lowercase alphanumeric and hyphens); maximum 63 characters."`
	// region in which to deploy the app (DigitalOcean data center region slug).
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,region in which to deploy the app (DigitalOcean data center region slug)."`
	// type of service being deployed (e.g., a web service that receives HTTP traffic, a background worker, or a one-off job).
	ServiceType string `json:"service_type" jsonschema:"required,enum=web_service|worker|job,type of service being deployed (e.g.; a web service that receives HTTP traffic; a background worker; or a one-off job)."`
	// git repository source configuration (for App Platform to build and deploy from source code).
	GitSource *DigitalOceanAppPlatformGitSourceInput `json:"git_source,omitempty" jsonschema:"git repository source configuration (for App Platform to build and deploy from source code)."`
	// container image source configuration (deploy a pre-built image, typically from DigitalOcean Container Registry).
	ImageSource *DigitalOceanAppPlatformRegistrySourceInput `json:"image_source,omitempty" jsonschema:"container image source configuration (deploy a pre-built image; typically from DigitalOcean Container Registry)."`
	// instance_size_slug specifies the instance size (plan) for this service.
	//  Determines the CPU/memory allocated per instance. Common options include "basic-xxs", "basic-xs", "basic-s", "basic-m", and professional tiers.
	//  Default (if not specified by user): "basic-xxs".
	InstanceSizeSlug string `json:"instance_size_slug" jsonschema:"required,enum=basic_xxs|basic_xs|basic_s|basic_m|basic_l|professional_xs|professional_s|professional_m|professional_l|professional_xl,instance_size_slug specifies the instance size (plan) for this service. Determines the CPU/memory allocated per instance. Common options include 'basic-xxs'; 'basic-xs'; 'basic-s'; 'basic-m'; and prof..."`
	// instance_count is the number of instances (containers) to run for this service.
	//  Default: 1.
	InstanceCount uint32 `json:"instance_count,omitempty" jsonschema:"instance_count is the number of instances (containers) to run for this service. Default: 1."`
	// enable_autoscale controls whether to use auto-scaling for this service.
	//  If true, the service will automatically scale between the specified min and max instance counts based on load.
	//  Default: false (manual scaling).
	EnableAutoscale bool `json:"enable_autoscale,omitempty" jsonschema:"enable_autoscale controls whether to use auto-scaling for this service. If true; the service will automatically scale between the specified min and max instance counts based on load. Default: false (m..."`
	// min_instance_count specifies the minimum number of instances to run when auto-scaling is enabled.
	//  Required if enable_autoscale = true.
	MinInstanceCount uint32 `json:"min_instance_count,omitempty" jsonschema:"min_instance_count specifies the minimum number of instances to run when auto-scaling is enabled. Required if enable_autoscale = true."`
	// max_instance_count specifies the maximum number of instances to run when auto-scaling is enabled.
	//  Required if enable_autoscale = true.
	MaxInstanceCount uint32 `json:"max_instance_count,omitempty" jsonschema:"max_instance_count specifies the maximum number of instances to run when auto-scaling is enabled. Required if enable_autoscale = true."`
	// env is a map of environment variables to set in the app's runtime environment.
	//  Keys are variable names and values are their corresponding values.
	Env map[string]string `json:"env,omitempty" jsonschema:"env is a map of environment variables to set in the app's runtime environment. Keys are variable names and values are their corresponding values."`
	// custom_domain is an optional custom domain to use for the app, in addition to the default ondigitalocean.app hostname.
	//  Provide a reference to a DigitalOceanDnsZone resource (typically its domain name). The system will create the necessary DNS records.
	CustomDomain string `json:"custom_domain,omitempty" jsonschema:"custom_domain is an optional custom domain to use for the app; in addition to the default ondigitalocean.app hostname. Provide a reference to a DigitalOceanDnsZone resource (typically its domain name)..."`
}

func (s *DigitalOceanAppPlatformServiceSpecInput) validate() error {
	if s.ServiceName == "" {
		return fmt.Errorf("service_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.ServiceType == "" {
		return fmt.Errorf("service_type is required")
	}
	switch s.ServiceType {
	case "web_service", "worker", "job":
	default:
		return fmt.Errorf("invalid service_type: %q", s.ServiceType)
	}
	if s.GitSource != nil {
		if err := s.GitSource.validate(); err != nil {
			return fmt.Errorf("git_source: %w", err)
		}
	}
	if s.ImageSource != nil {
		if err := s.ImageSource.validate(); err != nil {
			return fmt.Errorf("image_source: %w", err)
		}
	}
	if s.InstanceSizeSlug == "" {
		return fmt.Errorf("instance_size_slug is required")
	}
	switch s.InstanceSizeSlug {
	case "basic_xxs", "basic_xs", "basic_s", "basic_m", "basic_l", "professional_xs", "professional_s", "professional_m", "professional_l", "professional_xl":
	default:
		return fmt.Errorf("invalid instance_size_slug: %q", s.InstanceSizeSlug)
	}
	return nil
}

func (s *DigitalOceanAppPlatformServiceSpecInput) applyDefaults() {
	if s.GitSource != nil {
		s.GitSource.applyDefaults()
	}
	if s.ImageSource != nil {
		s.ImageSource.applyDefaults()
	}
}

func (s *DigitalOceanAppPlatformServiceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_name"] = s.ServiceName
	m["region"] = s.Region
	m["service_type"] = s.ServiceType
	if s.GitSource != nil {
		m["git_source"] = s.GitSource.toMap()
	}
	if s.ImageSource != nil {
		m["image_source"] = s.ImageSource.toMap()
	}
	m["instance_size_slug"] = s.InstanceSizeSlug
	if s.InstanceCount != 0 {
		m["instance_count"] = s.InstanceCount
	}
	if s.EnableAutoscale {
		m["enable_autoscale"] = s.EnableAutoscale
	}
	if s.MinInstanceCount != 0 {
		m["min_instance_count"] = s.MinInstanceCount
	}
	if s.MaxInstanceCount != 0 {
		m["max_instance_count"] = s.MaxInstanceCount
	}
	if len(s.Env) > 0 {
		m["env"] = s.Env
	}
	if s.CustomDomain != "" {
		m["custom_domain"] = s.CustomDomain
	}
	return m
}

// DigitalOceanAppPlatformGitSource describes a git repository source for building and deploying the app.
type DigitalOceanAppPlatformGitSourceInput struct {
	// repo_url is the URL of the git repository (HTTPS or git) containing the source code.
	RepoUrl string `json:"repo_url" jsonschema:"required,repo_url is the URL of the git repository (HTTPS or git) containing the source code."`
	// branch specifies the git branch to deploy from.
	Branch string `json:"branch" jsonschema:"required,branch specifies the git branch to deploy from."`
	// build_command optionally overrides the default build command for the app.
	//  Example: "npm run build". If not provided, DigitalOcean will auto-detect build steps or use defaults.
	BuildCommand string `json:"build_command,omitempty" jsonschema:"build_command optionally overrides the default build command for the app. Example: 'npm run build'. If not provided; DigitalOcean will auto-detect build steps or use defaults."`
	// run_command optionally overrides the start command for the app.
	//  Example: "npm start". If not provided, defaults are inferred from the build or Dockerfile.
	RunCommand string `json:"run_command,omitempty" jsonschema:"run_command optionally overrides the start command for the app. Example: 'npm start'. If not provided; defaults are inferred from the build or Dockerfile."`
}

func (s *DigitalOceanAppPlatformGitSourceInput) validate() error {
	if s.RepoUrl == "" {
		return fmt.Errorf("repo_url is required")
	}
	if s.Branch == "" {
		return fmt.Errorf("branch is required")
	}
	return nil
}

func (s *DigitalOceanAppPlatformGitSourceInput) applyDefaults() {
}

func (s *DigitalOceanAppPlatformGitSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["repo_url"] = s.RepoUrl
	m["branch"] = s.Branch
	if s.BuildCommand != "" {
		m["build_command"] = s.BuildCommand
	}
	if s.RunCommand != "" {
		m["run_command"] = s.RunCommand
	}
	return m
}

// DigitalOceanAppPlatformRegistrySource describes a container image source from DigitalOcean Container Registry (DOCR).
type DigitalOceanAppPlatformRegistrySourceInput struct {
	// registry is a reference to a DigitalOceanContainerRegistry resource that hosts the image.
	//  This typically provides the registry URL and ensures credentials are available for pulling the image.
	Registry string `json:"registry" jsonschema:"required,registry is a reference to a DigitalOceanContainerRegistry resource that hosts the image. This typically provides the registry URL and ensures credentials are available for pulling the image."`
	// repository is the name of the repository in the registry containing the image.
	//  For example, "myapp/backend".
	Repository string `json:"repository" jsonschema:"required,repository is the name of the repository in the registry containing the image. For example; 'myapp/backend'."`
	// tag is the image tag to deploy.
	//  For example, "latest" or a specific version like "v1.0.0".
	Tag string `json:"tag" jsonschema:"required,tag is the image tag to deploy. For example; 'latest' or a specific version like 'v1.0.0'."`
}

func (s *DigitalOceanAppPlatformRegistrySourceInput) validate() error {
	if s.Registry == "" {
		return fmt.Errorf("registry is required")
	}
	if s.Repository == "" {
		return fmt.Errorf("repository is required")
	}
	if s.Tag == "" {
		return fmt.Errorf("tag is required")
	}
	return nil
}

func (s *DigitalOceanAppPlatformRegistrySourceInput) applyDefaults() {
}

func (s *DigitalOceanAppPlatformRegistrySourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["registry"] = s.Registry
	m["repository"] = s.Repository
	m["tag"] = s.Tag
	return m
}

// ParseDigitalOceanAppPlatformService validates and normalizes a DigitalOceanAppPlatformService cloud_object.
func ParseDigitalOceanAppPlatformService(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanAppPlatformService"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanAppPlatformServiceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
