// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-dns-zone
type DigitalOceanDnsZoneSpecInput struct {
	// The domain name for the DNS zone.
	//  Must be a valid fully-qualified domain name (e.g., "example.com").
	DomainName string `json:"domain_name" jsonschema:"required,The domain name for the DNS zone. Must be a valid fully-qualified domain name (e.g.; 'example.com')."`
	// A list of DNS records to create within the zone (optional).
	//  Each record includes its type, name, value(s), and TTL.
	Records []*DigitalOceanDnsZoneRecordInput `json:"records,omitempty" jsonschema:"A list of DNS records to create within the zone (optional). Each record includes its type; name; value(s); and TTL."`
}

func (s *DigitalOceanDnsZoneSpecInput) validate() error {
	if s.DomainName == "" {
		return fmt.Errorf("domain_name is required")
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *DigitalOceanDnsZoneSpecInput) applyDefaults() {
}

func (s *DigitalOceanDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domain_name"] = s.DomainName
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// DnsRecord represents a DNS record entry to be created in the zone.
type DigitalOceanDnsZoneRecordInput struct {
	// The host/name for the DNS record, relative to the zone.
	//  For root records, use "@" to denote the zone itself.
	Name string `json:"name" jsonschema:"required,The host/name for the DNS record; relative to the zone. For root records; use '@' to denote the zone itself."`
	// The value or values for the DNS record.
	//  - For A/AAAA: one or more IP address(es).
	//  - For CNAME: the target domain name.
	//  - For TXT: the text data (if multiple strings, they will be concatenated by DNS).
	//  - For MX: the mail server domain name (priority is specified separately in the priority field)....
	Values []string `json:"values" jsonschema:"required,The value or values for the DNS record. - For A/AAAA: one or more IP address(es). - For CNAME: the target domain name. - For TXT: the text data (if multiple strings; they will be concatenated by DNS)...."`
	// The time-to-live for this DNS record, in seconds.
	//  Determines how long resolvers cache the record. Defaults to 3600 seconds (1 hour) if not set.
	TtlSeconds uint32 `json:"ttl_seconds,omitempty" jsonschema:"The time-to-live for this DNS record; in seconds. Determines how long resolvers cache the record. Defaults to 3600 seconds (1 hour) if not set."`
	// The type of the DNS record.
	//  This field is required and must be one of the supported record types.
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|ALIAS|CNAME|MX|NS|PTR|SOA|SRV|TXT|CAA,The type of the DNS record. This field is required and must be one of the supported record types."`
	// Priority for MX and SRV records.
	//  - For MX records: Lower values indicate higher priority (e.g., 1 is higher priority than 10).
	//  - For SRV records: Used in conjunction with weight for load distribution.
	//  - Ignored for other record types.
	//  Defaults to 0 if not specified.
	Priority uint32 `json:"priority,omitempty" jsonschema:"Priority for MX and SRV records. - For MX records: Lower values indicate higher priority (e.g.; 1 is higher priority than 10). - For SRV records: Used in conjunction with weight for load distribution...."`
	// Weight for SRV records.
	//  Specifies the relative weight for records with the same priority.
	//  Higher weights are chosen more often.
	//  Ignored for non-SRV record types.
	//  Defaults to 0 if not specified.
	Weight uint32 `json:"weight,omitempty" jsonschema:"Weight for SRV records. Specifies the relative weight for records with the same priority. Higher weights are chosen more often. Ignored for non-SRV record types. Defaults to 0 if not specified."`
	// Port for SRV records.
	//  Specifies the TCP or UDP port on which the service is available.
	//  Required for SRV records, ignored for other types.
	//  Defaults to 0 if not specified.
	Port uint32 `json:"port,omitempty" jsonschema:"Port for SRV records. Specifies the TCP or UDP port on which the service is available. Required for SRV records; ignored for other types. Defaults to 0 if not specified."`
	// Flags for CAA records.
	//  - 0: Non-critical (default) - If a CA doesn't understand the tag, it can ignore it.
	//  - 128: Critical - If a CA doesn't understand the tag, it must refuse to issue.
	//  Ignored for non-CAA record types.
	//  Defaults to 0 if not specified.
	Flags uint32 `json:"flags,omitempty" jsonschema:"Flags for CAA records. - 0: Non-critical (default) - If a CA doesn't understand the tag; it can ignore it. - 128: Critical - If a CA doesn't understand the tag; it must refuse to issue. Ignored for no..."`
	// Tag for CAA records.
	//  Specifies the property being authorized:
	//  - "issue": Authorizes a CA to issue certificates for the domain.
	//  - "issuewild": Authorizes a CA to issue wildcard certificates.
	//  - "iodef": Specifies a URL to which a CA may report policy violations.
	//  Required for CAA records, ignored ...
	Tag string `json:"tag,omitempty" jsonschema:"Tag for CAA records. Specifies the property being authorized: - 'issue': Authorizes a CA to issue certificates for the domain. - 'issuewild': Authorizes a CA to issue wildcard certificates. - 'iodef':..."`
}

func (s *DigitalOceanDnsZoneRecordInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.Values) == 0 {
		return fmt.Errorf("values is required")
	}
	if len(s.Values) < 1 {
		return fmt.Errorf("values requires at least 1 items, got %d", len(s.Values))
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "ALIAS", "CNAME", "MX", "NS", "PTR", "SOA", "SRV", "TXT", "CAA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *DigitalOceanDnsZoneRecordInput) applyDefaults() {
}

func (s *DigitalOceanDnsZoneRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["values"] = s.Values
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	m["type"] = s.Type
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Flags != 0 {
		m["flags"] = s.Flags
	}
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	return m
}

// ParseDigitalOceanDnsZone validates and normalizes a DigitalOceanDnsZone cloud_object.
func ParseDigitalOceanDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
