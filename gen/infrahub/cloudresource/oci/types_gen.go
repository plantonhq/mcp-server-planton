// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30
// Shared types used by multiple providers in the oci package.

package oci

import "fmt"

var _ = fmt.Errorf

// Backend defines where matching requests are forwarded.
type BackendInput struct {
	// Backend type.
	Type string `json:"type,omitempty" jsonschema:"enum=http|oracle_functions|stock_response,Backend type."`
	// Target URL for HTTP backends (e.g., "https://backend.example.com:8080").
	//  Required when type is http.
	Url string `json:"url,omitempty" jsonschema:"Target URL for HTTP backends (e.g.; 'https://backend.example.com:8080'). Required when type is http."`
	// OCID of the OCI function to invoke. Required when type is oracle_functions.
	FunctionId string `json:"function_id,omitempty" jsonschema:"OCID of the OCI function to invoke. Required when type is oracle_functions."`
	// HTTP status code for stock responses (e.g., 200, 404).
	//  Only applicable when type is stock_response.
	Status int32 `json:"status,omitempty" jsonschema:"HTTP status code for stock responses (e.g.; 200; 404). Only applicable when type is stock_response."`
	// Response body for stock responses.
	//  Only applicable when type is stock_response.
	Body string `json:"body,omitempty" jsonschema:"Response body for stock responses. Only applicable when type is stock_response."`
	// Connection timeout in seconds. Applicable to http and oracle_functions backends.
	ConnectTimeoutInSeconds float32 `json:"connect_timeout_in_seconds,omitempty" jsonschema:"Connection timeout in seconds. Applicable to http and oracle_functions backends."`
	// Read timeout in seconds. Applicable to http and oracle_functions backends.
	ReadTimeoutInSeconds float32 `json:"read_timeout_in_seconds,omitempty" jsonschema:"Read timeout in seconds. Applicable to http and oracle_functions backends."`
	// Send timeout in seconds. Applicable to http and oracle_functions backends.
	SendTimeoutInSeconds float32 `json:"send_timeout_in_seconds,omitempty" jsonschema:"Send timeout in seconds. Applicable to http and oracle_functions backends."`
	// Whether to skip TLS certificate verification for the backend.
	//  Applicable to http backends.
	IsSslVerifyDisabled bool `json:"is_ssl_verify_disabled,omitempty" jsonschema:"Whether to skip TLS certificate verification for the backend. Applicable to http backends."`
	// Custom headers to add to requests forwarded to the backend.
	Headers []*BackendHeaderInput `json:"headers,omitempty" jsonschema:"Custom headers to add to requests forwarded to the backend."`
}

func (s *BackendInput) validate() error {
	switch s.Type {
	case "", "http", "oracle_functions", "stock_response":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	for i, v := range s.Headers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("headers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *BackendInput) applyDefaults() {
}

func (s *BackendInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Url != "" {
		m["url"] = s.Url
	}
	if s.FunctionId != "" {
		m["function_id"] = s.FunctionId
	}
	if s.Status != 0 {
		m["status"] = s.Status
	}
	if s.Body != "" {
		m["body"] = s.Body
	}
	if s.ConnectTimeoutInSeconds != 0 {
		m["connect_timeout_in_seconds"] = s.ConnectTimeoutInSeconds
	}
	if s.ReadTimeoutInSeconds != 0 {
		m["read_timeout_in_seconds"] = s.ReadTimeoutInSeconds
	}
	if s.SendTimeoutInSeconds != 0 {
		m["send_timeout_in_seconds"] = s.SendTimeoutInSeconds
	}
	if s.IsSslVerifyDisabled {
		m["is_ssl_verify_disabled"] = s.IsSslVerifyDisabled
	}
	if len(s.Headers) > 0 {
		items := make([]any, len(s.Headers))
		for i, v := range s.Headers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["headers"] = items
	}
	return m
}

// BackendSet defines a group of backend servers that receive traffic
//
//	from the load balancer, along with the load balancing policy and
//	health checking configuration.
type BackendSetInput struct {
	// Unique name for this backend set within the load balancer.
	//  Listeners reference backend sets by this name.
	Name string `json:"name,omitempty" jsonschema:"Unique name for this backend set within the load balancer. Listeners reference backend sets by this name."`
	// Load balancing policy that determines how traffic is distributed
	//  across backends.
	Policy string `json:"policy,omitempty" jsonschema:"enum=round_robin|least_connections|ip_hash,Load balancing policy that determines how traffic is distributed across backends."`
	// Health checker configuration that monitors backend availability.
	//  The load balancer removes unhealthy backends from the rotation
	//  until they pass health checks again.
	HealthChecker *HealthCheckerInput `json:"health_checker" jsonschema:"required,Health checker configuration that monitors backend availability. The load balancer removes unhealthy backends from the rotation until they pass health checks again."`
	// Backend servers in this set. When omitted, the backend set is
	//  created without backends (useful when backends are added dynamically).
	Backends []*BackendInput `json:"backends,omitempty" jsonschema:"Backend servers in this set. When omitted; the backend set is created without backends (useful when backends are added dynamically)."`
	// SSL configuration for encrypting traffic between the load balancer
	//  and the backend servers (backend SSL / re-encryption).
	SslConfiguration *SslConfigurationInput `json:"ssl_configuration,omitempty" jsonschema:"SSL configuration for encrypting traffic between the load balancer and the backend servers (backend SSL / re-encryption)."`
	// Maximum number of simultaneous connections to allow per backend.
	//  When omitted, connections are unlimited.
	BackendMaxConnections int32 `json:"backend_max_connections,omitempty" jsonschema:"Maximum number of simultaneous connections to allow per backend. When omitted; connections are unlimited."`
	// Load-balancer-managed cookie persistence. The LB injects and tracks
	//  a cookie to pin clients to specific backends.
	LbCookieSessionPersistence *LbCookieSessionPersistenceConfigInput `json:"lb_cookie_session_persistence,omitempty" jsonschema:"Load-balancer-managed cookie persistence. The LB injects and tracks a cookie to pin clients to specific backends."`
	// Application-managed cookie persistence. The LB reads an existing
	//  application cookie to determine backend affinity.
	AppCookieSessionPersistence *SessionPersistenceConfigInput `json:"app_cookie_session_persistence,omitempty" jsonschema:"Application-managed cookie persistence. The LB reads an existing application cookie to determine backend affinity."`
}

func (s *BackendSetInput) validate() error {
	switch s.Policy {
	case "", "round_robin", "least_connections", "ip_hash":
	default:
		return fmt.Errorf("invalid policy: %q", s.Policy)
	}
	if s.HealthChecker == nil {
		return fmt.Errorf("health_checker is required")
	}
	if s.HealthChecker != nil {
		if err := s.HealthChecker.validate(); err != nil {
			return fmt.Errorf("health_checker: %w", err)
		}
	}
	for i, v := range s.Backends {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backends[%d]: %w", i, err)
			}
		}
	}
	if s.SslConfiguration != nil {
		if err := s.SslConfiguration.validate(); err != nil {
			return fmt.Errorf("ssl_configuration: %w", err)
		}
	}
	if s.LbCookieSessionPersistence != nil {
		if err := s.LbCookieSessionPersistence.validate(); err != nil {
			return fmt.Errorf("lb_cookie_session_persistence: %w", err)
		}
	}
	if s.AppCookieSessionPersistence != nil {
		if err := s.AppCookieSessionPersistence.validate(); err != nil {
			return fmt.Errorf("app_cookie_session_persistence: %w", err)
		}
	}
	return nil
}

func (s *BackendSetInput) applyDefaults() {
	if s.HealthChecker != nil {
		s.HealthChecker.applyDefaults()
	}
	if s.SslConfiguration != nil {
		s.SslConfiguration.applyDefaults()
	}
	if s.LbCookieSessionPersistence != nil {
		s.LbCookieSessionPersistence.applyDefaults()
	}
	if s.AppCookieSessionPersistence != nil {
		s.AppCookieSessionPersistence.applyDefaults()
	}
}

func (s *BackendSetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Policy != "" {
		m["policy"] = s.Policy
	}
	if s.HealthChecker != nil {
		m["health_checker"] = s.HealthChecker.toMap()
	}
	if len(s.Backends) > 0 {
		items := make([]any, len(s.Backends))
		for i, v := range s.Backends {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backends"] = items
	}
	if s.SslConfiguration != nil {
		m["ssl_configuration"] = s.SslConfiguration.toMap()
	}
	if s.BackendMaxConnections != 0 {
		m["backend_max_connections"] = s.BackendMaxConnections
	}
	if s.LbCookieSessionPersistence != nil {
		m["lb_cookie_session_persistence"] = s.LbCookieSessionPersistence.toMap()
	}
	if s.AppCookieSessionPersistence != nil {
		m["app_cookie_session_persistence"] = s.AppCookieSessionPersistence.toMap()
	}
	return m
}

// BackupPolicy configures automatic backups for the DB System.
type BackupPolicyInput struct {
	// Whether automatic backups are enabled.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether automatic backups are enabled."`
	// Number of days to retain automatic backups.
	RetentionInDays int32 `json:"retention_in_days,omitempty" jsonschema:"Number of days to retain automatic backups."`
	// Start of the 30-minute daily backup window in RFC3339 time format
	//  (e.g. "03:00"). When omitted, OCI selects the window.
	WindowStartTime string `json:"window_start_time,omitempty" jsonschema:"Start of the 30-minute daily backup window in RFC3339 time format (e.g. '03:00'). When omitted; OCI selects the window."`
	// Point-in-time recovery configuration.
	PitrPolicy *PitrPolicyInput `json:"pitr_policy,omitempty" jsonschema:"Point-in-time recovery configuration."`
}

func (s *BackupPolicyInput) validate() error {
	if s.PitrPolicy != nil {
		if err := s.PitrPolicy.validate(); err != nil {
			return fmt.Errorf("pitr_policy: %w", err)
		}
	}
	return nil
}

func (s *BackupPolicyInput) applyDefaults() {
	if s.PitrPolicy != nil {
		s.PitrPolicy.applyDefaults()
	}
}

func (s *BackupPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.RetentionInDays != 0 {
		m["retention_in_days"] = s.RetentionInDays
	}
	if s.WindowStartTime != "" {
		m["window_start_time"] = s.WindowStartTime
	}
	if s.PitrPolicy != nil {
		m["pitr_policy"] = s.PitrPolicy.toMap()
	}
	return m
}

// CustomerContact holds a single customer contact email for notifications.
type CustomerContactInput struct {
	// Email address for operational notifications.
	Email string `json:"email,omitempty" jsonschema:"Email address for operational notifications."`
}

func (s *CustomerContactInput) validate() error {
	return nil
}

func (s *CustomerContactInput) applyDefaults() {
}

func (s *CustomerContactInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Email != "" {
		m["email"] = s.Email
	}
	return m
}

// HealthChecker configures periodic health probes sent to backend servers.
//
//	Backends that fail health checks are temporarily removed from the load
//	balancing rotation.
type HealthCheckerInput struct {
	// Protocol used for health checks.
	Protocol string `json:"protocol,omitempty" jsonschema:"enum=http|tcp,Protocol used for health checks."`
	// Port on the backend server to probe. When omitted or set to 0,
	//  the health checker uses the backend's traffic port.
	Port int32 `json:"port,omitempty" jsonschema:"Port on the backend server to probe. When omitted or set to 0; the health checker uses the backend's traffic port."`
	// URL path for HTTP health checks (e.g., "/health", "/ready").
	//  Required when protocol is http. Ignored for tcp.
	UrlPath string `json:"url_path,omitempty" jsonschema:"URL path for HTTP health checks (e.g.; '/health'; '/ready'). Required when protocol is http. Ignored for tcp."`
	// Expected HTTP status code from healthy backends (e.g., 200).
	//  When omitted, any 2xx status is considered healthy.
	ReturnCode int32 `json:"return_code,omitempty" jsonschema:"Expected HTTP status code from healthy backends (e.g.; 200). When omitted; any 2xx status is considered healthy."`
	// Regex pattern to match against the response body. The backend is
	//  considered healthy only if the response body matches this pattern.
	//  When omitted, body content is not checked.
	ResponseBodyRegex string `json:"response_body_regex,omitempty" jsonschema:"Regex pattern to match against the response body. The backend is considered healthy only if the response body matches this pattern. When omitted; body content is not checked."`
	// Interval between consecutive health checks in milliseconds.
	//  When omitted, defaults to 30000 (30 seconds).
	IntervalMs int32 `json:"interval_ms,omitempty" jsonschema:"Interval between consecutive health checks in milliseconds. When omitted; defaults to 30000 (30 seconds)."`
	// Maximum time to wait for a health check response in milliseconds.
	//  When omitted, defaults to 3000 (3 seconds).
	TimeoutInMillis int32 `json:"timeout_in_millis,omitempty" jsonschema:"Maximum time to wait for a health check response in milliseconds. When omitted; defaults to 3000 (3 seconds)."`
	// Number of consecutive failed health checks before marking a backend
	//  as unhealthy. When omitted, defaults to 3.
	Retries int32 `json:"retries,omitempty" jsonschema:"Number of consecutive failed health checks before marking a backend as unhealthy. When omitted; defaults to 3."`
	// When true, forces health checks over plain text even when the
	//  backend set has SSL configured.
	IsForcePlainText bool `json:"is_force_plain_text,omitempty" jsonschema:"When true; forces health checks over plain text even when the backend set has SSL configured."`
}

func (s *HealthCheckerInput) validate() error {
	switch s.Protocol {
	case "", "http", "tcp":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	return nil
}

func (s *HealthCheckerInput) applyDefaults() {
}

func (s *HealthCheckerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.UrlPath != "" {
		m["url_path"] = s.UrlPath
	}
	if s.ReturnCode != 0 {
		m["return_code"] = s.ReturnCode
	}
	if s.ResponseBodyRegex != "" {
		m["response_body_regex"] = s.ResponseBodyRegex
	}
	if s.IntervalMs != 0 {
		m["interval_ms"] = s.IntervalMs
	}
	if s.TimeoutInMillis != 0 {
		m["timeout_in_millis"] = s.TimeoutInMillis
	}
	if s.Retries != 0 {
		m["retries"] = s.Retries
	}
	if s.IsForcePlainText {
		m["is_force_plain_text"] = s.IsForcePlainText
	}
	return m
}

// ImagePolicyConfig enables container image signature verification.
//
//	When enabled with KMS keys, all images deployed to the cluster must
//	be signed with at least one of the specified keys.
type ImagePolicyConfigInput struct {
	// Whether the image verification policy is enabled.
	IsPolicyEnabled bool `json:"is_policy_enabled,omitempty" jsonschema:"Whether the image verification policy is enabled."`
	// KMS keys used for image signature verification.
	KeyDetails []*ImagePolicyKeyDetailInput `json:"key_details,omitempty" jsonschema:"KMS keys used for image signature verification."`
}

func (s *ImagePolicyConfigInput) validate() error {
	for i, v := range s.KeyDetails {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("key_details[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ImagePolicyConfigInput) applyDefaults() {
}

func (s *ImagePolicyConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsPolicyEnabled {
		m["is_policy_enabled"] = s.IsPolicyEnabled
	}
	if len(s.KeyDetails) > 0 {
		items := make([]any, len(s.KeyDetails))
		for i, v := range s.KeyDetails {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["key_details"] = items
	}
	return m
}

// ImagePolicyKeyDetail identifies a KMS key for image signature verification.
type ImagePolicyKeyDetailInput struct {
	// OCID of the KMS key used to verify image signatures.
	//  default_kind will be updated when OciKmsKey (R25) is implemented.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of the KMS key used to verify image signatures. default_kind will be updated when OciKmsKey (R25) is implemented."`
}

func (s *ImagePolicyKeyDetailInput) validate() error {
	return nil
}

func (s *ImagePolicyKeyDetailInput) applyDefaults() {
}

func (s *ImagePolicyKeyDetailInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	return m
}

// Listener defines a port and protocol on which the load balancer accepts
//
//	incoming client connections and routes them to a backend set.
type ListenerInput struct {
	// Unique name for this listener within the load balancer.
	Name string `json:"name,omitempty" jsonschema:"Unique name for this listener within the load balancer."`
	// Port on which the listener accepts connections.
	Port int32 `json:"port,omitempty" jsonschema:"Port on which the listener accepts connections."`
	// Protocol for the listener.
	Protocol string `json:"protocol,omitempty" jsonschema:"enum=http|http2|tcp|grpc,Protocol for the listener."`
	// Name of the backend set that receives traffic from this listener.
	//  Must match a backend set defined in backend_sets.
	DefaultBackendSetName string `json:"default_backend_set_name,omitempty" jsonschema:"Name of the backend set that receives traffic from this listener. Must match a backend set defined in backend_sets."`
	// SSL configuration for encrypting traffic between clients and
	//  the load balancer (SSL termination). Required for HTTPS listeners.
	SslConfiguration *SslConfigurationInput `json:"ssl_configuration,omitempty" jsonschema:"SSL configuration for encrypting traffic between clients and the load balancer (SSL termination). Required for HTTPS listeners."`
	// Connection configuration for idle timeout and proxy protocol settings.
	ConnectionConfiguration *ConnectionConfigurationInput `json:"connection_configuration,omitempty" jsonschema:"Connection configuration for idle timeout and proxy protocol settings."`
	// Names of hostname resources defined in this load balancer's hostnames
	//  list. When set, the listener only handles requests matching these
	//  hostnames (virtual host routing).
	HostnameNames []string `json:"hostname_names,omitempty" jsonschema:"Names of hostname resources defined in this load balancer's hostnames list. When set; the listener only handles requests matching these hostnames (virtual host routing)."`
	// Names of rule set resources defined in this load balancer's rule_sets
	//  list. Rule sets are applied in the order specified.
	RuleSetNames []string `json:"rule_set_names,omitempty" jsonschema:"Names of rule set resources defined in this load balancer's rule_sets list. Rule sets are applied in the order specified."`
	// Name of a routing policy for content-based routing.
	//  Routing policies are an advanced OCI feature managed outside
	//  this component.
	RoutingPolicyName string `json:"routing_policy_name,omitempty" jsonschema:"Name of a routing policy for content-based routing. Routing policies are an advanced OCI feature managed outside this component."`
}

func (s *ListenerInput) validate() error {
	switch s.Protocol {
	case "", "http", "http2", "tcp", "grpc":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	if s.SslConfiguration != nil {
		if err := s.SslConfiguration.validate(); err != nil {
			return fmt.Errorf("ssl_configuration: %w", err)
		}
	}
	if s.ConnectionConfiguration != nil {
		if err := s.ConnectionConfiguration.validate(); err != nil {
			return fmt.Errorf("connection_configuration: %w", err)
		}
	}
	return nil
}

func (s *ListenerInput) applyDefaults() {
	if s.SslConfiguration != nil {
		s.SslConfiguration.applyDefaults()
	}
	if s.ConnectionConfiguration != nil {
		s.ConnectionConfiguration.applyDefaults()
	}
}

func (s *ListenerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.DefaultBackendSetName != "" {
		m["default_backend_set_name"] = s.DefaultBackendSetName
	}
	if s.SslConfiguration != nil {
		m["ssl_configuration"] = s.SslConfiguration.toMap()
	}
	if s.ConnectionConfiguration != nil {
		m["connection_configuration"] = s.ConnectionConfiguration.toMap()
	}
	if len(s.HostnameNames) > 0 {
		m["hostname_names"] = s.HostnameNames
	}
	if len(s.RuleSetNames) > 0 {
		m["rule_set_names"] = s.RuleSetNames
	}
	if s.RoutingPolicyName != "" {
		m["routing_policy_name"] = s.RoutingPolicyName
	}
	return m
}

// NetworkDetails describes the network resource being attached to the DRG.
type NetworkDetailsInput struct {
	// Type of network resource being attached.
	Type string `json:"type,omitempty" jsonschema:"enum=vcn|ipsec_tunnel|remote_peering_connection|virtual_circuit|loopback,Type of network resource being attached."`
	// OCID of the network resource (VCN, IPSec connection, virtual circuit,
	//  or remote peering connection). For VCN attachments this is the VCN
	//  OCID; for IPSec it is the IPSec connection OCID, etc.
	//
	//  Uses StringValueOrRef without a default_kind because the referenced
	//  resource type depends on the attachm...
	Id string `json:"id" jsonschema:"required,OCID of the network resource (VCN; IPSec connection; virtual circuit; or remote peering connection). For VCN attachments this is the VCN OCID; for IPSec it is the IPSec connection OCID; etc. Uses Stri..."`
	// OCID of the VCN route table to use for ingress routing (transit
	//  routing). Only applicable for VCN attachments. When set, traffic
	//  entering the VCN through this DRG attachment is routed according
	//  to this VCN route table rather than the VCN's default route table.
	RouteTableId string `json:"route_table_id,omitempty" jsonschema:"OCID of the VCN route table to use for ingress routing (transit routing). Only applicable for VCN attachments. When set; traffic entering the VCN through this DRG attachment is routed according to thi..."`
	// Controls whether VCN CIDRs or individual subnet CIDRs are imported
	//  into the DRG route table. Only applicable for VCN attachments.
	VcnRouteType string `json:"vcn_route_type,omitempty" jsonschema:"enum=vcn_cidrs|subnet_cidrs,Controls whether VCN CIDRs or individual subnet CIDRs are imported into the DRG route table. Only applicable for VCN attachments."`
}

func (s *NetworkDetailsInput) validate() error {
	switch s.Type {
	case "", "vcn", "ipsec_tunnel", "remote_peering_connection", "virtual_circuit", "loopback":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.Id == "" {
		return fmt.Errorf("id is required")
	}
	switch s.VcnRouteType {
	case "", "vcn_cidrs", "subnet_cidrs":
	default:
		return fmt.Errorf("invalid vcn_route_type: %q", s.VcnRouteType)
	}
	return nil
}

func (s *NetworkDetailsInput) applyDefaults() {
}

func (s *NetworkDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	m["id"] = s.Id
	if s.RouteTableId != "" {
		m["route_table_id"] = s.RouteTableId
	}
	if s.VcnRouteType != "" {
		m["vcn_route_type"] = s.VcnRouteType
	}
	return m
}

// PortRange defines a range of ports (or a single port when maximum
//
//	is omitted).
type PortRangeInput struct {
	// Start of the port range (inclusive). Must be 1-65535.
	MinimumPort int32 `json:"minimum_port,omitempty" jsonschema:"Start of the port range (inclusive). Must be 1-65535."`
	// End of the port range (inclusive). When omitted, equals
	//  minimum_port (single port). Must be >= minimum_port when set.
	MaximumPort int32 `json:"maximum_port,omitempty" jsonschema:"End of the port range (inclusive). When omitted; equals minimum_port (single port). Must be >= minimum_port when set."`
}

func (s *PortRangeInput) validate() error {
	return nil
}

func (s *PortRangeInput) applyDefaults() {
}

func (s *PortRangeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinimumPort != 0 {
		m["minimum_port"] = s.MinimumPort
	}
	if s.MaximumPort != 0 {
		m["maximum_port"] = s.MaximumPort
	}
	return m
}

// ReservedIp references a pre-created OCI reserved public IP.
type ReservedIpInput struct {
	// OCID of the reserved public IP to assign to the load balancer.
	Id string `json:"id,omitempty" jsonschema:"OCID of the reserved public IP to assign to the load balancer."`
}

func (s *ReservedIpInput) validate() error {
	return nil
}

func (s *ReservedIpInput) applyDefaults() {
}

func (s *ReservedIpInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Id != "" {
		m["id"] = s.Id
	}
	return m
}

// ShapeConfig specifies the exact resource allocation for flexible shapes.
type ShapeConfigInput struct {
	// Number of OCPUs (Oracle CPUs). Each OCPU maps to a physical core
	//  with simultaneous multi-threading.
	Ocpus float32 `json:"ocpus,omitempty" jsonschema:"Number of OCPUs (Oracle CPUs). Each OCPU maps to a physical core with simultaneous multi-threading."`
	// Amount of memory in GiB. Flex shapes allow a range per OCPU; consult
	//  the shape documentation for valid ratios.
	MemoryInGbs float32 `json:"memory_in_gbs,omitempty" jsonschema:"Amount of memory in GiB. Flex shapes allow a range per OCPU; consult the shape documentation for valid ratios."`
	// Baseline OCPU utilization for burstable instances.
	//  Valid values: "BASELINE_1_8", "BASELINE_1_2", "BASELINE_1_1".
	//  Only applicable to burstable shapes.
	BaselineOcpuUtilization string `json:"baseline_ocpu_utilization,omitempty" jsonschema:"Baseline OCPU utilization for burstable instances. Valid values: 'BASELINE_1_8'; 'BASELINE_1_2'; 'BASELINE_1_1'. Only applicable to burstable shapes."`
	// Number of NVMe drives for dense-IO shapes.
	Nvmes int32 `json:"nvmes,omitempty" jsonschema:"Number of NVMe drives for dense-IO shapes."`
}

func (s *ShapeConfigInput) validate() error {
	return nil
}

func (s *ShapeConfigInput) applyDefaults() {
}

func (s *ShapeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Ocpus != 0 {
		m["ocpus"] = s.Ocpus
	}
	if s.MemoryInGbs != 0 {
		m["memory_in_gbs"] = s.MemoryInGbs
	}
	if s.BaselineOcpuUtilization != "" {
		m["baseline_ocpu_utilization"] = s.BaselineOcpuUtilization
	}
	if s.Nvmes != 0 {
		m["nvmes"] = s.Nvmes
	}
	return m
}
