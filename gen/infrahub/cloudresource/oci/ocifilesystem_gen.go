// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciFileSystem is the top-level resource representing an OCI File Storage
//
//	file system with a dedicated mount target and NFS exports.
type OciFileSystemSpecInput struct {
	// OCID of the compartment where the file system and mount target
	//  will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the file system and mount target will be created."`
	// Availability domain where the file system and mount target are created.
	//  Both must reside in the same AD. Example: "Uocm:US-ASHBURN-AD-1".
	//  Changing this forces recreation of all resources.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain where the file system and mount target are created. Both must reside in the same AD. Example: 'Uocm:US-ASHBURN-AD-1'. Changing this forces recreation of all resources."`
	// Display name for the file system. When omitted, OCI generates one.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the file system. When omitted; OCI generates one."`
	// OCID of a KMS master encryption key for server-side encryption.
	//  When unset, Oracle-managed keys are used.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of a KMS master encryption key for server-side encryption. When unset; Oracle-managed keys are used."`
	// OCID of a filesystem snapshot policy to attach for automated snapshots.
	//  The policy must exist in the same availability domain.
	FilesystemSnapshotPolicyId string `json:"filesystem_snapshot_policy_id,omitempty" jsonschema:"OCID of a filesystem snapshot policy to attach for automated snapshots. The policy must exist in the same availability domain."`
	// Configuration for the dedicated NFS mount target. The mount target
	//  provides the network endpoint (IP address) that clients use to
	//  mount the file system via NFS.
	//
	//  Note: OCI's default service limit is 2 mount targets per availability
	//  domain. Request a limit increase if deploying more than 2 file s...
	MountTarget *MountTargetInput `json:"mount_target" jsonschema:"required,Configuration for the dedicated NFS mount target. The mount target provides the network endpoint (IP address) that clients use to mount the file system via NFS. Note: OCI's default service limit is 2 ..."`
	// NFS export paths. Each export makes the file system accessible at
	//  a specific path on the mount target. At least one export is required.
	Exports []*ExportInput `json:"exports,omitempty" jsonschema:"NFS export paths. Each export makes the file system accessible at a specific path on the mount target. At least one export is required."`
}

func (s *OciFileSystemSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.MountTarget == nil {
		return fmt.Errorf("mount_target is required")
	}
	if s.MountTarget != nil {
		if err := s.MountTarget.validate(); err != nil {
			return fmt.Errorf("mount_target: %w", err)
		}
	}
	if len(s.Exports) < 1 {
		return fmt.Errorf("exports requires at least 1 items, got %d", len(s.Exports))
	}
	for i, v := range s.Exports {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("exports[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciFileSystemSpecInput) applyDefaults() {
	if s.MountTarget != nil {
		s.MountTarget.applyDefaults()
	}
}

func (s *OciFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.FilesystemSnapshotPolicyId != "" {
		m["filesystem_snapshot_policy_id"] = s.FilesystemSnapshotPolicyId
	}
	if s.MountTarget != nil {
		m["mount_target"] = s.MountTarget.toMap()
	}
	if len(s.Exports) > 0 {
		items := make([]any, len(s.Exports))
		for i, v := range s.Exports {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["exports"] = items
	}
	return m
}

// Export defines an NFS export path that connects the file system to
//
//	the mount target. Clients mount the file system using:
//	  mount -t nfs <mount_target_ip>:<path> /local/mount/point
type ExportInput struct {
	// NFS export path. Must start with '/' and be unique within the
	//  mount target's export set. Example: "/shared-data".
	//  Changing this forces recreation.
	Path string `json:"path,omitempty" jsonschema:"NFS export path. Must start with '/' and be unique within the mount target's export set. Example: '/shared-data'. Changing this forces recreation."`
	// NFS access control rules. Each rule specifies a source CIDR
	//  and its permissions. When omitted, OCI applies default access.
	ExportOptions []*ExportOptionInput `json:"export_options,omitempty" jsonschema:"NFS access control rules. Each rule specifies a source CIDR and its permissions. When omitted; OCI applies default access."`
}

func (s *ExportInput) validate() error {
	for i, v := range s.ExportOptions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("export_options[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ExportInput) applyDefaults() {
}

func (s *ExportInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Path != "" {
		m["path"] = s.Path
	}
	if len(s.ExportOptions) > 0 {
		items := make([]any, len(s.ExportOptions))
		for i, v := range s.ExportOptions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["export_options"] = items
	}
	return m
}

// ExportOption defines NFS access control for a source CIDR range.
type ExportOptionInput struct {
	// Source IP address or CIDR block allowed to access this export.
	//  Use "0.0.0.0/0" for unrestricted access within the network.
	Source string `json:"source,omitempty" jsonschema:"Source IP address or CIDR block allowed to access this export. Use '0.0.0.0/0' for unrestricted access within the network."`
	// NFS access level for this source.
	Access string `json:"access,omitempty" jsonschema:"enum=read_write|read_only,NFS access level for this source."`
	// Identity squashing mode for NFS requests from this source.
	IdentitySquash string `json:"identity_squash,omitempty" jsonschema:"enum=no_squash|root_squash|all_squash,Identity squashing mode for NFS requests from this source."`
	// When true, only connections from privileged source ports
	//  (< 1024) are allowed. Standard for UNIX NFS clients.
	RequirePrivilegedSourcePort bool `json:"require_privileged_source_port,omitempty" jsonschema:"When true; only connections from privileged source ports (< 1024) are allowed. Standard for UNIX NFS clients."`
	// When true, anonymous (unauthenticated) access is allowed.
	IsAnonymousAccessAllowed bool `json:"is_anonymous_access_allowed,omitempty" jsonschema:"When true; anonymous (unauthenticated) access is allowed."`
	// UNIX UID to map anonymous or squashed users to.
	//  Typically 65534 (nobody). Stored as Int64 string in OCI API.
	AnonymousUid int64 `json:"anonymous_uid,omitempty" jsonschema:"UNIX UID to map anonymous or squashed users to. Typically 65534 (nobody). Stored as Int64 string in OCI API."`
	// UNIX GID to map anonymous or squashed users to.
	//  Typically 65534 (nogroup). Stored as Int64 string in OCI API.
	AnonymousGid int64 `json:"anonymous_gid,omitempty" jsonschema:"UNIX GID to map anonymous or squashed users to. Typically 65534 (nogroup). Stored as Int64 string in OCI API."`
}

func (s *ExportOptionInput) validate() error {
	switch s.Access {
	case "", "read_write", "read_only":
	default:
		return fmt.Errorf("invalid access: %q", s.Access)
	}
	switch s.IdentitySquash {
	case "", "no_squash", "root_squash", "all_squash":
	default:
		return fmt.Errorf("invalid identity_squash: %q", s.IdentitySquash)
	}
	return nil
}

func (s *ExportOptionInput) applyDefaults() {
}

func (s *ExportOptionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Source != "" {
		m["source"] = s.Source
	}
	if s.Access != "" {
		m["access"] = s.Access
	}
	if s.IdentitySquash != "" {
		m["identity_squash"] = s.IdentitySquash
	}
	if s.RequirePrivilegedSourcePort {
		m["require_privileged_source_port"] = s.RequirePrivilegedSourcePort
	}
	if s.IsAnonymousAccessAllowed {
		m["is_anonymous_access_allowed"] = s.IsAnonymousAccessAllowed
	}
	if s.AnonymousUid != 0 {
		m["anonymous_uid"] = s.AnonymousUid
	}
	if s.AnonymousGid != 0 {
		m["anonymous_gid"] = s.AnonymousGid
	}
	return m
}

// MountTarget configures the NFS endpoint that provides network access
//
//	to the file system. Created in the specified subnet with an assigned
//	or auto-allocated private IP address.
type MountTargetInput struct {
	// OCID of the subnet where the mount target will be created.
	//  The subnet determines the VCN and availability domain for
	//  NFS access. Changing this forces recreation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the mount target will be created. The subnet determines the VCN and availability domain for NFS access. Changing this forces recreation."`
	// Display name for the mount target. When omitted, OCI generates one.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the mount target. When omitted; OCI generates one."`
	// DNS hostname label for the mount target within the VCN's DNS.
	//  When combined with the subnet and VCN DNS labels, produces an
	//  FQDN like <hostname>.<subnet>.<vcn>.oraclevcn.com.
	//  Changing this forces recreation.
	HostnameLabel string `json:"hostname_label,omitempty" jsonschema:"DNS hostname label for the mount target within the VCN's DNS. When combined with the subnet and VCN DNS labels; produces an FQDN like <hostname>.<subnet>.<vcn>.oraclevcn.com. Changing this forces recr..."`
	// Specific private IP address to assign. Must be available in the
	//  subnet's CIDR. When omitted, OCI auto-assigns from the subnet.
	//  Changing this forces recreation.
	IpAddress string `json:"ip_address,omitempty" jsonschema:"Specific private IP address to assign. Must be available in the subnet's CIDR. When omitted; OCI auto-assigns from the subnet. Changing this forces recreation."`
	// OCIDs of network security groups to associate with the mount target.
	//  Controls NFS traffic (port 2049/TCP, 111/TCP for portmapper).
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups to associate with the mount target. Controls NFS traffic (port 2049/TCP; 111/TCP for portmapper)."`
	// Requested throughput in Mbps for the mount target. When omitted,
	//  OCI uses the default throughput tier.
	RequestedThroughput int64 `json:"requested_throughput,omitempty" jsonschema:"Requested throughput in Mbps for the mount target. When omitted; OCI uses the default throughput tier."`
	// Maximum NFS capacity in bytes reported to clients via statfs.
	//  Configures the auto-created export set. When omitted, the actual
	//  file system metered size is reported.
	MaxFsStatBytes int64 `json:"max_fs_stat_bytes,omitempty" jsonschema:"Maximum NFS capacity in bytes reported to clients via statfs. Configures the auto-created export set. When omitted; the actual file system metered size is reported."`
	// Maximum file count reported to clients via statfs.
	//  Configures the auto-created export set. When omitted, the actual
	//  count is reported.
	MaxFsStatFiles int64 `json:"max_fs_stat_files,omitempty" jsonschema:"Maximum file count reported to clients via statfs. Configures the auto-created export set. When omitted; the actual count is reported."`
}

func (s *MountTargetInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *MountTargetInput) applyDefaults() {
}

func (s *MountTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.HostnameLabel != "" {
		m["hostname_label"] = s.HostnameLabel
	}
	if s.IpAddress != "" {
		m["ip_address"] = s.IpAddress
	}
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.RequestedThroughput != 0 {
		m["requested_throughput"] = s.RequestedThroughput
	}
	if s.MaxFsStatBytes != 0 {
		m["max_fs_stat_bytes"] = s.MaxFsStatBytes
	}
	if s.MaxFsStatFiles != 0 {
		m["max_fs_stat_files"] = s.MaxFsStatFiles
	}
	return m
}

// ParseOciFileSystem validates and normalizes a OciFileSystem cloud_object.
func ParseOciFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
