// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciSecurityGroup is the top-level resource representing an Oracle
//
//	Cloud Infrastructure Network Security Group with inline security rules.
type OciSecurityGroupSpecInput struct {
	// OCID of the compartment where the NSG will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the NSG will be created."`
	// OCID of the VCN that this NSG belongs to. Changing this forces recreation.
	VcnId string `json:"vcn_id" jsonschema:"required,OCID of the VCN that this NSG belongs to. Changing this forces recreation."`
	// Human-readable name shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Inbound security rules. Each rule defines traffic that is allowed TO
	//  resources associated with this NSG.
	IngressRules []*IngressRuleInput `json:"ingress_rules,omitempty" jsonschema:"Inbound security rules. Each rule defines traffic that is allowed TO resources associated with this NSG."`
	// Outbound security rules. Each rule defines traffic that is allowed FROM
	//  resources associated with this NSG.
	EgressRules []*EgressRuleInput `json:"egress_rules,omitempty" jsonschema:"Outbound security rules. Each rule defines traffic that is allowed FROM resources associated with this NSG."`
}

func (s *OciSecurityGroupSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.VcnId == "" {
		return fmt.Errorf("vcn_id is required")
	}
	for i, v := range s.IngressRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ingress_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.EgressRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("egress_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciSecurityGroupSpecInput) applyDefaults() {
}

func (s *OciSecurityGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	m["vcn_id"] = s.VcnId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if len(s.IngressRules) > 0 {
		items := make([]any, len(s.IngressRules))
		for i, v := range s.IngressRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ingress_rules"] = items
	}
	if len(s.EgressRules) > 0 {
		items := make([]any, len(s.EgressRules))
		for i, v := range s.EgressRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["egress_rules"] = items
	}
	return m
}

// EgressRule defines a single outbound security rule.
type EgressRuleInput struct {
	// Traffic destination: a CIDR block, a service CIDR label, or the OCID of
	//  another NSG.
	Destination string `json:"destination,omitempty" jsonschema:"Traffic destination: a CIDR block; a service CIDR label; or the OCID of another NSG."`
	// Interpretation of the destination field. Defaults to cidr_block when unset.
	DestinationType string `json:"destination_type,omitempty" jsonschema:"enum=cidr_block|service_cidr_block|network_security_group,Interpretation of the destination field. Defaults to cidr_block when unset."`
	// Transport protocol for this rule.
	Protocol string `json:"protocol" jsonschema:"required,enum=all|icmp|tcp|udp|icmpv6,Transport protocol for this rule."`
	// Optional human-readable description.
	Description string `json:"description,omitempty" jsonschema:"Optional human-readable description."`
	// When true the rule is stateless. When false (the default) the rule is stateful.
	Stateless bool `json:"stateless,omitempty" jsonschema:"When true the rule is stateless. When false (the default) the rule is stateful."`
	// TCP port constraints. Only valid when protocol is tcp.
	TcpOptions *TcpOptionsInput `json:"tcp_options,omitempty" jsonschema:"TCP port constraints. Only valid when protocol is tcp."`
	// UDP port constraints. Only valid when protocol is udp.
	UdpOptions *UdpOptionsInput `json:"udp_options,omitempty" jsonschema:"UDP port constraints. Only valid when protocol is udp."`
	// ICMP type/code constraints. Only valid when protocol is icmp or icmpv6.
	IcmpOptions *IcmpOptionsInput `json:"icmp_options,omitempty" jsonschema:"ICMP type/code constraints. Only valid when protocol is icmp or icmpv6."`
}

func (s *EgressRuleInput) validate() error {
	switch s.DestinationType {
	case "", "cidr_block", "service_cidr_block", "network_security_group":
	default:
		return fmt.Errorf("invalid destination_type: %q", s.DestinationType)
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	switch s.Protocol {
	case "all", "icmp", "tcp", "udp", "icmpv6":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	if s.TcpOptions != nil {
		if err := s.TcpOptions.validate(); err != nil {
			return fmt.Errorf("tcp_options: %w", err)
		}
	}
	if s.UdpOptions != nil {
		if err := s.UdpOptions.validate(); err != nil {
			return fmt.Errorf("udp_options: %w", err)
		}
	}
	if s.IcmpOptions != nil {
		if err := s.IcmpOptions.validate(); err != nil {
			return fmt.Errorf("icmp_options: %w", err)
		}
	}
	return nil
}

func (s *EgressRuleInput) applyDefaults() {
	if s.TcpOptions != nil {
		s.TcpOptions.applyDefaults()
	}
	if s.UdpOptions != nil {
		s.UdpOptions.applyDefaults()
	}
	if s.IcmpOptions != nil {
		s.IcmpOptions.applyDefaults()
	}
}

func (s *EgressRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Destination != "" {
		m["destination"] = s.Destination
	}
	if s.DestinationType != "" {
		m["destination_type"] = s.DestinationType
	}
	m["protocol"] = s.Protocol
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Stateless {
		m["stateless"] = s.Stateless
	}
	if s.TcpOptions != nil {
		m["tcp_options"] = s.TcpOptions.toMap()
	}
	if s.UdpOptions != nil {
		m["udp_options"] = s.UdpOptions.toMap()
	}
	if s.IcmpOptions != nil {
		m["icmp_options"] = s.IcmpOptions.toMap()
	}
	return m
}

// IcmpOptions constrains ICMP traffic by type and optionally code.
type IcmpOptionsInput struct {
	// ICMP message type (e.g. 3 for "Destination Unreachable", 8 for "Echo").
	Type int32 `json:"type,omitempty" jsonschema:"ICMP message type (e.g. 3 for 'Destination Unreachable'; 8 for 'Echo')."`
	// ICMP message code. When omitted, all codes for the given type are matched.
	//  Use optional so that code=0 (a valid ICMP code) is distinguishable from "not set".
	Code int32 `json:"code,omitempty" jsonschema:"ICMP message code. When omitted; all codes for the given type are matched. Use optional so that code=0 (a valid ICMP code) is distinguishable from 'not set'."`
}

func (s *IcmpOptionsInput) validate() error {
	return nil
}

func (s *IcmpOptionsInput) applyDefaults() {
}

func (s *IcmpOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != 0 {
		m["type"] = s.Type
	}
	if s.Code != 0 {
		m["code"] = s.Code
	}
	return m
}

// IngressRule defines a single inbound security rule.
type IngressRuleInput struct {
	// Traffic source: a CIDR block (e.g. "10.0.0.0/16"), a service CIDR label
	//  (e.g. "all-iad-services-in-oracle-services-network"), or the OCID of
	//  another NSG.
	Source string `json:"source,omitempty" jsonschema:"Traffic source: a CIDR block (e.g. '10.0.0.0/16'); a service CIDR label (e.g. 'all-iad-services-in-oracle-services-network'); or the OCID of another NSG."`
	// Interpretation of the source field. Defaults to cidr_block when unset.
	SourceType string `json:"source_type,omitempty" jsonschema:"enum=cidr_block|service_cidr_block|network_security_group,Interpretation of the source field. Defaults to cidr_block when unset."`
	// Transport protocol for this rule.
	Protocol string `json:"protocol" jsonschema:"required,enum=all|icmp|tcp|udp|icmpv6,Transport protocol for this rule."`
	// Optional human-readable description.
	Description string `json:"description,omitempty" jsonschema:"Optional human-readable description."`
	// When true the rule is stateless (return traffic must be explicitly
	//  allowed). When false (the default) the rule is stateful.
	Stateless bool `json:"stateless,omitempty" jsonschema:"When true the rule is stateless (return traffic must be explicitly allowed). When false (the default) the rule is stateful."`
	// TCP port constraints. Only valid when protocol is tcp.
	TcpOptions *TcpOptionsInput `json:"tcp_options,omitempty" jsonschema:"TCP port constraints. Only valid when protocol is tcp."`
	// UDP port constraints. Only valid when protocol is udp.
	UdpOptions *UdpOptionsInput `json:"udp_options,omitempty" jsonschema:"UDP port constraints. Only valid when protocol is udp."`
	// ICMP type/code constraints. Only valid when protocol is icmp or icmpv6.
	IcmpOptions *IcmpOptionsInput `json:"icmp_options,omitempty" jsonschema:"ICMP type/code constraints. Only valid when protocol is icmp or icmpv6."`
}

func (s *IngressRuleInput) validate() error {
	switch s.SourceType {
	case "", "cidr_block", "service_cidr_block", "network_security_group":
	default:
		return fmt.Errorf("invalid source_type: %q", s.SourceType)
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	switch s.Protocol {
	case "all", "icmp", "tcp", "udp", "icmpv6":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	if s.TcpOptions != nil {
		if err := s.TcpOptions.validate(); err != nil {
			return fmt.Errorf("tcp_options: %w", err)
		}
	}
	if s.UdpOptions != nil {
		if err := s.UdpOptions.validate(); err != nil {
			return fmt.Errorf("udp_options: %w", err)
		}
	}
	if s.IcmpOptions != nil {
		if err := s.IcmpOptions.validate(); err != nil {
			return fmt.Errorf("icmp_options: %w", err)
		}
	}
	return nil
}

func (s *IngressRuleInput) applyDefaults() {
	if s.TcpOptions != nil {
		s.TcpOptions.applyDefaults()
	}
	if s.UdpOptions != nil {
		s.UdpOptions.applyDefaults()
	}
	if s.IcmpOptions != nil {
		s.IcmpOptions.applyDefaults()
	}
}

func (s *IngressRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Source != "" {
		m["source"] = s.Source
	}
	if s.SourceType != "" {
		m["source_type"] = s.SourceType
	}
	m["protocol"] = s.Protocol
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Stateless {
		m["stateless"] = s.Stateless
	}
	if s.TcpOptions != nil {
		m["tcp_options"] = s.TcpOptions.toMap()
	}
	if s.UdpOptions != nil {
		m["udp_options"] = s.UdpOptions.toMap()
	}
	if s.IcmpOptions != nil {
		m["icmp_options"] = s.IcmpOptions.toMap()
	}
	return m
}

// TcpOptions constrains TCP traffic by destination and/or source port range.
//
//	At least one range should be provided; when omitted, all ports are allowed.
type TcpOptionsInput struct {
	DestinationPortRange *PortRangeInput `json:"destination_port_range,omitempty" jsonschema:""`
	SourcePortRange      *PortRangeInput `json:"source_port_range,omitempty" jsonschema:""`
}

func (s *TcpOptionsInput) validate() error {
	if s.DestinationPortRange != nil {
		if err := s.DestinationPortRange.validate(); err != nil {
			return fmt.Errorf("destination_port_range: %w", err)
		}
	}
	if s.SourcePortRange != nil {
		if err := s.SourcePortRange.validate(); err != nil {
			return fmt.Errorf("source_port_range: %w", err)
		}
	}
	return nil
}

func (s *TcpOptionsInput) applyDefaults() {
	if s.DestinationPortRange != nil {
		s.DestinationPortRange.applyDefaults()
	}
	if s.SourcePortRange != nil {
		s.SourcePortRange.applyDefaults()
	}
}

func (s *TcpOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DestinationPortRange != nil {
		m["destination_port_range"] = s.DestinationPortRange.toMap()
	}
	if s.SourcePortRange != nil {
		m["source_port_range"] = s.SourcePortRange.toMap()
	}
	return m
}

// UdpOptions constrains UDP traffic by destination and/or source port range.
type UdpOptionsInput struct {
	DestinationPortRange *PortRangeInput `json:"destination_port_range,omitempty" jsonschema:""`
	SourcePortRange      *PortRangeInput `json:"source_port_range,omitempty" jsonschema:""`
}

func (s *UdpOptionsInput) validate() error {
	if s.DestinationPortRange != nil {
		if err := s.DestinationPortRange.validate(); err != nil {
			return fmt.Errorf("destination_port_range: %w", err)
		}
	}
	if s.SourcePortRange != nil {
		if err := s.SourcePortRange.validate(); err != nil {
			return fmt.Errorf("source_port_range: %w", err)
		}
	}
	return nil
}

func (s *UdpOptionsInput) applyDefaults() {
	if s.DestinationPortRange != nil {
		s.DestinationPortRange.applyDefaults()
	}
	if s.SourcePortRange != nil {
		s.SourcePortRange.applyDefaults()
	}
}

func (s *UdpOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DestinationPortRange != nil {
		m["destination_port_range"] = s.DestinationPortRange.toMap()
	}
	if s.SourcePortRange != nil {
		m["source_port_range"] = s.SourcePortRange.toMap()
	}
	return m
}

// ParseOciSecurityGroup validates and normalizes a OciSecurityGroup cloud_object.
func ParseOciSecurityGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciSecurityGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciSecurityGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
