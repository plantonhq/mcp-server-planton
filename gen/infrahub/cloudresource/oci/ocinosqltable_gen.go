// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciNosqlTable is the top-level resource representing an OCI NoSQL
//
//	table -- a fully managed, serverless NoSQL database with provisioned
//	or on-demand throughput capacity and DDL-defined schema.
type OciNosqlTableSpecInput struct {
	// OCID of the compartment where the NoSQL table will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the NoSQL table will be created."`
	// Table name. Must match the table name used in ddl_statement.
	//  Changing this forces recreation.
	Name string `json:"name,omitempty" jsonschema:"Table name. Must match the table name used in ddl_statement. Changing this forces recreation."`
	// DDL statement defining the table schema. For new tables use
	//  CREATE TABLE; for schema evolution use ALTER TABLE.
	//  Column order should not change; new columns can only be appended.
	//  Example: "CREATE TABLE users (id INTEGER, name STRING, PRIMARY KEY(id))"
	DdlStatement string `json:"ddl_statement,omitempty" jsonschema:"DDL statement defining the table schema. For new tables use CREATE TABLE; for schema evolution use ALTER TABLE. Column order should not change; new columns can only be appended. Example: 'CREATE TABLE..."`
	// Throughput and storage limits for the table.
	TableLimits *TableLimitsInput `json:"table_limits" jsonschema:"required,Throughput and storage limits for the table."`
	// When true, the table can be automatically reclaimed by OCI after
	//  an idle period. Changing this forces recreation.
	IsAutoReclaimable bool `json:"is_auto_reclaimable,omitempty" jsonschema:"When true; the table can be automatically reclaimed by OCI after an idle period. Changing this forces recreation."`
	// Secondary indexes on the table. Each index is immutable; any
	//  change to an index requires its recreation.
	Indexes []*IndexInput `json:"indexes,omitempty" jsonschema:"Secondary indexes on the table. Each index is immutable; any change to an index requires its recreation."`
}

func (s *OciNosqlTableSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.TableLimits == nil {
		return fmt.Errorf("table_limits is required")
	}
	if s.TableLimits != nil {
		if err := s.TableLimits.validate(); err != nil {
			return fmt.Errorf("table_limits: %w", err)
		}
	}
	for i, v := range s.Indexes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("indexes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciNosqlTableSpecInput) applyDefaults() {
	if s.TableLimits != nil {
		s.TableLimits.applyDefaults()
	}
}

func (s *OciNosqlTableSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.DdlStatement != "" {
		m["ddl_statement"] = s.DdlStatement
	}
	if s.TableLimits != nil {
		m["table_limits"] = s.TableLimits.toMap()
	}
	if s.IsAutoReclaimable {
		m["is_auto_reclaimable"] = s.IsAutoReclaimable
	}
	if len(s.Indexes) > 0 {
		items := make([]any, len(s.Indexes))
		for i, v := range s.Indexes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["indexes"] = items
	}
	return m
}

// Index defines a secondary index on the table.
type IndexInput struct {
	// Index name. Used as the resource key in IaC modules.
	Name string `json:"name,omitempty" jsonschema:"Index name. Used as the resource key in IaC modules."`
	// Columns included in the index.
	Keys []*IndexKeyInput `json:"keys,omitempty" jsonschema:"Columns included in the index."`
}

func (s *IndexInput) validate() error {
	if len(s.Keys) < 1 {
		return fmt.Errorf("keys requires at least 1 items, got %d", len(s.Keys))
	}
	for i, v := range s.Keys {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("keys[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *IndexInput) applyDefaults() {
}

func (s *IndexInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Keys) > 0 {
		items := make([]any, len(s.Keys))
		for i, v := range s.Keys {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["keys"] = items
	}
	return m
}

// IndexKey identifies a column (or JSON field within a column)
//
//	to include in the index.
type IndexKeyInput struct {
	// Name of the column to index.
	ColumnName string `json:"column_name,omitempty" jsonschema:"Name of the column to index."`
	// If the column is of type JSON, the scalar type of the JSON
	//  field being indexed (e.g. "STRING", "INTEGER", "NUMBER").
	JsonFieldType string `json:"json_field_type,omitempty" jsonschema:"If the column is of type JSON; the scalar type of the JSON field being indexed (e.g. 'STRING'; 'INTEGER'; 'NUMBER')."`
	// If the column is of type JSON, the dot-separated path to the
	//  field being indexed (e.g. "address.zipCode").
	JsonPath string `json:"json_path,omitempty" jsonschema:"If the column is of type JSON; the dot-separated path to the field being indexed (e.g. 'address.zipCode')."`
}

func (s *IndexKeyInput) validate() error {
	return nil
}

func (s *IndexKeyInput) applyDefaults() {
}

func (s *IndexKeyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ColumnName != "" {
		m["column_name"] = s.ColumnName
	}
	if s.JsonFieldType != "" {
		m["json_field_type"] = s.JsonFieldType
	}
	if s.JsonPath != "" {
		m["json_path"] = s.JsonPath
	}
	return m
}

// TableLimits controls throughput capacity and storage for the table.
type TableLimitsInput struct {
	// Capacity mode determines how throughput is managed.
	//  When on_demand, max_read_units and max_write_units are ignored.
	//  When unset, defaults to provisioned.
	CapacityMode string `json:"capacity_mode,omitempty" jsonschema:"enum=provisioned|on_demand,Capacity mode determines how throughput is managed. When on_demand; max_read_units and max_write_units are ignored. When unset; defaults to provisioned."`
	// Maximum sustained read throughput limit.
	//  Required when capacity_mode is provisioned (or unspecified).
	MaxReadUnits int32 `json:"max_read_units,omitempty" jsonschema:"Maximum sustained read throughput limit. Required when capacity_mode is provisioned (or unspecified)."`
	// Maximum sustained write throughput limit.
	//  Required when capacity_mode is provisioned (or unspecified).
	MaxWriteUnits int32 `json:"max_write_units,omitempty" jsonschema:"Maximum sustained write throughput limit. Required when capacity_mode is provisioned (or unspecified)."`
	// Maximum amount of storage in GB that the table can use.
	MaxStorageInGbs int32 `json:"max_storage_in_gbs,omitempty" jsonschema:"Maximum amount of storage in GB that the table can use."`
}

func (s *TableLimitsInput) validate() error {
	switch s.CapacityMode {
	case "", "provisioned", "on_demand":
	default:
		return fmt.Errorf("invalid capacity_mode: %q", s.CapacityMode)
	}
	return nil
}

func (s *TableLimitsInput) applyDefaults() {
}

func (s *TableLimitsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CapacityMode != "" {
		m["capacity_mode"] = s.CapacityMode
	}
	if s.MaxReadUnits != 0 {
		m["max_read_units"] = s.MaxReadUnits
	}
	if s.MaxWriteUnits != 0 {
		m["max_write_units"] = s.MaxWriteUnits
	}
	if s.MaxStorageInGbs != 0 {
		m["max_storage_in_gbs"] = s.MaxStorageInGbs
	}
	return m
}

// ParseOciNosqlTable validates and normalizes a OciNosqlTable cloud_object.
func ParseOciNosqlTable(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciNosqlTable"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciNosqlTableSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
