// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciApiGateway is the top-level resource representing an OCI API Gateway
//
//	bundled with a single API deployment -- providing managed REST API
//	endpoints with routing, authentication, CORS, and rate limiting.
type OciApiGatewaySpecInput struct {
	// OCID of the compartment where the gateway and deployment will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the gateway and deployment will be created."`
	// Whether the gateway is internet-facing (public) or VCN-internal (private).
	//  Immutable after creation.
	EndpointType string `json:"endpoint_type,omitempty" jsonschema:"enum=endpoint_type_public|endpoint_type_private,Whether the gateway is internet-facing (public) or VCN-internal (private). Immutable after creation."`
	// OCID of the subnet where the gateway will be deployed.
	//  For public gateways, this must be a public subnet. Immutable after creation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the gateway will be deployed. For public gateways; this must be a public subnet. Immutable after creation."`
	// Display name for the gateway. When omitted, the metadata name is used.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the gateway. When omitted; the metadata name is used."`
	// OCID of the OCI Certificates service certificate for TLS termination
	//  on the gateway. Only meaningful for public gateways serving HTTPS.
	CertificateId string `json:"certificate_id,omitempty" jsonschema:"OCID of the OCI Certificates service certificate for TLS termination on the gateway. Only meaningful for public gateways serving HTTPS."`
	// OCIDs of network security groups applied to the gateway.
	NetworkSecurityGroupIds []string `json:"network_security_group_ids,omitempty" jsonschema:"OCIDs of network security groups applied to the gateway."`
	// The API deployment that defines routes, backends, and policies.
	Deployment *DeploymentInput `json:"deployment" jsonschema:"required,The API deployment that defines routes; backends; and policies."`
}

func (s *OciApiGatewaySpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	switch s.EndpointType {
	case "", "endpoint_type_public", "endpoint_type_private":
	default:
		return fmt.Errorf("invalid endpoint_type: %q", s.EndpointType)
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if s.Deployment == nil {
		return fmt.Errorf("deployment is required")
	}
	if s.Deployment != nil {
		if err := s.Deployment.validate(); err != nil {
			return fmt.Errorf("deployment: %w", err)
		}
	}
	return nil
}

func (s *OciApiGatewaySpecInput) applyDefaults() {
	if s.Deployment != nil {
		s.Deployment.applyDefaults()
	}
}

func (s *OciApiGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.EndpointType != "" {
		m["endpoint_type"] = s.EndpointType
	}
	m["subnet_id"] = s.SubnetId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.CertificateId != "" {
		m["certificate_id"] = s.CertificateId
	}
	if len(s.NetworkSecurityGroupIds) > 0 {
		m["network_security_group_ids"] = s.NetworkSecurityGroupIds
	}
	if s.Deployment != nil {
		m["deployment"] = s.Deployment.toMap()
	}
	return m
}

// AccessLog controls request/response access logging.
type AccessLogInput struct {
	// Whether access logging is enabled.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether access logging is enabled."`
}

func (s *AccessLogInput) validate() error {
	return nil
}

func (s *AccessLogInput) applyDefaults() {
}

func (s *AccessLogInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	return m
}

// Authentication configures JWT token validation at the deployment level.
//
//	Tokens are validated before requests reach route backends. This covers
//	the most common API security pattern: an IdP (Auth0, OCI IDCS, Okta)
//	issues tokens and the gateway validates them via JWKS or static keys.
type AuthenticationInput struct {
	// Token issuers (iss claim). Tokens with issuers not in this list are rejected.
	Issuers []string `json:"issuers,omitempty" jsonschema:"Token issuers (iss claim). Tokens with issuers not in this list are rejected."`
	// Allowed audiences (aud claim). Tokens not targeting any of these audiences are rejected.
	Audiences []string `json:"audiences,omitempty" jsonschema:"Allowed audiences (aud claim). Tokens not targeting any of these audiences are rejected."`
	// HTTP header containing the token. Defaults to "Authorization" on the OCI side.
	TokenHeader string `json:"token_header,omitempty" jsonschema:"HTTP header containing the token. Defaults to 'Authorization' on the OCI side."`
	// Query parameter containing the token. Mutually exclusive with token_header
	//  in practice, but OCI allows both (header takes precedence).
	TokenQueryParam string `json:"token_query_param,omitempty" jsonschema:"Query parameter containing the token. Mutually exclusive with token_header in practice; but OCI allows both (header takes precedence)."`
	// Authentication scheme prefix in the header value (e.g., "Bearer").
	//  Defaults to "Bearer" on the OCI side.
	TokenAuthScheme string `json:"token_auth_scheme,omitempty" jsonschema:"Authentication scheme prefix in the header value (e.g.; 'Bearer'). Defaults to 'Bearer' on the OCI side."`
	// Maximum allowed clock skew in seconds when verifying token exp/nbf/iat claims.
	MaxClockSkewInSeconds float32 `json:"max_clock_skew_in_seconds,omitempty" jsonschema:"Maximum allowed clock skew in seconds when verifying token exp/nbf/iat claims."`
	// When true, unauthenticated requests are allowed through (routes can still
	//  enforce authorization individually). Useful for APIs with mixed public/private routes.
	IsAnonymousAccessAllowed bool `json:"is_anonymous_access_allowed,omitempty" jsonschema:"When true; unauthenticated requests are allowed through (routes can still enforce authorization individually). Useful for APIs with mixed public/private routes."`
	// Public key configuration for verifying token signatures.
	PublicKeys *PublicKeysInput `json:"public_keys,omitempty" jsonschema:"Public key configuration for verifying token signatures."`
	// Additional claims to verify on validated tokens.
	VerifyClaims []*VerifyClaimInput `json:"verify_claims,omitempty" jsonschema:"Additional claims to verify on validated tokens."`
}

func (s *AuthenticationInput) validate() error {
	if s.PublicKeys != nil {
		if err := s.PublicKeys.validate(); err != nil {
			return fmt.Errorf("public_keys: %w", err)
		}
	}
	for i, v := range s.VerifyClaims {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("verify_claims[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AuthenticationInput) applyDefaults() {
	if s.PublicKeys != nil {
		s.PublicKeys.applyDefaults()
	}
}

func (s *AuthenticationInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Issuers) > 0 {
		m["issuers"] = s.Issuers
	}
	if len(s.Audiences) > 0 {
		m["audiences"] = s.Audiences
	}
	if s.TokenHeader != "" {
		m["token_header"] = s.TokenHeader
	}
	if s.TokenQueryParam != "" {
		m["token_query_param"] = s.TokenQueryParam
	}
	if s.TokenAuthScheme != "" {
		m["token_auth_scheme"] = s.TokenAuthScheme
	}
	if s.MaxClockSkewInSeconds != 0 {
		m["max_clock_skew_in_seconds"] = s.MaxClockSkewInSeconds
	}
	if s.IsAnonymousAccessAllowed {
		m["is_anonymous_access_allowed"] = s.IsAnonymousAccessAllowed
	}
	if s.PublicKeys != nil {
		m["public_keys"] = s.PublicKeys.toMap()
	}
	if len(s.VerifyClaims) > 0 {
		items := make([]any, len(s.VerifyClaims))
		for i, v := range s.VerifyClaims {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["verify_claims"] = items
	}
	return m
}

// BackendHeader is a custom HTTP header added to backend requests.
type BackendHeaderInput struct {
	// Header name.
	Name string `json:"name,omitempty" jsonschema:"Header name."`
	// Header value.
	Value string `json:"value,omitempty" jsonschema:"Header value."`
}

func (s *BackendHeaderInput) validate() error {
	return nil
}

func (s *BackendHeaderInput) applyDefaults() {
}

func (s *BackendHeaderInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// CorsPolicy configures Cross-Origin Resource Sharing for browser-based clients.
type CorsPolicyInput struct {
	// Allowed origins. At least one origin is required (e.g., ["*"] or
	//  ["https://app.example.com"]).
	AllowedOrigins []string `json:"allowed_origins,omitempty" jsonschema:"Allowed origins. At least one origin is required (e.g.; ['*'] or ['https://app.example.com'])."`
	// Allowed HTTP methods (e.g., ["GET", "POST", "PUT", "DELETE"]).
	AllowedMethods []string `json:"allowed_methods,omitempty" jsonschema:"Allowed HTTP methods (e.g.; ['GET'; 'POST'; 'PUT'; 'DELETE'])."`
	// Allowed request headers.
	AllowedHeaders []string `json:"allowed_headers,omitempty" jsonschema:"Allowed request headers."`
	// Response headers exposed to the browser.
	ExposedHeaders []string `json:"exposed_headers,omitempty" jsonschema:"Response headers exposed to the browser."`
	// Whether the browser may send credentials (cookies, authorization headers).
	IsAllowCredentialsEnabled bool `json:"is_allow_credentials_enabled,omitempty" jsonschema:"Whether the browser may send credentials (cookies; authorization headers)."`
	// How long (in seconds) the browser may cache preflight responses.
	MaxAgeInSeconds int32 `json:"max_age_in_seconds,omitempty" jsonschema:"How long (in seconds) the browser may cache preflight responses."`
}

func (s *CorsPolicyInput) validate() error {
	if len(s.AllowedOrigins) < 1 {
		return fmt.Errorf("allowed_origins requires at least 1 items, got %d", len(s.AllowedOrigins))
	}
	return nil
}

func (s *CorsPolicyInput) applyDefaults() {
}

func (s *CorsPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AllowedOrigins) > 0 {
		m["allowed_origins"] = s.AllowedOrigins
	}
	if len(s.AllowedMethods) > 0 {
		m["allowed_methods"] = s.AllowedMethods
	}
	if len(s.AllowedHeaders) > 0 {
		m["allowed_headers"] = s.AllowedHeaders
	}
	if len(s.ExposedHeaders) > 0 {
		m["exposed_headers"] = s.ExposedHeaders
	}
	if s.IsAllowCredentialsEnabled {
		m["is_allow_credentials_enabled"] = s.IsAllowCredentialsEnabled
	}
	if s.MaxAgeInSeconds != 0 {
		m["max_age_in_seconds"] = s.MaxAgeInSeconds
	}
	return m
}

// Deployment defines the API specification deployed on the gateway.
//
//	Each deployment has a unique path_prefix and contains the route
//	definitions, request policies, and logging configuration.
type DeploymentInput struct {
	// URL path prefix for all routes in this deployment (e.g., "/api/v1").
	//  Must start with "/" and must be unique per gateway. Immutable after creation.
	PathPrefix string `json:"path_prefix,omitempty" jsonschema:"URL path prefix for all routes in this deployment (e.g.; '/api/v1'). Must start with '/' and must be unique per gateway. Immutable after creation."`
	// Display name for the deployment. When omitted, defaults to
	//  "{gateway_display_name}-deployment".
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the deployment. When omitted; defaults to '{gateway_display_name}-deployment'."`
	// Logging configuration for the deployment.
	LoggingPolicies *LoggingPoliciesInput `json:"logging_policies,omitempty" jsonschema:"Logging configuration for the deployment."`
	// Deployment-level request policies applied before route matching.
	RequestPolicies *RequestPoliciesInput `json:"request_policies,omitempty" jsonschema:"Deployment-level request policies applied before route matching."`
	// API routes defining path-to-backend mappings. At least one route
	//  is required. Routes are evaluated in order; first match wins.
	Routes []*RouteInput `json:"routes,omitempty" jsonschema:"API routes defining path-to-backend mappings. At least one route is required. Routes are evaluated in order; first match wins."`
}

func (s *DeploymentInput) validate() error {
	if s.LoggingPolicies != nil {
		if err := s.LoggingPolicies.validate(); err != nil {
			return fmt.Errorf("logging_policies: %w", err)
		}
	}
	if s.RequestPolicies != nil {
		if err := s.RequestPolicies.validate(); err != nil {
			return fmt.Errorf("request_policies: %w", err)
		}
	}
	if len(s.Routes) < 1 {
		return fmt.Errorf("routes requires at least 1 items, got %d", len(s.Routes))
	}
	for i, v := range s.Routes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("routes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *DeploymentInput) applyDefaults() {
	if s.LoggingPolicies != nil {
		s.LoggingPolicies.applyDefaults()
	}
	if s.RequestPolicies != nil {
		s.RequestPolicies.applyDefaults()
	}
}

func (s *DeploymentInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.PathPrefix != "" {
		m["path_prefix"] = s.PathPrefix
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.LoggingPolicies != nil {
		m["logging_policies"] = s.LoggingPolicies.toMap()
	}
	if s.RequestPolicies != nil {
		m["request_policies"] = s.RequestPolicies.toMap()
	}
	if len(s.Routes) > 0 {
		items := make([]any, len(s.Routes))
		for i, v := range s.Routes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["routes"] = items
	}
	return m
}

// ExecutionLog controls gateway processing detail logging.
type ExecutionLogInput struct {
	// Whether execution logging is enabled.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether execution logging is enabled."`
	// Log verbosity level. Only meaningful when is_enabled is true.
	LogLevel string `json:"log_level,omitempty" jsonschema:"enum=info|warn|error,Log verbosity level. Only meaningful when is_enabled is true."`
}

func (s *ExecutionLogInput) validate() error {
	switch s.LogLevel {
	case "", "info", "warn", "error":
	default:
		return fmt.Errorf("invalid log_level: %q", s.LogLevel)
	}
	return nil
}

func (s *ExecutionLogInput) applyDefaults() {
}

func (s *ExecutionLogInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.LogLevel != "" {
		m["log_level"] = s.LogLevel
	}
	return m
}

// LoggingPolicies configures access and execution logging for the deployment
//
//	or individual routes.
type LoggingPoliciesInput struct {
	// Access log captures every request/response pair.
	AccessLog *AccessLogInput `json:"access_log,omitempty" jsonschema:"Access log captures every request/response pair."`
	// Execution log captures gateway processing details.
	ExecutionLog *ExecutionLogInput `json:"execution_log,omitempty" jsonschema:"Execution log captures gateway processing details."`
}

func (s *LoggingPoliciesInput) validate() error {
	if s.AccessLog != nil {
		if err := s.AccessLog.validate(); err != nil {
			return fmt.Errorf("access_log: %w", err)
		}
	}
	if s.ExecutionLog != nil {
		if err := s.ExecutionLog.validate(); err != nil {
			return fmt.Errorf("execution_log: %w", err)
		}
	}
	return nil
}

func (s *LoggingPoliciesInput) applyDefaults() {
	if s.AccessLog != nil {
		s.AccessLog.applyDefaults()
	}
	if s.ExecutionLog != nil {
		s.ExecutionLog.applyDefaults()
	}
}

func (s *LoggingPoliciesInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AccessLog != nil {
		m["access_log"] = s.AccessLog.toMap()
	}
	if s.ExecutionLog != nil {
		m["execution_log"] = s.ExecutionLog.toMap()
	}
	return m
}

// PublicKeys configures how the gateway obtains keys for JWT signature verification.
type PublicKeysInput struct {
	// How public keys are obtained.
	Type string `json:"type,omitempty" jsonschema:"enum=remote_jwks|static_keys,How public keys are obtained."`
	// URI of the JWKS endpoint (e.g., "https://idp.example.com/.well-known/jwks.json").
	//  Required when type is remote_jwks.
	Uri string `json:"uri,omitempty" jsonschema:"URI of the JWKS endpoint (e.g.; 'https://idp.example.com/.well-known/jwks.json'). Required when type is remote_jwks."`
	// Whether to skip TLS certificate verification when fetching JWKS.
	//  Only applicable when type is remote_jwks.
	IsSslVerifyDisabled bool `json:"is_ssl_verify_disabled,omitempty" jsonschema:"Whether to skip TLS certificate verification when fetching JWKS. Only applicable when type is remote_jwks."`
	// How long (in hours) to cache the JWKS response. Only applicable when
	//  type is remote_jwks. OCI defaults to 1 hour.
	MaxCacheDurationInHours int32 `json:"max_cache_duration_in_hours,omitempty" jsonschema:"How long (in hours) to cache the JWKS response. Only applicable when type is remote_jwks. OCI defaults to 1 hour."`
	// Static keys for token verification. Required when type is static_keys.
	Keys []*StaticKeyInput `json:"keys,omitempty" jsonschema:"Static keys for token verification. Required when type is static_keys."`
}

func (s *PublicKeysInput) validate() error {
	switch s.Type {
	case "", "remote_jwks", "static_keys":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	for i, v := range s.Keys {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("keys[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *PublicKeysInput) applyDefaults() {
}

func (s *PublicKeysInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Uri != "" {
		m["uri"] = s.Uri
	}
	if s.IsSslVerifyDisabled {
		m["is_ssl_verify_disabled"] = s.IsSslVerifyDisabled
	}
	if s.MaxCacheDurationInHours != 0 {
		m["max_cache_duration_in_hours"] = s.MaxCacheDurationInHours
	}
	if len(s.Keys) > 0 {
		items := make([]any, len(s.Keys))
		for i, v := range s.Keys {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["keys"] = items
	}
	return m
}

// RateLimiting configures request rate limiting at the deployment level.
type RateLimitingInput struct {
	// Maximum number of requests per second.
	RateInRequestsPerSecond int32 `json:"rate_in_requests_per_second,omitempty" jsonschema:"Maximum number of requests per second."`
	// How requests are grouped for rate limiting.
	RateKey string `json:"rate_key,omitempty" jsonschema:"enum=client_ip|total,How requests are grouped for rate limiting."`
}

func (s *RateLimitingInput) validate() error {
	switch s.RateKey {
	case "", "client_ip", "total":
	default:
		return fmt.Errorf("invalid rate_key: %q", s.RateKey)
	}
	return nil
}

func (s *RateLimitingInput) applyDefaults() {
}

func (s *RateLimitingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RateInRequestsPerSecond != 0 {
		m["rate_in_requests_per_second"] = s.RateInRequestsPerSecond
	}
	if s.RateKey != "" {
		m["rate_key"] = s.RateKey
	}
	return m
}

// RequestPolicies defines deployment-level policies applied to every request
//
//	before route matching.
type RequestPoliciesInput struct {
	// JWT-based authentication configuration.
	Authentication *AuthenticationInput `json:"authentication,omitempty" jsonschema:"JWT-based authentication configuration."`
	// Cross-Origin Resource Sharing policy for browser-based clients.
	Cors *CorsPolicyInput `json:"cors,omitempty" jsonschema:"Cross-Origin Resource Sharing policy for browser-based clients."`
	// Rate limiting policy.
	RateLimiting *RateLimitingInput `json:"rate_limiting,omitempty" jsonschema:"Rate limiting policy."`
}

func (s *RequestPoliciesInput) validate() error {
	if s.Authentication != nil {
		if err := s.Authentication.validate(); err != nil {
			return fmt.Errorf("authentication: %w", err)
		}
	}
	if s.Cors != nil {
		if err := s.Cors.validate(); err != nil {
			return fmt.Errorf("cors: %w", err)
		}
	}
	if s.RateLimiting != nil {
		if err := s.RateLimiting.validate(); err != nil {
			return fmt.Errorf("rate_limiting: %w", err)
		}
	}
	return nil
}

func (s *RequestPoliciesInput) applyDefaults() {
	if s.Authentication != nil {
		s.Authentication.applyDefaults()
	}
	if s.Cors != nil {
		s.Cors.applyDefaults()
	}
	if s.RateLimiting != nil {
		s.RateLimiting.applyDefaults()
	}
}

func (s *RequestPoliciesInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Authentication != nil {
		m["authentication"] = s.Authentication.toMap()
	}
	if s.Cors != nil {
		m["cors"] = s.Cors.toMap()
	}
	if s.RateLimiting != nil {
		m["rate_limiting"] = s.RateLimiting.toMap()
	}
	return m
}

// Route defines a path-to-backend mapping within the deployment.
type RouteInput struct {
	// URL path pattern (e.g., "/users/{userId}", "/health").
	//  Supports exact, prefix, and wildcard matching per OCI path semantics.
	Path string `json:"path,omitempty" jsonschema:"URL path pattern (e.g.; '/users/{userId}'; '/health'). Supports exact; prefix; and wildcard matching per OCI path semantics."`
	// HTTP methods this route handles (e.g., ["GET", "POST"]).
	//  When empty, all methods are accepted.
	Methods []string `json:"methods,omitempty" jsonschema:"HTTP methods this route handles (e.g.; ['GET'; 'POST']). When empty; all methods are accepted."`
	// Backend that processes matching requests.
	Backend *BackendInput `json:"backend" jsonschema:"required,Backend that processes matching requests."`
	// Per-route authorization policy. When authentication is configured at
	//  the deployment level, this controls which routes require valid tokens.
	Authorization *RouteAuthorizationInput `json:"authorization,omitempty" jsonschema:"Per-route authorization policy. When authentication is configured at the deployment level; this controls which routes require valid tokens."`
	// Per-route logging policy override.
	LoggingPolicies *LoggingPoliciesInput `json:"logging_policies,omitempty" jsonschema:"Per-route logging policy override."`
}

func (s *RouteInput) validate() error {
	if s.Backend == nil {
		return fmt.Errorf("backend is required")
	}
	if s.Backend != nil {
		if err := s.Backend.validate(); err != nil {
			return fmt.Errorf("backend: %w", err)
		}
	}
	if s.Authorization != nil {
		if err := s.Authorization.validate(); err != nil {
			return fmt.Errorf("authorization: %w", err)
		}
	}
	if s.LoggingPolicies != nil {
		if err := s.LoggingPolicies.validate(); err != nil {
			return fmt.Errorf("logging_policies: %w", err)
		}
	}
	return nil
}

func (s *RouteInput) applyDefaults() {
	if s.Backend != nil {
		s.Backend.applyDefaults()
	}
	if s.Authorization != nil {
		s.Authorization.applyDefaults()
	}
	if s.LoggingPolicies != nil {
		s.LoggingPolicies.applyDefaults()
	}
}

func (s *RouteInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Path != "" {
		m["path"] = s.Path
	}
	if len(s.Methods) > 0 {
		m["methods"] = s.Methods
	}
	if s.Backend != nil {
		m["backend"] = s.Backend.toMap()
	}
	if s.Authorization != nil {
		m["authorization"] = s.Authorization.toMap()
	}
	if s.LoggingPolicies != nil {
		m["logging_policies"] = s.LoggingPolicies.toMap()
	}
	return m
}

// RouteAuthorization controls access for individual routes when deployment-level
//
//	authentication is enabled.
type RouteAuthorizationInput struct {
	// Authorization enforcement level.
	Type string `json:"type,omitempty" jsonschema:"enum=anonymous|any_of|authentication_only,Authorization enforcement level."`
	// OAuth2 scopes required when type is any_of. The token must contain
	//  at least one of these scopes.
	AllowedScope []string `json:"allowed_scope,omitempty" jsonschema:"OAuth2 scopes required when type is any_of. The token must contain at least one of these scopes."`
}

func (s *RouteAuthorizationInput) validate() error {
	switch s.Type {
	case "", "anonymous", "any_of", "authentication_only":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *RouteAuthorizationInput) applyDefaults() {
}

func (s *RouteAuthorizationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if len(s.AllowedScope) > 0 {
		m["allowed_scope"] = s.AllowedScope
	}
	return m
}

// StaticKey defines a single public key for JWT signature verification.
//
//	Supports both PEM-encoded certificates and JSON Web Key (JWK) format.
type StaticKeyInput struct {
	// Key identifier (kid). Used to match incoming tokens to the correct key.
	Kid string `json:"kid,omitempty" jsonschema:"Key identifier (kid). Used to match incoming tokens to the correct key."`
	// Key encoding format.
	Format string `json:"format,omitempty" jsonschema:"enum=pem|json_web_key,Key encoding format."`
	// PEM-encoded public key or certificate. Required when format is pem.
	Key string `json:"key,omitempty" jsonschema:"PEM-encoded public key or certificate. Required when format is pem."`
	// JWK key type (e.g., "RSA", "EC"). Required when format is json_web_key.
	Kty string `json:"kty,omitempty" jsonschema:"JWK key type (e.g.; 'RSA'; 'EC'). Required when format is json_web_key."`
	// JWK algorithm (e.g., "RS256"). Used when format is json_web_key.
	Alg string `json:"alg,omitempty" jsonschema:"JWK algorithm (e.g.; 'RS256'). Used when format is json_web_key."`
	// RSA public exponent (Base64url-encoded). Used for RSA keys in JWK format.
	E string `json:"e,omitempty" jsonschema:"RSA public exponent (Base64url-encoded). Used for RSA keys in JWK format."`
	// RSA modulus (Base64url-encoded). Used for RSA keys in JWK format.
	N string `json:"n,omitempty" jsonschema:"RSA modulus (Base64url-encoded). Used for RSA keys in JWK format."`
	// JWK public key use (e.g., "sig"). Used when format is json_web_key.
	Use string `json:"use,omitempty" jsonschema:"JWK public key use (e.g.; 'sig'). Used when format is json_web_key."`
}

func (s *StaticKeyInput) validate() error {
	switch s.Format {
	case "", "pem", "json_web_key":
	default:
		return fmt.Errorf("invalid format: %q", s.Format)
	}
	return nil
}

func (s *StaticKeyInput) applyDefaults() {
}

func (s *StaticKeyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Kid != "" {
		m["kid"] = s.Kid
	}
	if s.Format != "" {
		m["format"] = s.Format
	}
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.Kty != "" {
		m["kty"] = s.Kty
	}
	if s.Alg != "" {
		m["alg"] = s.Alg
	}
	if s.E != "" {
		m["e"] = s.E
	}
	if s.N != "" {
		m["n"] = s.N
	}
	if s.Use != "" {
		m["use"] = s.Use
	}
	return m
}

// VerifyClaim defines an additional claim to verify on validated JWT tokens.
type VerifyClaimInput struct {
	// Claim name (e.g., "scope", "groups", "email").
	Key string `json:"key,omitempty" jsonschema:"Claim name (e.g.; 'scope'; 'groups'; 'email')."`
	// Expected claim values. If non-empty, the token's claim must match
	//  at least one of these values.
	Values []string `json:"values,omitempty" jsonschema:"Expected claim values. If non-empty; the token's claim must match at least one of these values."`
	// Whether the claim must be present in the token.
	IsRequired bool `json:"is_required,omitempty" jsonschema:"Whether the claim must be present in the token."`
}

func (s *VerifyClaimInput) validate() error {
	return nil
}

func (s *VerifyClaimInput) applyDefaults() {
}

func (s *VerifyClaimInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Key != "" {
		m["key"] = s.Key
	}
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.IsRequired {
		m["is_required"] = s.IsRequired
	}
	return m
}

// ParseOciApiGateway validates and normalizes a OciApiGateway cloud_object.
func ParseOciApiGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciApiGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciApiGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
