// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciAlarm is the top-level resource representing an OCI Monitoring
//
//	Alarm -- a rule that evaluates metrics via MQL and triggers
//	notifications when thresholds are breached.
type OciAlarmSpecInput struct {
	// OCID of the compartment where the alarm will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the alarm will be created."`
	// OCID of the compartment containing the metric being evaluated.
	//  Often the same as compartment_id, but can differ when monitoring
	//  metrics from another compartment.
	MetricCompartmentId string `json:"metric_compartment_id" jsonschema:"required,OCID of the compartment containing the metric being evaluated. Often the same as compartment_id; but can differ when monitoring metrics from another compartment."`
	// Source service or application emitting the metric.
	//  Examples: "oci_computeagent", "oci_blockstore",
	//  "oci_autonomous_database", "oci_vcn".
	Namespace string `json:"namespace,omitempty" jsonschema:"Source service or application emitting the metric. Examples: 'oci_computeagent'; 'oci_blockstore'; 'oci_autonomous_database'; 'oci_vcn'."`
	// Monitoring Query Language (MQL) expression to evaluate.
	//  Must specify metric, statistic, interval, and trigger rule.
	//  Example: "CpuUtilization[5m].mean() > 80"
	Query string `json:"query,omitempty" jsonschema:"Monitoring Query Language (MQL) expression to evaluate. Must specify metric; statistic; interval; and trigger rule. Example: 'CpuUtilization[5m].mean() > 80'"`
	// Perceived severity when the alarm is in the FIRING state.
	//  Must be explicitly set (unspecified is rejected).
	Severity string `json:"severity,omitempty" jsonschema:"enum=critical|error|warning|info,Perceived severity when the alarm is in the FIRING state. Must be explicitly set (unspecified is rejected)."`
	// OCIDs of notification destinations. Each OCID must reference an
	//  ONS Notification Topic or a Streaming stream. At least one
	//  destination is required.
	Destinations []string `json:"destinations,omitempty" jsonschema:"OCIDs of notification destinations. Each OCID must reference an ONS Notification Topic or a Streaming stream. At least one destination is required."`
	// Whether the alarm is enabled. When false, the alarm does not
	//  evaluate metrics or send notifications.
	//  Proto3 default is false -- alarms start disabled unless
	//  explicitly set to true.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether the alarm is enabled. When false; the alarm does not evaluate metrics or send notifications. Proto3 default is false -- alarms start disabled unless explicitly set to true."`
	// Human-readable content of the delivered alarm notification.
	//  Supports dynamic variables: {{severity}}, {{query}},
	//  {{metricValues}}, {{resourceId}}, {{timestamp}}.
	Body string `json:"body,omitempty" jsonschema:"Human-readable content of the delivered alarm notification. Supports dynamic variables: {{severity}}; {{query}}; {{metricValues}}; {{resourceId}}; {{timestamp}}."`
	// Customizable alarm summary. Appears in the alarm message body
	//  and API responses. Supports the same dynamic variables as body.
	AlarmSummary string `json:"alarm_summary,omitempty" jsonschema:"Customizable alarm summary. Appears in the alarm message body and API responses. Supports the same dynamic variables as body."`
	// Custom notification title. Appears as the email subject line
	//  or Slack notification title. Supports dynamic variables.
	NotificationTitle string `json:"notification_title,omitempty" jsonschema:"Custom notification title. Appears as the email subject line or Slack notification title. Supports dynamic variables."`
	// Period of time the condition must persist before the alarm
	//  transitions from OK to FIRING. ISO 8601 duration format.
	//  Minimum: PT1M. Maximum: PT1H. OCI default: PT1M.
	PendingDuration string `json:"pending_duration,omitempty" jsonschema:"Period of time the condition must persist before the alarm transitions from OK to FIRING. ISO 8601 duration format. Minimum: PT1M. Maximum: PT1H. OCI default: PT1M."`
	// Slack period to wait for metric ingestion before evaluating
	//  the alarm. Accounts for delayed metric delivery. ISO 8601
	//  duration format. Minimum: PT3M. Maximum: PT2H. OCI default: PT3M.
	EvaluationSlackDuration string `json:"evaluation_slack_duration,omitempty" jsonschema:"Slack period to wait for metric ingestion before evaluating the alarm. Accounts for delayed metric delivery. ISO 8601 duration format. Minimum: PT3M. Maximum: PT2H. OCI default: PT3M."`
	// Frequency for re-submitting alarm notifications while the
	//  alarm remains in FIRING state. ISO 8601 duration format.
	//  Minimum: PT1M. Maximum: P30D. When omitted, notifications
	//  are not re-submitted.
	RepeatNotificationDuration string `json:"repeat_notification_duration,omitempty" jsonschema:"Frequency for re-submitting alarm notifications while the alarm remains in FIRING state. ISO 8601 duration format. Minimum: PT1M. Maximum: P30D. When omitted; notifications are not re-submitted."`
	// Format for alarm notification delivery.
	//  When omitted (zero-value), OCI applies RAW format.
	MessageFormat string `json:"message_format,omitempty" jsonschema:"enum=pretty_json|ons_optimized,Format for alarm notification delivery. When omitted (zero-value); OCI applies RAW format."`
	// When true, evaluates metrics from the specified compartment
	//  and all of its sub-compartments. Can only be true when
	//  metric_compartment_id is a tenancy OCID.
	MetricCompartmentIdInSubtree bool `json:"metric_compartment_id_in_subtree,omitempty" jsonschema:"When true; evaluates metrics from the specified compartment and all of its sub-compartments. Can only be true when metric_compartment_id is a tenancy OCID."`
	// When true, splits alarm notifications per metric stream
	//  dimension. When false (default), groups notifications across
	//  all metric streams matching the query.
	IsNotificationsPerMetricDimensionEnabled bool `json:"is_notifications_per_metric_dimension_enabled,omitempty" jsonschema:"When true; splits alarm notifications per metric stream dimension. When false (default); groups notifications across all metric streams matching the query."`
	// Resource group to match when filtering metric data.
	//  When omitted, only metric data with no resource group is
	//  returned.
	ResourceGroup string `json:"resource_group,omitempty" jsonschema:"Resource group to match when filtering metric data. When omitted; only metric data with no resource group is returned."`
	// Version of the alarm notification to be delivered.
	//  Format: a number (up to 4 digits) followed by a period
	//  and uppercase X (e.g., "1.X").
	NotificationVersion string `json:"notification_version,omitempty" jsonschema:"Version of the alarm notification to be delivered. Format: a number (up to 4 digits) followed by a period and uppercase X (e.g.; '1.X')."`
	// Identifier for the alarm's base values for evaluation.
	//  Default value is "BASE". Only meaningful when overrides
	//  are configured. Must be unique across all rule_name values
	//  (including those in overrides).
	RuleName string `json:"rule_name,omitempty" jsonschema:"Identifier for the alarm's base values for evaluation. Default value is 'BASE'. Only meaningful when overrides are configured. Must be unique across all rule_name values (including those in overrides)..."`
	// Overrides controlling alarm evaluation at different thresholds.
	//  Each override can specify its own query, severity, body, and
	//  pending duration. Evaluated in order before the base rule.
	Overrides []*AlarmOverrideInput `json:"overrides,omitempty" jsonschema:"Overrides controlling alarm evaluation at different thresholds. Each override can specify its own query; severity; body; and pending duration. Evaluated in order before the base rule."`
}

func (s *OciAlarmSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.MetricCompartmentId == "" {
		return fmt.Errorf("metric_compartment_id is required")
	}
	switch s.Severity {
	case "", "critical", "error", "warning", "info":
	default:
		return fmt.Errorf("invalid severity: %q", s.Severity)
	}
	if len(s.Destinations) < 1 {
		return fmt.Errorf("destinations requires at least 1 items, got %d", len(s.Destinations))
	}
	switch s.MessageFormat {
	case "", "pretty_json", "ons_optimized":
	default:
		return fmt.Errorf("invalid message_format: %q", s.MessageFormat)
	}
	for i, v := range s.Overrides {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("overrides[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciAlarmSpecInput) applyDefaults() {
}

func (s *OciAlarmSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	m["metric_compartment_id"] = s.MetricCompartmentId
	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}
	if s.Query != "" {
		m["query"] = s.Query
	}
	if s.Severity != "" {
		m["severity"] = s.Severity
	}
	if len(s.Destinations) > 0 {
		m["destinations"] = s.Destinations
	}
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.Body != "" {
		m["body"] = s.Body
	}
	if s.AlarmSummary != "" {
		m["alarm_summary"] = s.AlarmSummary
	}
	if s.NotificationTitle != "" {
		m["notification_title"] = s.NotificationTitle
	}
	if s.PendingDuration != "" {
		m["pending_duration"] = s.PendingDuration
	}
	if s.EvaluationSlackDuration != "" {
		m["evaluation_slack_duration"] = s.EvaluationSlackDuration
	}
	if s.RepeatNotificationDuration != "" {
		m["repeat_notification_duration"] = s.RepeatNotificationDuration
	}
	if s.MessageFormat != "" {
		m["message_format"] = s.MessageFormat
	}
	if s.MetricCompartmentIdInSubtree {
		m["metric_compartment_id_in_subtree"] = s.MetricCompartmentIdInSubtree
	}
	if s.IsNotificationsPerMetricDimensionEnabled {
		m["is_notifications_per_metric_dimension_enabled"] = s.IsNotificationsPerMetricDimensionEnabled
	}
	if s.ResourceGroup != "" {
		m["resource_group"] = s.ResourceGroup
	}
	if s.NotificationVersion != "" {
		m["notification_version"] = s.NotificationVersion
	}
	if s.RuleName != "" {
		m["rule_name"] = s.RuleName
	}
	if len(s.Overrides) > 0 {
		items := make([]any, len(s.Overrides))
		for i, v := range s.Overrides {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["overrides"] = items
	}
	return m
}

// AlarmOverride specifies alternative evaluation parameters for
//
//	an alarm. Overrides are evaluated in order before the base
//	rule (rule_name = "BASE"). Each override can customize the
//	query, severity, notification body, and pending duration
//	independently.
type AlarmOverrideInput struct {
	// User-friendly identifier for this override. Must be unique
	//  across all rule_name values for the alarm.
	RuleName string `json:"rule_name,omitempty" jsonschema:"User-friendly identifier for this override. Must be unique across all rule_name values for the alarm."`
	// Override MQL query. When omitted, the base query is used.
	Query string `json:"query,omitempty" jsonschema:"Override MQL query. When omitted; the base query is used."`
	// Override severity. When unspecified (zero-value), the base
	//  severity is used.
	Severity string `json:"severity,omitempty" jsonschema:"enum=critical|error|warning|info,Override severity. When unspecified (zero-value); the base severity is used."`
	// Override notification body. When omitted, the base body
	//  is used. Supports the same dynamic variables.
	Body string `json:"body,omitempty" jsonschema:"Override notification body. When omitted; the base body is used. Supports the same dynamic variables."`
	// Override pending duration. When omitted, the base pending
	//  duration is used. ISO 8601 format.
	PendingDuration string `json:"pending_duration,omitempty" jsonschema:"Override pending duration. When omitted; the base pending duration is used. ISO 8601 format."`
}

func (s *AlarmOverrideInput) validate() error {
	switch s.Severity {
	case "", "critical", "error", "warning", "info":
	default:
		return fmt.Errorf("invalid severity: %q", s.Severity)
	}
	return nil
}

func (s *AlarmOverrideInput) applyDefaults() {
}

func (s *AlarmOverrideInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RuleName != "" {
		m["rule_name"] = s.RuleName
	}
	if s.Query != "" {
		m["query"] = s.Query
	}
	if s.Severity != "" {
		m["severity"] = s.Severity
	}
	if s.Body != "" {
		m["body"] = s.Body
	}
	if s.PendingDuration != "" {
		m["pending_duration"] = s.PendingDuration
	}
	return m
}

// ParseOciAlarm validates and normalizes a OciAlarm cloud_object.
func ParseOciAlarm(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciAlarm"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciAlarmSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
