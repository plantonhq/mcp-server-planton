// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciContainerEngineCluster is the top-level resource representing an Oracle
//
//	Cloud Infrastructure Container Engine for Kubernetes (OKE) cluster.
type OciContainerEngineClusterSpecInput struct {
	// OCID of the compartment where the cluster will be created.
	//  Changing this after creation forces cluster recreation.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the cluster will be created. Changing this after creation forces cluster recreation."`
	// OCID of the VCN where the cluster will be deployed.
	//  Changing this after creation forces cluster recreation.
	VcnId string `json:"vcn_id" jsonschema:"required,OCID of the VCN where the cluster will be deployed. Changing this after creation forces cluster recreation."`
	// Human-readable name for the cluster shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	Name string `json:"name,omitempty" jsonschema:"Human-readable name for the cluster shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Kubernetes version to install on the cluster control plane.
	//  Example: "v1.28.2". Use `oci ce cluster-options list` to see available versions.
	KubernetesVersion string `json:"kubernetes_version,omitempty" jsonschema:"Kubernetes version to install on the cluster control plane. Example: 'v1.28.2'. Use 'oci ce cluster-options list' to see available versions."`
	// Cluster type. Enhanced clusters provide virtual node pools, workload
	//  identity, and cluster add-on lifecycle management.
	Type string `json:"type,omitempty" jsonschema:"enum=basic_cluster|enhanced_cluster,Cluster type. Enhanced clusters provide virtual node pools; workload identity; and cluster add-on lifecycle management."`
	// Container Network Interface (CNI) plugin for pod networking.
	//  oci_vcn_ip_native assigns VCN IP addresses directly to pods (recommended
	//  for production; enables network policies and security groups on pods).
	//  flannel_overlay uses an overlay network (simpler, legacy).
	//  Changing this after creation for...
	CniType string `json:"cni_type,omitempty" jsonschema:"enum=flannel_overlay|oci_vcn_ip_native,Container Network Interface (CNI) plugin for pod networking. oci_vcn_ip_native assigns VCN IP addresses directly to pods (recommended for production; enables network policies and security groups on po..."`
	// Network configuration for the Kubernetes API server endpoint.
	//  Controls whether the API server is reachable via a public or private IP,
	//  which subnet hosts the endpoint, and which NSGs protect it.
	EndpointConfig *EndpointConfigInput `json:"endpoint_config,omitempty" jsonschema:"Network configuration for the Kubernetes API server endpoint. Controls whether the API server is reachable via a public or private IP; which subnet hosts the endpoint; and which NSGs protect it."`
	// Optional cluster configuration for networking, service load balancers,
	//  persistent volumes, and OIDC authentication.
	Options *ClusterOptionsInput `json:"options,omitempty" jsonschema:"Optional cluster configuration for networking; service load balancers; persistent volumes; and OIDC authentication."`
	// OCID of the KMS key to encrypt Kubernetes secrets at rest.
	//  Requires kubernetes_version >= v1.13.0.
	//  Changing this after creation forces cluster recreation.
	//  default_kind will be updated when OciKmsKey (R25) is implemented.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of the KMS key to encrypt Kubernetes secrets at rest. Requires kubernetes_version >= v1.13.0. Changing this after creation forces cluster recreation. default_kind will be updated when OciKmsKey (..."`
	// Image verification policy for the cluster. When enabled, all container
	//  images deployed to the cluster must be signed with one of the specified
	//  KMS keys.
	ImagePolicyConfig *ImagePolicyConfigInput `json:"image_policy_config,omitempty" jsonschema:"Image verification policy for the cluster. When enabled; all container images deployed to the cluster must be signed with one of the specified KMS keys."`
}

func (s *OciContainerEngineClusterSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.VcnId == "" {
		return fmt.Errorf("vcn_id is required")
	}
	switch s.Type {
	case "", "basic_cluster", "enhanced_cluster":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	switch s.CniType {
	case "", "flannel_overlay", "oci_vcn_ip_native":
	default:
		return fmt.Errorf("invalid cni_type: %q", s.CniType)
	}
	if s.EndpointConfig != nil {
		if err := s.EndpointConfig.validate(); err != nil {
			return fmt.Errorf("endpoint_config: %w", err)
		}
	}
	if s.Options != nil {
		if err := s.Options.validate(); err != nil {
			return fmt.Errorf("options: %w", err)
		}
	}
	if s.ImagePolicyConfig != nil {
		if err := s.ImagePolicyConfig.validate(); err != nil {
			return fmt.Errorf("image_policy_config: %w", err)
		}
	}
	return nil
}

func (s *OciContainerEngineClusterSpecInput) applyDefaults() {
	if s.EndpointConfig != nil {
		s.EndpointConfig.applyDefaults()
	}
	if s.Options != nil {
		s.Options.applyDefaults()
	}
	if s.ImagePolicyConfig != nil {
		s.ImagePolicyConfig.applyDefaults()
	}
}

func (s *OciContainerEngineClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	m["vcn_id"] = s.VcnId
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.KubernetesVersion != "" {
		m["kubernetes_version"] = s.KubernetesVersion
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.CniType != "" {
		m["cni_type"] = s.CniType
	}
	if s.EndpointConfig != nil {
		m["endpoint_config"] = s.EndpointConfig.toMap()
	}
	if s.Options != nil {
		m["options"] = s.Options.toMap()
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.ImagePolicyConfig != nil {
		m["image_policy_config"] = s.ImagePolicyConfig.toMap()
	}
	return m
}

// ClusterOptions groups optional networking, OIDC, and resource tagging
//
//	configuration. All fields have sane defaults when omitted.
type ClusterOptionsInput struct {
	// Kubernetes pod and service CIDR configuration.
	//  Changing this after creation forces cluster recreation.
	KubernetesNetworkConfig *KubernetesNetworkConfigInput `json:"kubernetes_network_config,omitempty" jsonschema:"Kubernetes pod and service CIDR configuration. Changing this after creation forces cluster recreation."`
	// OCIDs of subnets where Kubernetes Service load balancers will be placed.
	//  Typically one or two public subnets in different availability domains.
	//  Changing this after creation forces cluster recreation.
	ServiceLbSubnetIds []string `json:"service_lb_subnet_ids,omitempty" jsonschema:"OCIDs of subnets where Kubernetes Service load balancers will be placed. Typically one or two public subnets in different availability domains. Changing this after creation forces cluster recreation."`
	// IP address family for the cluster. Use [ipv4] for IPv4-only (default)
	//  or [ipv4, ipv6] for dual-stack.
	//  Changing this after creation forces cluster recreation.
	IpFamilies []string `json:"ip_families,omitempty" jsonschema:"IP address family for the cluster. Use [ipv4] for IPv4-only (default) or [ipv4; ipv6] for dual-stack. Changing this after creation forces cluster recreation."`
	// Default configuration applied to load balancers created by Kubernetes
	//  Service resources of type LoadBalancer.
	ServiceLbConfig *ServiceLbConfigInput `json:"service_lb_config,omitempty" jsonschema:"Default configuration applied to load balancers created by Kubernetes Service resources of type LoadBalancer."`
	// Default configuration applied to block volumes created by Kubernetes
	//  PersistentVolumeClaim resources.
	PersistentVolumeConfig *PersistentVolumeConfigInput `json:"persistent_volume_config,omitempty" jsonschema:"Default configuration applied to block volumes created by Kubernetes PersistentVolumeClaim resources."`
	// OpenID Connect token authentication for the Kubernetes API server.
	//  Enables external identity provider integration for kubectl and API access.
	OpenIdConnectTokenAuthenticationConfig *OpenIdConnectTokenAuthenticationConfigInput `json:"open_id_connect_token_authentication_config,omitempty" jsonschema:"OpenID Connect token authentication for the Kubernetes API server. Enables external identity provider integration for kubectl and API access."`
	// When true, enables the cluster-specific OIDC Discovery endpoint,
	//  allowing external systems to discover the cluster's public signing keys.
	IsOpenIdConnectDiscoveryEnabled bool `json:"is_open_id_connect_discovery_enabled,omitempty" jsonschema:"When true; enables the cluster-specific OIDC Discovery endpoint; allowing external systems to discover the cluster's public signing keys."`
}

func (s *ClusterOptionsInput) validate() error {
	if s.KubernetesNetworkConfig != nil {
		if err := s.KubernetesNetworkConfig.validate(); err != nil {
			return fmt.Errorf("kubernetes_network_config: %w", err)
		}
	}
	if s.ServiceLbConfig != nil {
		if err := s.ServiceLbConfig.validate(); err != nil {
			return fmt.Errorf("service_lb_config: %w", err)
		}
	}
	if s.PersistentVolumeConfig != nil {
		if err := s.PersistentVolumeConfig.validate(); err != nil {
			return fmt.Errorf("persistent_volume_config: %w", err)
		}
	}
	if s.OpenIdConnectTokenAuthenticationConfig != nil {
		if err := s.OpenIdConnectTokenAuthenticationConfig.validate(); err != nil {
			return fmt.Errorf("open_id_connect_token_authentication_config: %w", err)
		}
	}
	return nil
}

func (s *ClusterOptionsInput) applyDefaults() {
	if s.KubernetesNetworkConfig != nil {
		s.KubernetesNetworkConfig.applyDefaults()
	}
	if s.ServiceLbConfig != nil {
		s.ServiceLbConfig.applyDefaults()
	}
	if s.PersistentVolumeConfig != nil {
		s.PersistentVolumeConfig.applyDefaults()
	}
	if s.OpenIdConnectTokenAuthenticationConfig != nil {
		s.OpenIdConnectTokenAuthenticationConfig.applyDefaults()
	}
}

func (s *ClusterOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.KubernetesNetworkConfig != nil {
		m["kubernetes_network_config"] = s.KubernetesNetworkConfig.toMap()
	}
	if len(s.ServiceLbSubnetIds) > 0 {
		m["service_lb_subnet_ids"] = s.ServiceLbSubnetIds
	}
	if len(s.IpFamilies) > 0 {
		m["ip_families"] = s.IpFamilies
	}
	if s.ServiceLbConfig != nil {
		m["service_lb_config"] = s.ServiceLbConfig.toMap()
	}
	if s.PersistentVolumeConfig != nil {
		m["persistent_volume_config"] = s.PersistentVolumeConfig.toMap()
	}
	if s.OpenIdConnectTokenAuthenticationConfig != nil {
		m["open_id_connect_token_authentication_config"] = s.OpenIdConnectTokenAuthenticationConfig.toMap()
	}
	if s.IsOpenIdConnectDiscoveryEnabled {
		m["is_open_id_connect_discovery_enabled"] = s.IsOpenIdConnectDiscoveryEnabled
	}
	return m
}

// EndpointConfig controls network access to the Kubernetes API server.
//
//	For production clusters, use a private endpoint (is_public_ip_enabled=false)
//	in a dedicated subnet with restrictive NSGs.
type EndpointConfigInput struct {
	// OCID of the regional subnet hosting the cluster API server endpoint.
	//  Changing this after creation forces cluster recreation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the regional subnet hosting the cluster API server endpoint. Changing this after creation forces cluster recreation."`
	// Whether to assign a public IP to the API server endpoint.
	//  Set to false for private clusters. Must be false when the subnet is
	//  private (no public IP assignment possible).
	IsPublicIpEnabled bool `json:"is_public_ip_enabled,omitempty" jsonschema:"Whether to assign a public IP to the API server endpoint. Set to false for private clusters. Must be false when the subnet is private (no public IP assignment possible)."`
	// OCIDs of network security groups applied to the API server endpoint.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups applied to the API server endpoint."`
}

func (s *EndpointConfigInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *EndpointConfigInput) applyDefaults() {
}

func (s *EndpointConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	if s.IsPublicIpEnabled {
		m["is_public_ip_enabled"] = s.IsPublicIpEnabled
	}
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	return m
}

// KubernetesNetworkConfig defines the CIDR ranges for Kubernetes pods and
//
//	services. These must not overlap with the VCN CIDR or each other.
type KubernetesNetworkConfigInput struct {
	// CIDR block for Kubernetes pods.
	//  Default when omitted: 10.244.0.0/16 (IPv4), fd00:eeee:eeee:0000::/96 (IPv6).
	PodsCidr string `json:"pods_cidr,omitempty" jsonschema:"CIDR block for Kubernetes pods. Default when omitted: 10.244.0.0/16 (IPv4); fd00:eeee:eeee:0000::/96 (IPv6)."`
	// CIDR block for Kubernetes services (ClusterIP range).
	//  Default when omitted: 10.96.0.0/16 (IPv4), fd00:eeee:eeee:0001::/108 (IPv6).
	ServicesCidr string `json:"services_cidr,omitempty" jsonschema:"CIDR block for Kubernetes services (ClusterIP range). Default when omitted: 10.96.0.0/16 (IPv4); fd00:eeee:eeee:0001::/108 (IPv6)."`
}

func (s *KubernetesNetworkConfigInput) validate() error {
	return nil
}

func (s *KubernetesNetworkConfigInput) applyDefaults() {
}

func (s *KubernetesNetworkConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.PodsCidr != "" {
		m["pods_cidr"] = s.PodsCidr
	}
	if s.ServicesCidr != "" {
		m["services_cidr"] = s.ServicesCidr
	}
	return m
}

// OpenIdConnectTokenAuthenticationConfig configures OIDC token authentication
//
//	for the Kubernetes API server. This allows users to authenticate using tokens
//	from an external OIDC-compliant identity provider.
//
//	Two configuration modes are supported:
//	  1. Inline: set individual fields (issuer_url, client_id, etc.)
//	  2. Configuration file: set configuration_file with a base64-encoded
//	     Kubernetes OIDC Auth Config file
//	These modes are mutually exclusive. When configuration_file is set,
//	the inline fields (issuer_url through username_prefix) must not be set.
type OpenIdConnectTokenAuthenticationConfigInput struct {
	// Whether OIDC token authentication is enabled.
	IsOpenIdConnectAuthEnabled bool `json:"is_open_id_connect_auth_enabled,omitempty" jsonschema:"Whether OIDC token authentication is enabled."`
	// Base64-encoded Kubernetes OIDC Auth Config file.
	//  Mutually exclusive with the inline fields below.
	ConfigurationFile string `json:"configuration_file,omitempty" jsonschema:"Base64-encoded Kubernetes OIDC Auth Config file. Mutually exclusive with the inline fields below."`
	// URL of the OIDC identity provider. Must use https://.
	//  The API server uses this to discover signing keys.
	IssuerUrl string `json:"issuer_url,omitempty" jsonschema:"URL of the OIDC identity provider. Must use https://. The API server uses this to discover signing keys."`
	// Client ID that all tokens must be issued for.
	ClientId string `json:"client_id,omitempty" jsonschema:"Client ID that all tokens must be issued for."`
	// Base64-encoded public RSA or ECDSA certificate of the identity provider.
	CaCertificate string `json:"ca_certificate,omitempty" jsonschema:"Base64-encoded public RSA or ECDSA certificate of the identity provider."`
	// JWT claim to use as the Kubernetes username. Default: "sub".
	UsernameClaim string `json:"username_claim,omitempty" jsonschema:"JWT claim to use as the Kubernetes username. Default: 'sub'."`
	// Prefix prepended to username claims to prevent collisions with
	//  existing names (e.g. "oidc:").
	UsernamePrefix string `json:"username_prefix,omitempty" jsonschema:"Prefix prepended to username claims to prevent collisions with existing names (e.g. 'oidc:')."`
	// JWT claim to use as the user's group. Must be an array of strings
	//  in the token.
	GroupsClaim string `json:"groups_claim,omitempty" jsonschema:"JWT claim to use as the user's group. Must be an array of strings in the token."`
	// Prefix prepended to group claims.
	GroupsPrefix string `json:"groups_prefix,omitempty" jsonschema:"Prefix prepended to group claims."`
	// Accepted signing algorithms for tokens. Default: ["RS256"].
	SigningAlgorithms []string `json:"signing_algorithms,omitempty" jsonschema:"Accepted signing algorithms for tokens. Default: ['RS256']."`
	// Key-value pairs of required claims in the ID token. If any required
	//  claim is missing or has a different value, authentication is rejected.
	RequiredClaims []*RequiredClaimInput `json:"required_claims,omitempty" jsonschema:"Key-value pairs of required claims in the ID token. If any required claim is missing or has a different value; authentication is rejected."`
}

func (s *OpenIdConnectTokenAuthenticationConfigInput) validate() error {
	for i, v := range s.RequiredClaims {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("required_claims[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenIdConnectTokenAuthenticationConfigInput) applyDefaults() {
}

func (s *OpenIdConnectTokenAuthenticationConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsOpenIdConnectAuthEnabled {
		m["is_open_id_connect_auth_enabled"] = s.IsOpenIdConnectAuthEnabled
	}
	if s.ConfigurationFile != "" {
		m["configuration_file"] = s.ConfigurationFile
	}
	if s.IssuerUrl != "" {
		m["issuer_url"] = s.IssuerUrl
	}
	if s.ClientId != "" {
		m["client_id"] = s.ClientId
	}
	if s.CaCertificate != "" {
		m["ca_certificate"] = s.CaCertificate
	}
	if s.UsernameClaim != "" {
		m["username_claim"] = s.UsernameClaim
	}
	if s.UsernamePrefix != "" {
		m["username_prefix"] = s.UsernamePrefix
	}
	if s.GroupsClaim != "" {
		m["groups_claim"] = s.GroupsClaim
	}
	if s.GroupsPrefix != "" {
		m["groups_prefix"] = s.GroupsPrefix
	}
	if len(s.SigningAlgorithms) > 0 {
		m["signing_algorithms"] = s.SigningAlgorithms
	}
	if len(s.RequiredClaims) > 0 {
		items := make([]any, len(s.RequiredClaims))
		for i, v := range s.RequiredClaims {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["required_claims"] = items
	}
	return m
}

// PersistentVolumeConfig applies default tags to block volumes created
//
//	by Kubernetes PersistentVolumeClaim resources.
type PersistentVolumeConfigInput struct {
	// Freeform tags applied to persistent volumes.
	FreeformTags map[string]string `json:"freeform_tags,omitempty" jsonschema:"Freeform tags applied to persistent volumes."`
	// Defined tags applied to persistent volumes.
	//  Keys use the format "namespace.key" (e.g. "Operations.CostCenter").
	DefinedTags map[string]string `json:"defined_tags,omitempty" jsonschema:"Defined tags applied to persistent volumes. Keys use the format 'namespace.key' (e.g. 'Operations.CostCenter')."`
}

func (s *PersistentVolumeConfigInput) validate() error {
	return nil
}

func (s *PersistentVolumeConfigInput) applyDefaults() {
}

func (s *PersistentVolumeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.FreeformTags) > 0 {
		m["freeform_tags"] = s.FreeformTags
	}
	if len(s.DefinedTags) > 0 {
		m["defined_tags"] = s.DefinedTags
	}
	return m
}

// RequiredClaim is a key-value pair that must be present in the OIDC
//
//	ID token for authentication to succeed.
type RequiredClaimInput struct {
	Key   string `json:"key,omitempty" jsonschema:""`
	Value string `json:"value,omitempty" jsonschema:""`
}

func (s *RequiredClaimInput) validate() error {
	return nil
}

func (s *RequiredClaimInput) applyDefaults() {
}

func (s *RequiredClaimInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// ServiceLbConfig applies default tags and NSGs to load balancers
//
//	created by Kubernetes Service resources.
type ServiceLbConfigInput struct {
	// OCIDs of NSGs applied to load balancer backends.
	BackendNsgIds []string `json:"backend_nsg_ids,omitempty" jsonschema:"OCIDs of NSGs applied to load balancer backends."`
	// Freeform tags applied to service load balancers.
	FreeformTags map[string]string `json:"freeform_tags,omitempty" jsonschema:"Freeform tags applied to service load balancers."`
	// Defined tags applied to service load balancers.
	//  Keys use the format "namespace.key" (e.g. "Operations.CostCenter").
	DefinedTags map[string]string `json:"defined_tags,omitempty" jsonschema:"Defined tags applied to service load balancers. Keys use the format 'namespace.key' (e.g. 'Operations.CostCenter')."`
}

func (s *ServiceLbConfigInput) validate() error {
	return nil
}

func (s *ServiceLbConfigInput) applyDefaults() {
}

func (s *ServiceLbConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.BackendNsgIds) > 0 {
		m["backend_nsg_ids"] = s.BackendNsgIds
	}
	if len(s.FreeformTags) > 0 {
		m["freeform_tags"] = s.FreeformTags
	}
	if len(s.DefinedTags) > 0 {
		m["defined_tags"] = s.DefinedTags
	}
	return m
}

// ParseOciContainerEngineCluster validates and normalizes a OciContainerEngineCluster cloud_object.
func ParseOciContainerEngineCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciContainerEngineCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciContainerEngineClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
