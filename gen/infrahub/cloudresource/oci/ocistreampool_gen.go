// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T22:24:53+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciStreamPool is the top-level resource representing an OCI Stream
//
//	Pool -- a Kafka-compatible managed streaming container that groups
//	streams under shared Kafka settings, encryption, and networking.
type OciStreamPoolSpecInput struct {
	// OCID of the compartment where the stream pool will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the stream pool will be created."`
	// Kafka compatibility settings for the stream pool. All fields are
	//  optional and updatable; OCI applies sensible defaults when omitted.
	KafkaSettings *KafkaSettingsInput `json:"kafka_settings,omitempty" jsonschema:"Kafka compatibility settings for the stream pool. All fields are optional and updatable; OCI applies sensible defaults when omitted."`
	// OCID of the KMS master encryption key for encrypting streams in
	//  this pool. When omitted, Oracle-managed encryption is used.
	//  Updatable -- the pool can be re-encrypted with a different key.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of the KMS master encryption key for encrypting streams in this pool. When omitted; Oracle-managed encryption is used. Updatable -- the pool can be re-encrypted with a different key."`
	// Private endpoint configuration for the stream pool. When provided,
	//  the pool is accessible only from within the specified subnet.
	//  Entire block is ForceNew -- any change forces pool recreation.
	PrivateEndpointSettings *PrivateEndpointSettingsInput `json:"private_endpoint_settings,omitempty" jsonschema:"Private endpoint configuration for the stream pool. When provided; the pool is accessible only from within the specified subnet. Entire block is ForceNew -- any change forces pool recreation."`
	// Streams within this pool. Each stream is identified by its name,
	//  which is used as the resource key in IaC modules.
	Streams []*StreamInput `json:"streams,omitempty" jsonschema:"Streams within this pool. Each stream is identified by its name; which is used as the resource key in IaC modules."`
}

func (s *OciStreamPoolSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.KafkaSettings != nil {
		if err := s.KafkaSettings.validate(); err != nil {
			return fmt.Errorf("kafka_settings: %w", err)
		}
	}
	if s.PrivateEndpointSettings != nil {
		if err := s.PrivateEndpointSettings.validate(); err != nil {
			return fmt.Errorf("private_endpoint_settings: %w", err)
		}
	}
	for i, v := range s.Streams {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("streams[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciStreamPoolSpecInput) applyDefaults() {
	if s.KafkaSettings != nil {
		s.KafkaSettings.applyDefaults()
	}
	if s.PrivateEndpointSettings != nil {
		s.PrivateEndpointSettings.applyDefaults()
	}
}

func (s *OciStreamPoolSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.KafkaSettings != nil {
		m["kafka_settings"] = s.KafkaSettings.toMap()
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.PrivateEndpointSettings != nil {
		m["private_endpoint_settings"] = s.PrivateEndpointSettings.toMap()
	}
	if len(s.Streams) > 0 {
		items := make([]any, len(s.Streams))
		for i, v := range s.Streams {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["streams"] = items
	}
	return m
}

// KafkaSettings controls the Kafka compatibility layer for the pool.
//
//	All fields are optional; OCI applies defaults when omitted.
type KafkaSettingsInput struct {
	// Enable automatic topic creation when a Kafka producer publishes
	//  to a non-existent topic.
	AutoCreateTopicsEnable bool `json:"auto_create_topics_enable,omitempty" jsonschema:"Enable automatic topic creation when a Kafka producer publishes to a non-existent topic."`
	// Default hours to retain log data before deletion (24-168).
	//  OCI defaults to 24 when omitted.
	LogRetentionHours int32 `json:"log_retention_hours,omitempty" jsonschema:"Default hours to retain log data before deletion (24-168). OCI defaults to 24 when omitted."`
	// Default number of partitions for auto-created topics.
	NumPartitions int32 `json:"num_partitions,omitempty" jsonschema:"Default number of partitions for auto-created topics."`
}

func (s *KafkaSettingsInput) validate() error {
	return nil
}

func (s *KafkaSettingsInput) applyDefaults() {
}

func (s *KafkaSettingsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AutoCreateTopicsEnable {
		m["auto_create_topics_enable"] = s.AutoCreateTopicsEnable
	}
	if s.LogRetentionHours != 0 {
		m["log_retention_hours"] = s.LogRetentionHours
	}
	if s.NumPartitions != 0 {
		m["num_partitions"] = s.NumPartitions
	}
	return m
}

// PrivateEndpointSettings configures private networking for the pool.
//
//	All fields are ForceNew.
type PrivateEndpointSettingsInput struct {
	// OCID of the subnet for the private endpoint.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet for the private endpoint."`
	// OCIDs of network security groups for the private endpoint.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups for the private endpoint."`
	// Specific IP address within the subnet CIDR for the private
	//  endpoint. When omitted, OCI auto-assigns an available IP.
	PrivateEndpointIp string `json:"private_endpoint_ip,omitempty" jsonschema:"Specific IP address within the subnet CIDR for the private endpoint. When omitted; OCI auto-assigns an available IP."`
}

func (s *PrivateEndpointSettingsInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *PrivateEndpointSettingsInput) applyDefaults() {
}

func (s *PrivateEndpointSettingsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.PrivateEndpointIp != "" {
		m["private_endpoint_ip"] = s.PrivateEndpointIp
	}
	return m
}

// Stream defines an individual stream within the pool.
//
//	Streams are immutable -- changing name, partitions, or
//	retention_in_hours forces recreation.
type StreamInput struct {
	// Stream name. Used as the resource key in IaC modules. ForceNew.
	Name string `json:"name,omitempty" jsonschema:"Stream name. Used as the resource key in IaC modules. ForceNew."`
	// Number of partitions in the stream. ForceNew.
	Partitions int32 `json:"partitions,omitempty" jsonschema:"Number of partitions in the stream. ForceNew."`
	// Retention period in hours (24-168). ForceNew.
	//  When omitted, OCI defaults to 24 hours.
	RetentionInHours int32 `json:"retention_in_hours,omitempty" jsonschema:"Retention period in hours (24-168). ForceNew. When omitted; OCI defaults to 24 hours."`
}

func (s *StreamInput) validate() error {
	return nil
}

func (s *StreamInput) applyDefaults() {
}

func (s *StreamInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Partitions != 0 {
		m["partitions"] = s.Partitions
	}
	if s.RetentionInHours != 0 {
		m["retention_in_hours"] = s.RetentionInHours
	}
	return m
}

// ParseOciStreamPool validates and normalizes a OciStreamPool cloud_object.
func ParseOciStreamPool(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciStreamPool"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciStreamPoolSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
