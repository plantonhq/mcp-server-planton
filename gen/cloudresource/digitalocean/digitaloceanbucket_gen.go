// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-bucket
type DigitalOceanBucketSpecInput struct {
	// bucket name (DNS-compatible, 3–63 chars)
	BucketName string `json:"bucket_name" jsonschema:"required,bucket name (DNS-compatible; 3–63 chars)"`
	// region slug (datacenter location for the bucket)
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,region slug (datacenter location for the bucket)"`
	// access control setting for the bucket (private or public-read)
	AccessControl string `json:"access_control,omitempty" jsonschema:"enum=PUBLIC_READ,access control setting for the bucket (private or public-read)"`
	// enable versioning for the bucket (disabled by default)
	VersioningEnabled bool `json:"versioning_enabled,omitempty" jsonschema:"enable versioning for the bucket (disabled by default)"`
	// tags to apply to the bucket (must be unique)
	Tags []string `json:"tags,omitempty" jsonschema:"tags to apply to the bucket (must be unique)"`
}

func (s *DigitalOceanBucketSpecInput) validate() error {
	if s.BucketName == "" {
		return fmt.Errorf("bucket_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	switch s.AccessControl {
	case "", "PUBLIC_READ":
	default:
		return fmt.Errorf("invalid access_control: %q", s.AccessControl)
	}
	return nil
}

func (s *DigitalOceanBucketSpecInput) applyDefaults() {
}

func (s *DigitalOceanBucketSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket_name"] = s.BucketName
	m["region"] = s.Region
	if s.AccessControl != "" {
		m["access_control"] = s.AccessControl
	}
	if s.VersioningEnabled {
		m["versioning_enabled"] = s.VersioningEnabled
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// ParseDigitalOceanBucket validates and normalizes a DigitalOceanBucket cloud_object.
func ParseDigitalOceanBucket(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanBucket"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanBucketSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
