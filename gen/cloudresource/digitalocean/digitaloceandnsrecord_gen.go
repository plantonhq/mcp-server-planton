// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// DigitalOceanDnsRecord is a Kubernetes Resource Model (KRM) style resource for managing
//
//	individual DNS records within a DigitalOcean DNS zone (domain).
type DigitalOceanDnsRecordSpecInput struct {
	// The DigitalOcean domain name (DNS zone) where this DNS record will be created.
	//  This can be a direct value or a reference to a DigitalOceanDnsZone resource's output.
	//  Example: "example.com"
	Domain string `json:"domain" jsonschema:"required,The DigitalOcean domain name (DNS zone) where this DNS record will be created. This can be a direct value or a reference to a DigitalOceanDnsZone resource's output. Example: 'example.com'"`
	// The name of the DNS record (hostname/subdomain).
	//  Use "@" for root domain records, or specify the subdomain name.
	//  Examples:
	//    - "@" for root domain (example.com)
	//    - "www" for subdomain (www.example.com)
	//    - "api.v1" for nested subdomain (api.v1.example.com)
	Name string `json:"name" jsonschema:"required,The name of the DNS record (hostname/subdomain). Use '@' for root domain records; or specify the subdomain name. Examples: - '@' for root domain (example.com) - 'www' for subdomain (www.example.com) -..."`
	// The type of DNS record to create.
	//  Supported types: A, AAAA, CNAME, MX, TXT, SRV, NS, CAA.
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|CNAME|MX|TXT|SRV|NS|CAA,The type of DNS record to create. Supported types: A; AAAA; CNAME; MX; TXT; SRV; NS; CAA."`
	// The value/target of the DNS record.
	//  This can be a direct value or a reference to another resource's output.
	//  Format depends on record type:
	//    - A record: IPv4 address (e.g., "192.0.2.1")
	//    - AAAA record: IPv6 address (e.g., "2001:db8::1")
	//    - CNAME record: Target hostname (e.g., "target.example....
	Value string `json:"value" jsonschema:"required,The value/target of the DNS record. This can be a direct value or a reference to another resource's output. Format depends on record type: - A record: IPv4 address (e.g.; '192.0.2.1') - AAAA record: I..."`
	// Time to live (TTL) for the DNS record in seconds.
	//  Determines how long DNS resolvers should cache this record.
	//  Common values: 60 (1 min), 300 (5 min), 1800 (30 min), 3600 (1 hour), 86400 (1 day).
	//  Default: 1800 seconds (30 minutes).
	//  Valid range: 30-86400 seconds.
	TtlSeconds int32 `json:"ttl_seconds,omitempty" jsonschema:"Time to live (TTL) for the DNS record in seconds. Determines how long DNS resolvers should cache this record. Common values: 60 (1 min); 300 (5 min); 1800 (30 min); 3600 (1 hour); 86400 (1 day). Defau..."`
	// Priority for MX and SRV records.
	//  Lower values indicate higher priority.
	//  For MX records: Typically 10, 20, 30 for primary, secondary, tertiary mail servers.
	//  For SRV records: Used with weight for load distribution.
	//  Range: 0-65535. Defaults to 0 if not specified.
	Priority int32 `json:"priority,omitempty" jsonschema:"Priority for MX and SRV records. Lower values indicate higher priority. For MX records: Typically 10; 20; 30 for primary; secondary; tertiary mail servers. For SRV records: Used with weight for load d..."`
	// Weight for SRV records.
	//  Specifies the relative weight for records with the same priority.
	//  Higher weights receive proportionally more traffic.
	//  Range: 0-65535. Defaults to 0 if not specified.
	//  Ignored for non-SRV record types.
	Weight int32 `json:"weight,omitempty" jsonschema:"Weight for SRV records. Specifies the relative weight for records with the same priority. Higher weights receive proportionally more traffic. Range: 0-65535. Defaults to 0 if not specified. Ignored fo..."`
	// Port for SRV records.
	//  Specifies the TCP or UDP port on which the service is available.
	//  Range: 0-65535.
	//  Required for SRV records, ignored for other types.
	Port int32 `json:"port,omitempty" jsonschema:"Port for SRV records. Specifies the TCP or UDP port on which the service is available. Range: 0-65535. Required for SRV records; ignored for other types."`
	// Flags for CAA records.
	//  Values:
	//    - 0: Non-critical (default) - CA may ignore unknown tags
	//    - 128: Critical - CA must refuse if tag is not understood
	//  Ignored for non-CAA record types.
	Flags int32 `json:"flags,omitempty" jsonschema:"Flags for CAA records. Values: - 0: Non-critical (default) - CA may ignore unknown tags - 128: Critical - CA must refuse if tag is not understood Ignored for non-CAA record types."`
	// Tag for CAA records.
	//  Specifies the property being authorized:
	//    - "issue": Authorizes a CA to issue certificates for the domain
	//    - "issuewild": Authorizes a CA to issue wildcard certificates
	//    - "iodef": URL to report policy violations
	//  Required for CAA records, ignored for other types.
	Tag string `json:"tag,omitempty" jsonschema:"Tag for CAA records. Specifies the property being authorized: - 'issue': Authorizes a CA to issue certificates for the domain - 'issuewild': Authorizes a CA to issue wildcard certificates - 'iodef': U..."`
}

func (s *DigitalOceanDnsRecordSpecInput) validate() error {
	if s.Domain == "" {
		return fmt.Errorf("domain is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "NS", "CAA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *DigitalOceanDnsRecordSpecInput) applyDefaults() {
	if s.TtlSeconds == 0 {
		s.TtlSeconds = 1800
	}
}

func (s *DigitalOceanDnsRecordSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domain"] = s.Domain
	m["name"] = s.Name
	m["type"] = s.Type
	m["value"] = s.Value
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Flags != 0 {
		m["flags"] = s.Flags
	}
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	return m
}

// ParseDigitalOceanDnsRecord validates and normalizes a DigitalOceanDnsRecord cloud_object.
func ParseDigitalOceanDnsRecord(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanDnsRecord"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanDnsRecordSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
