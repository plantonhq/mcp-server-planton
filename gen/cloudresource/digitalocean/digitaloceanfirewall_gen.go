// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-firewall
type DigitalOceanFirewallSpecInput struct {
	// Name of the firewall for identification (must be unique per account/project).
	Name string `json:"name,omitempty" jsonschema:"Name of the firewall for identification (must be unique per account/project)."`
	// Inbound rules: traffic allowed *to* Droplets on specific ports from specified sources.
	InboundRules []*DigitalOceanFirewallInboundRuleInput `json:"inbound_rules,omitempty" jsonschema:"Inbound rules: traffic allowed *to* Droplets on specific ports from specified sources."`
	// Outbound rules: traffic allowed *from* Droplets on specific ports to specified destinations.
	OutboundRules []*DigitalOceanFirewallOutboundRuleInput `json:"outbound_rules,omitempty" jsonschema:"Outbound rules: traffic allowed *from* Droplets on specific ports to specified destinations."`
	// The Droplet IDs to which this firewall is applied (max 10).
	//  These Droplets will have the firewall's rules enforced.
	DropletIds []int64 `json:"droplet_ids,omitempty" jsonschema:"The Droplet IDs to which this firewall is applied (max 10). These Droplets will have the firewall's rules enforced."`
	// The names of Droplet tags to which this firewall is applied (max 5).
	//  Any Droplet with these tags will be protected by this firewall.
	Tags []string `json:"tags,omitempty" jsonschema:"The names of Droplet tags to which this firewall is applied (max 5). Any Droplet with these tags will be protected by this firewall."`
}

func (s *DigitalOceanFirewallSpecInput) validate() error {
	for i, v := range s.InboundRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("inbound_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.OutboundRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("outbound_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *DigitalOceanFirewallSpecInput) applyDefaults() {
}

func (s *DigitalOceanFirewallSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.InboundRules) > 0 {
		items := make([]any, len(s.InboundRules))
		for i, v := range s.InboundRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["inbound_rules"] = items
	}
	if len(s.OutboundRules) > 0 {
		items := make([]any, len(s.OutboundRules))
		for i, v := range s.OutboundRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["outbound_rules"] = items
	}
	if len(s.DropletIds) > 0 {
		m["droplet_ids"] = s.DropletIds
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// Definition of an inbound (ingress) firewall rule.
type DigitalOceanFirewallInboundRuleInput struct {
	// "tcp", "udp", or "icmp". Required.
	Protocol string `json:"protocol,omitempty" jsonschema:"'tcp'; 'udp'; or 'icmp'. Required."`
	// Ports to allow (e.g., "80", "8000-9000", or "1-65535"; empty or "1-65535" means all ports for tcp/udp).
	PortRange string `json:"port_range,omitempty" jsonschema:"Ports to allow (e.g.; '80'; '8000-9000'; or '1-65535'; empty or '1-65535' means all ports for tcp/udp)."`
	// IPv4 or IPv6 addresses or CIDR ranges (e.g., "192.0.2.0/24", "0.0.0.0/0").
	SourceAddresses []string `json:"source_addresses,omitempty" jsonschema:"IPv4 or IPv6 addresses or CIDR ranges (e.g.; '192.0.2.0/24'; '0.0.0.0/0')."`
	// IDs of Droplets from which traffic is allowed.
	SourceDropletIds []int64 `json:"source_droplet_ids,omitempty" jsonschema:"IDs of Droplets from which traffic is allowed."`
	// Names of Droplet tags; any Droplet with these tags is allowed.
	SourceTags []string `json:"source_tags,omitempty" jsonschema:"Names of Droplet tags; any Droplet with these tags is allowed."`
	// IDs of Kubernetes clusters from which traffic is allowed.
	SourceKubernetesIds []string `json:"source_kubernetes_ids,omitempty" jsonschema:"IDs of Kubernetes clusters from which traffic is allowed."`
	// IDs of Load Balancers from which traffic is allowed.
	SourceLoadBalancerUids []string `json:"source_load_balancer_uids,omitempty" jsonschema:"IDs of Load Balancers from which traffic is allowed."`
}

func (s *DigitalOceanFirewallInboundRuleInput) validate() error {
	return nil
}

func (s *DigitalOceanFirewallInboundRuleInput) applyDefaults() {
}

func (s *DigitalOceanFirewallInboundRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRange != "" {
		m["port_range"] = s.PortRange
	}
	if len(s.SourceAddresses) > 0 {
		m["source_addresses"] = s.SourceAddresses
	}
	if len(s.SourceDropletIds) > 0 {
		m["source_droplet_ids"] = s.SourceDropletIds
	}
	if len(s.SourceTags) > 0 {
		m["source_tags"] = s.SourceTags
	}
	if len(s.SourceKubernetesIds) > 0 {
		m["source_kubernetes_ids"] = s.SourceKubernetesIds
	}
	if len(s.SourceLoadBalancerUids) > 0 {
		m["source_load_balancer_uids"] = s.SourceLoadBalancerUids
	}
	return m
}

// Definition of an outbound (egress) firewall rule.
type DigitalOceanFirewallOutboundRuleInput struct {
	// "tcp", "udp", or "icmp". Required.
	Protocol string `json:"protocol,omitempty" jsonschema:"'tcp'; 'udp'; or 'icmp'. Required."`
	// Ports to allow (format as in inbound rules; required for tcp/udp).
	PortRange string `json:"port_range,omitempty" jsonschema:"Ports to allow (format as in inbound rules; required for tcp/udp)."`
	// IPv4/IPv6 addresses or CIDRs to which traffic is allowed.
	DestinationAddresses []string `json:"destination_addresses,omitempty" jsonschema:"IPv4/IPv6 addresses or CIDRs to which traffic is allowed."`
	// IDs of Droplets to which traffic is allowed.
	DestinationDropletIds []int64 `json:"destination_droplet_ids,omitempty" jsonschema:"IDs of Droplets to which traffic is allowed."`
	// Names of Droplet tags whose members are allowed destinations.
	DestinationTags []string `json:"destination_tags,omitempty" jsonschema:"Names of Droplet tags whose members are allowed destinations."`
	// IDs of Kubernetes clusters to which traffic is allowed.
	DestinationKubernetesIds []string `json:"destination_kubernetes_ids,omitempty" jsonschema:"IDs of Kubernetes clusters to which traffic is allowed."`
	// IDs of Load Balancers which are allowed as destinations.
	DestinationLoadBalancerUids []string `json:"destination_load_balancer_uids,omitempty" jsonschema:"IDs of Load Balancers which are allowed as destinations."`
}

func (s *DigitalOceanFirewallOutboundRuleInput) validate() error {
	return nil
}

func (s *DigitalOceanFirewallOutboundRuleInput) applyDefaults() {
}

func (s *DigitalOceanFirewallOutboundRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRange != "" {
		m["port_range"] = s.PortRange
	}
	if len(s.DestinationAddresses) > 0 {
		m["destination_addresses"] = s.DestinationAddresses
	}
	if len(s.DestinationDropletIds) > 0 {
		m["destination_droplet_ids"] = s.DestinationDropletIds
	}
	if len(s.DestinationTags) > 0 {
		m["destination_tags"] = s.DestinationTags
	}
	if len(s.DestinationKubernetesIds) > 0 {
		m["destination_kubernetes_ids"] = s.DestinationKubernetesIds
	}
	if len(s.DestinationLoadBalancerUids) > 0 {
		m["destination_load_balancer_uids"] = s.DestinationLoadBalancerUids
	}
	return m
}

// ParseDigitalOceanFirewall validates and normalizes a DigitalOceanFirewall cloud_object.
func ParseDigitalOceanFirewall(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanFirewall"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanFirewallSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
