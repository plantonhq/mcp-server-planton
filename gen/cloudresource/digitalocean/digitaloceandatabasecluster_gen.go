// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-database-cluster
type DigitalOceanDatabaseClusterSpecInput struct {
	// A human-readable name for the database cluster.
	//  This name will be used as the cluster's identifier in DigitalOcean.
	ClusterName string `json:"cluster_name" jsonschema:"required,A human-readable name for the database cluster. This name will be used as the cluster's identifier in DigitalOcean."`
	// The database engine for the cluster.
	//  Allowed values include: POSTGRES, MYSQL, REDIS, MONGODB.
	Engine string `json:"engine" jsonschema:"required,enum=pg|mysql|redis|mongodb,The database engine for the cluster. Allowed values include: POSTGRES; MYSQL; REDIS; MONGODB."`
	// The engine version for the cluster.
	//  For example, "14" for PostgreSQL 14, "8" for MySQL 8, etc.
	//  Only major (and optionally minor) version numbers are expected.
	EngineVersion string `json:"engine_version" jsonschema:"required,The engine version for the cluster. For example; '14' for PostgreSQL 14; '8' for MySQL 8; etc. Only major (and optionally minor) version numbers are expected."`
	// The DigitalOcean region where the cluster will be created.
	//  Determines the data center location for the cluster.
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,The DigitalOcean region where the cluster will be created. Determines the data center location for the cluster."`
	// The slug identifier for the cluster's node size (e.g., "db-s-2vcpu-4gb").
	//  This defines the CPU/memory resources for each node in the cluster.
	SizeSlug string `json:"size_slug" jsonschema:"required,The slug identifier for the cluster's node size (e.g.; 'db-s-2vcpu-4gb'). This defines the CPU/memory resources for each node in the cluster."`
	// The number of nodes in the cluster. Allowed values are 1 to 3 for primary nodes.
	NodeCount uint32 `json:"node_count" jsonschema:"required,The number of nodes in the cluster. Allowed values are 1 to 3 for primary nodes."`
	// (Optional) Reference to a DigitalOcean VPC for the database cluster.
	//  If provided, the cluster will be created within the specified private network.
	//  Use a literal VPC UUID or a reference to a DigitalOceanVpc resource.
	Vpc string `json:"vpc,omitempty" jsonschema:"(Optional) Reference to a DigitalOcean VPC for the database cluster. If provided; the cluster will be created within the specified private network. Use a literal VPC UUID or a reference to a DigitalOc..."`
	// (Optional) Custom storage size in GiB for the cluster.
	//  If not set, the default storage for the chosen size_slug will be used.
	StorageGib uint32 `json:"storage_gib,omitempty" jsonschema:"(Optional) Custom storage size in GiB for the cluster. If not set; the default storage for the chosen size_slug will be used."`
	// (Optional) Whether to enable cluster access to public networking.
	//  When false (default), no public connection is available; the cluster is accessible only via the VPC or DigitalOcean internal network.
	EnablePublicConnectivity bool `json:"enable_public_connectivity,omitempty" jsonschema:"(Optional) Whether to enable cluster access to public networking. When false (default); no public connection is available; the cluster is accessible only via the VPC or DigitalOcean internal network."`
}

func (s *DigitalOceanDatabaseClusterSpecInput) validate() error {
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	if s.Engine == "" {
		return fmt.Errorf("engine is required")
	}
	switch s.Engine {
	case "pg", "mysql", "redis", "mongodb":
	default:
		return fmt.Errorf("invalid engine: %q", s.Engine)
	}
	if s.EngineVersion == "" {
		return fmt.Errorf("engine_version is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.SizeSlug == "" {
		return fmt.Errorf("size_slug is required")
	}
	return nil
}

func (s *DigitalOceanDatabaseClusterSpecInput) applyDefaults() {
}

func (s *DigitalOceanDatabaseClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cluster_name"] = s.ClusterName
	m["engine"] = s.Engine
	m["engine_version"] = s.EngineVersion
	m["region"] = s.Region
	m["size_slug"] = s.SizeSlug
	m["node_count"] = s.NodeCount
	if s.Vpc != "" {
		m["vpc"] = s.Vpc
	}
	if s.StorageGib != 0 {
		m["storage_gib"] = s.StorageGib
	}
	if s.EnablePublicConnectivity {
		m["enable_public_connectivity"] = s.EnablePublicConnectivity
	}
	return m
}

// ParseDigitalOceanDatabaseCluster validates and normalizes a DigitalOceanDatabaseCluster cloud_object.
func ParseDigitalOceanDatabaseCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanDatabaseCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanDatabaseClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
