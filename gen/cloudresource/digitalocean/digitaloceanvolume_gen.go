// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-volume
type DigitalOceanVolumeSpecInput struct {
	// The name of the volume. Must be lowercase letters, numbers, and hyphens only,
	//  starting with a letter and ending with a letter or number. Maximum 64 characters.
	VolumeName string `json:"volume_name" jsonschema:"required,The name of the volume. Must be lowercase letters; numbers; and hyphens only; starting with a letter and ending with a letter or number. Maximum 64 characters."`
	// An optional description for the volume.
	//  Constraints: Maximum 100 characters.
	Description string `json:"description,omitempty" jsonschema:"An optional description for the volume. Constraints: Maximum 100 characters."`
	// The DigitalOcean region where the volume will be created.
	//  Must match the region of any Droplet that will attach to this volume.
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,The DigitalOcean region where the volume will be created. Must match the region of any Droplet that will attach to this volume."`
	// The size of the volume in GiB.
	//  Constraints: between 1 and 16000 (inclusive).
	SizeGib uint32 `json:"size_gib" jsonschema:"required,The size of the volume in GiB. Constraints: between 1 and 16000 (inclusive)."`
	// The initial filesystem to format the volume with.
	//  Allowed values: ext4, xfs, or none (no pre-formatting). Default is none.
	FilesystemType string `json:"filesystem_type,omitempty" jsonschema:"enum=ext4|xfs,The initial filesystem to format the volume with. Allowed values: ext4; xfs; or none (no pre-formatting). Default is none."`
	// An optional snapshot ID or reference to a volume snapshot to create this volume from.
	//  If provided, the new volume will be created from the given snapshot (inheriting its region and minimum size).
	SnapshotId string `json:"snapshot_id,omitempty" jsonschema:"An optional snapshot ID or reference to a volume snapshot to create this volume from. If provided; the new volume will be created from the given snapshot (inheriting its region and minimum size)."`
	// A list of tags to apply to the volume.
	//  Tags must be unique and consist of letters, numbers, colons, dashes, or underscores.
	Tags []string `json:"tags,omitempty" jsonschema:"A list of tags to apply to the volume. Tags must be unique and consist of letters; numbers; colons; dashes; or underscores."`
}

func (s *DigitalOceanVolumeSpecInput) validate() error {
	if s.VolumeName == "" {
		return fmt.Errorf("volume_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	switch s.FilesystemType {
	case "", "ext4", "xfs":
	default:
		return fmt.Errorf("invalid filesystem_type: %q", s.FilesystemType)
	}
	return nil
}

func (s *DigitalOceanVolumeSpecInput) applyDefaults() {
}

func (s *DigitalOceanVolumeSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["volume_name"] = s.VolumeName
	if s.Description != "" {
		m["description"] = s.Description
	}
	m["region"] = s.Region
	m["size_gib"] = s.SizeGib
	if s.FilesystemType != "" {
		m["filesystem_type"] = s.FilesystemType
	}
	if s.SnapshotId != "" {
		m["snapshot_id"] = s.SnapshotId
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// ParseDigitalOceanVolume validates and normalizes a DigitalOceanVolume cloud_object.
func ParseDigitalOceanVolume(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanVolume"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanVolumeSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
