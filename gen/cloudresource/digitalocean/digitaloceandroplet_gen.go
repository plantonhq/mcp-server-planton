// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-droplet
type DigitalOceanDropletSpecInput struct {
	// droplet hostname (DNS-compatible, <=63 chars)
	DropletName string `json:"droplet_name" jsonschema:"required,droplet hostname (DNS-compatible; <=63 chars)"`
	// region slug (datacenter location for the droplet)
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,region slug (datacenter location for the droplet)"`
	// Droplet size slug, e.g. "s-2vcpu-4gb" or "g-8vcpu-32gb".
	//  Valid values: must match the regexp "^[a-z0-9]+(-[a-z0-9]+)+$" and
	//  must be accepted by the DigitalOcean /v2/sizes API at creation time.
	Size string `json:"size" jsonschema:"required,Droplet size slug; e.g. 's-2vcpu-4gb' or 'g-8vcpu-32gb'. Valid values: must match the regexp '^[a-z0-9]+(-[a-z0-9]+)+$' and must be accepted by the DigitalOcean /v2/sizes API at creation time."`
	// image slug for the droplet base image (e.g. "ubuntu-22-04-x64")
	Image string `json:"image" jsonschema:"required,image slug for the droplet base image (e.g. 'ubuntu-22-04-x64')"`
	// target vpc network uuid for the droplet
	Vpc string `json:"vpc" jsonschema:"required,target vpc network uuid for the droplet"`
	// enable IPv6 networking (disabled by default)
	EnableIpv6 bool `json:"enable_ipv6,omitempty" jsonschema:"enable IPv6 networking (disabled by default)"`
	// enable automated backups (disabled by default)
	EnableBackups bool `json:"enable_backups,omitempty" jsonschema:"enable automated backups (disabled by default)"`
	// disable digitalocean monitoring agent (monitoring on by default)
	DisableMonitoring bool `json:"disable_monitoring,omitempty" jsonschema:"disable digitalocean monitoring agent (monitoring on by default)"`
	// block storage volumes to attach (must reside in same region)
	VolumeIds []string `json:"volume_ids,omitempty" jsonschema:"block storage volumes to attach (must reside in same region)"`
	// tags to apply to the droplet (must be unique)
	Tags []string `json:"tags,omitempty" jsonschema:"tags to apply to the droplet (must be unique)"`
	// cloud-init user data script (<=32 KiB)
	UserData string `json:"user_data,omitempty" jsonschema:"cloud-init user data script (<=32 KiB)"`
	// timezone setting for the droplet's clock (default: UTC)
	Timezone string `json:"timezone,omitempty" jsonschema:"enum=local,timezone setting for the droplet's clock (default: UTC)"`
}

func (s *DigitalOceanDropletSpecInput) validate() error {
	if s.DropletName == "" {
		return fmt.Errorf("droplet_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	if s.Vpc == "" {
		return fmt.Errorf("vpc is required")
	}
	switch s.Timezone {
	case "", "local":
	default:
		return fmt.Errorf("invalid timezone: %q", s.Timezone)
	}
	return nil
}

func (s *DigitalOceanDropletSpecInput) applyDefaults() {
	if s.Timezone == "" {
		s.Timezone = "UTC"
	}
}

func (s *DigitalOceanDropletSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["droplet_name"] = s.DropletName
	m["region"] = s.Region
	m["size"] = s.Size
	m["image"] = s.Image
	m["vpc"] = s.Vpc
	if s.EnableIpv6 {
		m["enable_ipv6"] = s.EnableIpv6
	}
	if s.EnableBackups {
		m["enable_backups"] = s.EnableBackups
	}
	if s.DisableMonitoring {
		m["disable_monitoring"] = s.DisableMonitoring
	}
	if len(s.VolumeIds) > 0 {
		m["volume_ids"] = s.VolumeIds
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.UserData != "" {
		m["user_data"] = s.UserData
	}
	if s.Timezone != "" {
		m["timezone"] = s.Timezone
	}
	return m
}

// ParseDigitalOceanDroplet validates and normalizes a DigitalOceanDroplet cloud_object.
func ParseDigitalOceanDroplet(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanDroplet"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanDropletSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
