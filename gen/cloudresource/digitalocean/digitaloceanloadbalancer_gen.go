// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-load-balancer
type DigitalOceanLoadBalancerSpecInput struct {
	// The name of the Load Balancer. Must be unique per account.
	//  Constraints: 1-64 characters, lowercase alphanumeric and hyphens.
	LoadBalancerName string `json:"load_balancer_name" jsonschema:"required,The name of the Load Balancer. Must be unique per account. Constraints: 1-64 characters; lowercase alphanumeric and hyphens."`
	// The DigitalOcean region where the Load Balancer will be created.
	//  Determines the geographical location of the load balancer.
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,The DigitalOcean region where the Load Balancer will be created. Determines the geographical location of the load balancer."`
	// Reference to the DigitalOcean VPC in which to create the Load Balancer.
	//  This should be a foreign key reference to an existing DigitalOceanVpc resource.
	Vpc string `json:"vpc" jsonschema:"required,Reference to the DigitalOcean VPC in which to create the Load Balancer. This should be a foreign key reference to an existing DigitalOceanVpc resource."`
	// A list of forwarding rules that define how traffic is routed from the load balancer to backend Droplets.
	//  Each forwarding rule specifies an incoming port/protocol and a corresponding target port/protocol.
	ForwardingRules []*DigitalOceanLoadBalancerForwardingRuleInput `json:"forwarding_rules" jsonschema:"required,A list of forwarding rules that define how traffic is routed from the load balancer to backend Droplets. Each forwarding rule specifies an incoming port/protocol and a corresponding target port/protoc..."`
	// Health check configuration for the load balancer’s backend Droplets.
	//  This defines how the load balancer will probe the Droplets to check their health.
	HealthCheck *DigitalOceanLoadBalancerHealthCheckInput `json:"health_check,omitempty" jsonschema:"Health check configuration for the load balancer’s backend Droplets. This defines how the load balancer will probe the Droplets to check their health."`
	// A list of specific Droplet IDs to attach to the Load Balancer.
	//  Mutually exclusive with `droplet_tag`. These can be literal IDs or references to Droplet resources.
	DropletIds []string `json:"droplet_ids,omitempty" jsonschema:"A list of specific Droplet IDs to attach to the Load Balancer. Mutually exclusive with 'droplet_tag'. These can be literal IDs or references to Droplet resources."`
	// A Droplet tag name. All Droplets with this tag in the specified VPC will be attached to the Load Balancer.
	//  Mutually exclusive with `droplet_ids`.
	DropletTag string `json:"droplet_tag,omitempty" jsonschema:"A Droplet tag name. All Droplets with this tag in the specified VPC will be attached to the Load Balancer. Mutually exclusive with 'droplet_ids'."`
	// Enables sticky sessions if true (disabled by default).
	//  When enabled, the load balancer will attempt to direct repeated requests from the same client to the same Droplet.
	EnableStickySessions bool `json:"enable_sticky_sessions,omitempty" jsonschema:"Enables sticky sessions if true (disabled by default). When enabled; the load balancer will attempt to direct repeated requests from the same client to the same Droplet."`
}

func (s *DigitalOceanLoadBalancerSpecInput) validate() error {
	if s.LoadBalancerName == "" {
		return fmt.Errorf("load_balancer_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.Vpc == "" {
		return fmt.Errorf("vpc is required")
	}
	if len(s.ForwardingRules) == 0 {
		return fmt.Errorf("forwarding_rules is required")
	}
	if len(s.ForwardingRules) < 1 {
		return fmt.Errorf("forwarding_rules requires at least 1 items, got %d", len(s.ForwardingRules))
	}
	for i, v := range s.ForwardingRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("forwarding_rules[%d]: %w", i, err)
			}
		}
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	return nil
}

func (s *DigitalOceanLoadBalancerSpecInput) applyDefaults() {
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *DigitalOceanLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["load_balancer_name"] = s.LoadBalancerName
	m["region"] = s.Region
	m["vpc"] = s.Vpc
	if len(s.ForwardingRules) > 0 {
		items := make([]any, len(s.ForwardingRules))
		for i, v := range s.ForwardingRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["forwarding_rules"] = items
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	if len(s.DropletIds) > 0 {
		m["droplet_ids"] = s.DropletIds
	}
	if s.DropletTag != "" {
		m["droplet_tag"] = s.DropletTag
	}
	if s.EnableStickySessions {
		m["enable_sticky_sessions"] = s.EnableStickySessions
	}
	return m
}

// ForwardingRule represents a single rule for routing traffic from the load balancer to the backend.
type DigitalOceanLoadBalancerForwardingRuleInput struct {
	// Port on the load balancer that will listen for incoming traffic.
	EntryPort uint32 `json:"entry_port" jsonschema:"required,Port on the load balancer that will listen for incoming traffic."`
	// Protocol for incoming traffic on the load balancer's entry port (e.g., HTTP, HTTPS, TCP).
	EntryProtocol string `json:"entry_protocol" jsonschema:"required,enum=http|https|tcp,Protocol for incoming traffic on the load balancer's entry port (e.g.; HTTP; HTTPS; TCP)."`
	// Port on the Droplet that will receive forwarded traffic.
	TargetPort uint32 `json:"target_port" jsonschema:"required,Port on the Droplet that will receive forwarded traffic."`
	// Protocol for traffic between the load balancer and the Droplet (e.g., HTTP, HTTPS, TCP).
	TargetProtocol string `json:"target_protocol" jsonschema:"required,enum=http|https|tcp,Protocol for traffic between the load balancer and the Droplet (e.g.; HTTP; HTTPS; TCP)."`
	// The name of a TLS certificate resource uploaded to DigitalOcean.
	//  Required when entry_protocol is HTTPS. The certificate is used for SSL termination.
	//  Use certificate name (not ID) to avoid breaking IaC state when Let's Encrypt auto-renews certificates.
	CertificateName string `json:"certificate_name,omitempty" jsonschema:"The name of a TLS certificate resource uploaded to DigitalOcean. Required when entry_protocol is HTTPS. The certificate is used for SSL termination. Use certificate name (not ID) to avoid breaking IaC..."`
}

func (s *DigitalOceanLoadBalancerForwardingRuleInput) validate() error {
	if s.EntryProtocol == "" {
		return fmt.Errorf("entry_protocol is required")
	}
	switch s.EntryProtocol {
	case "http", "https", "tcp":
	default:
		return fmt.Errorf("invalid entry_protocol: %q", s.EntryProtocol)
	}
	if s.TargetProtocol == "" {
		return fmt.Errorf("target_protocol is required")
	}
	switch s.TargetProtocol {
	case "http", "https", "tcp":
	default:
		return fmt.Errorf("invalid target_protocol: %q", s.TargetProtocol)
	}
	return nil
}

func (s *DigitalOceanLoadBalancerForwardingRuleInput) applyDefaults() {
}

func (s *DigitalOceanLoadBalancerForwardingRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["entry_port"] = s.EntryPort
	m["entry_protocol"] = s.EntryProtocol
	m["target_port"] = s.TargetPort
	m["target_protocol"] = s.TargetProtocol
	if s.CertificateName != "" {
		m["certificate_name"] = s.CertificateName
	}
	return m
}

// HealthCheck defines how the load balancer checks the health of attached Droplets.
type DigitalOceanLoadBalancerHealthCheckInput struct {
	// The port on the Droplet to which the health check will be performed.
	Port uint32 `json:"port" jsonschema:"required,The port on the Droplet to which the health check will be performed."`
	// Protocol to use for health checking (HTTP, HTTPS, or TCP).
	Protocol string `json:"protocol" jsonschema:"required,enum=http|https|tcp,Protocol to use for health checking (HTTP; HTTPS; or TCP)."`
	// If using HTTP/HTTPS for health checks, the request path to probe (e.g., "/health").
	//  Ignored for TCP health checks.
	Path string `json:"path,omitempty" jsonschema:"If using HTTP/HTTPS for health checks; the request path to probe (e.g.; '/health'). Ignored for TCP health checks."`
	// Interval (in seconds) between health check probes.
	CheckIntervalSec uint32 `json:"check_interval_sec,omitempty" jsonschema:"Interval (in seconds) between health check probes."`
}

func (s *DigitalOceanLoadBalancerHealthCheckInput) validate() error {
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	switch s.Protocol {
	case "http", "https", "tcp":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	return nil
}

func (s *DigitalOceanLoadBalancerHealthCheckInput) applyDefaults() {
}

func (s *DigitalOceanLoadBalancerHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	m["port"] = s.Port
	m["protocol"] = s.Protocol
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.CheckIntervalSec != 0 {
		m["check_interval_sec"] = s.CheckIntervalSec
	}
	return m
}

// ParseDigitalOceanLoadBalancer validates and normalizes a DigitalOceanLoadBalancer cloud_object.
func ParseDigitalOceanLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
