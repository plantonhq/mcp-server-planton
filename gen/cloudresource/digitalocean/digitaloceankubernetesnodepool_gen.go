// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-kubernetes-node-pool
type DigitalOceanKubernetesNodePoolSpecInput struct {
	// A name for the node pool. Must be unique within the Kubernetes cluster.
	NodePoolName string `json:"node_pool_name" jsonschema:"required,A name for the node pool. Must be unique within the Kubernetes cluster."`
	// Reference to the DigitalOcean Kubernetes Cluster in which to create this node pool.
	//  Accepts the cluster's name or a reference to the DigitalOceanKubernetesCluster resource.
	Cluster string `json:"cluster" jsonschema:"required,Reference to the DigitalOcean Kubernetes Cluster in which to create this node pool. Accepts the cluster's name or a reference to the DigitalOceanKubernetesCluster resource."`
	// The slug identifier for the Droplet size to use for each node (e.g., "s-4vcpu-8gb").
	//  This defines the CPU and memory of the nodes in the pool.
	Size string `json:"size" jsonschema:"required,The slug identifier for the Droplet size to use for each node (e.g.; 's-4vcpu-8gb'). This defines the CPU and memory of the nodes in the pool."`
	// The number of nodes to provision in the pool.
	//  Must be at least 1. If auto_scale is enabled, this acts as the initial desired node count.
	NodeCount uint32 `json:"node_count" jsonschema:"required,The number of nodes to provision in the pool. Must be at least 1. If auto_scale is enabled; this acts as the initial desired node count."`
	// Enable auto-scaling for this node pool.
	//  If true, the platform will manage node count between min_nodes and max_nodes.
	AutoScale bool `json:"auto_scale,omitempty" jsonschema:"Enable auto-scaling for this node pool. If true; the platform will manage node count between min_nodes and max_nodes."`
	// Minimum number of nodes when auto-scaling is enabled.
	//  Required if auto_scale is true.
	MinNodes uint32 `json:"min_nodes,omitempty" jsonschema:"Minimum number of nodes when auto-scaling is enabled. Required if auto_scale is true."`
	// Maximum number of nodes when auto-scaling is enabled.
	//  Required if auto_scale is true.
	MaxNodes uint32 `json:"max_nodes,omitempty" jsonschema:"Maximum number of nodes when auto-scaling is enabled. Required if auto_scale is true."`
	// Kubernetes labels to apply to all nodes in this pool.
	//  Labels are key-value pairs used for node selection and workload scheduling.
	//  Example: {"workload": "web", "env": "production"}
	Labels map[string]string `json:"labels,omitempty" jsonschema:"Kubernetes labels to apply to all nodes in this pool. Labels are key-value pairs used for node selection and workload scheduling. Example: {'workload': 'web'; 'env': 'production'}"`
	// Kubernetes taints to apply to all nodes in this pool.
	//  Taints prevent pods from being scheduled on these nodes unless they have matching tolerations.
	//  Commonly used for workload isolation (e.g., GPU nodes, dedicated system pools).
	Taints []*DigitalOceanKubernetesNodePoolTaintInput `json:"taints,omitempty" jsonschema:"Kubernetes taints to apply to all nodes in this pool. Taints prevent pods from being scheduled on these nodes unless they have matching tolerations. Commonly used for workload isolation (e.g.; GPU nod..."`
	// A list of DigitalOcean tags to apply to the node pool Droplets.
	//  Tags are used for cost attribution and organizational purposes in DigitalOcean's billing and management.
	//  Note: This is different from Kubernetes labels. Tags affect DO billing, labels affect K8s scheduling.
	Tags []string `json:"tags,omitempty" jsonschema:"A list of DigitalOcean tags to apply to the node pool Droplets. Tags are used for cost attribution and organizational purposes in DigitalOcean's billing and management. Note: This is different from Ku..."`
}

func (s *DigitalOceanKubernetesNodePoolSpecInput) validate() error {
	if s.NodePoolName == "" {
		return fmt.Errorf("node_pool_name is required")
	}
	if s.Cluster == "" {
		return fmt.Errorf("cluster is required")
	}
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	for i, v := range s.Taints {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("taints[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *DigitalOceanKubernetesNodePoolSpecInput) applyDefaults() {
}

func (s *DigitalOceanKubernetesNodePoolSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["node_pool_name"] = s.NodePoolName
	m["cluster"] = s.Cluster
	m["size"] = s.Size
	m["node_count"] = s.NodeCount
	if s.AutoScale {
		m["auto_scale"] = s.AutoScale
	}
	if s.MinNodes != 0 {
		m["min_nodes"] = s.MinNodes
	}
	if s.MaxNodes != 0 {
		m["max_nodes"] = s.MaxNodes
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Taints) > 0 {
		items := make([]any, len(s.Taints))
		for i, v := range s.Taints {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["taints"] = items
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// DigitalOcean Kubernetes Node Pool Taint
//
//	Taints prevent pods from being scheduled on nodes unless they tolerate the taint.
type DigitalOceanKubernetesNodePoolTaintInput struct {
	// The taint key (e.g., "nvidia.com/gpu", "workload", "dedicated")
	Key string `json:"key" jsonschema:"required,The taint key (e.g.; 'nvidia.com/gpu'; 'workload'; 'dedicated')"`
	// The taint value (e.g., "true", "gpu", "system")
	Value string `json:"value,omitempty" jsonschema:"The taint value (e.g.; 'true'; 'gpu'; 'system')"`
	// The taint effect: NoSchedule, PreferNoSchedule, or NoExecute
	//  - NoSchedule: Pods that don't tolerate this taint will not be scheduled on the node
	//  - PreferNoSchedule: Kubernetes will try to avoid scheduling pods that don't tolerate this taint
	//  - NoExecute: Pods that don't tolerate this taint will be...
	Effect string `json:"effect" jsonschema:"required,The taint effect: NoSchedule; PreferNoSchedule; or NoExecute - NoSchedule: Pods that don't tolerate this taint will not be scheduled on the node - PreferNoSchedule: Kubernetes will try to avoid schedu..."`
}

func (s *DigitalOceanKubernetesNodePoolTaintInput) validate() error {
	if s.Key == "" {
		return fmt.Errorf("key is required")
	}
	if s.Effect == "" {
		return fmt.Errorf("effect is required")
	}
	return nil
}

func (s *DigitalOceanKubernetesNodePoolTaintInput) applyDefaults() {
}

func (s *DigitalOceanKubernetesNodePoolTaintInput) toMap() map[string]any {
	m := make(map[string]any)
	m["key"] = s.Key
	if s.Value != "" {
		m["value"] = s.Value
	}
	m["effect"] = s.Effect
	return m
}

// ParseDigitalOceanKubernetesNodePool validates and normalizes a DigitalOceanKubernetesNodePool cloud_object.
func ParseDigitalOceanKubernetesNodePool(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanKubernetesNodePool"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanKubernetesNodePoolSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
