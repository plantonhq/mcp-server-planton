// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-container-registry
type DigitalOceanContainerRegistrySpecInput struct {
	// Registry name (must be unique within your DigitalOcean account).
	//  1-63 characters, lowercase letters, numbers, and hyphens; must start and end with an alphanumeric.
	Name string `json:"name" jsonschema:"required,Registry name (must be unique within your DigitalOcean account). 1-63 characters; lowercase letters; numbers; and hyphens; must start and end with an alphanumeric."`
	// Subscription tier slug (defines storage limits and pricing).
	SubscriptionTier string `json:"subscription_tier" jsonschema:"required,enum=starter|basic|professional,Subscription tier slug (defines storage limits and pricing)."`
	// Optional region slug where registry data is stored (e.g., "nyc3", "sfo3").
	//  If omitted, DigitalOcean chooses a default/nearest region.
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,Optional region slug where registry data is stored (e.g.; 'nyc3'; 'sfo3'). If omitted; DigitalOcean chooses a default/nearest region."`
	// Enable garbage collection of untagged images.
	//  Default is false (no automatic GC).
	GarbageCollectionEnabled bool `json:"garbage_collection_enabled,omitempty" jsonschema:"Enable garbage collection of untagged images. Default is false (no automatic GC)."`
}

func (s *DigitalOceanContainerRegistrySpecInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.SubscriptionTier == "" {
		return fmt.Errorf("subscription_tier is required")
	}
	switch s.SubscriptionTier {
	case "starter", "basic", "professional":
	default:
		return fmt.Errorf("invalid subscription_tier: %q", s.SubscriptionTier)
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	return nil
}

func (s *DigitalOceanContainerRegistrySpecInput) applyDefaults() {
}

func (s *DigitalOceanContainerRegistrySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["subscription_tier"] = s.SubscriptionTier
	m["region"] = s.Region
	if s.GarbageCollectionEnabled {
		m["garbage_collection_enabled"] = s.GarbageCollectionEnabled
	}
	return m
}

// ParseDigitalOceanContainerRegistry validates and normalizes a DigitalOceanContainerRegistry cloud_object.
func ParseDigitalOceanContainerRegistry(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanContainerRegistry"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanContainerRegistrySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
