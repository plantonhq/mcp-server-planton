// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-vpc
type DigitalOceanVpcSpecInput struct {
	// A human-readable description for the VPC.
	//  Constraints: Maximum 100 characters.
	Description string `json:"description,omitempty" jsonschema:"A human-readable description for the VPC. Constraints: Maximum 100 characters."`
	// The DigitalOcean region where the VPC will be created.
	//  This determines the geographical location of the VPC.
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,The DigitalOcean region where the VPC will be created. This determines the geographical location of the VPC."`
	// The IP range for the VPC in CIDR notation (optional).
	//  Only /16, /20, or /24 CIDR blocks are supported for VPCs on DigitalOcean.
	//  Example: "10.10.0.0/16"
	//
	//  80/20 Principle: When omitted, DigitalOcean auto-generates a non-conflicting /20 CIDR block (4,096 IPs).
	//  This is the recommended approach for d...
	IpRangeCidr string `json:"ip_range_cidr,omitempty" jsonschema:"The IP range for the VPC in CIDR notation (optional). Only /16; /20; or /24 CIDR blocks are supported for VPCs on DigitalOcean. Example: '10.10.0.0/16' 80/20 Principle: When omitted; DigitalOcean auto..."`
	// A boolean indicating whether this VPC should be set as the default for the specified region.
	//  Only one VPC can be the default for a given region.
	//  Default: false
	IsDefaultForRegion bool `json:"is_default_for_region,omitempty" jsonschema:"A boolean indicating whether this VPC should be set as the default for the specified region. Only one VPC can be the default for a given region. Default: false"`
}

func (s *DigitalOceanVpcSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	return nil
}

func (s *DigitalOceanVpcSpecInput) applyDefaults() {
}

func (s *DigitalOceanVpcSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Description != "" {
		m["description"] = s.Description
	}
	m["region"] = s.Region
	if s.IpRangeCidr != "" {
		m["ip_range_cidr"] = s.IpRangeCidr
	}
	if s.IsDefaultForRegion {
		m["is_default_for_region"] = s.IsDefaultForRegion
	}
	return m
}

// ParseDigitalOceanVpc validates and normalizes a DigitalOceanVpc cloud_object.
func ParseDigitalOceanVpc(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanVpc"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanVpcSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
