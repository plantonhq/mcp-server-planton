// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-certificate
type DigitalOceanCertificateSpecInput struct {
	// certificate_name is a unique, human‑readable identifier (≤ 64 chars).
	CertificateName string `json:"certificate_name" jsonschema:"required,certificate_name is a unique; human‑readable identifier (≤ 64 chars)."`
	// type must align with the branch chosen in certificate_source.
	Type        string                                         `json:"type" jsonschema:"required,enum=lets_encrypt|custom,type must align with the branch chosen in certificate_source."`
	LetsEncrypt *DigitalOceanCertificateLetsEncryptParamsInput `json:"lets_encrypt,omitempty" jsonschema:""`
	Custom      *DigitalOceanCertificateCustomParamsInput      `json:"custom,omitempty" jsonschema:""`
	// Optional free‑form description (≤ 128 chars).
	Description string `json:"description,omitempty" jsonschema:"Optional free‑form description (≤ 128 chars)."`
	// Optional tags; must be unique and lowercase kebab.
	Tags []string `json:"tags,omitempty" jsonschema:"Optional tags; must be unique and lowercase kebab."`
}

func (s *DigitalOceanCertificateSpecInput) validate() error {
	if s.CertificateName == "" {
		return fmt.Errorf("certificate_name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "lets_encrypt", "custom":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.LetsEncrypt != nil {
		if err := s.LetsEncrypt.validate(); err != nil {
			return fmt.Errorf("lets_encrypt: %w", err)
		}
	}
	if s.Custom != nil {
		if err := s.Custom.validate(); err != nil {
			return fmt.Errorf("custom: %w", err)
		}
	}
	return nil
}

func (s *DigitalOceanCertificateSpecInput) applyDefaults() {
	if s.LetsEncrypt != nil {
		s.LetsEncrypt.applyDefaults()
	}
	if s.Custom != nil {
		s.Custom.applyDefaults()
	}
}

func (s *DigitalOceanCertificateSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["certificate_name"] = s.CertificateName
	m["type"] = s.Type
	if s.LetsEncrypt != nil {
		m["lets_encrypt"] = s.LetsEncrypt.toMap()
	}
	if s.Custom != nil {
		m["custom"] = s.Custom.toMap()
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// Parameters specific to a custom (user‑supplied) certificate.
type DigitalOceanCertificateCustomParamsInput struct {
	// leaf_certificate is the PEM‑encoded public certificate.
	LeafCertificate string `json:"leaf_certificate" jsonschema:"required,leaf_certificate is the PEM‑encoded public certificate."`
	// private_key is the PEM‑encoded private key.
	PrivateKey string `json:"private_key" jsonschema:"required,private_key is the PEM‑encoded private key."`
	// certificate_chain is an optional PEM‑encoded intermediate chain.
	CertificateChain string `json:"certificate_chain,omitempty" jsonschema:"certificate_chain is an optional PEM‑encoded intermediate chain."`
}

func (s *DigitalOceanCertificateCustomParamsInput) validate() error {
	if s.LeafCertificate == "" {
		return fmt.Errorf("leaf_certificate is required")
	}
	if s.PrivateKey == "" {
		return fmt.Errorf("private_key is required")
	}
	return nil
}

func (s *DigitalOceanCertificateCustomParamsInput) applyDefaults() {
}

func (s *DigitalOceanCertificateCustomParamsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["leaf_certificate"] = s.LeafCertificate
	m["private_key"] = s.PrivateKey
	if s.CertificateChain != "" {
		m["certificate_chain"] = s.CertificateChain
	}
	return m
}

// Parameters specific to a Let's Encrypt certificate request.
type DigitalOceanCertificateLetsEncryptParamsInput struct {
	// domains is the list of FQDNs (or wildcard domains) to include.
	//  At least one domain is required.
	Domains []string `json:"domains" jsonschema:"required,domains is the list of FQDNs (or wildcard domains) to include. At least one domain is required."`
	// disable auto_renew controls automatic renewal of the Let's Encrypt certificate.
	DisableAutoRenew bool `json:"disable_auto_renew,omitempty" jsonschema:"disable auto_renew controls automatic renewal of the Let's Encrypt certificate."`
}

func (s *DigitalOceanCertificateLetsEncryptParamsInput) validate() error {
	if len(s.Domains) == 0 {
		return fmt.Errorf("domains is required")
	}
	return nil
}

func (s *DigitalOceanCertificateLetsEncryptParamsInput) applyDefaults() {
}

func (s *DigitalOceanCertificateLetsEncryptParamsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domains"] = s.Domains
	if s.DisableAutoRenew {
		m["disable_auto_renew"] = s.DisableAutoRenew
	}
	return m
}

// ParseDigitalOceanCertificate validates and normalizes a DigitalOceanCertificate cloud_object.
func ParseDigitalOceanCertificate(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanCertificate"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanCertificateSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
