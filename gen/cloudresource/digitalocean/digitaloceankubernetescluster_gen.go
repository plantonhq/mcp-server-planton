// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package digitalocean

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// digital-ocean-kubernetes-cluster
type DigitalOceanKubernetesClusterSpecInput struct {
	// The name of the Kubernetes cluster. This will be the cluster's identifier in DigitalOcean.
	//  Constraints: Must be unique per account. (A maximum length or character set may be enforced by DigitalOcean, e.g., alphanumeric and hyphens.)
	ClusterName string `json:"cluster_name" jsonschema:"required,The name of the Kubernetes cluster. This will be the cluster's identifier in DigitalOcean. Constraints: Must be unique per account. (A maximum length or character set may be enforced by DigitalOcean; ..."`
	// The DigitalOcean region where the cluster will be created.
	//  Determines where the cluster's control plane and nodes are provisioned.
	Region string `json:"region" jsonschema:"required,enum=nyc3|sfo3|fra1|sgp1|lon1|tor1|blr1|ams3,The DigitalOcean region where the cluster will be created. Determines where the cluster's control plane and nodes are provisioned."`
	// The Kubernetes version to use for the cluster (semantic versioning).
	//  Must be a supported version on DigitalOcean (e.g., 1.22+).
	//  Example: "1.26.3"
	KubernetesVersion string `json:"kubernetes_version" jsonschema:"required,The Kubernetes version to use for the cluster (semantic versioning). Must be a supported version on DigitalOcean (e.g.; 1.22+). Example: '1.26.3'"`
	// Reference to the DigitalOcean VPC where the cluster's control plane will reside.
	//  This must be an existing VPC in the same region. Only the VPC's name is needed; the system will resolve it to the VPC ID.
	Vpc string `json:"vpc" jsonschema:"required,Reference to the DigitalOcean VPC where the cluster's control plane will reside. This must be an existing VPC in the same region. Only the VPC's name is needed; the system will resolve it to the VPC I..."`
	// Whether to enable a highly available control plane for the cluster.
	//  If true, the cluster is created with a High Availability control plane (multiple masters for increased uptime, additional cost).
	//  Default: false.
	HighlyAvailable bool `json:"highly_available,omitempty" jsonschema:"Whether to enable a highly available control plane for the cluster. If true; the cluster is created with a High Availability control plane (multiple masters for increased uptime; additional cost). Def..."`
	// Whether to enable automatic patch upgrades for the cluster.
	//  If true, the cluster will automatically upgrade to new patch releases of Kubernetes when available.
	AutoUpgrade bool `json:"auto_upgrade,omitempty" jsonschema:"Whether to enable automatic patch upgrades for the cluster. If true; the cluster will automatically upgrade to new patch releases of Kubernetes when available."`
	// Whether to disable surge upgrades for the cluster.
	//  If false(default), cluster upgrades will temporarily provision extra nodes to minimize downtime during updates.
	DisableSurgeUpgrade bool `json:"disable_surge_upgrade,omitempty" jsonschema:"Whether to disable surge upgrades for the cluster. If false(default); cluster upgrades will temporarily provision extra nodes to minimize downtime during updates."`
	// Scheduled maintenance window for cluster updates (format: "day=HH:MM" or "any=HH:MM").
	//  Examples: "sunday=02:00" or "any=00:00"
	//  If not specified, DigitalOcean will apply updates at any time.
	MaintenanceWindow string `json:"maintenance_window,omitempty" jsonschema:"Scheduled maintenance window for cluster updates (format: 'day=HH:MM' or 'any=HH:MM'). Examples: 'sunday=02:00' or 'any=00:00' If not specified; DigitalOcean will apply updates at any time."`
	// Whether to enable DigitalOcean Container Registry (DOCR) integration.
	//  If true, automatically creates imagePullSecrets in the cluster for pulling private images from DOCR.
	//  Default: false.
	RegistryIntegration bool `json:"registry_integration,omitempty" jsonschema:"Whether to enable DigitalOcean Container Registry (DOCR) integration. If true; automatically creates imagePullSecrets in the cluster for pulling private images from DOCR. Default: false."`
	// List of allowed IP addresses (CIDR notation) for control plane firewall.
	//  Restricts Kubernetes API server access to specified IPs for security.
	//  If empty, API server is publicly accessible (not recommended for production).
	//  Example: ["203.0.113.5/32", "198.51.100.0/24"]
	ControlPlaneFirewallAllowedIps []string `json:"control_plane_firewall_allowed_ips,omitempty" jsonschema:"List of allowed IP addresses (CIDR notation) for control plane firewall. Restricts Kubernetes API server access to specified IPs for security. If empty; API server is publicly accessible (not recommen..."`
	// A list of tags to apply to the cluster.
	//  Tags help organize and identify the cluster within DigitalOcean.
	Tags []string `json:"tags,omitempty" jsonschema:"A list of tags to apply to the cluster. Tags help organize and identify the cluster within DigitalOcean."`
	// Reference to the default node pool for the cluster.
	DefaultNodePool *DigitalOceanKubernetesClusterDefaultNodePoolInput `json:"default_node_pool" jsonschema:"required,Reference to the default node pool for the cluster."`
}

func (s *DigitalOceanKubernetesClusterSpecInput) validate() error {
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "nyc3", "sfo3", "fra1", "sgp1", "lon1", "tor1", "blr1", "ams3":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.KubernetesVersion == "" {
		return fmt.Errorf("kubernetes_version is required")
	}
	if s.Vpc == "" {
		return fmt.Errorf("vpc is required")
	}
	if s.DefaultNodePool == nil {
		return fmt.Errorf("default_node_pool is required")
	}
	if s.DefaultNodePool != nil {
		if err := s.DefaultNodePool.validate(); err != nil {
			return fmt.Errorf("default_node_pool: %w", err)
		}
	}
	return nil
}

func (s *DigitalOceanKubernetesClusterSpecInput) applyDefaults() {
	if s.DefaultNodePool != nil {
		s.DefaultNodePool.applyDefaults()
	}
}

func (s *DigitalOceanKubernetesClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cluster_name"] = s.ClusterName
	m["region"] = s.Region
	m["kubernetes_version"] = s.KubernetesVersion
	m["vpc"] = s.Vpc
	if s.HighlyAvailable {
		m["highly_available"] = s.HighlyAvailable
	}
	if s.AutoUpgrade {
		m["auto_upgrade"] = s.AutoUpgrade
	}
	if s.DisableSurgeUpgrade {
		m["disable_surge_upgrade"] = s.DisableSurgeUpgrade
	}
	if s.MaintenanceWindow != "" {
		m["maintenance_window"] = s.MaintenanceWindow
	}
	if s.RegistryIntegration {
		m["registry_integration"] = s.RegistryIntegration
	}
	if len(s.ControlPlaneFirewallAllowedIps) > 0 {
		m["control_plane_firewall_allowed_ips"] = s.ControlPlaneFirewallAllowedIps
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.DefaultNodePool != nil {
		m["default_node_pool"] = s.DefaultNodePool.toMap()
	}
	return m
}

// DigitalOcean Kubernetes Cluster Default Node Pool
type DigitalOceanKubernetesClusterDefaultNodePoolInput struct {
	// The slug identifier for the Droplet size to use for each node (e.g., "s-4vcpu-8gb").
	//  This defines the CPU and memory of the nodes in the pool.
	Size string `json:"size" jsonschema:"required,The slug identifier for the Droplet size to use for each node (e.g.; 's-4vcpu-8gb'). This defines the CPU and memory of the nodes in the pool."`
	// The number of nodes to provision in the pool.
	//  Must be at least 1. If auto_scale is enabled, this acts as the initial desired node count.
	NodeCount uint32 `json:"node_count" jsonschema:"required,The number of nodes to provision in the pool. Must be at least 1. If auto_scale is enabled; this acts as the initial desired node count."`
	// Enable auto-scaling for this node pool.
	//  If true, the platform will manage node count between min_nodes and max_nodes.
	AutoScale bool `json:"auto_scale,omitempty" jsonschema:"Enable auto-scaling for this node pool. If true; the platform will manage node count between min_nodes and max_nodes."`
	// Minimum number of nodes when auto-scaling is enabled.
	//  Required if auto_scale is true.
	MinNodes uint32 `json:"min_nodes,omitempty" jsonschema:"Minimum number of nodes when auto-scaling is enabled. Required if auto_scale is true."`
	// Maximum number of nodes when auto-scaling is enabled.
	//  Required if auto_scale is true.
	MaxNodes uint32 `json:"max_nodes,omitempty" jsonschema:"Maximum number of nodes when auto-scaling is enabled. Required if auto_scale is true."`
}

func (s *DigitalOceanKubernetesClusterDefaultNodePoolInput) validate() error {
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	return nil
}

func (s *DigitalOceanKubernetesClusterDefaultNodePoolInput) applyDefaults() {
}

func (s *DigitalOceanKubernetesClusterDefaultNodePoolInput) toMap() map[string]any {
	m := make(map[string]any)
	m["size"] = s.Size
	m["node_count"] = s.NodeCount
	if s.AutoScale {
		m["auto_scale"] = s.AutoScale
	}
	if s.MinNodes != 0 {
		m["min_nodes"] = s.MinNodes
	}
	if s.MaxNodes != 0 {
		m["max_nodes"] = s.MaxNodes
	}
	return m
}

// ParseDigitalOceanKubernetesCluster validates and normalizes a DigitalOceanKubernetesCluster cloud_object.
func ParseDigitalOceanKubernetesCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "digital-ocean.openmcf.org/v1", "DigitalOceanKubernetesCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec DigitalOceanKubernetesClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
