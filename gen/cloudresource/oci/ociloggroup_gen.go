// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciLogGroup is the top-level resource representing an OCI Logging
//
//	log group -- an organizational container for related logs with
//	bundled service and custom log sub-resources.
type OciLogGroupSpecInput struct {
	// OCID of the compartment where the log group will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the log group will be created."`
	// Description for the log group.
	Description string `json:"description,omitempty" jsonschema:"Description for the log group."`
	// Logs within this group. Each log is identified by its display_name,
	//  which is used as the resource key in IaC modules and must be unique
	//  within the log group.
	Logs []*LogInput `json:"logs,omitempty" jsonschema:"Logs within this group. Each log is identified by its display_name; which is used as the resource key in IaC modules and must be unique within the log group."`
}

func (s *OciLogGroupSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	for i, v := range s.Logs {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("logs[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciLogGroupSpecInput) applyDefaults() {
}

func (s *OciLogGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Logs) > 0 {
		items := make([]any, len(s.Logs))
		for i, v := range s.Logs {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["logs"] = items
	}
	return m
}

// Log defines an individual log within the group.
//
//	Service logs auto-collect from OCI services and require a
//	configuration block specifying the source. Custom logs accept
//	entries pushed via the Logging Ingestion API and do not require
//	configuration.
type LogInput struct {
	// Display name for the log. Must be unique within the log group.
	//  Used as the for_each key in IaC modules.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the log. Must be unique within the log group. Used as the for_each key in IaC modules."`
	// Type of log. Must be explicitly set.
	//  custom: entries pushed via Logging Ingestion API.
	//  service: auto-collected from an OCI service.
	LogType string `json:"log_type,omitempty" jsonschema:"enum=custom|service,Type of log. Must be explicitly set. custom: entries pushed via Logging Ingestion API. service: auto-collected from an OCI service."`
	// Whether the log is enabled. When nil, OCI defaults to true.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether the log is enabled. When nil; OCI defaults to true."`
	// Retention period in days, in 30-day increments (30, 60, 90, 120,
	//  150, 180). When nil, OCI defaults to 30 days.
	RetentionDuration int32 `json:"retention_duration,omitempty" jsonschema:"Retention period in days; in 30-day increments (30; 60; 90; 120; 150; 180). When nil; OCI defaults to 30 days."`
	// Source configuration for service logs. Required when log_type is
	//  service; ignored for custom logs.
	//
	//  The provider nests this as configuration > source, but we flatten
	//  by removing the source wrapper (it is the only child alongside an
	//  optional compartment override). source_type is hardcoded to
	//  "OC...
	Configuration *ServiceLogConfigurationInput `json:"configuration,omitempty" jsonschema:"Source configuration for service logs. Required when log_type is service; ignored for custom logs. The provider nests this as configuration > source; but we flatten by removing the source wrapper (it ..."`
}

func (s *LogInput) validate() error {
	switch s.LogType {
	case "", "custom", "service":
	default:
		return fmt.Errorf("invalid log_type: %q", s.LogType)
	}
	if s.Configuration != nil {
		if err := s.Configuration.validate(); err != nil {
			return fmt.Errorf("configuration: %w", err)
		}
	}
	return nil
}

func (s *LogInput) applyDefaults() {
	if s.Configuration != nil {
		s.Configuration.applyDefaults()
	}
}

func (s *LogInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.LogType != "" {
		m["log_type"] = s.LogType
	}
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.RetentionDuration != 0 {
		m["retention_duration"] = s.RetentionDuration
	}
	if s.Configuration != nil {
		m["configuration"] = s.Configuration.toMap()
	}
	return m
}

// ServiceLogConfiguration identifies which OCI service, resource,
//
//	and log category to auto-collect logs from.
type ServiceLogConfigurationInput struct {
	// OCI service generating the log.
	//  Examples: "objectstorage", "flowlogs", "apigateway",
	//  "loadbalancer", "functionsInvoke".
	Service string `json:"service,omitempty" jsonschema:"OCI service generating the log. Examples: 'objectstorage'; 'flowlogs'; 'apigateway'; 'loadbalancer'; 'functionsInvoke'."`
	// OCID of the resource emitting logs. Polymorphic -- could be a
	//  VCN (for flow logs), a bucket (for object storage), an API
	//  gateway, etc. StringValueOrRef without default_kind because
	//  the resource type varies; valueFrom enables composability
	//  with any OpenMCF component.
	Resource string `json:"resource" jsonschema:"required,OCID of the resource emitting logs. Polymorphic -- could be a VCN (for flow logs); a bucket (for object storage); an API gateway; etc. StringValueOrRef without default_kind because the resource type v..."`
	// Log category within the service.
	//  Examples: "write", "read", "all" (object storage);
	//  "access" (API gateway); "invoke" (functions).
	Category string `json:"category,omitempty" jsonschema:"Log category within the service. Examples: 'write'; 'read'; 'all' (object storage); 'access' (API gateway); 'invoke' (functions)."`
	// Additional parameters for the log source. Pass-through to OCI.
	Parameters map[string]string `json:"parameters,omitempty" jsonschema:"Additional parameters for the log source. Pass-through to OCI."`
	// Optional compartment override for source resource lookup.
	//  When omitted, the log group's compartment is used.
	CompartmentId string `json:"compartment_id,omitempty" jsonschema:"Optional compartment override for source resource lookup. When omitted; the log group's compartment is used."`
}

func (s *ServiceLogConfigurationInput) validate() error {
	if s.Resource == "" {
		return fmt.Errorf("resource is required")
	}
	return nil
}

func (s *ServiceLogConfigurationInput) applyDefaults() {
}

func (s *ServiceLogConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Service != "" {
		m["service"] = s.Service
	}
	m["resource"] = s.Resource
	if s.Category != "" {
		m["category"] = s.Category
	}
	if len(s.Parameters) > 0 {
		m["parameters"] = s.Parameters
	}
	if s.CompartmentId != "" {
		m["compartment_id"] = s.CompartmentId
	}
	return m
}

// ParseOciLogGroup validates and normalizes a OciLogGroup cloud_object.
func ParseOciLogGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciLogGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciLogGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
