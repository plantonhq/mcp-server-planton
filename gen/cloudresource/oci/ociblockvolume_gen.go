// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciBlockVolume is the top-level resource representing an OCI Block Volume
//
//	with optional backup policy assignment and cross-region replicas.
type OciBlockVolumeSpecInput struct {
	// OCID of the compartment where the block volume will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the block volume will be created."`
	// Availability domain where the volume is placed (e.g., "Uocm:US-ASHBURN-AD-1").
	//  The volume and any attached compute instance must be in the same AD.
	//  Changing this forces recreation.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain where the volume is placed (e.g.; 'Uocm:US-ASHBURN-AD-1'). The volume and any attached compute instance must be in the same AD. Changing this forces recreation."`
	// Display name for the volume. When omitted, the metadata name is used.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the volume. When omitted; the metadata name is used."`
	// Size of the volume in gigabytes. Valid range: 50-32768 (50 GB to 32 TB).
	//  Must be specified explicitly to prevent accidental creation at OCI's
	//  1 TB default.
	SizeInGbs int32 `json:"size_in_gbs,omitempty" jsonschema:"Size of the volume in gigabytes. Valid range: 50-32768 (50 GB to 32 TB). Must be specified explicitly to prevent accidental creation at OCI's 1 TB default."`
	// Volume Performance Units per GB. Controls IOPS and throughput.
	//  When unset, OCI defaults to 10 (Balanced). Set to 0 for Lower Cost.
	//  Valid values: 0, 10, 20, 30-120 (in increments of 10).
	//  Stored as Int64 string in OCI API.
	VpusPerGb int32 `json:"vpus_per_gb,omitempty" jsonschema:"Volume Performance Units per GB. Controls IOPS and throughput. When unset; OCI defaults to 10 (Balanced). Set to 0 for Lower Cost. Valid values: 0; 10; 20; 30-120 (in increments of 10). Stored as Int6..."`
	// OCID of a KMS master encryption key for volume encryption.
	//  When unset, Oracle-managed keys are used.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of a KMS master encryption key for volume encryption. When unset; Oracle-managed keys are used."`
	// Enables SCSI persistent reservation support on the volume.
	//  Required for shared-storage clustering scenarios (e.g., Oracle RAC).
	IsReservationsEnabled bool `json:"is_reservations_enabled,omitempty" jsonschema:"Enables SCSI persistent reservation support on the volume. Required for shared-storage clustering scenarios (e.g.; Oracle RAC)."`
	// Autotune policies that automatically adjust volume performance
	//  (VPUs/GB) based on detachment state or workload patterns.
	AutotunePolicies []*AutotunePolicyInput `json:"autotune_policies,omitempty" jsonschema:"Autotune policies that automatically adjust volume performance (VPUs/GB) based on detachment state or workload patterns."`
	// Cross-region block volume replicas for disaster recovery.
	//  Each replica is placed in a target availability domain (can be
	//  in a different region) and asynchronously replicated.
	BlockVolumeReplicas []*BlockVolumeReplicaInput `json:"block_volume_replicas,omitempty" jsonschema:"Cross-region block volume replicas for disaster recovery. Each replica is placed in a target availability domain (can be in a different region) and asynchronously replicated."`
	// OCID of a backup policy to assign to this volume.
	//  OCI provides Oracle-defined policies (Gold, Silver, Bronze) or
	//  custom user-defined policies. When set, the component creates an
	//  oci_core_volume_backup_policy_assignment sub-resource.
	BackupPolicyId string `json:"backup_policy_id,omitempty" jsonschema:"OCID of a backup policy to assign to this volume. OCI provides Oracle-defined policies (Gold; Silver; Bronze) or custom user-defined policies. When set; the component creates an oci_core_volume_backup..."`
	// OCID of a KMS key used to encrypt cross-region volume backups.
	//  Only relevant when a backup policy with cross-region copy is assigned.
	//  Changing this forces recreation.
	XrcKmsKeyId string `json:"xrc_kms_key_id,omitempty" jsonschema:"OCID of a KMS key used to encrypt cross-region volume backups. Only relevant when a backup policy with cross-region copy is assigned. Changing this forces recreation."`
}

func (s *OciBlockVolumeSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	for i, v := range s.AutotunePolicies {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("autotune_policies[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.BlockVolumeReplicas {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("block_volume_replicas[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciBlockVolumeSpecInput) applyDefaults() {
}

func (s *OciBlockVolumeSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.SizeInGbs != 0 {
		m["size_in_gbs"] = s.SizeInGbs
	}
	if s.VpusPerGb != 0 {
		m["vpus_per_gb"] = s.VpusPerGb
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.IsReservationsEnabled {
		m["is_reservations_enabled"] = s.IsReservationsEnabled
	}
	if len(s.AutotunePolicies) > 0 {
		items := make([]any, len(s.AutotunePolicies))
		for i, v := range s.AutotunePolicies {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["autotune_policies"] = items
	}
	if len(s.BlockVolumeReplicas) > 0 {
		items := make([]any, len(s.BlockVolumeReplicas))
		for i, v := range s.BlockVolumeReplicas {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["block_volume_replicas"] = items
	}
	if s.BackupPolicyId != "" {
		m["backup_policy_id"] = s.BackupPolicyId
	}
	if s.XrcKmsKeyId != "" {
		m["xrc_kms_key_id"] = s.XrcKmsKeyId
	}
	return m
}

// AutotunePolicy controls automatic performance adjustment for the volume.
type AutotunePolicyInput struct {
	// Type of autotune policy to apply.
	AutotuneType string `json:"autotune_type,omitempty" jsonschema:"enum=detached_volume|performance_based,Type of autotune policy to apply."`
	// Maximum VPUs/GB for performance-based autotune.
	//  Required when autotune_type is performance_based.
	MaxVpusPerGb int32 `json:"max_vpus_per_gb,omitempty" jsonschema:"Maximum VPUs/GB for performance-based autotune. Required when autotune_type is performance_based."`
}

func (s *AutotunePolicyInput) validate() error {
	switch s.AutotuneType {
	case "", "detached_volume", "performance_based":
	default:
		return fmt.Errorf("invalid autotune_type: %q", s.AutotuneType)
	}
	return nil
}

func (s *AutotunePolicyInput) applyDefaults() {
}

func (s *AutotunePolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AutotuneType != "" {
		m["autotune_type"] = s.AutotuneType
	}
	if s.MaxVpusPerGb != 0 {
		m["max_vpus_per_gb"] = s.MaxVpusPerGb
	}
	return m
}

// BlockVolumeReplica configures an asynchronous cross-region volume replica.
type BlockVolumeReplicaInput struct {
	// Availability domain for the replica (e.g., "Uocm:US-PHOENIX-AD-1").
	//  Can be in a different region from the source volume.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain for the replica (e.g.; 'Uocm:US-PHOENIX-AD-1'). Can be in a different region from the source volume."`
	// Display name for the replica. When omitted, OCI generates one.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the replica. When omitted; OCI generates one."`
	// OCID of a KMS key for encrypting the cross-region replica.
	XrrKmsKeyId string `json:"xrr_kms_key_id,omitempty" jsonschema:"OCID of a KMS key for encrypting the cross-region replica."`
}

func (s *BlockVolumeReplicaInput) validate() error {
	return nil
}

func (s *BlockVolumeReplicaInput) applyDefaults() {
}

func (s *BlockVolumeReplicaInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.XrrKmsKeyId != "" {
		m["xrr_kms_key_id"] = s.XrrKmsKeyId
	}
	return m
}

// ParseOciBlockVolume validates and normalizes a OciBlockVolume cloud_object.
func ParseOciBlockVolume(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciBlockVolume"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciBlockVolumeSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
