// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciRedisCluster is the top-level resource representing an OCI Cache
//
//	(Redis) cluster -- a fully managed, Redis-compatible in-memory caching
//	service supporting sharded and non-sharded topologies.
type OciRedisClusterSpecInput struct {
	// OCID of the compartment where the Redis cluster will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the Redis cluster will be created."`
	// Human-readable name shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name shown in the OCI Console. Falls back to metadata.name if not provided."`
	// OCID of the subnet where the Redis cluster will be placed.
	//  Changing this forces recreation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the Redis cluster will be placed. Changing this forces recreation."`
	// Number of nodes in the cluster. For non-sharded clusters this is the
	//  total node count (1 primary + N-1 replicas). For sharded clusters
	//  this is the number of nodes per shard. Updatable.
	NodeCount int32 `json:"node_count,omitempty" jsonschema:"Number of nodes in the cluster. For non-sharded clusters this is the total node count (1 primary + N-1 replicas). For sharded clusters this is the number of nodes per shard. Updatable."`
	// Memory allocated to each node in gigabytes. Determines the total
	//  cache capacity. Updatable. Common values: 2, 4, 8, 16, 32.
	NodeMemoryInGbs float32 `json:"node_memory_in_gbs,omitempty" jsonschema:"Memory allocated to each node in gigabytes. Determines the total cache capacity. Updatable. Common values: 2; 4; 8; 16; 32."`
	// OCI Cache engine version (e.g. "V7.0.5", "V7.1.1").
	//  Available versions depend on the region. Updatable.
	SoftwareVersion string `json:"software_version,omitempty" jsonschema:"OCI Cache engine version (e.g. 'V7.0.5'; 'V7.1.1'). Available versions depend on the region. Updatable."`
	// Cluster topology mode. Changing this forces recreation.
	//  When unset, OCI defaults to NONSHARDED.
	ClusterMode string `json:"cluster_mode,omitempty" jsonschema:"enum=nonsharded|sharded,Cluster topology mode. Changing this forces recreation. When unset; OCI defaults to NONSHARDED."`
	// Number of shards in the cluster. Only applicable when cluster_mode
	//  is sharded. Each shard has node_count nodes. Updatable.
	ShardCount int32 `json:"shard_count,omitempty" jsonschema:"Number of shards in the cluster. Only applicable when cluster_mode is sharded. Each shard has node_count nodes. Updatable."`
	// OCIDs of network security groups controlling access to the cluster.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups controlling access to the cluster."`
	// OCID of an OCI Cache Config Set providing custom Redis configuration
	//  parameters (e.g. maxmemory-policy, timeout). When omitted, the
	//  default configuration is used.
	ConfigSetId string `json:"config_set_id,omitempty" jsonschema:"OCID of an OCI Cache Config Set providing custom Redis configuration parameters (e.g. maxmemory-policy; timeout). When omitted; the default configuration is used."`
}

func (s *OciRedisClusterSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	switch s.ClusterMode {
	case "", "nonsharded", "sharded":
	default:
		return fmt.Errorf("invalid cluster_mode: %q", s.ClusterMode)
	}
	return nil
}

func (s *OciRedisClusterSpecInput) applyDefaults() {
}

func (s *OciRedisClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	m["subnet_id"] = s.SubnetId
	if s.NodeCount != 0 {
		m["node_count"] = s.NodeCount
	}
	if s.NodeMemoryInGbs != 0 {
		m["node_memory_in_gbs"] = s.NodeMemoryInGbs
	}
	if s.SoftwareVersion != "" {
		m["software_version"] = s.SoftwareVersion
	}
	if s.ClusterMode != "" {
		m["cluster_mode"] = s.ClusterMode
	}
	if s.ShardCount != 0 {
		m["shard_count"] = s.ShardCount
	}
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.ConfigSetId != "" {
		m["config_set_id"] = s.ConfigSetId
	}
	return m
}

// ParseOciRedisCluster validates and normalizes a OciRedisCluster cloud_object.
func ParseOciRedisCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciRedisCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciRedisClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
