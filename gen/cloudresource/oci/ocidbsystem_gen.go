// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciDbSystem is the top-level resource representing an Oracle Cloud
//
//	Infrastructure Database System -- a managed Oracle Database running on
//	Virtual Machine or Bare Metal infrastructure with full control over
//	compute shape, storage layout, patching, and Oracle Database edition.
type OciDbSystemSpecInput struct {
	// OCID of the compartment where the DB System will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the DB System will be created."`
	// Human-readable name for the DB System shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the DB System shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Availability domain where the DB System will be placed.
	//  Example: "Uocm:PHX-AD-1". Changing this forces recreation.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain where the DB System will be placed. Example: 'Uocm:PHX-AD-1'. Changing this forces recreation."`
	// Compute shape for the DB System nodes. Determines CPU architecture,
	//  core count range, and memory. Examples: "VM.Standard2.4",
	//  "VM.Standard.E4.Flex", "BM.DenseIO2.52".
	Shape string `json:"shape,omitempty" jsonschema:"Compute shape for the DB System nodes. Determines CPU architecture; core count range; and memory. Examples: 'VM.Standard2.4'; 'VM.Standard.E4.Flex'; 'BM.DenseIO2.52'."`
	// OCID of the subnet where the DB System will be placed.
	//  Changing this forces recreation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the DB System will be placed. Changing this forces recreation."`
	// SSH public keys for administrative access to the DB System nodes.
	//  At least one key is required. Keys must be in OpenSSH format.
	SshPublicKeys []string `json:"ssh_public_keys,omitempty" jsonschema:"SSH public keys for administrative access to the DB System nodes. At least one key is required. Keys must be in OpenSSH format."`
	// Hostname for the DB System. Must be unique within the subnet.
	//  Combined with the domain to form the FQDN. Changing this forces recreation.
	Hostname string `json:"hostname,omitempty" jsonschema:"Hostname for the DB System. Must be unique within the subnet. Combined with the domain to form the FQDN. Changing this forces recreation."`
	// Number of CPU cores to enable. For VM shapes, this is the number
	//  of OCPUs. For BM shapes, this is the total core count. When omitted,
	//  the shape's default is used.
	CpuCoreCount int32 `json:"cpu_core_count,omitempty" jsonschema:"Number of CPU cores to enable. For VM shapes; this is the number of OCPUs. For BM shapes; this is the total core count. When omitted; the shape's default is used."`
	// Oracle Database edition. Determines available features and licensing
	//  tiers. Exadata and 2-node RAC require enterprise_edition_extreme_performance.
	//  Changing this forces recreation.
	DatabaseEdition string `json:"database_edition,omitempty" jsonschema:"enum=standard_edition|enterprise_edition|enterprise_edition_high_performance|enterprise_edition_extreme_performance,Oracle Database edition. Determines available features and licensing tiers. Exadata and 2-node RAC require enterprise_edition_extreme_performance. Changing this forces recreation."`
	// License model for the DB System. Determines whether existing Oracle
	//  licenses are applied (BYOL) or new licenses are included in the price.
	LicenseModel string `json:"license_model,omitempty" jsonschema:"enum=bring_your_own_license|license_included,License model for the DB System. Determines whether existing Oracle licenses are applied (BYOL) or new licenses are included in the price."`
	// Initial data storage size in gigabytes. Required for VM DB Systems.
	//  Supported values depend on the shape (typically 256, 512, 1024, 2048,
	//  4096, 6144, 8192, 10240, 12288, 14336, 16384, 20480, 24576, 28672,
	//  32768, 36864, 40960).
	DataStorageSizeInGb int32 `json:"data_storage_size_in_gb,omitempty" jsonschema:"Initial data storage size in gigabytes. Required for VM DB Systems. Supported values depend on the shape (typically 256; 512; 1024; 2048; 4096; 6144; 8192; 10240; 12288; 14336; 16384; 20480; 24576; 28..."`
	// Percentage of total storage allocated to data (as opposed to recovery).
	//  Valid values: 40 or 80. Only applicable for BM DB Systems.
	//  Changing this forces recreation.
	DataStoragePercentage int32 `json:"data_storage_percentage,omitempty" jsonschema:"Percentage of total storage allocated to data (as opposed to recovery). Valid values: 40 or 80. Only applicable for BM DB Systems. Changing this forces recreation."`
	// Disk redundancy level. "normal" provides 2-way mirroring; "high"
	//  provides 3-way mirroring. Only applicable for BM DB Systems.
	//  Changing this forces recreation.
	DiskRedundancy string `json:"disk_redundancy,omitempty" jsonschema:"enum=normal|high,Disk redundancy level. 'normal' provides 2-way mirroring; 'high' provides 3-way mirroring. Only applicable for BM DB Systems. Changing this forces recreation."`
	// Number of DB System nodes. Use 1 for a single-node system or 2 for
	//  a 2-node RAC cluster. Changing this forces recreation.
	NodeCount int32 `json:"node_count,omitempty" jsonschema:"Number of DB System nodes. Use 1 for a single-node system or 2 for a 2-node RAC cluster. Changing this forces recreation."`
	// Network domain name for the DB System. Defaults to the subnet's
	//  domain if not specified. Changing this forces recreation.
	Domain string `json:"domain,omitempty" jsonschema:"Network domain name for the DB System. Defaults to the subnet's domain if not specified. Changing this forces recreation."`
	// Cluster name for the DB System. Used for RAC clusters.
	//  Maximum 11 characters. Changing this forces recreation.
	ClusterName string `json:"cluster_name,omitempty" jsonschema:"Cluster name for the DB System. Used for RAC clusters. Maximum 11 characters. Changing this forces recreation."`
	// Fault domains for distributing DB System nodes. Use for RAC to
	//  place nodes in different fault domains for high availability.
	//  Changing this forces recreation.
	FaultDomains []string `json:"fault_domains,omitempty" jsonschema:"Fault domains for distributing DB System nodes. Use for RAC to place nodes in different fault domains for high availability. Changing this forces recreation."`
	// OCIDs of network security groups to apply to the DB System VNIC.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups to apply to the DB System VNIC."`
	// OCID of the backup subnet for the DB System. Required for RAC
	//  configurations. Changing this forces recreation.
	BackupSubnetId string `json:"backup_subnet_id,omitempty" jsonschema:"OCID of the backup subnet for the DB System. Required for RAC configurations. Changing this forces recreation."`
	// OCIDs of network security groups for the backup VNIC.
	BackupNetworkNsgIds []string `json:"backup_network_nsg_ids,omitempty" jsonschema:"OCIDs of network security groups for the backup VNIC."`
	// OCID of the KMS key for encrypting the DB System's data at rest.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of the KMS key for encrypting the DB System's data at rest."`
	// OCID of the specific KMS key version. When omitted, the current
	//  key version is used.
	KmsKeyVersionId string `json:"kms_key_version_id,omitempty" jsonschema:"OCID of the specific KMS key version. When omitted; the current key version is used."`
	// Time zone for the DB System. Example: "UTC", "US/Pacific".
	//  Changing this forces recreation.
	TimeZone string `json:"time_zone,omitempty" jsonschema:"Time zone for the DB System. Example: 'UTC'; 'US/Pacific'. Changing this forces recreation."`
	// When true, configures a sparse disk group on the BM DB System.
	//  Only applicable for BM shapes. Changing this forces recreation.
	SparseDiskgroup bool `json:"sparse_diskgroup,omitempty" jsonschema:"When true; configures a sparse disk group on the BM DB System. Only applicable for BM shapes. Changing this forces recreation."`
	// Storage volume performance mode. "balanced" is suitable for most
	//  workloads; "high_performance" provides lower latency at higher cost.
	//  Changing this forces recreation.
	StorageVolumePerformanceMode string `json:"storage_volume_performance_mode,omitempty" jsonschema:"enum=balanced|high_performance,Storage volume performance mode. 'balanced' is suitable for most workloads; 'high_performance' provides lower latency at higher cost. Changing this forces recreation."`
	// Specific private IP address for the DB System. When omitted,
	//  OCI auto-assigns an available IP from the subnet.
	//  Changing this forces recreation.
	PrivateIp string `json:"private_ip,omitempty" jsonschema:"Specific private IP address for the DB System. When omitted; OCI auto-assigns an available IP from the subnet. Changing this forces recreation."`
	// Data collection options controlling OCI diagnostic telemetry.
	DataCollectionOptions *DataCollectionOptionsInput `json:"data_collection_options,omitempty" jsonschema:"Data collection options controlling OCI diagnostic telemetry."`
	// DB System options controlling storage management strategy.
	DbSystemOptions *DbSystemOptionsInput `json:"db_system_options,omitempty" jsonschema:"DB System options controlling storage management strategy."`
	// Maintenance window scheduling. When omitted or preference is
	//  no_preference, OCI selects the maintenance window automatically.
	MaintenanceWindowDetails *MaintenanceWindowDetailsInput `json:"maintenance_window_details,omitempty" jsonschema:"Maintenance window scheduling. When omitted or preference is no_preference; OCI selects the maintenance window automatically."`
	// DB Home configuration. Contains the Oracle Database software version
	//  and the initial database to create. Exactly one DB Home is required
	//  at DB System creation time.
	DbHome *DbHomeInput `json:"db_home" jsonschema:"required,DB Home configuration. Contains the Oracle Database software version and the initial database to create. Exactly one DB Home is required at DB System creation time."`
}

func (s *OciDbSystemSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if len(s.SshPublicKeys) < 1 {
		return fmt.Errorf("ssh_public_keys requires at least 1 items, got %d", len(s.SshPublicKeys))
	}
	switch s.DatabaseEdition {
	case "", "standard_edition", "enterprise_edition", "enterprise_edition_high_performance", "enterprise_edition_extreme_performance":
	default:
		return fmt.Errorf("invalid database_edition: %q", s.DatabaseEdition)
	}
	switch s.LicenseModel {
	case "", "bring_your_own_license", "license_included":
	default:
		return fmt.Errorf("invalid license_model: %q", s.LicenseModel)
	}
	switch s.DiskRedundancy {
	case "", "normal", "high":
	default:
		return fmt.Errorf("invalid disk_redundancy: %q", s.DiskRedundancy)
	}
	switch s.StorageVolumePerformanceMode {
	case "", "balanced", "high_performance":
	default:
		return fmt.Errorf("invalid storage_volume_performance_mode: %q", s.StorageVolumePerformanceMode)
	}
	if s.DataCollectionOptions != nil {
		if err := s.DataCollectionOptions.validate(); err != nil {
			return fmt.Errorf("data_collection_options: %w", err)
		}
	}
	if s.DbSystemOptions != nil {
		if err := s.DbSystemOptions.validate(); err != nil {
			return fmt.Errorf("db_system_options: %w", err)
		}
	}
	if s.MaintenanceWindowDetails != nil {
		if err := s.MaintenanceWindowDetails.validate(); err != nil {
			return fmt.Errorf("maintenance_window_details: %w", err)
		}
	}
	if s.DbHome == nil {
		return fmt.Errorf("db_home is required")
	}
	if s.DbHome != nil {
		if err := s.DbHome.validate(); err != nil {
			return fmt.Errorf("db_home: %w", err)
		}
	}
	return nil
}

func (s *OciDbSystemSpecInput) applyDefaults() {
	if s.DataCollectionOptions != nil {
		s.DataCollectionOptions.applyDefaults()
	}
	if s.DbSystemOptions != nil {
		s.DbSystemOptions.applyDefaults()
	}
	if s.MaintenanceWindowDetails != nil {
		s.MaintenanceWindowDetails.applyDefaults()
	}
	if s.DbHome != nil {
		s.DbHome.applyDefaults()
	}
}

func (s *OciDbSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.Shape != "" {
		m["shape"] = s.Shape
	}
	m["subnet_id"] = s.SubnetId
	if len(s.SshPublicKeys) > 0 {
		m["ssh_public_keys"] = s.SshPublicKeys
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	if s.CpuCoreCount != 0 {
		m["cpu_core_count"] = s.CpuCoreCount
	}
	if s.DatabaseEdition != "" {
		m["database_edition"] = s.DatabaseEdition
	}
	if s.LicenseModel != "" {
		m["license_model"] = s.LicenseModel
	}
	if s.DataStorageSizeInGb != 0 {
		m["data_storage_size_in_gb"] = s.DataStorageSizeInGb
	}
	if s.DataStoragePercentage != 0 {
		m["data_storage_percentage"] = s.DataStoragePercentage
	}
	if s.DiskRedundancy != "" {
		m["disk_redundancy"] = s.DiskRedundancy
	}
	if s.NodeCount != 0 {
		m["node_count"] = s.NodeCount
	}
	if s.Domain != "" {
		m["domain"] = s.Domain
	}
	if s.ClusterName != "" {
		m["cluster_name"] = s.ClusterName
	}
	if len(s.FaultDomains) > 0 {
		m["fault_domains"] = s.FaultDomains
	}
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.BackupSubnetId != "" {
		m["backup_subnet_id"] = s.BackupSubnetId
	}
	if len(s.BackupNetworkNsgIds) > 0 {
		m["backup_network_nsg_ids"] = s.BackupNetworkNsgIds
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.KmsKeyVersionId != "" {
		m["kms_key_version_id"] = s.KmsKeyVersionId
	}
	if s.TimeZone != "" {
		m["time_zone"] = s.TimeZone
	}
	if s.SparseDiskgroup {
		m["sparse_diskgroup"] = s.SparseDiskgroup
	}
	if s.StorageVolumePerformanceMode != "" {
		m["storage_volume_performance_mode"] = s.StorageVolumePerformanceMode
	}
	if s.PrivateIp != "" {
		m["private_ip"] = s.PrivateIp
	}
	if s.DataCollectionOptions != nil {
		m["data_collection_options"] = s.DataCollectionOptions.toMap()
	}
	if s.DbSystemOptions != nil {
		m["db_system_options"] = s.DbSystemOptions.toMap()
	}
	if s.MaintenanceWindowDetails != nil {
		m["maintenance_window_details"] = s.MaintenanceWindowDetails.toMap()
	}
	if s.DbHome != nil {
		m["db_home"] = s.DbHome.toMap()
	}
	return m
}

// DataCollectionOptions controls diagnostic data collection for the
//
//	DB System. All fields default to provider behavior when omitted.
type DataCollectionOptionsInput struct {
	// Whether to enable diagnostic event collection.
	IsDiagnosticsEventsEnabled bool `json:"is_diagnostics_events_enabled,omitempty" jsonschema:"Whether to enable diagnostic event collection."`
	// Whether to enable health monitoring.
	IsHealthMonitoringEnabled bool `json:"is_health_monitoring_enabled,omitempty" jsonschema:"Whether to enable health monitoring."`
	// Whether to enable incident log collection.
	IsIncidentLogsEnabled bool `json:"is_incident_logs_enabled,omitempty" jsonschema:"Whether to enable incident log collection."`
}

func (s *DataCollectionOptionsInput) validate() error {
	return nil
}

func (s *DataCollectionOptionsInput) applyDefaults() {
}

func (s *DataCollectionOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsDiagnosticsEventsEnabled {
		m["is_diagnostics_events_enabled"] = s.IsDiagnosticsEventsEnabled
	}
	if s.IsHealthMonitoringEnabled {
		m["is_health_monitoring_enabled"] = s.IsHealthMonitoringEnabled
	}
	if s.IsIncidentLogsEnabled {
		m["is_incident_logs_enabled"] = s.IsIncidentLogsEnabled
	}
	return m
}

// Database represents the Oracle Database instance created within a DB Home.
type DatabaseInput struct {
	// Administrator password for the SYS and SYSTEM users. Must be 2 to 30
	//  characters, contain at least one uppercase, one lowercase, and one
	//  numeric character. Cannot contain the double-quote character.
	//  This value is not returned by the API after creation.
	AdminPassword string `json:"admin_password,omitempty" jsonschema:"Administrator password for the SYS and SYSTEM users. Must be 2 to 30 characters; contain at least one uppercase; one lowercase; and one numeric character. Cannot contain the double-quote character. Th..."`
	// Database name. Must be alphanumeric, begin with a letter, and be
	//  at most 8 characters for single-node or 30 characters otherwise.
	//  Changing this forces recreation.
	DbName string `json:"db_name,omitempty" jsonschema:"Database name. Must be alphanumeric; begin with a letter; and be at most 8 characters for single-node or 30 characters otherwise. Changing this forces recreation."`
	// Character set for the database. Defaults to AL32UTF8 when omitted.
	//  Changing this forces recreation.
	CharacterSet string `json:"character_set,omitempty" jsonschema:"Character set for the database. Defaults to AL32UTF8 when omitted. Changing this forces recreation."`
	// National character set. Defaults to AL16UTF16 when omitted.
	//  Valid values: AL16UTF16, UTF8. Changing this forces recreation.
	NcharacterSet string `json:"ncharacter_set,omitempty" jsonschema:"National character set. Defaults to AL16UTF16 when omitted. Valid values: AL16UTF16; UTF8. Changing this forces recreation."`
	// Pluggable database name. Must begin with a letter and contain only
	//  alphanumeric characters. Changing this forces recreation.
	PdbName string `json:"pdb_name,omitempty" jsonschema:"Pluggable database name. Must begin with a letter and contain only alphanumeric characters. Changing this forces recreation."`
	// Database domain. Defaults to the DB System's domain when omitted.
	//  Changing this forces recreation.
	DbDomain string `json:"db_domain,omitempty" jsonschema:"Database domain. Defaults to the DB System's domain when omitted. Changing this forces recreation."`
	// OCID of the KMS key for Transparent Data Encryption (TDE).
	//  When omitted, Oracle-managed encryption is used.
	//  Changing this forces recreation.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of the KMS key for Transparent Data Encryption (TDE). When omitted; Oracle-managed encryption is used. Changing this forces recreation."`
	// OCID of the specific KMS key version for TDE.
	//  Changing this forces recreation.
	KmsKeyVersionId string `json:"kms_key_version_id,omitempty" jsonschema:"OCID of the specific KMS key version for TDE. Changing this forces recreation."`
	// OCID of the OCI Vault containing the TDE encryption key.
	//  Required when kms_key_id is set. Changing this forces recreation.
	VaultId string `json:"vault_id,omitempty" jsonschema:"OCID of the OCI Vault containing the TDE encryption key. Required when kms_key_id is set. Changing this forces recreation."`
	// Automatic backup configuration for the database.
	DbBackupConfig *DbBackupConfigInput `json:"db_backup_config,omitempty" jsonschema:"Automatic backup configuration for the database."`
}

func (s *DatabaseInput) validate() error {
	if s.DbBackupConfig != nil {
		if err := s.DbBackupConfig.validate(); err != nil {
			return fmt.Errorf("db_backup_config: %w", err)
		}
	}
	return nil
}

func (s *DatabaseInput) applyDefaults() {
	if s.DbBackupConfig != nil {
		s.DbBackupConfig.applyDefaults()
	}
}

func (s *DatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AdminPassword != "" {
		m["admin_password"] = s.AdminPassword
	}
	if s.DbName != "" {
		m["db_name"] = s.DbName
	}
	if s.CharacterSet != "" {
		m["character_set"] = s.CharacterSet
	}
	if s.NcharacterSet != "" {
		m["ncharacter_set"] = s.NcharacterSet
	}
	if s.PdbName != "" {
		m["pdb_name"] = s.PdbName
	}
	if s.DbDomain != "" {
		m["db_domain"] = s.DbDomain
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.KmsKeyVersionId != "" {
		m["kms_key_version_id"] = s.KmsKeyVersionId
	}
	if s.VaultId != "" {
		m["vault_id"] = s.VaultId
	}
	if s.DbBackupConfig != nil {
		m["db_backup_config"] = s.DbBackupConfig.toMap()
	}
	return m
}

// DbBackupConfig configures automatic backups for the database.
type DbBackupConfigInput struct {
	// Whether automatic backups are enabled.
	AutoBackupEnabled bool `json:"auto_backup_enabled,omitempty" jsonschema:"Whether automatic backups are enabled."`
	// Preferred backup window. Values: SLOT_ONE through SLOT_TWELVE
	//  representing 2-hour windows starting from 00:00-02:00 UTC.
	//  Only applied when auto_backup_enabled is true.
	AutoBackupWindow string `json:"auto_backup_window,omitempty" jsonschema:"Preferred backup window. Values: SLOT_ONE through SLOT_TWELVE representing 2-hour windows starting from 00:00-02:00 UTC. Only applied when auto_backup_enabled is true."`
	// Number of days to retain automatic backups (1-60).
	//  Only applied when auto_backup_enabled is true.
	RecoveryWindowInDays int32 `json:"recovery_window_in_days,omitempty" jsonschema:"Number of days to retain automatic backups (1-60). Only applied when auto_backup_enabled is true."`
}

func (s *DbBackupConfigInput) validate() error {
	return nil
}

func (s *DbBackupConfigInput) applyDefaults() {
}

func (s *DbBackupConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AutoBackupEnabled {
		m["auto_backup_enabled"] = s.AutoBackupEnabled
	}
	if s.AutoBackupWindow != "" {
		m["auto_backup_window"] = s.AutoBackupWindow
	}
	if s.RecoveryWindowInDays != 0 {
		m["recovery_window_in_days"] = s.RecoveryWindowInDays
	}
	return m
}

// DbHome represents the Oracle Database Home -- a directory containing
//
//	Oracle Database software of a specific version.
type DbHomeInput struct {
	// Oracle Database version. Example: "19.0.0.0", "21.0.0.0".
	//  Mutually exclusive with database_software_image_id.
	//  Changing this forces recreation.
	DbVersion string `json:"db_version,omitempty" jsonschema:"Oracle Database version. Example: '19.0.0.0'; '21.0.0.0'. Mutually exclusive with database_software_image_id. Changing this forces recreation."`
	// Human-readable name for the DB Home.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the DB Home."`
	// OCID of a custom database software image to use instead of a
	//  standard db_version. Mutually exclusive with db_version.
	//  Changing this forces recreation.
	DatabaseSoftwareImageId string `json:"database_software_image_id,omitempty" jsonschema:"OCID of a custom database software image to use instead of a standard db_version. Mutually exclusive with db_version. Changing this forces recreation."`
	// The initial database to create within this DB Home.
	Database *DatabaseInput `json:"database" jsonschema:"required,The initial database to create within this DB Home."`
}

func (s *DbHomeInput) validate() error {
	if s.Database == nil {
		return fmt.Errorf("database is required")
	}
	if s.Database != nil {
		if err := s.Database.validate(); err != nil {
			return fmt.Errorf("database: %w", err)
		}
	}
	return nil
}

func (s *DbHomeInput) applyDefaults() {
	if s.Database != nil {
		s.Database.applyDefaults()
	}
}

func (s *DbHomeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DbVersion != "" {
		m["db_version"] = s.DbVersion
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.DatabaseSoftwareImageId != "" {
		m["database_software_image_id"] = s.DatabaseSoftwareImageId
	}
	if s.Database != nil {
		m["database"] = s.Database.toMap()
	}
	return m
}

// DbSystemOptions controls storage management for the DB System.
type DbSystemOptionsInput struct {
	// Storage management strategy. ASM (Automatic Storage Management) is
	//  the default for most shapes. LVM (Logical Volume Management) is
	//  available for single-node VM systems only.
	//  Changing this forces recreation.
	StorageManagement string `json:"storage_management,omitempty" jsonschema:"enum=asm|lvm,Storage management strategy. ASM (Automatic Storage Management) is the default for most shapes. LVM (Logical Volume Management) is available for single-node VM systems only. Changing this forces recre..."`
}

func (s *DbSystemOptionsInput) validate() error {
	switch s.StorageManagement {
	case "", "asm", "lvm":
	default:
		return fmt.Errorf("invalid storage_management: %q", s.StorageManagement)
	}
	return nil
}

func (s *DbSystemOptionsInput) applyDefaults() {
}

func (s *DbSystemOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.StorageManagement != "" {
		m["storage_management"] = s.StorageManagement
	}
	return m
}

// MaintenanceWindowDetails configures the patching schedule for the
//
//	DB System. When preference is no_preference, all other fields are
//	ignored and OCI selects the window automatically.
type MaintenanceWindowDetailsInput struct {
	// Maintenance scheduling preference.
	Preference string `json:"preference,omitempty" jsonschema:"enum=no_preference|custom_preference,Maintenance scheduling preference."`
	// Patching strategy. Rolling applies patches one node at a time
	//  (zero downtime for RAC). Nonrolling patches all nodes simultaneously.
	PatchingMode string `json:"patching_mode,omitempty" jsonschema:"enum=rolling|nonrolling,Patching strategy. Rolling applies patches one node at a time (zero downtime for RAC). Nonrolling patches all nodes simultaneously."`
	// Weeks of advance notice before the maintenance window opens.
	LeadTimeInWeeks int32 `json:"lead_time_in_weeks,omitempty" jsonschema:"Weeks of advance notice before the maintenance window opens."`
	// Months when maintenance is allowed. Example: ["JANUARY", "APRIL",
	//  "JULY", "OCTOBER"] for quarterly patching.
	Months []string `json:"months,omitempty" jsonschema:"Months when maintenance is allowed. Example: ['JANUARY'; 'APRIL'; 'JULY'; 'OCTOBER'] for quarterly patching."`
	// Weeks of the month (1-4) when maintenance is allowed.
	WeeksOfMonth []int32 `json:"weeks_of_month,omitempty" jsonschema:"Weeks of the month (1-4) when maintenance is allowed."`
	// Days of the week when maintenance is allowed. Example: ["MONDAY"].
	DaysOfWeek []string `json:"days_of_week,omitempty" jsonschema:"Days of the week when maintenance is allowed. Example: ['MONDAY']."`
	// Hours of the day (0-23) when maintenance may start.
	HoursOfDay []int32 `json:"hours_of_day,omitempty" jsonschema:"Hours of the day (0-23) when maintenance may start."`
	// Custom timeout for patching actions in minutes (0-120).
	CustomActionTimeoutInMins int32 `json:"custom_action_timeout_in_mins,omitempty" jsonschema:"Custom timeout for patching actions in minutes (0-120)."`
	// Whether the custom action timeout is enabled.
	IsCustomActionTimeoutEnabled bool `json:"is_custom_action_timeout_enabled,omitempty" jsonschema:"Whether the custom action timeout is enabled."`
	// Whether monthly patching is enabled.
	IsMonthlyPatchingEnabled bool `json:"is_monthly_patching_enabled,omitempty" jsonschema:"Whether monthly patching is enabled."`
}

func (s *MaintenanceWindowDetailsInput) validate() error {
	switch s.Preference {
	case "", "no_preference", "custom_preference":
	default:
		return fmt.Errorf("invalid preference: %q", s.Preference)
	}
	switch s.PatchingMode {
	case "", "rolling", "nonrolling":
	default:
		return fmt.Errorf("invalid patching_mode: %q", s.PatchingMode)
	}
	return nil
}

func (s *MaintenanceWindowDetailsInput) applyDefaults() {
}

func (s *MaintenanceWindowDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Preference != "" {
		m["preference"] = s.Preference
	}
	if s.PatchingMode != "" {
		m["patching_mode"] = s.PatchingMode
	}
	if s.LeadTimeInWeeks != 0 {
		m["lead_time_in_weeks"] = s.LeadTimeInWeeks
	}
	if len(s.Months) > 0 {
		m["months"] = s.Months
	}
	if len(s.WeeksOfMonth) > 0 {
		m["weeks_of_month"] = s.WeeksOfMonth
	}
	if len(s.DaysOfWeek) > 0 {
		m["days_of_week"] = s.DaysOfWeek
	}
	if len(s.HoursOfDay) > 0 {
		m["hours_of_day"] = s.HoursOfDay
	}
	if s.CustomActionTimeoutInMins != 0 {
		m["custom_action_timeout_in_mins"] = s.CustomActionTimeoutInMins
	}
	if s.IsCustomActionTimeoutEnabled {
		m["is_custom_action_timeout_enabled"] = s.IsCustomActionTimeoutEnabled
	}
	if s.IsMonthlyPatchingEnabled {
		m["is_monthly_patching_enabled"] = s.IsMonthlyPatchingEnabled
	}
	return m
}

// ParseOciDbSystem validates and normalizes a OciDbSystem cloud_object.
func ParseOciDbSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciDbSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciDbSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
