// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciDnsZone is the top-level resource representing an OCI DNS Zone --
//
//	a managed authoritative DNS zone supporting public and private
//	resolution scopes with zone transfer capabilities.
type OciDnsZoneSpecInput struct {
	// OCID of the compartment where this zone will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where this zone will be created."`
	// Zone type: PRIMARY or SECONDARY. Required. ForceNew.
	ZoneType string `json:"zone_type,omitempty" jsonschema:"enum=primary|secondary,Zone type: PRIMARY or SECONDARY. Required. ForceNew."`
	// Resolution scope. When omitted, defaults to GLOBAL (public DNS).
	//  ForceNew.
	Scope string `json:"scope,omitempty" jsonschema:"enum=global|scope_private,Resolution scope. When omitted; defaults to GLOBAL (public DNS). ForceNew."`
	// OCID of the private DNS view. Required when scope is private.
	//  Not applicable for global zones. ForceNew.
	ViewId string `json:"view_id,omitempty" jsonschema:"OCID of the private DNS view. Required when scope is private. Not applicable for global zones. ForceNew."`
	// Enable DNSSEC signing for the zone. When true, OCI generates
	//  KSK and ZSK key pairs and signs zone records. Only meaningful
	//  for GLOBAL zones. Nil/omitted = OCI default (disabled).
	IsDnssecEnabled bool `json:"is_dnssec_enabled,omitempty" jsonschema:"Enable DNSSEC signing for the zone. When true; OCI generates KSK and ZSK key pairs and signs zone records. Only meaningful for GLOBAL zones. Nil/omitted = OCI default (disabled)."`
	// External master DNS servers that this SECONDARY zone replicates
	//  from. Required when zone_type is secondary. Not applicable for
	//  PRIMARY zones (ignored if set).
	ExternalMasters []*ExternalServerInput `json:"external_masters,omitempty" jsonschema:"External master DNS servers that this SECONDARY zone replicates from. Required when zone_type is secondary. Not applicable for PRIMARY zones (ignored if set)."`
	// External downstream DNS servers that receive zone transfers
	//  from this PRIMARY zone. Only supported for PRIMARY zones with
	//  GLOBAL scope.
	ExternalDownstreams []*ExternalServerInput `json:"external_downstreams,omitempty" jsonschema:"External downstream DNS servers that receive zone transfers from this PRIMARY zone. Only supported for PRIMARY zones with GLOBAL scope."`
}

func (s *OciDnsZoneSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	switch s.ZoneType {
	case "", "primary", "secondary":
	default:
		return fmt.Errorf("invalid zone_type: %q", s.ZoneType)
	}
	switch s.Scope {
	case "", "global", "scope_private":
	default:
		return fmt.Errorf("invalid scope: %q", s.Scope)
	}
	for i, v := range s.ExternalMasters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("external_masters[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ExternalDownstreams {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("external_downstreams[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciDnsZoneSpecInput) applyDefaults() {
}

func (s *OciDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.ZoneType != "" {
		m["zone_type"] = s.ZoneType
	}
	if s.Scope != "" {
		m["scope"] = s.Scope
	}
	if s.ViewId != "" {
		m["view_id"] = s.ViewId
	}
	if s.IsDnssecEnabled {
		m["is_dnssec_enabled"] = s.IsDnssecEnabled
	}
	if len(s.ExternalMasters) > 0 {
		items := make([]any, len(s.ExternalMasters))
		for i, v := range s.ExternalMasters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["external_masters"] = items
	}
	if len(s.ExternalDownstreams) > 0 {
		items := make([]any, len(s.ExternalDownstreams))
		for i, v := range s.ExternalDownstreams {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["external_downstreams"] = items
	}
	return m
}

// External DNS server used for zone transfers.
//
//	Used by both external_masters (inbound to SECONDARY zones) and
//	external_downstreams (outbound from PRIMARY zones).
type ExternalServerInput struct {
	// IPv4 or IPv6 address of the external DNS server.
	Address string `json:"address,omitempty" jsonschema:"IPv4 or IPv6 address of the external DNS server."`
	// Port number. Must be 53 or omitted (OCI validates server-side).
	Port int32 `json:"port,omitempty" jsonschema:"Port number. Must be 53 or omitted (OCI validates server-side)."`
	// OCID of the TSIG key for authenticating zone transfers.
	//  TSIG keys are not modeled as OpenMCF components.
	TsigKeyId string `json:"tsig_key_id,omitempty" jsonschema:"OCID of the TSIG key for authenticating zone transfers. TSIG keys are not modeled as OpenMCF components."`
}

func (s *ExternalServerInput) validate() error {
	return nil
}

func (s *ExternalServerInput) applyDefaults() {
}

func (s *ExternalServerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Address != "" {
		m["address"] = s.Address
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.TsigKeyId != "" {
		m["tsig_key_id"] = s.TsigKeyId
	}
	return m
}

// ParseOciDnsZone validates and normalizes a OciDnsZone cloud_object.
func ParseOciDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
