// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciContainerInstance is the top-level resource representing an Oracle
//
//	Cloud Infrastructure Container Instance -- OCI's serverless container
//	service for running containers without managing compute infrastructure.
type OciContainerInstanceSpecInput struct {
	// OCID of the compartment where the container instance will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the container instance will be created."`
	// Availability domain where the container instance runs.
	//  Example: "Uocm:PHX-AD-1".
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain where the container instance runs. Example: 'Uocm:PHX-AD-1'."`
	// Human-readable name for the container instance shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the container instance shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Compute shape for the container instance.
	//  Example: "CI.Standard.E4.Flex", "CI.Standard.E3.Flex".
	Shape string `json:"shape,omitempty" jsonschema:"Compute shape for the container instance. Example: 'CI.Standard.E4.Flex'; 'CI.Standard.E3.Flex'."`
	// CPU and memory allocation for the entire container instance.
	//  Individual containers can set resource limits within this envelope.
	ShapeConfig *ShapeConfigInput `json:"shape_config" jsonschema:"required,CPU and memory allocation for the entire container instance. Individual containers can set resource limits within this envelope."`
	// Containers to run on this instance. At least one container is required.
	//  Multiple containers share the same network namespace and can communicate
	//  over localhost.
	Containers []*ContainerInput `json:"containers,omitempty" jsonschema:"Containers to run on this instance. At least one container is required. Multiple containers share the same network namespace and can communicate over localhost."`
	// Virtual network interface cards providing network connectivity.
	//  At least one VNIC is required. Each VNIC is attached to a subnet.
	Vnics []*VnicInput `json:"vnics,omitempty" jsonschema:"Virtual network interface cards providing network connectivity. At least one VNIC is required. Each VNIC is attached to a subnet."`
	// Restart policy applied to all containers in this instance.
	//  When omitted, defaults to ALWAYS.
	ContainerRestartPolicy string `json:"container_restart_policy,omitempty" jsonschema:"enum=always|never|on_failure,Restart policy applied to all containers in this instance. When omitted; defaults to ALWAYS."`
	// Fault domain within the availability domain.
	//  When omitted, OCI selects a fault domain automatically.
	//  Example: "FAULT-DOMAIN-1".
	FaultDomain string `json:"fault_domain,omitempty" jsonschema:"Fault domain within the availability domain. When omitted; OCI selects a fault domain automatically. Example: 'FAULT-DOMAIN-1'."`
	// Seconds to wait for containers to gracefully terminate before
	//  forcefully stopping them. Applies when the instance is stopped or deleted.
	GracefulShutdownTimeoutInSeconds int64 `json:"graceful_shutdown_timeout_in_seconds,omitempty" jsonschema:"Seconds to wait for containers to gracefully terminate before forcefully stopping them. Applies when the instance is stopped or deleted."`
	// DNS resolver configuration for containers. When omitted, containers
	//  inherit DNS settings from the subnet's DHCP options.
	DnsConfig *DnsConfigInput `json:"dns_config,omitempty" jsonschema:"DNS resolver configuration for containers. When omitted; containers inherit DNS settings from the subnet's DHCP options."`
	// Credentials for pulling container images from private registries.
	ImagePullSecrets []*ImagePullSecretInput `json:"image_pull_secrets,omitempty" jsonschema:"Credentials for pulling container images from private registries."`
	// Volumes accessible to containers via volume mounts. A container
	//  instance supports up to 32 volumes.
	Volumes []*VolumeInput `json:"volumes,omitempty" jsonschema:"Volumes accessible to containers via volume mounts. A container instance supports up to 32 volumes."`
}

func (s *OciContainerInstanceSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.ShapeConfig == nil {
		return fmt.Errorf("shape_config is required")
	}
	if s.ShapeConfig != nil {
		if err := s.ShapeConfig.validate(); err != nil {
			return fmt.Errorf("shape_config: %w", err)
		}
	}
	if len(s.Containers) < 1 {
		return fmt.Errorf("containers requires at least 1 items, got %d", len(s.Containers))
	}
	for i, v := range s.Containers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("containers[%d]: %w", i, err)
			}
		}
	}
	if len(s.Vnics) < 1 {
		return fmt.Errorf("vnics requires at least 1 items, got %d", len(s.Vnics))
	}
	for i, v := range s.Vnics {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("vnics[%d]: %w", i, err)
			}
		}
	}
	switch s.ContainerRestartPolicy {
	case "", "always", "never", "on_failure":
	default:
		return fmt.Errorf("invalid container_restart_policy: %q", s.ContainerRestartPolicy)
	}
	if s.DnsConfig != nil {
		if err := s.DnsConfig.validate(); err != nil {
			return fmt.Errorf("dns_config: %w", err)
		}
	}
	for i, v := range s.ImagePullSecrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("image_pull_secrets[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Volumes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volumes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciContainerInstanceSpecInput) applyDefaults() {
	if s.ShapeConfig != nil {
		s.ShapeConfig.applyDefaults()
	}
	if s.DnsConfig != nil {
		s.DnsConfig.applyDefaults()
	}
}

func (s *OciContainerInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.Shape != "" {
		m["shape"] = s.Shape
	}
	if s.ShapeConfig != nil {
		m["shape_config"] = s.ShapeConfig.toMap()
	}
	if len(s.Containers) > 0 {
		items := make([]any, len(s.Containers))
		for i, v := range s.Containers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["containers"] = items
	}
	if len(s.Vnics) > 0 {
		items := make([]any, len(s.Vnics))
		for i, v := range s.Vnics {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["vnics"] = items
	}
	if s.ContainerRestartPolicy != "" {
		m["container_restart_policy"] = s.ContainerRestartPolicy
	}
	if s.FaultDomain != "" {
		m["fault_domain"] = s.FaultDomain
	}
	if s.GracefulShutdownTimeoutInSeconds != 0 {
		m["graceful_shutdown_timeout_in_seconds"] = s.GracefulShutdownTimeoutInSeconds
	}
	if s.DnsConfig != nil {
		m["dns_config"] = s.DnsConfig.toMap()
	}
	if len(s.ImagePullSecrets) > 0 {
		items := make([]any, len(s.ImagePullSecrets))
		for i, v := range s.ImagePullSecrets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["image_pull_secrets"] = items
	}
	if len(s.Volumes) > 0 {
		items := make([]any, len(s.Volumes))
		for i, v := range s.Volumes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volumes"] = items
	}
	return m
}

// Capabilities controls Linux capability grants and revocations.
type CapabilitiesInput struct {
	// Capabilities to add to the container process.
	//  Example: ["NET_ADMIN", "SYS_TIME"]
	AddCapabilities []string `json:"add_capabilities,omitempty" jsonschema:"Capabilities to add to the container process. Example: ['NET_ADMIN'; 'SYS_TIME']"`
	// Capabilities to drop from the container process.
	//  Example: ["ALL"]
	DropCapabilities []string `json:"drop_capabilities,omitempty" jsonschema:"Capabilities to drop from the container process. Example: ['ALL']"`
}

func (s *CapabilitiesInput) validate() error {
	return nil
}

func (s *CapabilitiesInput) applyDefaults() {
}

func (s *CapabilitiesInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AddCapabilities) > 0 {
		m["add_capabilities"] = s.AddCapabilities
	}
	if len(s.DropCapabilities) > 0 {
		m["drop_capabilities"] = s.DropCapabilities
	}
	return m
}

// Container defines a single container running within the instance.
type ContainerInput struct {
	// Container image URL.
	//  Example: "docker.io/library/nginx:latest", "ghcr.io/org/app:v1.2".
	//  Default registry is docker.io/library if not specified.
	ImageUrl string `json:"image_url,omitempty" jsonschema:"Container image URL. Example: 'docker.io/library/nginx:latest'; 'ghcr.io/org/app:v1.2'. Default registry is docker.io/library if not specified."`
	// Human-readable name for the container.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the container."`
	// Overrides the image's ENTRYPOINT. Each element is a separate argument.
	Command []string `json:"command,omitempty" jsonschema:"Overrides the image's ENTRYPOINT. Each element is a separate argument."`
	// Arguments passed to the ENTRYPOINT process.
	//  Total size of all arguments combined must be <= 64 KB.
	Arguments []string `json:"arguments,omitempty" jsonschema:"Arguments passed to the ENTRYPOINT process. Total size of all arguments combined must be <= 64 KB."`
	// Environment variables injected into the container.
	//  Total size of all names + values combined must be <= 64 KB.
	EnvironmentVariables map[string]string `json:"environment_variables,omitempty" jsonschema:"Environment variables injected into the container. Total size of all names + values combined must be <= 64 KB."`
	// Working directory for the container's entrypoint process.
	WorkingDirectory string `json:"working_directory,omitempty" jsonschema:"Working directory for the container's entrypoint process."`
	// When true, disables OCI resource principal access for this container.
	//  Resource principal (v2.2) is enabled by default.
	IsResourcePrincipalDisabled bool `json:"is_resource_principal_disabled,omitempty" jsonschema:"When true; disables OCI resource principal access for this container. Resource principal (v2.2) is enabled by default."`
	// CPU and memory limits for this container. When omitted, the container
	//  can use all resources available to the instance.
	ResourceConfig *ContainerResourceConfigInput `json:"resource_config,omitempty" jsonschema:"CPU and memory limits for this container. When omitted; the container can use all resources available to the instance."`
	// Health checks for monitoring container readiness. Supports HTTP and
	//  TCP probe types with configurable thresholds and intervals.
	HealthChecks []*HealthCheckInput `json:"health_checks,omitempty" jsonschema:"Health checks for monitoring container readiness. Supports HTTP and TCP probe types with configurable thresholds and intervals."`
	// Linux security settings for the container process.
	SecurityContext *SecurityContextInput `json:"security_context,omitempty" jsonschema:"Linux security settings for the container process."`
	// Volumes to mount into this container's filesystem.
	VolumeMounts []*VolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"Volumes to mount into this container's filesystem."`
}

func (s *ContainerInput) validate() error {
	if s.ResourceConfig != nil {
		if err := s.ResourceConfig.validate(); err != nil {
			return fmt.Errorf("resource_config: %w", err)
		}
	}
	for i, v := range s.HealthChecks {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("health_checks[%d]: %w", i, err)
			}
		}
	}
	if s.SecurityContext != nil {
		if err := s.SecurityContext.validate(); err != nil {
			return fmt.Errorf("security_context: %w", err)
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ContainerInput) applyDefaults() {
	if s.ResourceConfig != nil {
		s.ResourceConfig.applyDefaults()
	}
	if s.SecurityContext != nil {
		s.SecurityContext.applyDefaults()
	}
}

func (s *ContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ImageUrl != "" {
		m["image_url"] = s.ImageUrl
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Arguments) > 0 {
		m["arguments"] = s.Arguments
	}
	if len(s.EnvironmentVariables) > 0 {
		m["environment_variables"] = s.EnvironmentVariables
	}
	if s.WorkingDirectory != "" {
		m["working_directory"] = s.WorkingDirectory
	}
	if s.IsResourcePrincipalDisabled {
		m["is_resource_principal_disabled"] = s.IsResourcePrincipalDisabled
	}
	if s.ResourceConfig != nil {
		m["resource_config"] = s.ResourceConfig.toMap()
	}
	if len(s.HealthChecks) > 0 {
		items := make([]any, len(s.HealthChecks))
		for i, v := range s.HealthChecks {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["health_checks"] = items
	}
	if s.SecurityContext != nil {
		m["security_context"] = s.SecurityContext.toMap()
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	return m
}

// ContainerResourceConfig sets CPU and memory limits for an individual
//
//	container. These limits are within the instance-level ShapeConfig envelope.
type ContainerResourceConfigInput struct {
	// Maximum memory in gigabytes the container can consume.
	//  When omitted, the container can use all available instance memory.
	MemoryLimitInGbs float32 `json:"memory_limit_in_gbs,omitempty" jsonschema:"Maximum memory in gigabytes the container can consume. When omitted; the container can use all available instance memory."`
	// Maximum logical CPUs the container can consume.
	//  1 OCPU = 2 logical CPUs. Values can be fractional (e.g., 0.5).
	//  When omitted, the container can use all available instance CPUs.
	VcpusLimit float32 `json:"vcpus_limit,omitempty" jsonschema:"Maximum logical CPUs the container can consume. 1 OCPU = 2 logical CPUs. Values can be fractional (e.g.; 0.5). When omitted; the container can use all available instance CPUs."`
}

func (s *ContainerResourceConfigInput) validate() error {
	return nil
}

func (s *ContainerResourceConfigInput) applyDefaults() {
}

func (s *ContainerResourceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MemoryLimitInGbs != 0 {
		m["memory_limit_in_gbs"] = s.MemoryLimitInGbs
	}
	if s.VcpusLimit != 0 {
		m["vcpus_limit"] = s.VcpusLimit
	}
	return m
}

// DnsConfig customizes DNS resolution for containers.
type DnsConfigInput struct {
	// IP addresses of DNS name servers (IPv4 or IPv6).
	//  When omitted, uses nameservers from the subnet's DHCP options.
	Nameservers []string `json:"nameservers,omitempty" jsonschema:"IP addresses of DNS name servers (IPv4 or IPv6). When omitted; uses nameservers from the subnet's DHCP options."`
	// Resolver options in resolv.conf format.
	//  Example: ["ndots:5", "edns0"]
	Options []string `json:"options,omitempty" jsonschema:"Resolver options in resolv.conf format. Example: ['ndots:5'; 'edns0']"`
	// Search domains for unqualified hostname lookups.
	//  When omitted, uses searches from the subnet's DHCP options.
	Searches []string `json:"searches,omitempty" jsonschema:"Search domains for unqualified hostname lookups. When omitted; uses searches from the subnet's DHCP options."`
}

func (s *DnsConfigInput) validate() error {
	return nil
}

func (s *DnsConfigInput) applyDefaults() {
}

func (s *DnsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Nameservers) > 0 {
		m["nameservers"] = s.Nameservers
	}
	if len(s.Options) > 0 {
		m["options"] = s.Options
	}
	if len(s.Searches) > 0 {
		m["searches"] = s.Searches
	}
	return m
}

// HealthCheck defines a probe for monitoring container health.
type HealthCheckInput struct {
	// Protocol for the health check.
	HealthCheckType string `json:"health_check_type,omitempty" jsonschema:"enum=http|tcp,Protocol for the health check."`
	// Port to probe.
	Port int32 `json:"port,omitempty" jsonschema:"Port to probe."`
	// Optional name for the health check, unique within the container instance.
	Name string `json:"name,omitempty" jsonschema:"Optional name for the health check; unique within the container instance."`
	// URL path for HTTP health checks. Required when health_check_type is http.
	//  Example: "/healthz".
	Path string `json:"path,omitempty" jsonschema:"URL path for HTTP health checks. Required when health_check_type is http. Example: '/healthz'."`
	// Action to take when the health check fails.
	//  When omitted, defaults to KILL.
	FailureAction string `json:"failure_action,omitempty" jsonschema:"enum=kill|none,Action to take when the health check fails. When omitted; defaults to KILL."`
	// Consecutive failures required to consider the container unhealthy.
	FailureThreshold int32 `json:"failure_threshold,omitempty" jsonschema:"Consecutive failures required to consider the container unhealthy."`
	// Consecutive successes required to consider the container healthy again.
	SuccessThreshold int32 `json:"success_threshold,omitempty" jsonschema:"Consecutive successes required to consider the container healthy again."`
	// Seconds to wait after container start before running the first check.
	InitialDelayInSeconds int32 `json:"initial_delay_in_seconds,omitempty" jsonschema:"Seconds to wait after container start before running the first check."`
	// Seconds between consecutive health checks.
	IntervalInSeconds int32 `json:"interval_in_seconds,omitempty" jsonschema:"Seconds between consecutive health checks."`
	// Seconds to wait for a health check response before considering it failed.
	TimeoutInSeconds int32 `json:"timeout_in_seconds,omitempty" jsonschema:"Seconds to wait for a health check response before considering it failed."`
	// Custom HTTP headers sent with HTTP health checks.
	Headers []*HealthCheckHeaderInput `json:"headers,omitempty" jsonschema:"Custom HTTP headers sent with HTTP health checks."`
}

func (s *HealthCheckInput) validate() error {
	switch s.HealthCheckType {
	case "", "http", "tcp":
	default:
		return fmt.Errorf("invalid health_check_type: %q", s.HealthCheckType)
	}
	switch s.FailureAction {
	case "", "kill", "none":
	default:
		return fmt.Errorf("invalid failure_action: %q", s.FailureAction)
	}
	for i, v := range s.Headers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("headers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *HealthCheckInput) applyDefaults() {
}

func (s *HealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HealthCheckType != "" {
		m["health_check_type"] = s.HealthCheckType
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.FailureAction != "" {
		m["failure_action"] = s.FailureAction
	}
	if s.FailureThreshold != 0 {
		m["failure_threshold"] = s.FailureThreshold
	}
	if s.SuccessThreshold != 0 {
		m["success_threshold"] = s.SuccessThreshold
	}
	if s.InitialDelayInSeconds != 0 {
		m["initial_delay_in_seconds"] = s.InitialDelayInSeconds
	}
	if s.IntervalInSeconds != 0 {
		m["interval_in_seconds"] = s.IntervalInSeconds
	}
	if s.TimeoutInSeconds != 0 {
		m["timeout_in_seconds"] = s.TimeoutInSeconds
	}
	if len(s.Headers) > 0 {
		items := make([]any, len(s.Headers))
		for i, v := range s.Headers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["headers"] = items
	}
	return m
}

// HealthCheckHeader is a key/value HTTP header sent with health check probes.
type HealthCheckHeaderInput struct {
	Name  string `json:"name,omitempty" jsonschema:""`
	Value string `json:"value,omitempty" jsonschema:""`
}

func (s *HealthCheckHeaderInput) validate() error {
	return nil
}

func (s *HealthCheckHeaderInput) applyDefaults() {
}

func (s *HealthCheckHeaderInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// ImagePullSecret provides credentials for pulling container images
//
//	from private registries.
type ImagePullSecretInput struct {
	// Registry endpoint URL.
	//  Example: "ghcr.io", "docker.io", "us-ashburn-1.ocir.io".
	RegistryEndpoint string `json:"registry_endpoint,omitempty" jsonschema:"Registry endpoint URL. Example: 'ghcr.io'; 'docker.io'; 'us-ashburn-1.ocir.io'."`
	// Authentication method for the registry.
	SecretType string `json:"secret_type,omitempty" jsonschema:"enum=basic|vault,Authentication method for the registry."`
	// Username for basic authentication. Required when secret_type is basic.
	//  Must be base64-encoded.
	Username string `json:"username,omitempty" jsonschema:"Username for basic authentication. Required when secret_type is basic. Must be base64-encoded."`
	// Password for basic authentication. Required when secret_type is basic.
	//  Must be base64-encoded.
	Password string `json:"password,omitempty" jsonschema:"Password for basic authentication. Required when secret_type is basic. Must be base64-encoded."`
	// OCID of an OCI Vault secret containing registry credentials.
	//  Required when secret_type is vault.
	SecretId string `json:"secret_id,omitempty" jsonschema:"OCID of an OCI Vault secret containing registry credentials. Required when secret_type is vault."`
}

func (s *ImagePullSecretInput) validate() error {
	switch s.SecretType {
	case "", "basic", "vault":
	default:
		return fmt.Errorf("invalid secret_type: %q", s.SecretType)
	}
	return nil
}

func (s *ImagePullSecretInput) applyDefaults() {
}

func (s *ImagePullSecretInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RegistryEndpoint != "" {
		m["registry_endpoint"] = s.RegistryEndpoint
	}
	if s.SecretType != "" {
		m["secret_type"] = s.SecretType
	}
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	if s.SecretId != "" {
		m["secret_id"] = s.SecretId
	}
	return m
}

// SecurityContext configures Linux security settings for a container.
//
//	The security context type is always LINUX (hardcoded by IaC modules).
type SecurityContextInput struct {
	// When true, validates at runtime that the container does not run as
	//  UID 0. Fails the container start if the image runs as root.
	IsNonRootUserCheckEnabled bool `json:"is_non_root_user_check_enabled,omitempty" jsonschema:"When true; validates at runtime that the container does not run as UID 0. Fails the container start if the image runs as root."`
	// When true, the container's root filesystem is mounted read-only.
	IsRootFileSystemReadonly bool `json:"is_root_file_system_readonly,omitempty" jsonschema:"When true; the container's root filesystem is mounted read-only."`
	// User ID (UID) for the container's entrypoint process.
	//  Defaults to the UID specified in the container image.
	RunAsUser int32 `json:"run_as_user,omitempty" jsonschema:"User ID (UID) for the container's entrypoint process. Defaults to the UID specified in the container image."`
	// Group ID (GID) for the container's entrypoint process.
	//  When specified, run_as_user should also be provided.
	RunAsGroup int32 `json:"run_as_group,omitempty" jsonschema:"Group ID (GID) for the container's entrypoint process. When specified; run_as_user should also be provided."`
	// Linux capabilities to add or drop from the container process.
	Capabilities *CapabilitiesInput `json:"capabilities,omitempty" jsonschema:"Linux capabilities to add or drop from the container process."`
}

func (s *SecurityContextInput) validate() error {
	if s.Capabilities != nil {
		if err := s.Capabilities.validate(); err != nil {
			return fmt.Errorf("capabilities: %w", err)
		}
	}
	return nil
}

func (s *SecurityContextInput) applyDefaults() {
	if s.Capabilities != nil {
		s.Capabilities.applyDefaults()
	}
}

func (s *SecurityContextInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsNonRootUserCheckEnabled {
		m["is_non_root_user_check_enabled"] = s.IsNonRootUserCheckEnabled
	}
	if s.IsRootFileSystemReadonly {
		m["is_root_file_system_readonly"] = s.IsRootFileSystemReadonly
	}
	if s.RunAsUser != 0 {
		m["run_as_user"] = s.RunAsUser
	}
	if s.RunAsGroup != 0 {
		m["run_as_group"] = s.RunAsGroup
	}
	if s.Capabilities != nil {
		m["capabilities"] = s.Capabilities.toMap()
	}
	return m
}

// Vnic defines a virtual network interface card attached to the container
//
//	instance. All containers share the instance's VNICs.
type VnicInput struct {
	// OCID of the subnet in which to create the VNIC.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet in which to create the VNIC."`
	// Human-readable name for the VNIC.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the VNIC."`
	// Hostname label for the VNIC's primary private IP in subnet DNS.
	HostnameLabel string `json:"hostname_label,omitempty" jsonschema:"Hostname label for the VNIC's primary private IP in subnet DNS."`
	// Whether to assign a public IP to the VNIC.
	//  When omitted, uses the subnet's default public IP assignment setting.
	IsPublicIpAssigned bool `json:"is_public_ip_assigned,omitempty" jsonschema:"Whether to assign a public IP to the VNIC. When omitted; uses the subnet's default public IP assignment setting."`
	// OCIDs of network security groups to add this VNIC to.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups to add this VNIC to."`
	// Static private IP address within the subnet's CIDR.
	//  When omitted, OCI assigns one automatically.
	PrivateIp string `json:"private_ip,omitempty" jsonschema:"Static private IP address within the subnet's CIDR. When omitted; OCI assigns one automatically."`
	// When true, disables source/destination checking on the VNIC.
	//  Required for NAT instances or virtual routers.
	SkipSourceDestCheck bool `json:"skip_source_dest_check,omitempty" jsonschema:"When true; disables source/destination checking on the VNIC. Required for NAT instances or virtual routers."`
}

func (s *VnicInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *VnicInput) applyDefaults() {
}

func (s *VnicInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.HostnameLabel != "" {
		m["hostname_label"] = s.HostnameLabel
	}
	if s.IsPublicIpAssigned {
		m["is_public_ip_assigned"] = s.IsPublicIpAssigned
	}
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.PrivateIp != "" {
		m["private_ip"] = s.PrivateIp
	}
	if s.SkipSourceDestCheck {
		m["skip_source_dest_check"] = s.SkipSourceDestCheck
	}
	return m
}

// Volume defines a shared storage volume accessible to containers via
//
//	volume mounts.
type VolumeInput struct {
	// Unique name for this volume within the container instance.
	//  Containers reference this name in their volume_mounts.
	Name string `json:"name,omitempty" jsonschema:"Unique name for this volume within the container instance. Containers reference this name in their volume_mounts."`
	// Storage backing for the volume.
	VolumeType string `json:"volume_type,omitempty" jsonschema:"enum=emptydir|configfile,Storage backing for the volume."`
	// Backing store for emptydir volumes. Options: "EPHEMERAL_STORAGE"
	//  (disk-backed) or "MEMORY" (tmpfs). Only applicable when volume_type
	//  is emptydir.
	BackingStore string `json:"backing_store,omitempty" jsonschema:"Backing store for emptydir volumes. Options: 'EPHEMERAL_STORAGE' (disk-backed) or 'MEMORY' (tmpfs). Only applicable when volume_type is emptydir."`
	// Config file entries for configfile volumes. Each entry becomes a file
	//  in the volume. Only applicable when volume_type is configfile.
	Configs []*VolumeConfigInput `json:"configs,omitempty" jsonschema:"Config file entries for configfile volumes. Each entry becomes a file in the volume. Only applicable when volume_type is configfile."`
}

func (s *VolumeInput) validate() error {
	switch s.VolumeType {
	case "", "emptydir", "configfile":
	default:
		return fmt.Errorf("invalid volume_type: %q", s.VolumeType)
	}
	for i, v := range s.Configs {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("configs[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *VolumeInput) applyDefaults() {
}

func (s *VolumeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.VolumeType != "" {
		m["volume_type"] = s.VolumeType
	}
	if s.BackingStore != "" {
		m["backing_store"] = s.BackingStore
	}
	if len(s.Configs) > 0 {
		items := make([]any, len(s.Configs))
		for i, v := range s.Configs {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["configs"] = items
	}
	return m
}

// VolumeConfig defines a single file within a configfile volume.
type VolumeConfigInput struct {
	// Base64-encoded contents of the file. Decoded to plain text at mount time.
	Data string `json:"data,omitempty" jsonschema:"Base64-encoded contents of the file. Decoded to plain text at mount time."`
	// Name of the file within the volume. Must be unique across the volume.
	FileName string `json:"file_name,omitempty" jsonschema:"Name of the file within the volume. Must be unique across the volume."`
	// Optional relative path within the volume mount directory.
	//  When omitted, the file is placed at the volume mount root.
	Path string `json:"path,omitempty" jsonschema:"Optional relative path within the volume mount directory. When omitted; the file is placed at the volume mount root."`
}

func (s *VolumeConfigInput) validate() error {
	return nil
}

func (s *VolumeConfigInput) applyDefaults() {
}

func (s *VolumeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Data != "" {
		m["data"] = s.Data
	}
	if s.FileName != "" {
		m["file_name"] = s.FileName
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	return m
}

// VolumeMount attaches a named volume to a path in the container's filesystem.
type VolumeMountInput struct {
	// Path inside the container where the volume is mounted.
	//  Example: "/data", "/etc/config".
	MountPath string `json:"mount_path,omitempty" jsonschema:"Path inside the container where the volume is mounted. Example: '/data'; '/etc/config'."`
	// Name of the volume to mount. Must match a volume defined in the
	//  instance-level volumes list.
	VolumeName string `json:"volume_name,omitempty" jsonschema:"Name of the volume to mount. Must match a volume defined in the instance-level volumes list."`
	// When true, the volume is mounted read-only.
	IsReadOnly bool `json:"is_read_only,omitempty" jsonschema:"When true; the volume is mounted read-only."`
	// If the volume has partitions, the partition number to mount.
	Partition int32 `json:"partition,omitempty" jsonschema:"If the volume has partitions; the partition number to mount."`
	// Sub-path within the volume to mount instead of the volume root.
	SubPath string `json:"sub_path,omitempty" jsonschema:"Sub-path within the volume to mount instead of the volume root."`
}

func (s *VolumeMountInput) validate() error {
	return nil
}

func (s *VolumeMountInput) applyDefaults() {
}

func (s *VolumeMountInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MountPath != "" {
		m["mount_path"] = s.MountPath
	}
	if s.VolumeName != "" {
		m["volume_name"] = s.VolumeName
	}
	if s.IsReadOnly {
		m["is_read_only"] = s.IsReadOnly
	}
	if s.Partition != 0 {
		m["partition"] = s.Partition
	}
	if s.SubPath != "" {
		m["sub_path"] = s.SubPath
	}
	return m
}

// ParseOciContainerInstance validates and normalizes a OciContainerInstance cloud_object.
func ParseOciContainerInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciContainerInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciContainerInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
