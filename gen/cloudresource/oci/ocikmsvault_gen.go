// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciKmsVault is the top-level resource representing an OCI KMS Vault
//
//	that provides an HSM-backed container for encryption keys.
type OciKmsVaultSpecInput struct {
	// OCID of the compartment where the vault will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the vault will be created."`
	// Display name for the vault. When omitted, the metadata name is used.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the vault. When omitted; the metadata name is used."`
	// Type of vault to create. Cannot be changed after creation.
	//    - default_vault:  shared HSM partition (lower cost)
	//    - virtual_private: dedicated HSM partition (higher throughput)
	//    - external:        external key manager via IDCS OAuth (BYOK/EKMS)
	VaultType string `json:"vault_type,omitempty" jsonschema:"enum=default_vault|virtual_private|external,Type of vault to create. Cannot be changed after creation. - default_vault: shared HSM partition (lower cost) - virtual_private: dedicated HSM partition (higher throughput) - external: external key ma..."`
	// Configuration for an external key manager. Required when vault_type
	//  is external; must not be set otherwise. All sub-fields within this
	//  message are immutable after creation (ForceNew).
	ExternalKeyManagerMetadata *ExternalKeyManagerMetadataInput `json:"external_key_manager_metadata,omitempty" jsonschema:"Configuration for an external key manager. Required when vault_type is external; must not be set otherwise. All sub-fields within this message are immutable after creation (ForceNew)."`
}

func (s *OciKmsVaultSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	switch s.VaultType {
	case "", "default_vault", "virtual_private", "external":
	default:
		return fmt.Errorf("invalid vault_type: %q", s.VaultType)
	}
	if s.ExternalKeyManagerMetadata != nil {
		if err := s.ExternalKeyManagerMetadata.validate(); err != nil {
			return fmt.Errorf("external_key_manager_metadata: %w", err)
		}
	}
	return nil
}

func (s *OciKmsVaultSpecInput) applyDefaults() {
	if s.ExternalKeyManagerMetadata != nil {
		s.ExternalKeyManagerMetadata.applyDefaults()
	}
}

func (s *OciKmsVaultSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.VaultType != "" {
		m["vault_type"] = s.VaultType
	}
	if s.ExternalKeyManagerMetadata != nil {
		m["external_key_manager_metadata"] = s.ExternalKeyManagerMetadata.toMap()
	}
	return m
}

// ExternalKeyManagerMetadata configures the connection to an external
//
//	key manager for EXTERNAL vault type. All fields are immutable after
//	creation.
type ExternalKeyManagerMetadataInput struct {
	// URI of the vault on the external key manager system.
	ExternalVaultEndpointUrl string `json:"external_vault_endpoint_url,omitempty" jsonschema:"URI of the vault on the external key manager system."`
	// OAuth credentials for authenticating with Oracle IDCS to reach
	//  the external key manager.
	OauthMetadata *OAuthMetadataInput `json:"oauth_metadata" jsonschema:"required,OAuth credentials for authenticating with Oracle IDCS to reach the external key manager."`
	// OCID of the KMS private endpoint used to connect to the external
	//  key manager over a private network path.
	PrivateEndpointId string `json:"private_endpoint_id,omitempty" jsonschema:"OCID of the KMS private endpoint used to connect to the external key manager over a private network path."`
}

func (s *ExternalKeyManagerMetadataInput) validate() error {
	if s.OauthMetadata == nil {
		return fmt.Errorf("oauth_metadata is required")
	}
	if s.OauthMetadata != nil {
		if err := s.OauthMetadata.validate(); err != nil {
			return fmt.Errorf("oauth_metadata: %w", err)
		}
	}
	return nil
}

func (s *ExternalKeyManagerMetadataInput) applyDefaults() {
	if s.OauthMetadata != nil {
		s.OauthMetadata.applyDefaults()
	}
}

func (s *ExternalKeyManagerMetadataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ExternalVaultEndpointUrl != "" {
		m["external_vault_endpoint_url"] = s.ExternalVaultEndpointUrl
	}
	if s.OauthMetadata != nil {
		m["oauth_metadata"] = s.OauthMetadata.toMap()
	}
	if s.PrivateEndpointId != "" {
		m["private_endpoint_id"] = s.PrivateEndpointId
	}
	return m
}

// OAuthMetadata holds the IDCS OAuth credentials for authenticating
//
//	with an external key manager.
type OAuthMetadataInput struct {
	// Application ID of the client app registered in IDCS.
	ClientAppId string `json:"client_app_id,omitempty" jsonschema:"Application ID of the client app registered in IDCS."`
	// Secret of the client app registered in IDCS. This value is
	//  sensitive and will not be returned by the API after creation.
	ClientAppSecret string `json:"client_app_secret,omitempty" jsonschema:"Secret of the client app registered in IDCS. This value is sensitive and will not be returned by the API after creation."`
	// Base URL of the IDCS account (e.g., "https://idcs-xxx.identity.oraclecloud.com").
	IdcsAccountNameUrl string `json:"idcs_account_name_url,omitempty" jsonschema:"Base URL of the IDCS account (e.g.; 'https://idcs-xxx.identity.oraclecloud.com')."`
}

func (s *OAuthMetadataInput) validate() error {
	return nil
}

func (s *OAuthMetadataInput) applyDefaults() {
}

func (s *OAuthMetadataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ClientAppId != "" {
		m["client_app_id"] = s.ClientAppId
	}
	if s.ClientAppSecret != "" {
		m["client_app_secret"] = s.ClientAppSecret
	}
	if s.IdcsAccountNameUrl != "" {
		m["idcs_account_name_url"] = s.IdcsAccountNameUrl
	}
	return m
}

// ParseOciKmsVault validates and normalizes a OciKmsVault cloud_object.
func ParseOciKmsVault(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciKmsVault"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciKmsVaultSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
