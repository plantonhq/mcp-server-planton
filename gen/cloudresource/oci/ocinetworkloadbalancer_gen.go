// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

type OciNetworkLoadBalancerSpecInput struct {
	// OCID of the compartment where the network load balancer will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the network load balancer will be created."`
	// Human-readable name for the network load balancer shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the network load balancer shown in the OCI Console. Falls back to metadata.name if not provided."`
	// OCID of the subnet where the network load balancer will be spawned.
	//  Unlike the L7 load balancer which accepts multiple subnets, the NLB
	//  is deployed into a single subnet. Changing this after creation forces
	//  recreation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the network load balancer will be spawned. Unlike the L7 load balancer which accepts multiple subnets; the NLB is deployed into a single subnet. Changing this after creation f..."`
	// When true, creates a private network load balancer that is not accessible
	//  from the public internet. Private NLBs receive only private IP addresses.
	//  Note: OCI defaults NLBs to private (true). The proto3 default is false,
	//  so explicitly set this to true for private NLBs.
	//  Changing this after creatio...
	IsPrivate bool `json:"is_private,omitempty" jsonschema:"When true; creates a private network load balancer that is not accessible from the public internet. Private NLBs receive only private IP addresses. Note: OCI defaults NLBs to private (true). The proto..."`
	// When true, the NLB preserves the source IP address and destination IP
	//  address in the IP header. This automatically enables skipSourceDestinationCheck
	//  on the NLB's VNIC, allowing packets to reach backends with the original
	//  client IP intact. Essential for firewalls, intrusion detection systems,
	//  an...
	IsPreserveSourceDestination bool `json:"is_preserve_source_destination,omitempty" jsonschema:"When true; the NLB preserves the source IP address and destination IP address in the IP header. This automatically enables skipSourceDestinationCheck on the NLB's VNIC; allowing packets to reach backe..."`
	// When true, enables symmetric hashing for the NLB. This can only be enabled
	//  when the NLB is working in transparent mode with source/destination
	//  preservation enabled. Removes the dependency on backends (like firewalls)
	//  to perform SNAT.
	IsSymmetricHashEnabled bool `json:"is_symmetric_hash_enabled,omitempty" jsonschema:"When true; enables symmetric hashing for the NLB. This can only be enabled when the NLB is working in transparent mode with source/destination preservation enabled. Removes the dependency on backends ..."`
	// OCIDs of network security groups applied to the network load balancer.
	NetworkSecurityGroupIds []string `json:"network_security_group_ids,omitempty" jsonschema:"OCIDs of network security groups applied to the network load balancer."`
	// IP version for the network load balancer. Accepted values:
	//  "IPV4", "IPV6", "IPV4_AND_IPV6".
	//  When omitted, defaults to "IPV4".
	NlbIpVersion string `json:"nlb_ip_version,omitempty" jsonschema:"IP version for the network load balancer. Accepted values: 'IPV4'; 'IPV6'; 'IPV4_AND_IPV6'. When omitted; defaults to 'IPV4'."`
	// Pre-created reserved public IPs to assign to the network load balancer.
	//  When omitted, OCI assigns ephemeral public IPs (for public NLBs).
	ReservedIps []*ReservedIpInput `json:"reserved_ips,omitempty" jsonschema:"Pre-created reserved public IPs to assign to the network load balancer. When omitted; OCI assigns ephemeral public IPs (for public NLBs)."`
	// Backend sets define groups of backend servers with load balancing
	//  policies and health checking. At least one backend set is required.
	//  Each listener routes traffic to exactly one default backend set.
	BackendSets []*BackendSetInput `json:"backend_sets,omitempty" jsonschema:"Backend sets define groups of backend servers with load balancing policies and health checking. At least one backend set is required. Each listener routes traffic to exactly one default backend set."`
	// Listeners define the ports and protocols on which the network load
	//  balancer accepts connections. At least one listener is required.
	Listeners []*ListenerInput `json:"listeners,omitempty" jsonschema:"Listeners define the ports and protocols on which the network load balancer accepts connections. At least one listener is required."`
	// IPv6 address to assign to the network load balancer. Must be part of
	//  one of the prefixes supported by the subnet.
	//  Example: "2607:9b80:9a0a:9a7e:abcd:ef01:2345:6789"
	AssignedIpv6 string `json:"assigned_ipv6,omitempty" jsonschema:"IPv6 address to assign to the network load balancer. Must be part of one of the prefixes supported by the subnet. Example: '2607:9b80:9a0a:9a7e:abcd:ef01:2345:6789'"`
	// Private IPv4 address to assign to the network load balancer. Must be
	//  in the CIDR range of the subnet. Changing this after creation forces
	//  recreation. Example: "10.0.0.1"
	AssignedPrivateIpv4 string `json:"assigned_private_ipv4,omitempty" jsonschema:"Private IPv4 address to assign to the network load balancer. Must be in the CIDR range of the subnet. Changing this after creation forces recreation. Example: '10.0.0.1'"`
	// IPv6 subnet prefix selection. When provided, the NLB IPv6 address is
	//  assigned within this CIDR block.
	SubnetIpv6cidr string `json:"subnet_ipv6cidr,omitempty" jsonschema:"IPv6 subnet prefix selection. When provided; the NLB IPv6 address is assigned within this CIDR block."`
}

func (s *OciNetworkLoadBalancerSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	for i, v := range s.ReservedIps {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("reserved_ips[%d]: %w", i, err)
			}
		}
	}
	if len(s.BackendSets) < 1 {
		return fmt.Errorf("backend_sets requires at least 1 items, got %d", len(s.BackendSets))
	}
	for i, v := range s.BackendSets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backend_sets[%d]: %w", i, err)
			}
		}
	}
	if len(s.Listeners) < 1 {
		return fmt.Errorf("listeners requires at least 1 items, got %d", len(s.Listeners))
	}
	for i, v := range s.Listeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("listeners[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciNetworkLoadBalancerSpecInput) applyDefaults() {
}

func (s *OciNetworkLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	m["subnet_id"] = s.SubnetId
	if s.IsPrivate {
		m["is_private"] = s.IsPrivate
	}
	if s.IsPreserveSourceDestination {
		m["is_preserve_source_destination"] = s.IsPreserveSourceDestination
	}
	if s.IsSymmetricHashEnabled {
		m["is_symmetric_hash_enabled"] = s.IsSymmetricHashEnabled
	}
	if len(s.NetworkSecurityGroupIds) > 0 {
		m["network_security_group_ids"] = s.NetworkSecurityGroupIds
	}
	if s.NlbIpVersion != "" {
		m["nlb_ip_version"] = s.NlbIpVersion
	}
	if len(s.ReservedIps) > 0 {
		items := make([]any, len(s.ReservedIps))
		for i, v := range s.ReservedIps {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["reserved_ips"] = items
	}
	if len(s.BackendSets) > 0 {
		items := make([]any, len(s.BackendSets))
		for i, v := range s.BackendSets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backend_sets"] = items
	}
	if len(s.Listeners) > 0 {
		items := make([]any, len(s.Listeners))
		for i, v := range s.Listeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["listeners"] = items
	}
	if s.AssignedIpv6 != "" {
		m["assigned_ipv6"] = s.AssignedIpv6
	}
	if s.AssignedPrivateIpv4 != "" {
		m["assigned_private_ipv4"] = s.AssignedPrivateIpv4
	}
	if s.SubnetIpv6cidr != "" {
		m["subnet_ipv6cidr"] = s.SubnetIpv6cidr
	}
	return m
}

// DnsHealthCheck configures DNS-based health checking. The NLB sends
//
//	DNS queries to backends and validates the response codes to determine
//	health. Useful for DNS servers and services that expose health via DNS.
type DnsHealthCheckInput struct {
	// Fully qualified domain name to query.
	DomainName string `json:"domain_name,omitempty" jsonschema:"Fully qualified domain name to query."`
	// DNS query class. Accepted values: "IN" (Internet), "CH" (Chaos).
	//  When omitted, defaults to "IN".
	QueryClass string `json:"query_class,omitempty" jsonschema:"DNS query class. Accepted values: 'IN' (Internet); 'CH' (Chaos). When omitted; defaults to 'IN'."`
	// DNS query type. Accepted values: "A", "AAAA", "TXT".
	//  When omitted, defaults to "A".
	QueryType string `json:"query_type,omitempty" jsonschema:"DNS query type. Accepted values: 'A'; 'AAAA'; 'TXT'. When omitted; defaults to 'A'."`
	// Acceptable DNS response codes. The backend is healthy if the
	//  response code matches any value in this list.
	//  Example values: "NOERROR", "NXDOMAIN".
	//  When omitted, defaults to ["NOERROR"].
	Rcodes []string `json:"rcodes,omitempty" jsonschema:"Acceptable DNS response codes. The backend is healthy if the response code matches any value in this list. Example values: 'NOERROR'; 'NXDOMAIN'. When omitted; defaults to ['NOERROR']."`
	// Transport protocol for DNS queries. Accepted values: "UDP", "TCP".
	//  When omitted, defaults to "UDP".
	TransportProtocol string `json:"transport_protocol,omitempty" jsonschema:"Transport protocol for DNS queries. Accepted values: 'UDP'; 'TCP'. When omitted; defaults to 'UDP'."`
}

func (s *DnsHealthCheckInput) validate() error {
	return nil
}

func (s *DnsHealthCheckInput) applyDefaults() {
}

func (s *DnsHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DomainName != "" {
		m["domain_name"] = s.DomainName
	}
	if s.QueryClass != "" {
		m["query_class"] = s.QueryClass
	}
	if s.QueryType != "" {
		m["query_type"] = s.QueryType
	}
	if len(s.Rcodes) > 0 {
		m["rcodes"] = s.Rcodes
	}
	if s.TransportProtocol != "" {
		m["transport_protocol"] = s.TransportProtocol
	}
	return m
}

// ParseOciNetworkLoadBalancer validates and normalizes a OciNetworkLoadBalancer cloud_object.
func ParseOciNetworkLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciNetworkLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciNetworkLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
