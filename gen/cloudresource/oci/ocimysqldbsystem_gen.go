// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciMysqlDbSystem is the top-level resource representing an Oracle Cloud
//
//	Infrastructure MySQL HeatWave Database System -- a fully managed MySQL
//	database service with optional in-memory analytics acceleration.
type OciMysqlDbSystemSpecInput struct {
	// OCID of the compartment where the MySQL DB System will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the MySQL DB System will be created."`
	// Human-readable name shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Availability domain for the primary (read/write) endpoint.
	//  Example: "Uocm:PHX-AD-1". Changing this forces recreation.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain for the primary (read/write) endpoint. Example: 'Uocm:PHX-AD-1'. Changing this forces recreation."`
	// Compute shape for the DB System. Determines CPU, memory, and network
	//  bandwidth. Examples: "MySQL.VM.Standard.E4.1.8GB",
	//  "MySQL.VM.Standard.E4.4.64GB", "MySQL.HeatWave.VM.Standard".
	ShapeName string `json:"shape_name,omitempty" jsonschema:"Compute shape for the DB System. Determines CPU; memory; and network bandwidth. Examples: 'MySQL.VM.Standard.E4.1.8GB'; 'MySQL.VM.Standard.E4.4.64GB'; 'MySQL.HeatWave.VM.Standard'."`
	// OCID of the subnet where the DB System will be placed.
	//  Changing this forces recreation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the DB System will be placed. Changing this forces recreation."`
	// Administrative username for the database. Changing this forces recreation.
	//  When omitted, the provider default applies.
	AdminUsername string `json:"admin_username,omitempty" jsonschema:"Administrative username for the database. Changing this forces recreation. When omitted; the provider default applies."`
	// Administrative password for the database. Must be 8-32 characters and
	//  contain at least one numeric, one lowercase, one uppercase, and one
	//  special character. Changing this forces recreation.
	AdminPassword string `json:"admin_password,omitempty" jsonschema:"Administrative password for the database. Must be 8-32 characters and contain at least one numeric; one lowercase; one uppercase; and one special character. Changing this forces recreation."`
	// MySQL version identifier (e.g. "8.0.36", "9.1.0").
	//  When omitted, the latest available version is used.
	//  Changing this forces recreation.
	MysqlVersion string `json:"mysql_version,omitempty" jsonschema:"MySQL version identifier (e.g. '8.0.36'; '9.1.0'). When omitted; the latest available version is used. Changing this forces recreation."`
	// OCID of a MySQL Configuration to apply to the DB System.
	//  Configurations define MySQL server variable settings (buffer pool size,
	//  max connections, etc.). When omitted, the default configuration for
	//  the selected shape is used.
	ConfigurationId string `json:"configuration_id,omitempty" jsonschema:"OCID of a MySQL Configuration to apply to the DB System. Configurations define MySQL server variable settings (buffer pool size; max connections; etc.). When omitted; the default configuration for the..."`
	// When true, enables High Availability. Three instances are provisioned
	//  across different fault domains with automatic failover. Standby
	//  instances are not directly accessible.
	IsHighlyAvailable bool `json:"is_highly_available,omitempty" jsonschema:"When true; enables High Availability. Three instances are provisioned across different fault domains with automatic failover. Standby instances are not directly accessible."`
	// Hostname for the primary endpoint. Combined with the subnet's DNS
	//  domain to form the FQDN for database access.
	HostnameLabel string `json:"hostname_label,omitempty" jsonschema:"Hostname for the primary endpoint. Combined with the subnet's DNS domain to form the FQDN for database access."`
	// Specific private IP address for the primary endpoint within the
	//  subnet. When omitted, OCI auto-assigns an available IP.
	//  Changing this forces recreation.
	IpAddress string `json:"ip_address,omitempty" jsonschema:"Specific private IP address for the primary endpoint within the subnet. When omitted; OCI auto-assigns an available IP. Changing this forces recreation."`
	// Fault domain for the primary (read/write) endpoint.
	//  Example: "FAULT-DOMAIN-1". Changing this forces recreation.
	FaultDomain string `json:"fault_domain,omitempty" jsonschema:"Fault domain for the primary (read/write) endpoint. Example: 'FAULT-DOMAIN-1'. Changing this forces recreation."`
	// TCP port for the MySQL protocol on the primary endpoint.
	//  Default: 3306. Changing this forces recreation.
	Port int32 `json:"port,omitempty" jsonschema:"TCP port for the MySQL protocol on the primary endpoint. Default: 3306. Changing this forces recreation."`
	// TCP port for the X Protocol (MySQL Shell, connectors) on the
	//  primary endpoint. Default: 33060. Changing this forces recreation.
	PortX int32 `json:"port_x,omitempty" jsonschema:"TCP port for the X Protocol (MySQL Shell; connectors) on the primary endpoint. Default: 33060. Changing this forces recreation."`
	// User-provided description of the DB System.
	Description string `json:"description,omitempty" jsonschema:"User-provided description of the DB System."`
	// Controls InnoDB crash recovery mechanisms (Redo Logs, Double Write
	//  Buffer, Binary Log syncing). Disabling improves write performance
	//  but risks data loss on unexpected failure. Values: "ENABLED",
	//  "DISABLED".
	CrashRecovery string `json:"crash_recovery,omitempty" jsonschema:"Controls InnoDB crash recovery mechanisms (Redo Logs; Double Write Buffer; Binary Log syncing). Disabling improves write performance but risks data loss on unexpected failure. Values: 'ENABLED'; 'DISA..."`
	// Enables monitoring via the OCI Database Management service.
	//  Values: "ENABLED", "DISABLED".
	DatabaseManagement string `json:"database_management,omitempty" jsonschema:"Enables monitoring via the OCI Database Management service. Values: 'ENABLED'; 'DISABLED'."`
	// OCIDs of network security groups for the DB System VNIC.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups for the DB System VNIC."`
	// Data storage configuration. Uses the modern data_storage block
	//  (the legacy top-level data_storage_size_in_gb is deprecated).
	DataStorage *DataStorageInput `json:"data_storage,omitempty" jsonschema:"Data storage configuration. Uses the modern data_storage block (the legacy top-level data_storage_size_in_gb is deprecated)."`
	// Automatic backup configuration.
	BackupPolicy *BackupPolicyInput `json:"backup_policy,omitempty" jsonschema:"Automatic backup configuration."`
	// Maintenance window configuration.
	Maintenance *MaintenanceInput `json:"maintenance,omitempty" jsonschema:"Maintenance window configuration."`
	// Deletion safety configuration.
	DeletionPolicy *DeletionPolicyInput `json:"deletion_policy,omitempty" jsonschema:"Deletion safety configuration."`
	// Data-at-rest encryption configuration.
	EncryptData *EncryptDataInput `json:"encrypt_data,omitempty" jsonschema:"Data-at-rest encryption configuration."`
	// TLS certificate configuration for client connections.
	SecureConnections *SecureConnectionsInput `json:"secure_connections,omitempty" jsonschema:"TLS certificate configuration for client connections."`
	// Customer contact email addresses for operational notifications
	//  (maintenance windows, critical alerts). Maximum 10 contacts.
	CustomerContacts []*CustomerContactInput `json:"customer_contacts,omitempty" jsonschema:"Customer contact email addresses for operational notifications (maintenance windows; critical alerts). Maximum 10 contacts."`
	// Read-only endpoint configuration for read scaling.
	ReadEndpoint *ReadEndpointInput `json:"read_endpoint,omitempty" jsonschema:"Read-only endpoint configuration for read scaling."`
	// MySQL Database Console (web-based management UI) configuration.
	DatabaseConsole *DatabaseConsoleInput `json:"database_console,omitempty" jsonschema:"MySQL Database Console (web-based management UI) configuration."`
	// MySQL REST API service configuration.
	Rest *RestInput `json:"rest,omitempty" jsonschema:"MySQL REST API service configuration."`
}

func (s *OciMysqlDbSystemSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if s.DataStorage != nil {
		if err := s.DataStorage.validate(); err != nil {
			return fmt.Errorf("data_storage: %w", err)
		}
	}
	if s.BackupPolicy != nil {
		if err := s.BackupPolicy.validate(); err != nil {
			return fmt.Errorf("backup_policy: %w", err)
		}
	}
	if s.Maintenance != nil {
		if err := s.Maintenance.validate(); err != nil {
			return fmt.Errorf("maintenance: %w", err)
		}
	}
	if s.DeletionPolicy != nil {
		if err := s.DeletionPolicy.validate(); err != nil {
			return fmt.Errorf("deletion_policy: %w", err)
		}
	}
	if s.EncryptData != nil {
		if err := s.EncryptData.validate(); err != nil {
			return fmt.Errorf("encrypt_data: %w", err)
		}
	}
	if s.SecureConnections != nil {
		if err := s.SecureConnections.validate(); err != nil {
			return fmt.Errorf("secure_connections: %w", err)
		}
	}
	for i, v := range s.CustomerContacts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("customer_contacts[%d]: %w", i, err)
			}
		}
	}
	if s.ReadEndpoint != nil {
		if err := s.ReadEndpoint.validate(); err != nil {
			return fmt.Errorf("read_endpoint: %w", err)
		}
	}
	if s.DatabaseConsole != nil {
		if err := s.DatabaseConsole.validate(); err != nil {
			return fmt.Errorf("database_console: %w", err)
		}
	}
	if s.Rest != nil {
		if err := s.Rest.validate(); err != nil {
			return fmt.Errorf("rest: %w", err)
		}
	}
	return nil
}

func (s *OciMysqlDbSystemSpecInput) applyDefaults() {
	if s.DataStorage != nil {
		s.DataStorage.applyDefaults()
	}
	if s.BackupPolicy != nil {
		s.BackupPolicy.applyDefaults()
	}
	if s.Maintenance != nil {
		s.Maintenance.applyDefaults()
	}
	if s.DeletionPolicy != nil {
		s.DeletionPolicy.applyDefaults()
	}
	if s.EncryptData != nil {
		s.EncryptData.applyDefaults()
	}
	if s.SecureConnections != nil {
		s.SecureConnections.applyDefaults()
	}
	if s.ReadEndpoint != nil {
		s.ReadEndpoint.applyDefaults()
	}
	if s.DatabaseConsole != nil {
		s.DatabaseConsole.applyDefaults()
	}
	if s.Rest != nil {
		s.Rest.applyDefaults()
	}
}

func (s *OciMysqlDbSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.ShapeName != "" {
		m["shape_name"] = s.ShapeName
	}
	m["subnet_id"] = s.SubnetId
	if s.AdminUsername != "" {
		m["admin_username"] = s.AdminUsername
	}
	if s.AdminPassword != "" {
		m["admin_password"] = s.AdminPassword
	}
	if s.MysqlVersion != "" {
		m["mysql_version"] = s.MysqlVersion
	}
	if s.ConfigurationId != "" {
		m["configuration_id"] = s.ConfigurationId
	}
	if s.IsHighlyAvailable {
		m["is_highly_available"] = s.IsHighlyAvailable
	}
	if s.HostnameLabel != "" {
		m["hostname_label"] = s.HostnameLabel
	}
	if s.IpAddress != "" {
		m["ip_address"] = s.IpAddress
	}
	if s.FaultDomain != "" {
		m["fault_domain"] = s.FaultDomain
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.PortX != 0 {
		m["port_x"] = s.PortX
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.CrashRecovery != "" {
		m["crash_recovery"] = s.CrashRecovery
	}
	if s.DatabaseManagement != "" {
		m["database_management"] = s.DatabaseManagement
	}
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.DataStorage != nil {
		m["data_storage"] = s.DataStorage.toMap()
	}
	if s.BackupPolicy != nil {
		m["backup_policy"] = s.BackupPolicy.toMap()
	}
	if s.Maintenance != nil {
		m["maintenance"] = s.Maintenance.toMap()
	}
	if s.DeletionPolicy != nil {
		m["deletion_policy"] = s.DeletionPolicy.toMap()
	}
	if s.EncryptData != nil {
		m["encrypt_data"] = s.EncryptData.toMap()
	}
	if s.SecureConnections != nil {
		m["secure_connections"] = s.SecureConnections.toMap()
	}
	if len(s.CustomerContacts) > 0 {
		items := make([]any, len(s.CustomerContacts))
		for i, v := range s.CustomerContacts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["customer_contacts"] = items
	}
	if s.ReadEndpoint != nil {
		m["read_endpoint"] = s.ReadEndpoint.toMap()
	}
	if s.DatabaseConsole != nil {
		m["database_console"] = s.DatabaseConsole.toMap()
	}
	if s.Rest != nil {
		m["rest"] = s.Rest.toMap()
	}
	return m
}

// DataStorage configures the data volume for the DB System.
type DataStorageInput struct {
	// Initial data volume size in gigabytes. Supported values depend on
	//  the shape (typically 50 GB minimum).
	DataStorageSizeInGb int32 `json:"data_storage_size_in_gb,omitempty" jsonschema:"Initial data volume size in gigabytes. Supported values depend on the shape (typically 50 GB minimum)."`
	// When true, storage automatically expands when usage nears the limit.
	IsAutoExpandStorageEnabled bool `json:"is_auto_expand_storage_enabled,omitempty" jsonschema:"When true; storage automatically expands when usage nears the limit."`
	// Maximum storage size in gigabytes for auto-expansion.
	//  Only effective when is_auto_expand_storage_enabled is true.
	//  Range: 32768-131072 depending on initial size.
	MaxStorageSizeInGbs int32 `json:"max_storage_size_in_gbs,omitempty" jsonschema:"Maximum storage size in gigabytes for auto-expansion. Only effective when is_auto_expand_storage_enabled is true. Range: 32768-131072 depending on initial size."`
}

func (s *DataStorageInput) validate() error {
	return nil
}

func (s *DataStorageInput) applyDefaults() {
}

func (s *DataStorageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DataStorageSizeInGb != 0 {
		m["data_storage_size_in_gb"] = s.DataStorageSizeInGb
	}
	if s.IsAutoExpandStorageEnabled {
		m["is_auto_expand_storage_enabled"] = s.IsAutoExpandStorageEnabled
	}
	if s.MaxStorageSizeInGbs != 0 {
		m["max_storage_size_in_gbs"] = s.MaxStorageSizeInGbs
	}
	return m
}

// DatabaseConsole configures the web-based MySQL management console.
type DatabaseConsoleInput struct {
	// Whether the database console is enabled or disabled.
	Status string `json:"status,omitempty" jsonschema:"enum=enabled|disabled,Whether the database console is enabled or disabled."`
	// Port for the database console. Valid values: 443 or 1024-65535.
	Port int32 `json:"port,omitempty" jsonschema:"Port for the database console. Valid values: 443 or 1024-65535."`
}

func (s *DatabaseConsoleInput) validate() error {
	switch s.Status {
	case "", "enabled", "disabled":
	default:
		return fmt.Errorf("invalid status: %q", s.Status)
	}
	return nil
}

func (s *DatabaseConsoleInput) applyDefaults() {
}

func (s *DatabaseConsoleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Status != "" {
		m["status"] = s.Status
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	return m
}

// DeletionPolicy controls behavior when the DB System is deleted.
type DeletionPolicyInput struct {
	// What to do with automatic backups on deletion.
	//  Values: "DELETE", "RETAIN".
	AutomaticBackupRetention string `json:"automatic_backup_retention,omitempty" jsonschema:"What to do with automatic backups on deletion. Values: 'DELETE'; 'RETAIN'."`
	// Whether to create a final backup before deletion.
	//  Values: "REQUIRE_FINAL_BACKUP", "SKIP_FINAL_BACKUP".
	FinalBackup string `json:"final_backup,omitempty" jsonschema:"Whether to create a final backup before deletion. Values: 'REQUIRE_FINAL_BACKUP'; 'SKIP_FINAL_BACKUP'."`
	// When true, the DB System cannot be deleted. Must be set to false
	//  before deletion is possible.
	IsDeleteProtected bool `json:"is_delete_protected,omitempty" jsonschema:"When true; the DB System cannot be deleted. Must be set to false before deletion is possible."`
}

func (s *DeletionPolicyInput) validate() error {
	return nil
}

func (s *DeletionPolicyInput) applyDefaults() {
}

func (s *DeletionPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AutomaticBackupRetention != "" {
		m["automatic_backup_retention"] = s.AutomaticBackupRetention
	}
	if s.FinalBackup != "" {
		m["final_backup"] = s.FinalBackup
	}
	if s.IsDeleteProtected {
		m["is_delete_protected"] = s.IsDeleteProtected
	}
	return m
}

// EncryptData configures data-at-rest encryption for the DB System.
type EncryptDataInput struct {
	// Key generation strategy. "system" uses Oracle-managed keys.
	//  "byok" (Bring Your Own Key) requires key_id to be set.
	KeyGenerationType string `json:"key_generation_type,omitempty" jsonschema:"enum=system|byok,Key generation strategy. 'system' uses Oracle-managed keys. 'byok' (Bring Your Own Key) requires key_id to be set."`
	// OCID of the customer-managed encryption key. Required when
	//  key_generation_type is byok.
	KeyId string `json:"key_id,omitempty" jsonschema:"OCID of the customer-managed encryption key. Required when key_generation_type is byok."`
}

func (s *EncryptDataInput) validate() error {
	switch s.KeyGenerationType {
	case "", "system", "byok":
	default:
		return fmt.Errorf("invalid key_generation_type: %q", s.KeyGenerationType)
	}
	return nil
}

func (s *EncryptDataInput) applyDefaults() {
}

func (s *EncryptDataInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.KeyGenerationType != "" {
		m["key_generation_type"] = s.KeyGenerationType
	}
	if s.KeyId != "" {
		m["key_id"] = s.KeyId
	}
	return m
}

// Maintenance configures the maintenance window for the DB System.
type MaintenanceInput struct {
	// Start of the maintenance window. Format: "{day-of-week} {time-of-day}"
	//  (e.g. "mon 10:00"). Required when maintenance is configured.
	WindowStartTime string `json:"window_start_time,omitempty" jsonschema:"Start of the maintenance window. Format: '{day-of-week} {time-of-day}' (e.g. 'mon 10:00'). Required when maintenance is configured."`
	// Maintenance schedule type.
	MaintenanceScheduleType string `json:"maintenance_schedule_type,omitempty" jsonschema:"enum=early|regular,Maintenance schedule type."`
	// Version preference for automatic upgrades.
	VersionPreference string `json:"version_preference,omitempty" jsonschema:"enum=oldest|second_newest|newest,Version preference for automatic upgrades."`
	// Version track preference controlling which release stream to follow.
	VersionTrackPreference string `json:"version_track_preference,omitempty" jsonschema:"enum=long_term_support|innovation|follow,Version track preference controlling which release stream to follow."`
}

func (s *MaintenanceInput) validate() error {
	switch s.MaintenanceScheduleType {
	case "", "early", "regular":
	default:
		return fmt.Errorf("invalid maintenance_schedule_type: %q", s.MaintenanceScheduleType)
	}
	switch s.VersionPreference {
	case "", "oldest", "second_newest", "newest":
	default:
		return fmt.Errorf("invalid version_preference: %q", s.VersionPreference)
	}
	switch s.VersionTrackPreference {
	case "", "long_term_support", "innovation", "follow":
	default:
		return fmt.Errorf("invalid version_track_preference: %q", s.VersionTrackPreference)
	}
	return nil
}

func (s *MaintenanceInput) applyDefaults() {
}

func (s *MaintenanceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.WindowStartTime != "" {
		m["window_start_time"] = s.WindowStartTime
	}
	if s.MaintenanceScheduleType != "" {
		m["maintenance_schedule_type"] = s.MaintenanceScheduleType
	}
	if s.VersionPreference != "" {
		m["version_preference"] = s.VersionPreference
	}
	if s.VersionTrackPreference != "" {
		m["version_track_preference"] = s.VersionTrackPreference
	}
	return m
}

// PitrPolicy configures point-in-time recovery for the DB System.
type PitrPolicyInput struct {
	// Whether point-in-time recovery is enabled. Requires automatic
	//  backups to be enabled.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether point-in-time recovery is enabled. Requires automatic backups to be enabled."`
}

func (s *PitrPolicyInput) validate() error {
	return nil
}

func (s *PitrPolicyInput) applyDefaults() {
}

func (s *PitrPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	return m
}

// ReadEndpoint configures the read-only endpoint for read scaling.
//
//	When enabled, a separate DNS endpoint is created that distributes
//	read queries across HA replicas.
type ReadEndpointInput struct {
	// Whether the read endpoint is enabled.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether the read endpoint is enabled."`
	// IP addresses to exclude from serving read requests.
	ExcludeIps []string `json:"exclude_ips,omitempty" jsonschema:"IP addresses to exclude from serving read requests."`
	// Hostname for the read endpoint. Combined with the subnet's DNS
	//  domain to form the read endpoint FQDN.
	ReadEndpointHostnameLabel string `json:"read_endpoint_hostname_label,omitempty" jsonschema:"Hostname for the read endpoint. Combined with the subnet's DNS domain to form the read endpoint FQDN."`
	// Specific private IP address for the read endpoint.
	//  When omitted, OCI auto-assigns an available IP.
	ReadEndpointIpAddress string `json:"read_endpoint_ip_address,omitempty" jsonschema:"Specific private IP address for the read endpoint. When omitted; OCI auto-assigns an available IP."`
}

func (s *ReadEndpointInput) validate() error {
	return nil
}

func (s *ReadEndpointInput) applyDefaults() {
}

func (s *ReadEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if len(s.ExcludeIps) > 0 {
		m["exclude_ips"] = s.ExcludeIps
	}
	if s.ReadEndpointHostnameLabel != "" {
		m["read_endpoint_hostname_label"] = s.ReadEndpointHostnameLabel
	}
	if s.ReadEndpointIpAddress != "" {
		m["read_endpoint_ip_address"] = s.ReadEndpointIpAddress
	}
	return m
}

// Rest configures the MySQL REST API service (MySQL Router REST API).
type RestInput struct {
	// REST API configuration mode.
	Configuration string `json:"configuration,omitempty" jsonschema:"REST API configuration mode."`
	// Port for the REST API service. Valid values: 443 or 1024-65535.
	Port int32 `json:"port,omitempty" jsonschema:"Port for the REST API service. Valid values: 443 or 1024-65535."`
}

func (s *RestInput) validate() error {
	return nil
}

func (s *RestInput) applyDefaults() {
}

func (s *RestInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Configuration != "" {
		m["configuration"] = s.Configuration
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	return m
}

// SecureConnections configures TLS certificates for client connections.
type SecureConnectionsInput struct {
	// Certificate generation strategy. "system" uses Oracle-managed
	//  certificates. "byoc" (Bring Your Own Certificate) requires
	//  certificate_id to be set.
	CertificateGenerationType string `json:"certificate_generation_type,omitempty" jsonschema:"enum=system_cert|byoc,Certificate generation strategy. 'system' uses Oracle-managed certificates. 'byoc' (Bring Your Own Certificate) requires certificate_id to be set."`
	// OCID of the customer-managed certificate. Required when
	//  certificate_generation_type is byoc.
	CertificateId string `json:"certificate_id,omitempty" jsonschema:"OCID of the customer-managed certificate. Required when certificate_generation_type is byoc."`
}

func (s *SecureConnectionsInput) validate() error {
	switch s.CertificateGenerationType {
	case "", "system_cert", "byoc":
	default:
		return fmt.Errorf("invalid certificate_generation_type: %q", s.CertificateGenerationType)
	}
	return nil
}

func (s *SecureConnectionsInput) applyDefaults() {
}

func (s *SecureConnectionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CertificateGenerationType != "" {
		m["certificate_generation_type"] = s.CertificateGenerationType
	}
	if s.CertificateId != "" {
		m["certificate_id"] = s.CertificateId
	}
	return m
}

// ParseOciMysqlDbSystem validates and normalizes a OciMysqlDbSystem cloud_object.
func ParseOciMysqlDbSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciMysqlDbSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciMysqlDbSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
