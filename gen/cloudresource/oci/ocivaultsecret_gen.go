// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciVaultSecret is the Kubernetes Resource Model (KRM) envelope for
//
//	deploying a secret into an OCI KMS Vault.
type OciVaultSecretSpecInput struct {
	// OCID of the compartment where the secret will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the secret will be created."`
	// User-friendly name for the secret. Must be unique within the vault.
	//  Immutable after creation.
	SecretName string `json:"secret_name,omitempty" jsonschema:"User-friendly name for the secret. Must be unique within the vault. Immutable after creation."`
	// OCID of the vault that will contain this secret.
	//  Immutable after creation.
	VaultId string `json:"vault_id" jsonschema:"required,OCID of the vault that will contain this secret. Immutable after creation."`
	// OCID of the master encryption key used to encrypt this secret.
	//  Must be a symmetric key within the specified vault.
	//  Immutable after creation.
	KeyId string `json:"key_id" jsonschema:"required,OCID of the master encryption key used to encrypt this secret. Must be a symmetric key within the specified vault. Immutable after creation."`
	// Brief description of the secret.
	Description string `json:"description,omitempty" jsonschema:"Brief description of the secret."`
	// Explicit secret content (base64-encoded). Mutually exclusive with
	//  auto-generation (enable_auto_generation + secret_generation_context).
	//  Updating this field creates a new secret version.
	SecretContent *SecretContentInput `json:"secret_content,omitempty" jsonschema:"Explicit secret content (base64-encoded). Mutually exclusive with auto-generation (enable_auto_generation + secret_generation_context). Updating this field creates a new secret version."`
	// Enable automatic secret content generation. When true,
	//  secret_generation_context must be provided and secret_content
	//  must not be set.
	EnableAutoGeneration bool `json:"enable_auto_generation,omitempty" jsonschema:"Enable automatic secret content generation. When true; secret_generation_context must be provided and secret_content must not be set."`
	// Configuration for automatic secret content generation.
	//  Required when enable_auto_generation is true; must not be set otherwise.
	SecretGenerationContext *SecretGenerationContextInput `json:"secret_generation_context,omitempty" jsonschema:"Configuration for automatic secret content generation. Required when enable_auto_generation is true; must not be set otherwise."`
	// Lifecycle rules controlling secret expiry and content reuse.
	SecretRules []*SecretRuleInput `json:"secret_rules,omitempty" jsonschema:"Lifecycle rules controlling secret expiry and content reuse."`
	// Configuration for scheduled secret rotation against a target system.
	RotationConfig *RotationConfigInput `json:"rotation_config,omitempty" jsonschema:"Configuration for scheduled secret rotation against a target system."`
	// Additional metadata key-value pairs for administrative context
	//  (e.g., rotation notes, target system hints). Named secret_metadata
	//  to distinguish from OpenMCF's CloudResourceMetadata.
	SecretMetadata map[string]string `json:"secret_metadata,omitempty" jsonschema:"Additional metadata key-value pairs for administrative context (e.g.; rotation notes; target system hints). Named secret_metadata to distinguish from OpenMCF's CloudResourceMetadata."`
}

func (s *OciVaultSecretSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.VaultId == "" {
		return fmt.Errorf("vault_id is required")
	}
	if s.KeyId == "" {
		return fmt.Errorf("key_id is required")
	}
	if s.SecretContent != nil {
		if err := s.SecretContent.validate(); err != nil {
			return fmt.Errorf("secret_content: %w", err)
		}
	}
	if s.SecretGenerationContext != nil {
		if err := s.SecretGenerationContext.validate(); err != nil {
			return fmt.Errorf("secret_generation_context: %w", err)
		}
	}
	for i, v := range s.SecretRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secret_rules[%d]: %w", i, err)
			}
		}
	}
	if s.RotationConfig != nil {
		if err := s.RotationConfig.validate(); err != nil {
			return fmt.Errorf("rotation_config: %w", err)
		}
	}
	return nil
}

func (s *OciVaultSecretSpecInput) applyDefaults() {
	if s.SecretContent != nil {
		s.SecretContent.applyDefaults()
	}
	if s.SecretGenerationContext != nil {
		s.SecretGenerationContext.applyDefaults()
	}
	if s.RotationConfig != nil {
		s.RotationConfig.applyDefaults()
	}
}

func (s *OciVaultSecretSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.SecretName != "" {
		m["secret_name"] = s.SecretName
	}
	m["vault_id"] = s.VaultId
	m["key_id"] = s.KeyId
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.SecretContent != nil {
		m["secret_content"] = s.SecretContent.toMap()
	}
	if s.EnableAutoGeneration {
		m["enable_auto_generation"] = s.EnableAutoGeneration
	}
	if s.SecretGenerationContext != nil {
		m["secret_generation_context"] = s.SecretGenerationContext.toMap()
	}
	if len(s.SecretRules) > 0 {
		items := make([]any, len(s.SecretRules))
		for i, v := range s.SecretRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["secret_rules"] = items
	}
	if s.RotationConfig != nil {
		m["rotation_config"] = s.RotationConfig.toMap()
	}
	if len(s.SecretMetadata) > 0 {
		m["secret_metadata"] = s.SecretMetadata
	}
	return m
}

// RotationConfig configures scheduled rotation of secret content
//
//	against a target system (Autonomous Database or OCI Functions).
type RotationConfigInput struct {
	// Enable scheduled automatic rotation.
	IsScheduledRotationEnabled bool `json:"is_scheduled_rotation_enabled,omitempty" jsonschema:"Enable scheduled automatic rotation."`
	// Rotation interval in ISO 8601 duration format (e.g., "P30D").
	//  Range: 1-360 days. Required when is_scheduled_rotation_enabled
	//  is true.
	RotationInterval string `json:"rotation_interval,omitempty" jsonschema:"Rotation interval in ISO 8601 duration format (e.g.; 'P30D'). Range: 1-360 days. Required when is_scheduled_rotation_enabled is true."`
	// Target system that will be updated during rotation.
	TargetSystemDetails *TargetSystemDetailsInput `json:"target_system_details" jsonschema:"required,Target system that will be updated during rotation."`
}

func (s *RotationConfigInput) validate() error {
	if s.TargetSystemDetails == nil {
		return fmt.Errorf("target_system_details is required")
	}
	if s.TargetSystemDetails != nil {
		if err := s.TargetSystemDetails.validate(); err != nil {
			return fmt.Errorf("target_system_details: %w", err)
		}
	}
	return nil
}

func (s *RotationConfigInput) applyDefaults() {
	if s.TargetSystemDetails != nil {
		s.TargetSystemDetails.applyDefaults()
	}
}

func (s *RotationConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsScheduledRotationEnabled {
		m["is_scheduled_rotation_enabled"] = s.IsScheduledRotationEnabled
	}
	if s.RotationInterval != "" {
		m["rotation_interval"] = s.RotationInterval
	}
	if s.TargetSystemDetails != nil {
		m["target_system_details"] = s.TargetSystemDetails.toMap()
	}
	return m
}

// SecretContent holds explicit secret data provided by the user.
//
//	content_type is hardcoded to BASE64 in IaC modules (only valid
//	value today) and not exposed in the spec.
type SecretContentInput struct {
	// Base64-encoded secret data.
	Content string `json:"content,omitempty" jsonschema:"Base64-encoded secret data."`
	// Optional version name. Must be unique across versions of this secret.
	Name string `json:"name,omitempty" jsonschema:"Optional version name. Must be unique across versions of this secret."`
	// Rotation state of this content version.
	//  Valid values: "CURRENT" (default when omitted), "PENDING".
	Stage string `json:"stage,omitempty" jsonschema:"Rotation state of this content version. Valid values: 'CURRENT' (default when omitted); 'PENDING'."`
}

func (s *SecretContentInput) validate() error {
	return nil
}

func (s *SecretContentInput) applyDefaults() {
}

func (s *SecretContentInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Content != "" {
		m["content"] = s.Content
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Stage != "" {
		m["stage"] = s.Stage
	}
	return m
}

// SecretGenerationContext configures OCI's automatic secret content
//
//	generation. Used when enable_auto_generation is true.
type SecretGenerationContextInput struct {
	// Type of secret content to generate.
	GenerationType string `json:"generation_type,omitempty" jsonschema:"enum=bytes|passphrase|ssh_key,Type of secret content to generate."`
	// Name of the generation template. Template names are provider-defined
	//  and vary by generation_type.
	GenerationTemplate string `json:"generation_template,omitempty" jsonschema:"Name of the generation template. Template names are provider-defined and vary by generation_type."`
	// Length of the passphrase to generate. Required when generation_type
	//  is passphrase.
	PassphraseLength int32 `json:"passphrase_length,omitempty" jsonschema:"Length of the passphrase to generate. Required when generation_type is passphrase."`
	// Optional template structure for storing the generated secret.
	//  Supports predefined placeholders for the generated values.
	SecretTemplate string `json:"secret_template,omitempty" jsonschema:"Optional template structure for storing the generated secret. Supports predefined placeholders for the generated values."`
}

func (s *SecretGenerationContextInput) validate() error {
	switch s.GenerationType {
	case "", "bytes", "passphrase", "ssh_key":
	default:
		return fmt.Errorf("invalid generation_type: %q", s.GenerationType)
	}
	return nil
}

func (s *SecretGenerationContextInput) applyDefaults() {
}

func (s *SecretGenerationContextInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.GenerationType != "" {
		m["generation_type"] = s.GenerationType
	}
	if s.GenerationTemplate != "" {
		m["generation_template"] = s.GenerationTemplate
	}
	if s.PassphraseLength != 0 {
		m["passphrase_length"] = s.PassphraseLength
	}
	if s.SecretTemplate != "" {
		m["secret_template"] = s.SecretTemplate
	}
	return m
}

// SecretRule defines a lifecycle policy for secret versions.
//
//	Uses a flat discriminated model: rule_type selects which fields apply.
type SecretRuleInput struct {
	// Discriminator selecting the rule type.
	RuleType string `json:"rule_type,omitempty" jsonschema:"enum=secret_expiry_rule|secret_reuse_rule,Discriminator selecting the rule type."`
	// Block retrieval of secret content after the version expires.
	//  Applies when rule_type is secret_expiry_rule.
	IsSecretContentRetrievalBlockedOnExpiry bool `json:"is_secret_content_retrieval_blocked_on_expiry,omitempty" jsonschema:"Block retrieval of secret content after the version expires. Applies when rule_type is secret_expiry_rule."`
	// Duration after which each secret version expires, in ISO 8601
	//  format (e.g., "P30D" for 30 days). Range: 1-90 days.
	//  Applies when rule_type is secret_expiry_rule.
	SecretVersionExpiryInterval string `json:"secret_version_expiry_interval,omitempty" jsonschema:"Duration after which each secret version expires; in ISO 8601 format (e.g.; 'P30D' for 30 days). Range: 1-90 days. Applies when rule_type is secret_expiry_rule."`
	// Absolute expiry timestamp in RFC 3339 format. Range: 1-365 days
	//  from creation. Applies when rule_type is secret_expiry_rule.
	TimeOfAbsoluteExpiry string `json:"time_of_absolute_expiry,omitempty" jsonschema:"Absolute expiry timestamp in RFC 3339 format. Range: 1-365 days from creation. Applies when rule_type is secret_expiry_rule."`
	// Enforce the reuse rule even on deleted secret versions.
	//  Applies when rule_type is secret_reuse_rule.
	IsEnforcedOnDeletedSecretVersions bool `json:"is_enforced_on_deleted_secret_versions,omitempty" jsonschema:"Enforce the reuse rule even on deleted secret versions. Applies when rule_type is secret_reuse_rule."`
}

func (s *SecretRuleInput) validate() error {
	switch s.RuleType {
	case "", "secret_expiry_rule", "secret_reuse_rule":
	default:
		return fmt.Errorf("invalid rule_type: %q", s.RuleType)
	}
	return nil
}

func (s *SecretRuleInput) applyDefaults() {
}

func (s *SecretRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RuleType != "" {
		m["rule_type"] = s.RuleType
	}
	if s.IsSecretContentRetrievalBlockedOnExpiry {
		m["is_secret_content_retrieval_blocked_on_expiry"] = s.IsSecretContentRetrievalBlockedOnExpiry
	}
	if s.SecretVersionExpiryInterval != "" {
		m["secret_version_expiry_interval"] = s.SecretVersionExpiryInterval
	}
	if s.TimeOfAbsoluteExpiry != "" {
		m["time_of_absolute_expiry"] = s.TimeOfAbsoluteExpiry
	}
	if s.IsEnforcedOnDeletedSecretVersions {
		m["is_enforced_on_deleted_secret_versions"] = s.IsEnforcedOnDeletedSecretVersions
	}
	return m
}

// TargetSystemDetails identifies the system whose credentials
//
//	are rotated. Uses a discriminated model: target_system_type
//	selects which ID field is required.
type TargetSystemDetailsInput struct {
	// Type of target system.
	TargetSystemType string `json:"target_system_type,omitempty" jsonschema:"enum=adb|function,Type of target system."`
	// OCID of the Autonomous Database whose credentials are rotated.
	//  Required when target_system_type is adb.
	AdbId string `json:"adb_id,omitempty" jsonschema:"OCID of the Autonomous Database whose credentials are rotated. Required when target_system_type is adb."`
	// OCID of the OCI Functions function invoked during rotation.
	//  Required when target_system_type is function.
	FunctionId string `json:"function_id,omitempty" jsonschema:"OCID of the OCI Functions function invoked during rotation. Required when target_system_type is function."`
}

func (s *TargetSystemDetailsInput) validate() error {
	switch s.TargetSystemType {
	case "", "adb", "function":
	default:
		return fmt.Errorf("invalid target_system_type: %q", s.TargetSystemType)
	}
	return nil
}

func (s *TargetSystemDetailsInput) applyDefaults() {
}

func (s *TargetSystemDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetSystemType != "" {
		m["target_system_type"] = s.TargetSystemType
	}
	if s.AdbId != "" {
		m["adb_id"] = s.AdbId
	}
	if s.FunctionId != "" {
		m["function_id"] = s.FunctionId
	}
	return m
}

// ParseOciVaultSecret validates and normalizes a OciVaultSecret cloud_object.
func ParseOciVaultSecret(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciVaultSecret"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciVaultSecretSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
