// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciComputeInstance is the top-level resource representing an Oracle Cloud
//
//	Infrastructure compute instance (virtual machine or bare metal host).
type OciComputeInstanceSpecInput struct {
	// OCID of the compartment where the instance will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the instance will be created."`
	// Availability domain where the instance will be placed
	//  (e.g. "Ixxj:US-ASHBURN-AD-1"). Changing this forces recreation.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain where the instance will be placed (e.g. 'Ixxj:US-ASHBURN-AD-1'). Changing this forces recreation."`
	// Compute shape that determines the base hardware profile
	//  (e.g. "VM.Standard.E4.Flex", "VM.Standard.A1.Flex", "BM.Standard3.64").
	//  Flex shapes require shape_config to specify OCPUs and memory.
	Shape string `json:"shape,omitempty" jsonschema:"Compute shape that determines the base hardware profile (e.g. 'VM.Standard.E4.Flex'; 'VM.Standard.A1.Flex'; 'BM.Standard3.64'). Flex shapes require shape_config to specify OCPUs and memory."`
	// Human-readable name shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Shape configuration for flexible shapes. Required when the chosen shape
	//  name contains "Flex". Ignored for fixed shapes.
	ShapeConfig *ShapeConfigInput `json:"shape_config,omitempty" jsonschema:"Shape configuration for flexible shapes. Required when the chosen shape name contains 'Flex'. Ignored for fixed shapes."`
	// Boot source for the instance: either an image OCID or a boot volume OCID.
	SourceDetails *SourceDetailsInput `json:"source_details" jsonschema:"required,Boot source for the instance: either an image OCID or a boot volume OCID."`
	// Primary VNIC configuration that determines the instance's network placement.
	CreateVnicDetails *CreateVnicDetailsInput `json:"create_vnic_details" jsonschema:"required,Primary VNIC configuration that determines the instance's network placement."`
	// Instance metadata key-value pairs. Common keys:
	//    - "ssh_authorized_keys": newline-separated public SSH keys
	//    - "user_data": base64-encoded cloud-init script
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"Instance metadata key-value pairs. Common keys: - 'ssh_authorized_keys': newline-separated public SSH keys - 'user_data': base64-encoded cloud-init script"`
	// Fault domain within the availability domain (e.g. "FAULT-DOMAIN-1").
	//  OCI distributes instances across fault domains for HA when unspecified.
	FaultDomain string `json:"fault_domain,omitempty" jsonschema:"Fault domain within the availability domain (e.g. 'FAULT-DOMAIN-1'). OCI distributes instances across fault domains for HA when unspecified."`
	// When true, enables in-transit encryption for the paravirtualized boot
	//  and data volume attachments. Changing this forces recreation.
	IsPvEncryptionInTransitEnabled bool `json:"is_pv_encryption_in_transit_enabled,omitempty" jsonschema:"When true; enables in-transit encryption for the paravirtualized boot and data volume attachments. Changing this forces recreation."`
	// Oracle Cloud Agent configuration controlling monitoring, management,
	//  and plugin behavior on the instance.
	AgentConfig *AgentConfigInput `json:"agent_config,omitempty" jsonschema:"Oracle Cloud Agent configuration controlling monitoring; management; and plugin behavior on the instance."`
	// Availability and recovery behavior for infrastructure maintenance events.
	AvailabilityConfig *AvailabilityConfigInput `json:"availability_config,omitempty" jsonschema:"Availability and recovery behavior for infrastructure maintenance events."`
	// Low-level launch options for boot volume type, network type, and firmware.
	//  Most users can omit this; the defaults chosen by OCI based on the image
	//  and shape are appropriate for the vast majority of workloads.
	LaunchOptions *LaunchOptionsInput `json:"launch_options,omitempty" jsonschema:"Low-level launch options for boot volume type; network type; and firmware. Most users can omit this; the defaults chosen by OCI based on the image and shape are appropriate for the vast majority of wo..."`
	// Instance Metadata Service (IMDS) endpoint configuration.
	InstanceOptions *InstanceOptionsInput `json:"instance_options,omitempty" jsonschema:"Instance Metadata Service (IMDS) endpoint configuration."`
	// Configures the instance as preemptible (spot-like), allowing OCI to
	//  reclaim it when capacity is needed. Significantly reduces cost for
	//  fault-tolerant workloads.
	PreemptibleInstanceConfig *PreemptibleInstanceConfigInput `json:"preemptible_instance_config,omitempty" jsonschema:"Configures the instance as preemptible (spot-like); allowing OCI to reclaim it when capacity is needed. Significantly reduces cost for fault-tolerant workloads."`
	// OCID of a capacity reservation to launch this instance against.
	CapacityReservationId string `json:"capacity_reservation_id,omitempty" jsonschema:"OCID of a capacity reservation to launch this instance against."`
	// OCID of a dedicated VM host to place this instance on.
	//  Used for workloads requiring physical isolation for compliance or licensing.
	DedicatedVmHostId string `json:"dedicated_vm_host_id,omitempty" jsonschema:"OCID of a dedicated VM host to place this instance on. Used for workloads requiring physical isolation for compliance or licensing."`
	// Platform-level security and hardware configuration. The applicable fields
	//  depend on the platform type: VM shapes (amd_vm, intel_vm) support secure
	//  boot, measured boot, TPM, and memory encryption; bare metal shapes support
	//  additional hardware tuning (NUMA, core percentage, SMT, etc.).
	PlatformConfig *PlatformConfigInput `json:"platform_config,omitempty" jsonschema:"Platform-level security and hardware configuration. The applicable fields depend on the platform type: VM shapes (amd_vm; intel_vm) support secure boot; measured boot; TPM; and memory encryption; bare..."`
}

func (s *OciComputeInstanceSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.ShapeConfig != nil {
		if err := s.ShapeConfig.validate(); err != nil {
			return fmt.Errorf("shape_config: %w", err)
		}
	}
	if s.SourceDetails == nil {
		return fmt.Errorf("source_details is required")
	}
	if s.SourceDetails != nil {
		if err := s.SourceDetails.validate(); err != nil {
			return fmt.Errorf("source_details: %w", err)
		}
	}
	if s.CreateVnicDetails == nil {
		return fmt.Errorf("create_vnic_details is required")
	}
	if s.CreateVnicDetails != nil {
		if err := s.CreateVnicDetails.validate(); err != nil {
			return fmt.Errorf("create_vnic_details: %w", err)
		}
	}
	if s.AgentConfig != nil {
		if err := s.AgentConfig.validate(); err != nil {
			return fmt.Errorf("agent_config: %w", err)
		}
	}
	if s.AvailabilityConfig != nil {
		if err := s.AvailabilityConfig.validate(); err != nil {
			return fmt.Errorf("availability_config: %w", err)
		}
	}
	if s.LaunchOptions != nil {
		if err := s.LaunchOptions.validate(); err != nil {
			return fmt.Errorf("launch_options: %w", err)
		}
	}
	if s.InstanceOptions != nil {
		if err := s.InstanceOptions.validate(); err != nil {
			return fmt.Errorf("instance_options: %w", err)
		}
	}
	if s.PreemptibleInstanceConfig != nil {
		if err := s.PreemptibleInstanceConfig.validate(); err != nil {
			return fmt.Errorf("preemptible_instance_config: %w", err)
		}
	}
	if s.PlatformConfig != nil {
		if err := s.PlatformConfig.validate(); err != nil {
			return fmt.Errorf("platform_config: %w", err)
		}
	}
	return nil
}

func (s *OciComputeInstanceSpecInput) applyDefaults() {
	if s.ShapeConfig != nil {
		s.ShapeConfig.applyDefaults()
	}
	if s.SourceDetails != nil {
		s.SourceDetails.applyDefaults()
	}
	if s.CreateVnicDetails != nil {
		s.CreateVnicDetails.applyDefaults()
	}
	if s.AgentConfig != nil {
		s.AgentConfig.applyDefaults()
	}
	if s.AvailabilityConfig != nil {
		s.AvailabilityConfig.applyDefaults()
	}
	if s.LaunchOptions != nil {
		s.LaunchOptions.applyDefaults()
	}
	if s.InstanceOptions != nil {
		s.InstanceOptions.applyDefaults()
	}
	if s.PreemptibleInstanceConfig != nil {
		s.PreemptibleInstanceConfig.applyDefaults()
	}
	if s.PlatformConfig != nil {
		s.PlatformConfig.applyDefaults()
	}
}

func (s *OciComputeInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.Shape != "" {
		m["shape"] = s.Shape
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.ShapeConfig != nil {
		m["shape_config"] = s.ShapeConfig.toMap()
	}
	if s.SourceDetails != nil {
		m["source_details"] = s.SourceDetails.toMap()
	}
	if s.CreateVnicDetails != nil {
		m["create_vnic_details"] = s.CreateVnicDetails.toMap()
	}
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if s.FaultDomain != "" {
		m["fault_domain"] = s.FaultDomain
	}
	if s.IsPvEncryptionInTransitEnabled {
		m["is_pv_encryption_in_transit_enabled"] = s.IsPvEncryptionInTransitEnabled
	}
	if s.AgentConfig != nil {
		m["agent_config"] = s.AgentConfig.toMap()
	}
	if s.AvailabilityConfig != nil {
		m["availability_config"] = s.AvailabilityConfig.toMap()
	}
	if s.LaunchOptions != nil {
		m["launch_options"] = s.LaunchOptions.toMap()
	}
	if s.InstanceOptions != nil {
		m["instance_options"] = s.InstanceOptions.toMap()
	}
	if s.PreemptibleInstanceConfig != nil {
		m["preemptible_instance_config"] = s.PreemptibleInstanceConfig.toMap()
	}
	if s.CapacityReservationId != "" {
		m["capacity_reservation_id"] = s.CapacityReservationId
	}
	if s.DedicatedVmHostId != "" {
		m["dedicated_vm_host_id"] = s.DedicatedVmHostId
	}
	if s.PlatformConfig != nil {
		m["platform_config"] = s.PlatformConfig.toMap()
	}
	return m
}

// AgentConfig controls the Oracle Cloud Agent software that runs inside the
//
//	instance for monitoring, management, and OS patching.
type AgentConfigInput struct {
	// When true, disables all Oracle Cloud Agent plugins.
	AreAllPluginsDisabled bool `json:"are_all_plugins_disabled,omitempty" jsonschema:"When true; disables all Oracle Cloud Agent plugins."`
	// When true, disables the management agent (OS Management, etc.).
	IsManagementDisabled bool `json:"is_management_disabled,omitempty" jsonschema:"When true; disables the management agent (OS Management; etc.)."`
	// When true, disables the monitoring agent (Compute Instance Monitoring).
	IsMonitoringDisabled bool `json:"is_monitoring_disabled,omitempty" jsonschema:"When true; disables the monitoring agent (Compute Instance Monitoring)."`
	// Per-plugin overrides.
	PluginsConfig []*PluginConfigInput `json:"plugins_config,omitempty" jsonschema:"Per-plugin overrides."`
}

func (s *AgentConfigInput) validate() error {
	for i, v := range s.PluginsConfig {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("plugins_config[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AgentConfigInput) applyDefaults() {
}

func (s *AgentConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AreAllPluginsDisabled {
		m["are_all_plugins_disabled"] = s.AreAllPluginsDisabled
	}
	if s.IsManagementDisabled {
		m["is_management_disabled"] = s.IsManagementDisabled
	}
	if s.IsMonitoringDisabled {
		m["is_monitoring_disabled"] = s.IsMonitoringDisabled
	}
	if len(s.PluginsConfig) > 0 {
		items := make([]any, len(s.PluginsConfig))
		for i, v := range s.PluginsConfig {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["plugins_config"] = items
	}
	return m
}

// AvailabilityConfig controls how the instance behaves during infrastructure
//
//	maintenance events.
type AvailabilityConfigInput struct {
	// When true, OCI prefers live migration over reboot during maintenance.
	IsLiveMigrationPreferred bool `json:"is_live_migration_preferred,omitempty" jsonschema:"When true; OCI prefers live migration over reboot during maintenance."`
	// Action to take when the underlying host has an unplanned failure.
	RecoveryAction string `json:"recovery_action,omitempty" jsonschema:"enum=restore_instance|stop_instance,Action to take when the underlying host has an unplanned failure."`
}

func (s *AvailabilityConfigInput) validate() error {
	switch s.RecoveryAction {
	case "", "restore_instance", "stop_instance":
	default:
		return fmt.Errorf("invalid recovery_action: %q", s.RecoveryAction)
	}
	return nil
}

func (s *AvailabilityConfigInput) applyDefaults() {
}

func (s *AvailabilityConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsLiveMigrationPreferred {
		m["is_live_migration_preferred"] = s.IsLiveMigrationPreferred
	}
	if s.RecoveryAction != "" {
		m["recovery_action"] = s.RecoveryAction
	}
	return m
}

// CreateVnicDetails configures the primary virtual network interface card
//
//	(VNIC) attached to the instance. This determines the subnet, security
//	groups, IP addressing, and DNS registration.
type CreateVnicDetailsInput struct {
	// OCID of the subnet for the primary VNIC.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet for the primary VNIC."`
	// OCIDs of network security groups to associate with the VNIC.
	NsgIds []string `json:"nsg_ids,omitempty" jsonschema:"OCIDs of network security groups to associate with the VNIC."`
	// Whether to assign a public IP. When unset, uses the subnet default
	//  (public subnets assign; private subnets do not).
	AssignPublicIp bool `json:"assign_public_ip,omitempty" jsonschema:"Whether to assign a public IP. When unset; uses the subnet default (public subnets assign; private subnets do not)."`
	// Display name for the VNIC in the OCI Console.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the VNIC in the OCI Console."`
	// Hostname label for DNS within the subnet's DNS domain.
	//  Must be alphanumeric, start with a letter, max 63 chars.
	HostnameLabel string `json:"hostname_label,omitempty" jsonschema:"Hostname label for DNS within the subnet's DNS domain. Must be alphanumeric; start with a letter; max 63 chars."`
	// Specific private IP address to assign. Must be available within the
	//  subnet's CIDR. When omitted, OCI auto-assigns.
	PrivateIp string `json:"private_ip,omitempty" jsonschema:"Specific private IP address to assign. Must be available within the subnet's CIDR. When omitted; OCI auto-assigns."`
	// When true, disables source/destination checking on the VNIC.
	//  Required for NAT instances or virtual routers.
	SkipSourceDestCheck bool `json:"skip_source_dest_check,omitempty" jsonschema:"When true; disables source/destination checking on the VNIC. Required for NAT instances or virtual routers."`
	// Whether to register a private DNS record for the VNIC.
	AssignPrivateDnsRecord bool `json:"assign_private_dns_record,omitempty" jsonschema:"Whether to register a private DNS record for the VNIC."`
}

func (s *CreateVnicDetailsInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *CreateVnicDetailsInput) applyDefaults() {
}

func (s *CreateVnicDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	if len(s.NsgIds) > 0 {
		m["nsg_ids"] = s.NsgIds
	}
	if s.AssignPublicIp {
		m["assign_public_ip"] = s.AssignPublicIp
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.HostnameLabel != "" {
		m["hostname_label"] = s.HostnameLabel
	}
	if s.PrivateIp != "" {
		m["private_ip"] = s.PrivateIp
	}
	if s.SkipSourceDestCheck {
		m["skip_source_dest_check"] = s.SkipSourceDestCheck
	}
	if s.AssignPrivateDnsRecord {
		m["assign_private_dns_record"] = s.AssignPrivateDnsRecord
	}
	return m
}

// InstanceOptions controls the Instance Metadata Service (IMDS) endpoint
//
//	behavior.
type InstanceOptionsInput struct {
	// When true, disables the legacy IMDSv1 endpoints. Recommended for
	//  security: use only the IMDSv2 token-based endpoint.
	AreLegacyImdsEndpointsDisabled bool `json:"are_legacy_imds_endpoints_disabled,omitempty" jsonschema:"When true; disables the legacy IMDSv1 endpoints. Recommended for security: use only the IMDSv2 token-based endpoint."`
}

func (s *InstanceOptionsInput) validate() error {
	return nil
}

func (s *InstanceOptionsInput) applyDefaults() {
}

func (s *InstanceOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AreLegacyImdsEndpointsDisabled {
		m["are_legacy_imds_endpoints_disabled"] = s.AreLegacyImdsEndpointsDisabled
	}
	return m
}

// LaunchOptions configure low-level boot and network settings. These are
//
//	usually set automatically based on the image and shape; only override
//	when you have specific requirements (e.g., paravirtualized networking
//	for higher throughput).
//
//	boot_volume_type and network_type use strings instead of enums because
//	both sets share values ("VFIO", "PARAVIRTUALIZED") and protobuf's C++
//	scoping rules prevent duplicate enum values in the same enclosing message.
type LaunchOptionsInput struct {
	// Emulation type for the boot volume attachment.
	//  Valid values: "ISCSI", "SCSI", "IDE", "VFIO", "PARAVIRTUALIZED".
	BootVolumeType string `json:"boot_volume_type,omitempty" jsonschema:"Emulation type for the boot volume attachment. Valid values: 'ISCSI'; 'SCSI'; 'IDE'; 'VFIO'; 'PARAVIRTUALIZED'."`
	// Emulation type for the primary network interface.
	//  Valid values: "E1000", "VFIO", "PARAVIRTUALIZED".
	NetworkType string `json:"network_type,omitempty" jsonschema:"Emulation type for the primary network interface. Valid values: 'E1000'; 'VFIO'; 'PARAVIRTUALIZED'."`
	// Firmware type for the instance.
	Firmware string `json:"firmware,omitempty" jsonschema:"enum=bios|uefi_64,Firmware type for the instance."`
	// In-transit encryption for the boot volume attachment (within launch options).
	IsPvEncryptionInTransitEnabled bool `json:"is_pv_encryption_in_transit_enabled,omitempty" jsonschema:"In-transit encryption for the boot volume attachment (within launch options)."`
	// Consistent naming for attached volumes (e.g. /dev/oracleoci/...).
	IsConsistentVolumeNamingEnabled bool `json:"is_consistent_volume_naming_enabled,omitempty" jsonschema:"Consistent naming for attached volumes (e.g. /dev/oracleoci/...)."`
}

func (s *LaunchOptionsInput) validate() error {
	switch s.Firmware {
	case "", "bios", "uefi_64":
	default:
		return fmt.Errorf("invalid firmware: %q", s.Firmware)
	}
	return nil
}

func (s *LaunchOptionsInput) applyDefaults() {
}

func (s *LaunchOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.BootVolumeType != "" {
		m["boot_volume_type"] = s.BootVolumeType
	}
	if s.NetworkType != "" {
		m["network_type"] = s.NetworkType
	}
	if s.Firmware != "" {
		m["firmware"] = s.Firmware
	}
	if s.IsPvEncryptionInTransitEnabled {
		m["is_pv_encryption_in_transit_enabled"] = s.IsPvEncryptionInTransitEnabled
	}
	if s.IsConsistentVolumeNamingEnabled {
		m["is_consistent_volume_naming_enabled"] = s.IsConsistentVolumeNamingEnabled
	}
	return m
}

// PlatformConfig provides hardware-level security and performance settings.
//
//	The available settings vary by shape family:
//	  - VM shapes (amd_vm, intel_vm): secure boot, measured boot, TPM, memory encryption
//	  - Bare metal shapes: all VM options plus NUMA, core percentage, SMT, etc.
//	Fields that don't apply to the chosen type are ignored by the OCI API.
type PlatformConfigInput struct {
	// Platform type. Must match the instance shape family.
	Type string `json:"type,omitempty" jsonschema:"enum=amd_milan_bm|amd_milan_bm_gpu|amd_rome_bm|amd_rome_bm_gpu|amd_vm|generic_bm|intel_icelake_bm|intel_skylake_bm|intel_vm,Platform type. Must match the instance shape family."`
	// Enable Secure Boot to verify boot software signatures (VM + BM).
	IsSecureBootEnabled bool `json:"is_secure_boot_enabled,omitempty" jsonschema:"Enable Secure Boot to verify boot software signatures (VM + BM)."`
	// Enable Measured Boot for integrity measurements stored in the TPM (VM + BM).
	IsMeasuredBootEnabled bool `json:"is_measured_boot_enabled,omitempty" jsonschema:"Enable Measured Boot for integrity measurements stored in the TPM (VM + BM)."`
	// Enable the Trusted Platform Module for secure key storage (VM + BM).
	IsTrustedPlatformModuleEnabled bool `json:"is_trusted_platform_module_enabled,omitempty" jsonschema:"Enable the Trusted Platform Module for secure key storage (VM + BM)."`
	// Enable AMD SEV or Intel TME memory encryption (VM + BM).
	IsMemoryEncryptionEnabled bool `json:"is_memory_encryption_enabled,omitempty" jsonschema:"Enable AMD SEV or Intel TME memory encryption (VM + BM)."`
	// Enable Symmetric Multi-Threading (SMT/Hyperthreading). BM shapes only.
	IsSymmetricMultiThreadingEnabled bool `json:"is_symmetric_multi_threading_enabled,omitempty" jsonschema:"Enable Symmetric Multi-Threading (SMT/Hyperthreading). BM shapes only."`
	// Enable nested virtualization (AMD-V or VT-x). BM shapes only.
	AreVirtualInstructionsEnabled bool `json:"are_virtual_instructions_enabled,omitempty" jsonschema:"Enable nested virtualization (AMD-V or VT-x). BM shapes only."`
	// Enable Access Control Service for PCI passthrough isolation. BM shapes only.
	IsAccessControlServiceEnabled bool `json:"is_access_control_service_enabled,omitempty" jsonschema:"Enable Access Control Service for PCI passthrough isolation. BM shapes only."`
	// Enable IOMMU for device memory protection. BM shapes only.
	IsInputOutputMemoryManagementUnitEnabled bool `json:"is_input_output_memory_management_unit_enabled,omitempty" jsonschema:"Enable IOMMU for device memory protection. BM shapes only."`
	// NUMA nodes per socket configuration. BM shapes only.
	//  Valid values: "NPS0", "NPS1", "NPS2", "NPS4".
	NumaNodesPerSocket string `json:"numa_nodes_per_socket,omitempty" jsonschema:"NUMA nodes per socket configuration. BM shapes only. Valid values: 'NPS0'; 'NPS1'; 'NPS2'; 'NPS4'."`
	// Percentage of cores enabled on the instance. BM shapes only.
	PercentageOfCoresEnabled int32 `json:"percentage_of_cores_enabled,omitempty" jsonschema:"Percentage of cores enabled on the instance. BM shapes only."`
}

func (s *PlatformConfigInput) validate() error {
	switch s.Type {
	case "", "amd_milan_bm", "amd_milan_bm_gpu", "amd_rome_bm", "amd_rome_bm_gpu", "amd_vm", "generic_bm", "intel_icelake_bm", "intel_skylake_bm", "intel_vm":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *PlatformConfigInput) applyDefaults() {
}

func (s *PlatformConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.IsSecureBootEnabled {
		m["is_secure_boot_enabled"] = s.IsSecureBootEnabled
	}
	if s.IsMeasuredBootEnabled {
		m["is_measured_boot_enabled"] = s.IsMeasuredBootEnabled
	}
	if s.IsTrustedPlatformModuleEnabled {
		m["is_trusted_platform_module_enabled"] = s.IsTrustedPlatformModuleEnabled
	}
	if s.IsMemoryEncryptionEnabled {
		m["is_memory_encryption_enabled"] = s.IsMemoryEncryptionEnabled
	}
	if s.IsSymmetricMultiThreadingEnabled {
		m["is_symmetric_multi_threading_enabled"] = s.IsSymmetricMultiThreadingEnabled
	}
	if s.AreVirtualInstructionsEnabled {
		m["are_virtual_instructions_enabled"] = s.AreVirtualInstructionsEnabled
	}
	if s.IsAccessControlServiceEnabled {
		m["is_access_control_service_enabled"] = s.IsAccessControlServiceEnabled
	}
	if s.IsInputOutputMemoryManagementUnitEnabled {
		m["is_input_output_memory_management_unit_enabled"] = s.IsInputOutputMemoryManagementUnitEnabled
	}
	if s.NumaNodesPerSocket != "" {
		m["numa_nodes_per_socket"] = s.NumaNodesPerSocket
	}
	if s.PercentageOfCoresEnabled != 0 {
		m["percentage_of_cores_enabled"] = s.PercentageOfCoresEnabled
	}
	return m
}

type PluginConfigInput struct {
	// Plugin name (e.g. "Vulnerability Scanning", "OS Management Service Agent").
	Name string `json:"name,omitempty" jsonschema:"Plugin name (e.g. 'Vulnerability Scanning'; 'OS Management Service Agent')."`
	// Whether the plugin should be enabled or disabled.
	DesiredState string `json:"desired_state,omitempty" jsonschema:"enum=enabled|disabled,Whether the plugin should be enabled or disabled."`
}

func (s *PluginConfigInput) validate() error {
	switch s.DesiredState {
	case "", "enabled", "disabled":
	default:
		return fmt.Errorf("invalid desired_state: %q", s.DesiredState)
	}
	return nil
}

func (s *PluginConfigInput) applyDefaults() {
}

func (s *PluginConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.DesiredState != "" {
		m["desired_state"] = s.DesiredState
	}
	return m
}

// PreemptibleInstanceConfig configures the instance as preemptible.
//
//	Preemptible instances can be reclaimed by OCI at any time when capacity
//	is needed, in exchange for significantly lower pricing.
type PreemptibleInstanceConfigInput struct {
	// When true, the boot volume is preserved when the instance is preempted.
	//  When false, both instance and boot volume are terminated.
	PreserveBootVolume bool `json:"preserve_boot_volume,omitempty" jsonschema:"When true; the boot volume is preserved when the instance is preempted. When false; both instance and boot volume are terminated."`
}

func (s *PreemptibleInstanceConfigInput) validate() error {
	return nil
}

func (s *PreemptibleInstanceConfigInput) applyDefaults() {
}

func (s *PreemptibleInstanceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.PreserveBootVolume {
		m["preserve_boot_volume"] = s.PreserveBootVolume
	}
	return m
}

// SourceDetails defines the boot source -- either a platform/custom image
//
//	or an existing boot volume to clone.
type SourceDetailsInput struct {
	// Whether the instance boots from an image or an existing boot volume.
	SourceType string `json:"source_type,omitempty" jsonschema:"enum=image|boot_volume,Whether the instance boots from an image or an existing boot volume."`
	// OCID of the image or boot volume to launch from.
	SourceId string `json:"source_id,omitempty" jsonschema:"OCID of the image or boot volume to launch from."`
	// Size of the boot volume in GiB. When launching from an image, defaults
	//  to the image's minimum size. Must be >= the image minimum.
	BootVolumeSizeInGbs int64 `json:"boot_volume_size_in_gbs,omitempty" jsonschema:"Size of the boot volume in GiB. When launching from an image; defaults to the image's minimum size. Must be >= the image minimum."`
	// VPUs per GB for the boot volume (10=Balanced, 20=Higher Performance,
	//  30-120=Ultra High Performance). Defaults to 10.
	BootVolumeVpusPerGb int64 `json:"boot_volume_vpus_per_gb,omitempty" jsonschema:"VPUs per GB for the boot volume (10=Balanced; 20=Higher Performance; 30-120=Ultra High Performance). Defaults to 10."`
	// OCID of a KMS key to encrypt the boot volume at rest.
	//  default_kind will be added when OciKmsKey (R25) is implemented.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of a KMS key to encrypt the boot volume at rest. default_kind will be added when OciKmsKey (R25) is implemented."`
}

func (s *SourceDetailsInput) validate() error {
	switch s.SourceType {
	case "", "image", "boot_volume":
	default:
		return fmt.Errorf("invalid source_type: %q", s.SourceType)
	}
	return nil
}

func (s *SourceDetailsInput) applyDefaults() {
}

func (s *SourceDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SourceType != "" {
		m["source_type"] = s.SourceType
	}
	if s.SourceId != "" {
		m["source_id"] = s.SourceId
	}
	if s.BootVolumeSizeInGbs != 0 {
		m["boot_volume_size_in_gbs"] = s.BootVolumeSizeInGbs
	}
	if s.BootVolumeVpusPerGb != 0 {
		m["boot_volume_vpus_per_gb"] = s.BootVolumeVpusPerGb
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	return m
}

// ParseOciComputeInstance validates and normalizes a OciComputeInstance cloud_object.
func ParseOciComputeInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciComputeInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciComputeInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
