// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciObjectStorageBucket is the top-level resource representing an OCI
//
//	Object Storage bucket with optional retention rules, lifecycle policies,
//	and cross-region replication.
type OciObjectStorageBucketSpecInput struct {
	// OCID of the compartment where the bucket will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the bucket will be created."`
	// Object Storage namespace for the tenancy. This is a unique identifier
	//  assigned to each tenancy (e.g. "axe1234abc"). Retrieve it via
	//  `oci os ns get` or from the OCI Console.
	Namespace string `json:"namespace,omitempty" jsonschema:"Object Storage namespace for the tenancy. This is a unique identifier assigned to each tenancy (e.g. 'axe1234abc'). Retrieve it via 'oci os ns get' or from the OCI Console."`
	// Bucket name. Must be unique within the namespace. Valid characters:
	//  uppercase/lowercase letters, numbers, hyphens, underscores, periods.
	//  Changing this forces recreation.
	Name string `json:"name,omitempty" jsonschema:"Bucket name. Must be unique within the namespace. Valid characters: uppercase/lowercase letters; numbers; hyphens; underscores; periods. Changing this forces recreation."`
	// Type of public access enabled on the bucket.
	//  When unspecified, defaults to no_public_access.
	AccessType string `json:"access_type,omitempty" jsonschema:"enum=no_public_access|object_read|object_read_without_list,Type of public access enabled on the bucket. When unspecified; defaults to no_public_access."`
	// Storage tier for the bucket. Immutable after creation.
	//  When unspecified, defaults to standard.
	StorageTier string `json:"storage_tier,omitempty" jsonschema:"enum=standard|archive,Storage tier for the bucket. Immutable after creation. When unspecified; defaults to standard."`
	// Versioning status. Objects in a version-enabled bucket are protected
	//  from overwrites and deletions by maintaining version history.
	//  On create: enabled or disabled. On update: enabled or suspended.
	Versioning string `json:"versioning,omitempty" jsonschema:"enum=enabled|disabled|suspended,Versioning status. Objects in a version-enabled bucket are protected from overwrites and deletions by maintaining version history. On create: enabled or disabled. On update: enabled or suspended."`
	// Auto-tiering automatically transitions objects between Standard
	//  and InfrequentAccess tiers based on access patterns.
	AutoTiering string `json:"auto_tiering,omitempty" jsonschema:"enum=auto_tiering_disabled|infrequent_access,Auto-tiering automatically transitions objects between Standard and InfrequentAccess tiers based on access patterns."`
	// When true, events are emitted for object state changes in this bucket
	//  via the OCI Events service.
	ObjectEventsEnabled bool `json:"object_events_enabled,omitempty" jsonschema:"When true; events are emitted for object state changes in this bucket via the OCI Events service."`
	// OCID of a KMS master encryption key for server-side encryption.
	//  When unset, Oracle-managed keys are used.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"OCID of a KMS master encryption key for server-side encryption. When unset; Oracle-managed keys are used."`
	// User-defined metadata as key-value pairs. Keys must be lowercase.
	//  Total size limit is 4KB.
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"User-defined metadata as key-value pairs. Keys must be lowercase. Total size limit is 4KB."`
	// Retention rules enforce minimum retention periods on objects.
	//  A maximum of 100 rules are supported per bucket. Rules take
	//  effect within approximately 30 seconds.
	RetentionRules []*RetentionRuleInput `json:"retention_rules,omitempty" jsonschema:"Retention rules enforce minimum retention periods on objects. A maximum of 100 rules are supported per bucket. Rules take effect within approximately 30 seconds."`
	// Lifecycle rules automate object transitions and deletions based
	//  on age. Managed as a single lifecycle policy resource on the bucket.
	LifecycleRules []*LifecycleRuleInput `json:"lifecycle_rules,omitempty" jsonschema:"Lifecycle rules automate object transitions and deletions based on age. Managed as a single lifecycle policy resource on the bucket."`
	// Cross-region replication policies. Each policy replicates objects
	//  to a destination bucket in another OCI region. Destination buckets
	//  must exist before creating the policy. All fields are immutable
	//  after creation.
	ReplicationPolicies []*ReplicationPolicyInput `json:"replication_policies,omitempty" jsonschema:"Cross-region replication policies. Each policy replicates objects to a destination bucket in another OCI region. Destination buckets must exist before creating the policy. All fields are immutable aft..."`
}

func (s *OciObjectStorageBucketSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	switch s.AccessType {
	case "", "no_public_access", "object_read", "object_read_without_list":
	default:
		return fmt.Errorf("invalid access_type: %q", s.AccessType)
	}
	switch s.StorageTier {
	case "", "standard", "archive":
	default:
		return fmt.Errorf("invalid storage_tier: %q", s.StorageTier)
	}
	switch s.Versioning {
	case "", "enabled", "disabled", "suspended":
	default:
		return fmt.Errorf("invalid versioning: %q", s.Versioning)
	}
	switch s.AutoTiering {
	case "", "auto_tiering_disabled", "infrequent_access":
	default:
		return fmt.Errorf("invalid auto_tiering: %q", s.AutoTiering)
	}
	for i, v := range s.RetentionRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("retention_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.LifecycleRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("lifecycle_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ReplicationPolicies {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("replication_policies[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciObjectStorageBucketSpecInput) applyDefaults() {
}

func (s *OciObjectStorageBucketSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.AccessType != "" {
		m["access_type"] = s.AccessType
	}
	if s.StorageTier != "" {
		m["storage_tier"] = s.StorageTier
	}
	if s.Versioning != "" {
		m["versioning"] = s.Versioning
	}
	if s.AutoTiering != "" {
		m["auto_tiering"] = s.AutoTiering
	}
	if s.ObjectEventsEnabled {
		m["object_events_enabled"] = s.ObjectEventsEnabled
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if len(s.RetentionRules) > 0 {
		items := make([]any, len(s.RetentionRules))
		for i, v := range s.RetentionRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["retention_rules"] = items
	}
	if len(s.LifecycleRules) > 0 {
		items := make([]any, len(s.LifecycleRules))
		for i, v := range s.LifecycleRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["lifecycle_rules"] = items
	}
	if len(s.ReplicationPolicies) > 0 {
		items := make([]any, len(s.ReplicationPolicies))
		for i, v := range s.ReplicationPolicies {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["replication_policies"] = items
	}
	return m
}

// Duration defines a time period for retention and lifecycle rules.
type DurationInput struct {
	// Time amount, interpreted in units defined by time_unit.
	TimeAmount int64 `json:"time_amount,omitempty" jsonschema:"Time amount; interpreted in units defined by time_unit."`
	// Unit of time for time_amount.
	TimeUnit string `json:"time_unit,omitempty" jsonschema:"enum=days|years,Unit of time for time_amount."`
}

func (s *DurationInput) validate() error {
	switch s.TimeUnit {
	case "", "days", "years":
	default:
		return fmt.Errorf("invalid time_unit: %q", s.TimeUnit)
	}
	return nil
}

func (s *DurationInput) applyDefaults() {
}

func (s *DurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TimeAmount != 0 {
		m["time_amount"] = s.TimeAmount
	}
	if s.TimeUnit != "" {
		m["time_unit"] = s.TimeUnit
	}
	return m
}

// LifecycleRule defines an automatic action on objects based on age.
type LifecycleRuleInput struct {
	// Rule name. Must be unique within the lifecycle policy.
	Name string `json:"name,omitempty" jsonschema:"Rule name. Must be unique within the lifecycle policy."`
	// Action to perform on matching objects.
	Action string `json:"action,omitempty" jsonschema:"enum=lifecycle_archive|lifecycle_infrequent_access|lifecycle_delete|lifecycle_abort,Action to perform on matching objects."`
	// Whether this rule is currently active.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"Whether this rule is currently active."`
	// Age threshold. Objects older than this are acted upon.
	TimeAmount int64 `json:"time_amount,omitempty" jsonschema:"Age threshold. Objects older than this are acted upon."`
	// Unit for time_amount.
	TimeUnit string `json:"time_unit,omitempty" jsonschema:"enum=days|years,Unit for time_amount."`
	// Target object type. Valid values: "objects" (default),
	//  "multipart-uploads", "previous-object-versions".
	//  Uses plain strings because the values contain hyphens.
	Target string `json:"target,omitempty" jsonschema:"Target object type. Valid values: 'objects' (default); 'multipart-uploads'; 'previous-object-versions'. Uses plain strings because the values contain hyphens."`
	// Filter to narrow which objects the rule applies to.
	//  Not valid when target is "multipart-uploads".
	ObjectNameFilter *ObjectNameFilterInput `json:"object_name_filter,omitempty" jsonschema:"Filter to narrow which objects the rule applies to. Not valid when target is 'multipart-uploads'."`
}

func (s *LifecycleRuleInput) validate() error {
	switch s.Action {
	case "", "lifecycle_archive", "lifecycle_infrequent_access", "lifecycle_delete", "lifecycle_abort":
	default:
		return fmt.Errorf("invalid action: %q", s.Action)
	}
	switch s.TimeUnit {
	case "", "days", "years":
	default:
		return fmt.Errorf("invalid time_unit: %q", s.TimeUnit)
	}
	if s.ObjectNameFilter != nil {
		if err := s.ObjectNameFilter.validate(); err != nil {
			return fmt.Errorf("object_name_filter: %w", err)
		}
	}
	return nil
}

func (s *LifecycleRuleInput) applyDefaults() {
	if s.ObjectNameFilter != nil {
		s.ObjectNameFilter.applyDefaults()
	}
}

func (s *LifecycleRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.TimeAmount != 0 {
		m["time_amount"] = s.TimeAmount
	}
	if s.TimeUnit != "" {
		m["time_unit"] = s.TimeUnit
	}
	if s.Target != "" {
		m["target"] = s.Target
	}
	if s.ObjectNameFilter != nil {
		m["object_name_filter"] = s.ObjectNameFilter.toMap()
	}
	return m
}

// ObjectNameFilter selects objects by name pattern for lifecycle rules.
//
//	Exclusion patterns take precedence over inclusion patterns.
type ObjectNameFilterInput struct {
	// Glob patterns to include. An empty list includes all objects.
	InclusionPatterns []string `json:"inclusion_patterns,omitempty" jsonschema:"Glob patterns to include. An empty list includes all objects."`
	// Object name prefixes to include. Kept for backward compatibility;
	//  prefer inclusion_patterns.
	InclusionPrefixes []string `json:"inclusion_prefixes,omitempty" jsonschema:"Object name prefixes to include. Kept for backward compatibility; prefer inclusion_patterns."`
	// Glob patterns to exclude. Takes precedence over inclusions.
	ExclusionPatterns []string `json:"exclusion_patterns,omitempty" jsonschema:"Glob patterns to exclude. Takes precedence over inclusions."`
}

func (s *ObjectNameFilterInput) validate() error {
	return nil
}

func (s *ObjectNameFilterInput) applyDefaults() {
}

func (s *ObjectNameFilterInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.InclusionPatterns) > 0 {
		m["inclusion_patterns"] = s.InclusionPatterns
	}
	if len(s.InclusionPrefixes) > 0 {
		m["inclusion_prefixes"] = s.InclusionPrefixes
	}
	if len(s.ExclusionPatterns) > 0 {
		m["exclusion_patterns"] = s.ExclusionPatterns
	}
	return m
}

// ReplicationPolicy defines cross-region asynchronous replication
//
//	to a destination bucket. All fields are immutable after creation.
type ReplicationPolicyInput struct {
	// Policy name.
	Name string `json:"name,omitempty" jsonschema:"Policy name."`
	// Name of the destination bucket. Must already exist in the
	//  destination region.
	DestinationBucketName string `json:"destination_bucket_name,omitempty" jsonschema:"Name of the destination bucket. Must already exist in the destination region."`
	// OCI region identifier for the destination (e.g. "us-ashburn-1").
	DestinationRegionName string `json:"destination_region_name,omitempty" jsonschema:"OCI region identifier for the destination (e.g. 'us-ashburn-1')."`
}

func (s *ReplicationPolicyInput) validate() error {
	return nil
}

func (s *ReplicationPolicyInput) applyDefaults() {
}

func (s *ReplicationPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.DestinationBucketName != "" {
		m["destination_bucket_name"] = s.DestinationBucketName
	}
	if s.DestinationRegionName != "" {
		m["destination_region_name"] = s.DestinationRegionName
	}
	return m
}

// RetentionRule enforces a minimum retention period on objects.
type RetentionRuleInput struct {
	// User-specified name for the retention rule. Must be unique
	//  within the bucket. Changing this forces recreation.
	DisplayName string `json:"display_name,omitempty" jsonschema:"User-specified name for the retention rule. Must be unique within the bucket. Changing this forces recreation."`
	// Retention duration. When omitted, the rule applies indefinitely.
	Duration *DurationInput `json:"duration,omitempty" jsonschema:"Retention duration. When omitted; the rule applies indefinitely."`
	// RFC 3339 datetime after which this rule becomes locked.
	//  Once locked, the rule can only be deleted by deleting the bucket,
	//  and only duration increases are allowed.
	TimeRuleLocked string `json:"time_rule_locked,omitempty" jsonschema:"RFC 3339 datetime after which this rule becomes locked. Once locked; the rule can only be deleted by deleting the bucket; and only duration increases are allowed."`
}

func (s *RetentionRuleInput) validate() error {
	if s.Duration != nil {
		if err := s.Duration.validate(); err != nil {
			return fmt.Errorf("duration: %w", err)
		}
	}
	return nil
}

func (s *RetentionRuleInput) applyDefaults() {
	if s.Duration != nil {
		s.Duration.applyDefaults()
	}
}

func (s *RetentionRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.Duration != nil {
		m["duration"] = s.Duration.toMap()
	}
	if s.TimeRuleLocked != "" {
		m["time_rule_locked"] = s.TimeRuleLocked
	}
	return m
}

// ParseOciObjectStorageBucket validates and normalizes a OciObjectStorageBucket cloud_object.
func ParseOciObjectStorageBucket(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciObjectStorageBucket"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciObjectStorageBucketSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
