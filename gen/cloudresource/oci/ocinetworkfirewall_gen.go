// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciNetworkFirewall is the top-level resource representing an OCI
//
//	Network Firewall bundled with an inline policy -- providing
//	next-generation firewall capabilities with L3/L4 network rules
//	and L7 URL filtering.
type OciNetworkFirewallSpecInput struct {
	// OCID of the compartment where the firewall and policy will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the firewall and policy will be created."`
	// OCID of the subnet where the firewall appliance will be deployed.
	//  Immutable after creation.
	SubnetId string `json:"subnet_id" jsonschema:"required,OCID of the subnet where the firewall appliance will be deployed. Immutable after creation."`
	// Display name for the firewall. When omitted, the metadata name is used.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the firewall. When omitted; the metadata name is used."`
	// Static IPv4 address for the firewall. When omitted, OCI auto-assigns
	//  from the subnet. Immutable after creation.
	Ipv4Address string `json:"ipv4_address,omitempty" jsonschema:"Static IPv4 address for the firewall. When omitted; OCI auto-assigns from the subnet. Immutable after creation."`
	// Static IPv6 address for the firewall. When omitted, OCI auto-assigns
	//  if the subnet supports IPv6. Immutable after creation.
	Ipv6Address string `json:"ipv6_address,omitempty" jsonschema:"Static IPv6 address for the firewall. When omitted; OCI auto-assigns if the subnet supports IPv6. Immutable after creation."`
	// Availability domain for the firewall placement.
	//  When omitted, OCI selects automatically. Immutable after creation.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain for the firewall placement. When omitted; OCI selects automatically. Immutable after creation."`
	// OCIDs of network security groups applied to the firewall.
	NetworkSecurityGroupIds []string `json:"network_security_group_ids,omitempty" jsonschema:"OCIDs of network security groups applied to the firewall."`
	// NAT configuration for the firewall. Controls whether private NAT
	//  is used for egress traffic inspection.
	NatConfiguration *NatConfigurationInput `json:"nat_configuration,omitempty" jsonschema:"NAT configuration for the firewall. Controls whether private NAT is used for egress traffic inspection."`
	// Firewall shape determining throughput capacity.
	//  When omitted, OCI applies the default shape.
	Shape string `json:"shape,omitempty" jsonschema:"Firewall shape determining throughput capacity. When omitted; OCI applies the default shape."`
	// Inline firewall policy defining security rules and their supporting
	//  objects (address lists, services, URL lists). The policy is always
	//  created as part of this component.
	Policy *PolicyInput `json:"policy" jsonschema:"required,Inline firewall policy defining security rules and their supporting objects (address lists; services; URL lists). The policy is always created as part of this component."`
}

func (s *OciNetworkFirewallSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if s.NatConfiguration != nil {
		if err := s.NatConfiguration.validate(); err != nil {
			return fmt.Errorf("nat_configuration: %w", err)
		}
	}
	if s.Policy == nil {
		return fmt.Errorf("policy is required")
	}
	if s.Policy != nil {
		if err := s.Policy.validate(); err != nil {
			return fmt.Errorf("policy: %w", err)
		}
	}
	return nil
}

func (s *OciNetworkFirewallSpecInput) applyDefaults() {
	if s.NatConfiguration != nil {
		s.NatConfiguration.applyDefaults()
	}
	if s.Policy != nil {
		s.Policy.applyDefaults()
	}
}

func (s *OciNetworkFirewallSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	m["subnet_id"] = s.SubnetId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.Ipv4Address != "" {
		m["ipv4_address"] = s.Ipv4Address
	}
	if s.Ipv6Address != "" {
		m["ipv6_address"] = s.Ipv6Address
	}
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if len(s.NetworkSecurityGroupIds) > 0 {
		m["network_security_group_ids"] = s.NetworkSecurityGroupIds
	}
	if s.NatConfiguration != nil {
		m["nat_configuration"] = s.NatConfiguration.toMap()
	}
	if s.Shape != "" {
		m["shape"] = s.Shape
	}
	if s.Policy != nil {
		m["policy"] = s.Policy.toMap()
	}
	return m
}

// AddressList defines a named collection of IP addresses/CIDRs or
//
//	FQDNs that can be referenced in security rule conditions.
type AddressListInput struct {
	// Unique name within the policy. Immutable after creation.
	//  Referenced by security rules via source_addresses and
	//  destination_addresses.
	Name string `json:"name,omitempty" jsonschema:"Unique name within the policy. Immutable after creation. Referenced by security rules via source_addresses and destination_addresses."`
	// Whether this list contains IP addresses/CIDRs or FQDNs.
	Type string `json:"type,omitempty" jsonschema:"enum=ip|fqdn,Whether this list contains IP addresses/CIDRs or FQDNs."`
	// Addresses in the list. IP lists accept CIDRs (e.g., "10.0.0.0/8")
	//  and individual IPs. FQDN lists accept domain names
	//  (e.g., "example.com").
	Addresses []string `json:"addresses,omitempty" jsonschema:"Addresses in the list. IP lists accept CIDRs (e.g.; '10.0.0.0/8') and individual IPs. FQDN lists accept domain names (e.g.; 'example.com')."`
	// Optional description.
	Description string `json:"description,omitempty" jsonschema:"Optional description."`
}

func (s *AddressListInput) validate() error {
	switch s.Type {
	case "", "ip", "fqdn":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if len(s.Addresses) < 1 {
		return fmt.Errorf("addresses requires at least 1 items, got %d", len(s.Addresses))
	}
	return nil
}

func (s *AddressListInput) applyDefaults() {
}

func (s *AddressListInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if len(s.Addresses) > 0 {
		m["addresses"] = s.Addresses
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// NatConfiguration controls NAT behavior for the firewall.
type NatConfigurationInput struct {
	// Whether to enable private NAT for the firewall.
	//  When true, the firewall uses a private IP for NAT operations
	//  instead of a public IP.
	MustEnablePrivateNat bool `json:"must_enable_private_nat,omitempty" jsonschema:"Whether to enable private NAT for the firewall. When true; the firewall uses a private IP for NAT operations instead of a public IP."`
}

func (s *NatConfigurationInput) validate() error {
	return nil
}

func (s *NatConfigurationInput) applyDefaults() {
}

func (s *NatConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MustEnablePrivateNat {
		m["must_enable_private_nat"] = s.MustEnablePrivateNat
	}
	return m
}

// Policy defines the firewall policy and all of its sub-resources.
//
//	The policy is the container for address lists, services, URL lists,
//	and security rules that determine how the firewall inspects traffic.
type PolicyInput struct {
	// Display name for the policy. When omitted, defaults to
	//  "{firewall_display_name}-policy".
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the policy. When omitted; defaults to '{firewall_display_name}-policy'."`
	// Description of the policy.
	Description string `json:"description,omitempty" jsonschema:"Description of the policy."`
	// IP and FQDN address lists referenced by security rules.
	AddressLists []*AddressListInput `json:"address_lists,omitempty" jsonschema:"IP and FQDN address lists referenced by security rules."`
	// TCP/UDP port definitions referenced by security rules.
	Services []*ServiceInput `json:"services,omitempty" jsonschema:"TCP/UDP port definitions referenced by security rules."`
	// Groups of services for reuse across multiple security rules.
	ServiceLists []*ServiceListInput `json:"service_lists,omitempty" jsonschema:"Groups of services for reuse across multiple security rules."`
	// URL pattern lists for L7 HTTP(S) traffic inspection.
	UrlLists []*UrlListInput `json:"url_lists,omitempty" jsonschema:"URL pattern lists for L7 HTTP(S) traffic inspection."`
	// Security rules evaluated in list order. Priority is derived from
	//  the position in this list (first rule = highest priority).
	SecurityRules []*SecurityRuleInput `json:"security_rules,omitempty" jsonschema:"Security rules evaluated in list order. Priority is derived from the position in this list (first rule = highest priority)."`
}

func (s *PolicyInput) validate() error {
	for i, v := range s.AddressLists {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("address_lists[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Services {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("services[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ServiceLists {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("service_lists[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.UrlLists {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("url_lists[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.SecurityRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("security_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *PolicyInput) applyDefaults() {
}

func (s *PolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.AddressLists) > 0 {
		items := make([]any, len(s.AddressLists))
		for i, v := range s.AddressLists {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["address_lists"] = items
	}
	if len(s.Services) > 0 {
		items := make([]any, len(s.Services))
		for i, v := range s.Services {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["services"] = items
	}
	if len(s.ServiceLists) > 0 {
		items := make([]any, len(s.ServiceLists))
		for i, v := range s.ServiceLists {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["service_lists"] = items
	}
	if len(s.UrlLists) > 0 {
		items := make([]any, len(s.UrlLists))
		for i, v := range s.UrlLists {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["url_lists"] = items
	}
	if len(s.SecurityRules) > 0 {
		items := make([]any, len(s.SecurityRules))
		for i, v := range s.SecurityRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["security_rules"] = items
	}
	return m
}

// SecurityRule defines a traffic inspection rule. Rules are evaluated
//
//	in the order they appear in the policy's security_rules list.
//	Priority is derived from list position (1-based).
type SecurityRuleInput struct {
	// Unique name within the policy. Immutable after creation.
	Name string `json:"name,omitempty" jsonschema:"Unique name within the policy. Immutable after creation."`
	// Action to take when traffic matches the condition.
	Action string `json:"action,omitempty" jsonschema:"enum=allow|drop|reject|inspect,Action to take when traffic matches the condition."`
	// Traffic matching condition. References address lists, services,
	//  and URL lists by name.
	Condition *SecurityRuleConditionInput `json:"condition" jsonschema:"required,Traffic matching condition. References address lists; services; and URL lists by name."`
	// Inspection type. Required when action is inspect.
	Inspection string `json:"inspection,omitempty" jsonschema:"enum=intrusion_detection|intrusion_prevention,Inspection type. Required when action is inspect."`
	// Optional description.
	Description string `json:"description,omitempty" jsonschema:"Optional description."`
}

func (s *SecurityRuleInput) validate() error {
	switch s.Action {
	case "", "allow", "drop", "reject", "inspect":
	default:
		return fmt.Errorf("invalid action: %q", s.Action)
	}
	if s.Condition == nil {
		return fmt.Errorf("condition is required")
	}
	if s.Condition != nil {
		if err := s.Condition.validate(); err != nil {
			return fmt.Errorf("condition: %w", err)
		}
	}
	switch s.Inspection {
	case "", "intrusion_detection", "intrusion_prevention":
	default:
		return fmt.Errorf("invalid inspection: %q", s.Inspection)
	}
	return nil
}

func (s *SecurityRuleInput) applyDefaults() {
	if s.Condition != nil {
		s.Condition.applyDefaults()
	}
}

func (s *SecurityRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.Condition != nil {
		m["condition"] = s.Condition.toMap()
	}
	if s.Inspection != "" {
		m["inspection"] = s.Inspection
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// SecurityRuleCondition defines the traffic matching criteria for a
//
//	security rule. All non-empty fields are AND-ed together. Within
//	each field, values are OR-ed.
type SecurityRuleConditionInput struct {
	// Names of address lists matching source IP addresses.
	SourceAddresses []string `json:"source_addresses,omitempty" jsonschema:"Names of address lists matching source IP addresses."`
	// Names of address lists matching destination IP addresses.
	DestinationAddresses []string `json:"destination_addresses,omitempty" jsonschema:"Names of address lists matching destination IP addresses."`
	// Names of services or service lists matching traffic ports.
	Services []string `json:"services,omitempty" jsonschema:"Names of services or service lists matching traffic ports."`
	// Names of URL lists matching HTTP(S) request URLs.
	Urls []string `json:"urls,omitempty" jsonschema:"Names of URL lists matching HTTP(S) request URLs."`
}

func (s *SecurityRuleConditionInput) validate() error {
	return nil
}

func (s *SecurityRuleConditionInput) applyDefaults() {
}

func (s *SecurityRuleConditionInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.SourceAddresses) > 0 {
		m["source_addresses"] = s.SourceAddresses
	}
	if len(s.DestinationAddresses) > 0 {
		m["destination_addresses"] = s.DestinationAddresses
	}
	if len(s.Services) > 0 {
		m["services"] = s.Services
	}
	if len(s.Urls) > 0 {
		m["urls"] = s.Urls
	}
	return m
}

// Service defines a named TCP or UDP port range definition that can
//
//	be referenced in security rule conditions.
type ServiceInput struct {
	// Unique name within the policy. Immutable after creation.
	//  Referenced by security rules and service lists.
	Name string `json:"name,omitempty" jsonschema:"Unique name within the policy. Immutable after creation. Referenced by security rules and service lists."`
	// Protocol for this service definition.
	Type string `json:"type,omitempty" jsonschema:"enum=tcp_service|udp_service,Protocol for this service definition."`
	// Port ranges for this service. At least one port range is required.
	PortRanges []*PortRangeInput `json:"port_ranges,omitempty" jsonschema:"Port ranges for this service. At least one port range is required."`
	// Optional description.
	Description string `json:"description,omitempty" jsonschema:"Optional description."`
}

func (s *ServiceInput) validate() error {
	switch s.Type {
	case "", "tcp_service", "udp_service":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if len(s.PortRanges) < 1 {
		return fmt.Errorf("port_ranges requires at least 1 items, got %d", len(s.PortRanges))
	}
	for i, v := range s.PortRanges {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("port_ranges[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ServiceInput) applyDefaults() {
}

func (s *ServiceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if len(s.PortRanges) > 0 {
		items := make([]any, len(s.PortRanges))
		for i, v := range s.PortRanges {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["port_ranges"] = items
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ServiceList defines a named group of services for reuse across
//
//	multiple security rules.
type ServiceListInput struct {
	// Unique name within the policy. Immutable after creation.
	//  Referenced by security rules via the services condition field.
	Name string `json:"name,omitempty" jsonschema:"Unique name within the policy. Immutable after creation. Referenced by security rules via the services condition field."`
	// Names of services to include in this list. Each name must match
	//  a Service defined in the policy's services field.
	Services []string `json:"services,omitempty" jsonschema:"Names of services to include in this list. Each name must match a Service defined in the policy's services field."`
	// Optional description.
	Description string `json:"description,omitempty" jsonschema:"Optional description."`
}

func (s *ServiceListInput) validate() error {
	return nil
}

func (s *ServiceListInput) applyDefaults() {
}

func (s *ServiceListInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Services) > 0 {
		m["services"] = s.Services
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// UrlList defines a named collection of URL patterns for L7 HTTP(S)
//
//	traffic inspection.
type UrlListInput struct {
	// Unique name within the policy. Immutable after creation.
	//  Referenced by security rules via the urls condition field.
	Name string `json:"name,omitempty" jsonschema:"Unique name within the policy. Immutable after creation. Referenced by security rules via the urls condition field."`
	// URL patterns in the list. At least one pattern is required.
	Urls []*UrlPatternInput `json:"urls,omitempty" jsonschema:"URL patterns in the list. At least one pattern is required."`
	// Optional description.
	Description string `json:"description,omitempty" jsonschema:"Optional description."`
}

func (s *UrlListInput) validate() error {
	if len(s.Urls) < 1 {
		return fmt.Errorf("urls requires at least 1 items, got %d", len(s.Urls))
	}
	for i, v := range s.Urls {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("urls[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *UrlListInput) applyDefaults() {
}

func (s *UrlListInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Urls) > 0 {
		items := make([]any, len(s.Urls))
		for i, v := range s.Urls {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["urls"] = items
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// UrlPattern defines a single URL matching pattern.
//
//	OCI evaluates patterns using simple string matching.
type UrlPatternInput struct {
	// URL pattern string (e.g., "*.example.com",
	//  "malware.example.com/path").
	Pattern string `json:"pattern,omitempty" jsonschema:"URL pattern string (e.g.; '*.example.com'; 'malware.example.com/path')."`
}

func (s *UrlPatternInput) validate() error {
	return nil
}

func (s *UrlPatternInput) applyDefaults() {
}

func (s *UrlPatternInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Pattern != "" {
		m["pattern"] = s.Pattern
	}
	return m
}

// ParseOciNetworkFirewall validates and normalizes a OciNetworkFirewall cloud_object.
func ParseOciNetworkFirewall(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciNetworkFirewall"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciNetworkFirewallSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
