// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciApplicationLoadBalancer is the top-level resource representing an Oracle Cloud
//
//	Infrastructure Application Load Balancer (Layer 7).
type OciApplicationLoadBalancerSpecInput struct {
	// OCID of the compartment where the load balancer will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the load balancer will be created."`
	// Human-readable name for the load balancer shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the load balancer shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Load balancer shape. Use "flexible" for configurable bandwidth (recommended).
	//  Deprecated fixed shapes ("100Mbps", "400Mbps", "8000Mbps") are accepted
	//  for backward compatibility.
	Shape string `json:"shape,omitempty" jsonschema:"Load balancer shape. Use 'flexible' for configurable bandwidth (recommended). Deprecated fixed shapes ('100Mbps'; '400Mbps'; '8000Mbps') are accepted for backward compatibility."`
	// Bandwidth configuration for flexible-shape load balancers.
	//  Required when shape is "flexible". Ignored for fixed shapes.
	ShapeDetails *ShapeDetailsInput `json:"shape_details,omitempty" jsonschema:"Bandwidth configuration for flexible-shape load balancers. Required when shape is 'flexible'. Ignored for fixed shapes."`
	// OCIDs of subnets where the load balancer will be provisioned.
	//  At least one subnet is required. For regional (recommended) load balancers,
	//  provide subnets in two different availability domains for high availability.
	//  Changing subnets after creation forces load balancer recreation.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"OCIDs of subnets where the load balancer will be provisioned. At least one subnet is required. For regional (recommended) load balancers; provide subnets in two different availability domains for high..."`
	// When true, creates a private load balancer that is not accessible from
	//  the public internet. Private load balancers receive only private IP
	//  addresses from the assigned subnets.
	//  Changing this after creation forces load balancer recreation.
	IsPrivate bool `json:"is_private,omitempty" jsonschema:"When true; creates a private load balancer that is not accessible from the public internet. Private load balancers receive only private IP addresses from the assigned subnets. Changing this after crea..."`
	// OCIDs of network security groups applied to the load balancer.
	NetworkSecurityGroupIds []string `json:"network_security_group_ids,omitempty" jsonschema:"OCIDs of network security groups applied to the load balancer."`
	// When true, prevents accidental deletion of the load balancer.
	//  The protection must be explicitly disabled before the load balancer
	//  can be deleted.
	IsDeleteProtectionEnabled bool `json:"is_delete_protection_enabled,omitempty" jsonschema:"When true; prevents accidental deletion of the load balancer. The protection must be explicitly disabled before the load balancer can be deleted."`
	// IP version mode for the load balancer. Accepted values: "IPV4", "IPV6".
	//  When omitted, defaults to "IPV4".
	IpMode string `json:"ip_mode,omitempty" jsonschema:"IP version mode for the load balancer. Accepted values: 'IPV4'; 'IPV6'. When omitted; defaults to 'IPV4'."`
	// Pre-created reserved public IPs to assign to the load balancer.
	//  When omitted, OCI assigns ephemeral public IPs.
	ReservedIps []*ReservedIpInput `json:"reserved_ips,omitempty" jsonschema:"Pre-created reserved public IPs to assign to the load balancer. When omitted; OCI assigns ephemeral public IPs."`
	// When true, the load balancer adds a request ID header to each request
	//  for tracing and debugging purposes.
	IsRequestIdEnabled bool `json:"is_request_id_enabled,omitempty" jsonschema:"When true; the load balancer adds a request ID header to each request for tracing and debugging purposes."`
	// Custom header name for the request ID. Only effective when
	//  is_request_id_enabled is true. When omitted, OCI uses a default header.
	RequestIdHeader string `json:"request_id_header,omitempty" jsonschema:"Custom header name for the request ID. Only effective when is_request_id_enabled is true. When omitted; OCI uses a default header."`
	// Backend sets define groups of backend servers with load balancing
	//  policies and health checking. At least one backend set is required.
	//  Each listener routes traffic to exactly one default backend set.
	BackendSets []*BackendSetInput `json:"backend_sets,omitempty" jsonschema:"Backend sets define groups of backend servers with load balancing policies and health checking. At least one backend set is required. Each listener routes traffic to exactly one default backend set."`
	// Listeners define the ports and protocols on which the load balancer
	//  accepts client connections. At least one listener is required.
	Listeners []*ListenerInput `json:"listeners,omitempty" jsonschema:"Listeners define the ports and protocols on which the load balancer accepts client connections. At least one listener is required."`
	// TLS/SSL certificates for HTTPS termination. Certificates are referenced
	//  by name in listener and backend set SSL configurations.
	Certificates []*CertificateInput `json:"certificates,omitempty" jsonschema:"TLS/SSL certificates for HTTPS termination. Certificates are referenced by name in listener and backend set SSL configurations."`
	// Virtual hostnames for host-based routing. Hostnames are referenced
	//  by name in listener configurations to route requests based on the
	//  HTTP Host header.
	Hostnames []*HostnameInput `json:"hostnames,omitempty" jsonschema:"Virtual hostnames for host-based routing. Hostnames are referenced by name in listener configurations to route requests based on the HTTP Host header."`
	// Rule sets for advanced request/response manipulation. Rule sets are
	//  referenced by name in listener configurations.
	RuleSets []*RuleSetInput `json:"rule_sets,omitempty" jsonschema:"Rule sets for advanced request/response manipulation. Rule sets are referenced by name in listener configurations."`
}

func (s *OciApplicationLoadBalancerSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.ShapeDetails != nil {
		if err := s.ShapeDetails.validate(); err != nil {
			return fmt.Errorf("shape_details: %w", err)
		}
	}
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	for i, v := range s.ReservedIps {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("reserved_ips[%d]: %w", i, err)
			}
		}
	}
	if len(s.BackendSets) < 1 {
		return fmt.Errorf("backend_sets requires at least 1 items, got %d", len(s.BackendSets))
	}
	for i, v := range s.BackendSets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backend_sets[%d]: %w", i, err)
			}
		}
	}
	if len(s.Listeners) < 1 {
		return fmt.Errorf("listeners requires at least 1 items, got %d", len(s.Listeners))
	}
	for i, v := range s.Listeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("listeners[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Certificates {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("certificates[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Hostnames {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("hostnames[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RuleSets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rule_sets[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciApplicationLoadBalancerSpecInput) applyDefaults() {
	if s.ShapeDetails != nil {
		s.ShapeDetails.applyDefaults()
	}
}

func (s *OciApplicationLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.Shape != "" {
		m["shape"] = s.Shape
	}
	if s.ShapeDetails != nil {
		m["shape_details"] = s.ShapeDetails.toMap()
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if s.IsPrivate {
		m["is_private"] = s.IsPrivate
	}
	if len(s.NetworkSecurityGroupIds) > 0 {
		m["network_security_group_ids"] = s.NetworkSecurityGroupIds
	}
	if s.IsDeleteProtectionEnabled {
		m["is_delete_protection_enabled"] = s.IsDeleteProtectionEnabled
	}
	if s.IpMode != "" {
		m["ip_mode"] = s.IpMode
	}
	if len(s.ReservedIps) > 0 {
		items := make([]any, len(s.ReservedIps))
		for i, v := range s.ReservedIps {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["reserved_ips"] = items
	}
	if s.IsRequestIdEnabled {
		m["is_request_id_enabled"] = s.IsRequestIdEnabled
	}
	if s.RequestIdHeader != "" {
		m["request_id_header"] = s.RequestIdHeader
	}
	if len(s.BackendSets) > 0 {
		items := make([]any, len(s.BackendSets))
		for i, v := range s.BackendSets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backend_sets"] = items
	}
	if len(s.Listeners) > 0 {
		items := make([]any, len(s.Listeners))
		for i, v := range s.Listeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["listeners"] = items
	}
	if len(s.Certificates) > 0 {
		items := make([]any, len(s.Certificates))
		for i, v := range s.Certificates {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["certificates"] = items
	}
	if len(s.Hostnames) > 0 {
		items := make([]any, len(s.Hostnames))
		for i, v := range s.Hostnames {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["hostnames"] = items
	}
	if len(s.RuleSets) > 0 {
		items := make([]any, len(s.RuleSets))
		for i, v := range s.RuleSets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rule_sets"] = items
	}
	return m
}

// Certificate defines a TLS/SSL certificate uploaded to the load balancer.
//
//	Certificates are referenced by name in SSL configurations.
type CertificateInput struct {
	// Unique name for this certificate within the load balancer.
	//  SSL configurations reference certificates by this name.
	CertificateName string `json:"certificate_name,omitempty" jsonschema:"Unique name for this certificate within the load balancer. SSL configurations reference certificates by this name."`
	// PEM-encoded CA certificate chain.
	CaCertificate string `json:"ca_certificate,omitempty" jsonschema:"PEM-encoded CA certificate chain."`
	// PEM-encoded public certificate.
	PublicCertificate string `json:"public_certificate,omitempty" jsonschema:"PEM-encoded public certificate."`
	// PEM-encoded private key for the certificate. Sensitive.
	PrivateKey string `json:"private_key,omitempty" jsonschema:"PEM-encoded private key for the certificate. Sensitive."`
	// Passphrase for an encrypted private key. Sensitive.
	Passphrase string `json:"passphrase,omitempty" jsonschema:"Passphrase for an encrypted private key. Sensitive."`
}

func (s *CertificateInput) validate() error {
	return nil
}

func (s *CertificateInput) applyDefaults() {
}

func (s *CertificateInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CertificateName != "" {
		m["certificate_name"] = s.CertificateName
	}
	if s.CaCertificate != "" {
		m["ca_certificate"] = s.CaCertificate
	}
	if s.PublicCertificate != "" {
		m["public_certificate"] = s.PublicCertificate
	}
	if s.PrivateKey != "" {
		m["private_key"] = s.PrivateKey
	}
	if s.Passphrase != "" {
		m["passphrase"] = s.Passphrase
	}
	return m
}

// ConnectionConfiguration controls TCP connection behavior for a listener.
type ConnectionConfigurationInput struct {
	// Maximum idle time in seconds before the load balancer closes the
	//  connection. Applies to both client-side and backend-side connections.
	IdleTimeoutInSeconds int64 `json:"idle_timeout_in_seconds,omitempty" jsonschema:"Maximum idle time in seconds before the load balancer closes the connection. Applies to both client-side and backend-side connections."`
	// Backend TCP proxy protocol version. When set, the load balancer
	//  prepends proxy protocol headers to backend connections, allowing
	//  backends to see the original client IP.
	//  Accepted values: 1 or 2.
	BackendTcpProxyProtocolVersion int32 `json:"backend_tcp_proxy_protocol_version,omitempty" jsonschema:"Backend TCP proxy protocol version. When set; the load balancer prepends proxy protocol headers to backend connections; allowing backends to see the original client IP. Accepted values: 1 or 2."`
}

func (s *ConnectionConfigurationInput) validate() error {
	return nil
}

func (s *ConnectionConfigurationInput) applyDefaults() {
}

func (s *ConnectionConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IdleTimeoutInSeconds != 0 {
		m["idle_timeout_in_seconds"] = s.IdleTimeoutInSeconds
	}
	if s.BackendTcpProxyProtocolVersion != 0 {
		m["backend_tcp_proxy_protocol_version"] = s.BackendTcpProxyProtocolVersion
	}
	return m
}

// Hostname defines a virtual hostname for host-based routing.
//
//	Listeners reference hostnames by name to restrict which requests
//	they handle based on the HTTP Host header.
type HostnameInput struct {
	// Unique name for this hostname resource within the load balancer.
	Name string `json:"name,omitempty" jsonschema:"Unique name for this hostname resource within the load balancer."`
	// The fully qualified domain name (FQDN) to match against the
	//  HTTP Host header. Example: "app.example.com".
	Hostname string `json:"hostname,omitempty" jsonschema:"The fully qualified domain name (FQDN) to match against the HTTP Host header. Example: 'app.example.com'."`
}

func (s *HostnameInput) validate() error {
	return nil
}

func (s *HostnameInput) applyDefaults() {
}

func (s *HostnameInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// IpMaxConnection defines per-IP connection limits for the
//
//	ip_based_max_connections rule action.
type IpMaxConnectionInput struct {
	// IP addresses to apply this connection limit to.
	IpAddresses []string `json:"ip_addresses,omitempty" jsonschema:"IP addresses to apply this connection limit to."`
	// Maximum simultaneous connections allowed from these IPs.
	MaxConnections int32 `json:"max_connections,omitempty" jsonschema:"Maximum simultaneous connections allowed from these IPs."`
}

func (s *IpMaxConnectionInput) validate() error {
	return nil
}

func (s *IpMaxConnectionInput) applyDefaults() {
}

func (s *IpMaxConnectionInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.IpAddresses) > 0 {
		m["ip_addresses"] = s.IpAddresses
	}
	if s.MaxConnections != 0 {
		m["max_connections"] = s.MaxConnections
	}
	return m
}

// LbCookieSessionPersistenceConfig configures session persistence using
//
//	a cookie managed by the load balancer. The LB injects a Set-Cookie
//	header to pin client sessions to specific backends.
type LbCookieSessionPersistenceConfigInput struct {
	// Name of the cookie. When omitted, OCI generates a default name.
	CookieName string `json:"cookie_name,omitempty" jsonschema:"Name of the cookie. When omitted; OCI generates a default name."`
	// When true, connections from clients without the cookie are rejected
	//  rather than being assigned to a new backend. Useful for preventing
	//  session migration.
	DisableFallback bool `json:"disable_fallback,omitempty" jsonschema:"When true; connections from clients without the cookie are rejected rather than being assigned to a new backend. Useful for preventing session migration."`
	// Domain attribute for the Set-Cookie header.
	//  When omitted, the cookie applies to the request domain.
	Domain string `json:"domain,omitempty" jsonschema:"Domain attribute for the Set-Cookie header. When omitted; the cookie applies to the request domain."`
	// When true, the cookie is marked HttpOnly (not accessible to JavaScript).
	IsHttpOnly bool `json:"is_http_only,omitempty" jsonschema:"When true; the cookie is marked HttpOnly (not accessible to JavaScript)."`
	// When true, the cookie is marked Secure (only sent over HTTPS).
	IsSecure bool `json:"is_secure,omitempty" jsonschema:"When true; the cookie is marked Secure (only sent over HTTPS)."`
	// Cookie lifetime in seconds. When omitted or set to 0, the cookie
	//  is a session cookie (expires when the browser closes).
	MaxAgeInSeconds int32 `json:"max_age_in_seconds,omitempty" jsonschema:"Cookie lifetime in seconds. When omitted or set to 0; the cookie is a session cookie (expires when the browser closes)."`
	// Path attribute for the Set-Cookie header.
	//  When omitted, defaults to "/".
	Path string `json:"path,omitempty" jsonschema:"Path attribute for the Set-Cookie header. When omitted; defaults to '/'."`
}

func (s *LbCookieSessionPersistenceConfigInput) validate() error {
	return nil
}

func (s *LbCookieSessionPersistenceConfigInput) applyDefaults() {
}

func (s *LbCookieSessionPersistenceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CookieName != "" {
		m["cookie_name"] = s.CookieName
	}
	if s.DisableFallback {
		m["disable_fallback"] = s.DisableFallback
	}
	if s.Domain != "" {
		m["domain"] = s.Domain
	}
	if s.IsHttpOnly {
		m["is_http_only"] = s.IsHttpOnly
	}
	if s.IsSecure {
		m["is_secure"] = s.IsSecure
	}
	if s.MaxAgeInSeconds != 0 {
		m["max_age_in_seconds"] = s.MaxAgeInSeconds
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	return m
}

// RedirectUri defines the target URI template for redirect rules.
//
//	Template variables {protocol}, {host}, {port}, {path}, {query}
//	are replaced with values from the original request.
type RedirectUriInput struct {
	// Target protocol. Use "{protocol}" to preserve the original.
	Protocol string `json:"protocol,omitempty" jsonschema:"Target protocol. Use '{protocol}' to preserve the original."`
	// Target hostname. Use "{host}" to preserve the original.
	Host string `json:"host,omitempty" jsonschema:"Target hostname. Use '{host}' to preserve the original."`
	// Target port. Use 0 to preserve the original.
	Port int32 `json:"port,omitempty" jsonschema:"Target port. Use 0 to preserve the original."`
	// Target path. Use "{path}" to preserve the original.
	Path string `json:"path,omitempty" jsonschema:"Target path. Use '{path}' to preserve the original."`
	// Target query string. Use "{query}" to preserve the original.
	Query string `json:"query,omitempty" jsonschema:"Target query string. Use '{query}' to preserve the original."`
}

func (s *RedirectUriInput) validate() error {
	return nil
}

func (s *RedirectUriInput) applyDefaults() {
}

func (s *RedirectUriInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Host != "" {
		m["host"] = s.Host
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Query != "" {
		m["query"] = s.Query
	}
	return m
}

// RuleSet groups one or more rules for request/response manipulation.
//
//	Rule sets are applied to listeners for advanced traffic management
//	including HTTP redirects, header manipulation, and access control.
type RuleSetInput struct {
	// Unique name for this rule set within the load balancer.
	Name string `json:"name,omitempty" jsonschema:"Unique name for this rule set within the load balancer."`
	// Rules in this set. At least one rule is required.
	Items []*RuleSetItemInput `json:"items,omitempty" jsonschema:"Rules in this set. At least one rule is required."`
}

func (s *RuleSetInput) validate() error {
	if len(s.Items) < 1 {
		return fmt.Errorf("items requires at least 1 items, got %d", len(s.Items))
	}
	for i, v := range s.Items {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("items[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *RuleSetInput) applyDefaults() {
}

func (s *RuleSetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Items) > 0 {
		items := make([]any, len(s.Items))
		for i, v := range s.Items {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["items"] = items
	}
	return m
}

// RuleSetItem defines a single rule within a rule set. The action field
//
//	determines which other fields are relevant:
//
//	  add_http_request_header:          header, value
//	  add_http_response_header:         header, value
//	  extend_http_request_header_value: header, prefix, suffix
//	  extend_http_response_header_value: header, prefix, suffix
//	  remove_http_request_header:       header
//	  remove_http_response_header:      header
//	  redirect:                         redirect_uri, response_code, conditions
//	  allow:                            conditions
//	  control_access_using_http_methods: allowed_methods, status_code
//	  http_header:                      are_invalid_characters_allowed,
//	                                    http_large_header_size_in_kb
//	  ip_based_max_connections:         default_max_connections, ip_max_connections
type RuleSetItemInput struct {
	// The type of rule. Determines which fields are applicable.
	Action string `json:"action,omitempty" jsonschema:"enum=add_http_request_header|add_http_response_header|extend_http_request_header_value|extend_http_response_header_value|remove_http_request_header|remove_http_response_header|redirect|allow|control_access_using_http_methods|http_header|ip_based_max_connections,The type of rule. Determines which fields are applicable."`
	// HTTP header name. Used by header add/remove/extend actions.
	Header string `json:"header,omitempty" jsonschema:"HTTP header name. Used by header add/remove/extend actions."`
	// Header value. Used by add_http_request_header and
	//  add_http_response_header actions.
	Value string `json:"value,omitempty" jsonschema:"Header value. Used by add_http_request_header and add_http_response_header actions."`
	// Prefix to prepend to an existing header value.
	//  Used by extend_http_request_header_value and
	//  extend_http_response_header_value actions.
	Prefix string `json:"prefix,omitempty" jsonschema:"Prefix to prepend to an existing header value. Used by extend_http_request_header_value and extend_http_response_header_value actions."`
	// Suffix to append to an existing header value.
	//  Used by extend_http_request_header_value and
	//  extend_http_response_header_value actions.
	Suffix string `json:"suffix,omitempty" jsonschema:"Suffix to append to an existing header value. Used by extend_http_request_header_value and extend_http_response_header_value actions."`
	// Redirect URI template. Used by the redirect action.
	RedirectUri *RedirectUriInput `json:"redirect_uri,omitempty" jsonschema:"Redirect URI template. Used by the redirect action."`
	// HTTP response code for the redirect (e.g., 301, 302, 307, 308).
	//  Used by the redirect action.
	ResponseCode int32 `json:"response_code,omitempty" jsonschema:"HTTP response code for the redirect (e.g.; 301; 302; 307; 308). Used by the redirect action."`
	// Conditions that must be met for this rule to apply.
	//  Used by redirect and allow actions.
	Conditions []*RuleSetItemConditionInput `json:"conditions,omitempty" jsonschema:"Conditions that must be met for this rule to apply. Used by redirect and allow actions."`
	// Allowed HTTP methods. Requests using other methods receive the
	//  status_code response. Used by control_access_using_http_methods.
	AllowedMethods []string `json:"allowed_methods,omitempty" jsonschema:"Allowed HTTP methods. Requests using other methods receive the status_code response. Used by control_access_using_http_methods."`
	// HTTP status code returned when access is denied (e.g., 403, 405).
	//  Used by control_access_using_http_methods.
	StatusCode int32 `json:"status_code,omitempty" jsonschema:"HTTP status code returned when access is denied (e.g.; 403; 405). Used by control_access_using_http_methods."`
	// When true, allows invalid characters in HTTP headers.
	//  Used by the http_header action.
	AreInvalidCharactersAllowed bool `json:"are_invalid_characters_allowed,omitempty" jsonschema:"When true; allows invalid characters in HTTP headers. Used by the http_header action."`
	// Maximum HTTP header size in KB.
	//  Used by the http_header action.
	HttpLargeHeaderSizeInKb int32 `json:"http_large_header_size_in_kb,omitempty" jsonschema:"Maximum HTTP header size in KB. Used by the http_header action."`
	// Default maximum connections per IP when no specific IP rule matches.
	//  Used by ip_based_max_connections.
	DefaultMaxConnections int32 `json:"default_max_connections,omitempty" jsonschema:"Default maximum connections per IP when no specific IP rule matches. Used by ip_based_max_connections."`
	// Per-IP connection limits.
	//  Used by ip_based_max_connections.
	IpMaxConnections []*IpMaxConnectionInput `json:"ip_max_connections,omitempty" jsonschema:"Per-IP connection limits. Used by ip_based_max_connections."`
	// Description of the rule.
	Description string `json:"description,omitempty" jsonschema:"Description of the rule."`
}

func (s *RuleSetItemInput) validate() error {
	switch s.Action {
	case "", "add_http_request_header", "add_http_response_header", "extend_http_request_header_value", "extend_http_response_header_value", "remove_http_request_header", "remove_http_response_header", "redirect", "allow", "control_access_using_http_methods", "http_header", "ip_based_max_connections":
	default:
		return fmt.Errorf("invalid action: %q", s.Action)
	}
	if s.RedirectUri != nil {
		if err := s.RedirectUri.validate(); err != nil {
			return fmt.Errorf("redirect_uri: %w", err)
		}
	}
	for i, v := range s.Conditions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("conditions[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.IpMaxConnections {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ip_max_connections[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *RuleSetItemInput) applyDefaults() {
	if s.RedirectUri != nil {
		s.RedirectUri.applyDefaults()
	}
}

func (s *RuleSetItemInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.Header != "" {
		m["header"] = s.Header
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.Prefix != "" {
		m["prefix"] = s.Prefix
	}
	if s.Suffix != "" {
		m["suffix"] = s.Suffix
	}
	if s.RedirectUri != nil {
		m["redirect_uri"] = s.RedirectUri.toMap()
	}
	if s.ResponseCode != 0 {
		m["response_code"] = s.ResponseCode
	}
	if len(s.Conditions) > 0 {
		items := make([]any, len(s.Conditions))
		for i, v := range s.Conditions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["conditions"] = items
	}
	if len(s.AllowedMethods) > 0 {
		m["allowed_methods"] = s.AllowedMethods
	}
	if s.StatusCode != 0 {
		m["status_code"] = s.StatusCode
	}
	if s.AreInvalidCharactersAllowed {
		m["are_invalid_characters_allowed"] = s.AreInvalidCharactersAllowed
	}
	if s.HttpLargeHeaderSizeInKb != 0 {
		m["http_large_header_size_in_kb"] = s.HttpLargeHeaderSizeInKb
	}
	if s.DefaultMaxConnections != 0 {
		m["default_max_connections"] = s.DefaultMaxConnections
	}
	if len(s.IpMaxConnections) > 0 {
		items := make([]any, len(s.IpMaxConnections))
		for i, v := range s.IpMaxConnections {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ip_max_connections"] = items
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// RuleSetItemCondition defines a condition for conditional rule application.
type RuleSetItemConditionInput struct {
	// Attribute to evaluate. Accepted values:
	//    "PATH", "SOURCE_IP_ADDRESS", "SOURCE_VCN_ID", "SOURCE_VCN_IP_ADDRESS".
	AttributeName string `json:"attribute_name,omitempty" jsonschema:"Attribute to evaluate. Accepted values: 'PATH'; 'SOURCE_IP_ADDRESS'; 'SOURCE_VCN_ID'; 'SOURCE_VCN_IP_ADDRESS'."`
	// Value to match against the attribute.
	AttributeValue string `json:"attribute_value,omitempty" jsonschema:"Value to match against the attribute."`
	// Matching operator. Accepted values:
	//    "EXACT_MATCH", "FORCE_LONGEST_PREFIX_MATCH", "PREFIX_MATCH", "SUFFIX_MATCH".
	//  When omitted, defaults to "EXACT_MATCH".
	Operator string `json:"operator,omitempty" jsonschema:"Matching operator. Accepted values: 'EXACT_MATCH'; 'FORCE_LONGEST_PREFIX_MATCH'; 'PREFIX_MATCH'; 'SUFFIX_MATCH'. When omitted; defaults to 'EXACT_MATCH'."`
}

func (s *RuleSetItemConditionInput) validate() error {
	return nil
}

func (s *RuleSetItemConditionInput) applyDefaults() {
}

func (s *RuleSetItemConditionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AttributeName != "" {
		m["attribute_name"] = s.AttributeName
	}
	if s.AttributeValue != "" {
		m["attribute_value"] = s.AttributeValue
	}
	if s.Operator != "" {
		m["operator"] = s.Operator
	}
	return m
}

// SessionPersistenceConfig configures session persistence using an
//
//	existing cookie managed by the backend application. The load balancer
//	reads this cookie to determine backend affinity.
type SessionPersistenceConfigInput struct {
	// Name of the application cookie used for session affinity.
	CookieName string `json:"cookie_name,omitempty" jsonschema:"Name of the application cookie used for session affinity."`
	// When true, connections from clients without the cookie are rejected
	//  rather than being assigned to a new backend.
	DisableFallback bool `json:"disable_fallback,omitempty" jsonschema:"When true; connections from clients without the cookie are rejected rather than being assigned to a new backend."`
}

func (s *SessionPersistenceConfigInput) validate() error {
	return nil
}

func (s *SessionPersistenceConfigInput) applyDefaults() {
}

func (s *SessionPersistenceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CookieName != "" {
		m["cookie_name"] = s.CookieName
	}
	if s.DisableFallback {
		m["disable_fallback"] = s.DisableFallback
	}
	return m
}

// ShapeDetails configures bandwidth for flexible-shape load balancers.
type ShapeDetailsInput struct {
	// Minimum bandwidth in Mbps. The load balancer always provides at least
	//  this bandwidth. Valid range: 10-8000.
	MinimumBandwidthInMbps int32 `json:"minimum_bandwidth_in_mbps,omitempty" jsonschema:"Minimum bandwidth in Mbps. The load balancer always provides at least this bandwidth. Valid range: 10-8000."`
	// Maximum bandwidth in Mbps. The load balancer can burst up to this
	//  bandwidth. Must be >= minimum_bandwidth_in_mbps. Valid range: 10-8000.
	MaximumBandwidthInMbps int32 `json:"maximum_bandwidth_in_mbps,omitempty" jsonschema:"Maximum bandwidth in Mbps. The load balancer can burst up to this bandwidth. Must be >= minimum_bandwidth_in_mbps. Valid range: 10-8000."`
}

func (s *ShapeDetailsInput) validate() error {
	return nil
}

func (s *ShapeDetailsInput) applyDefaults() {
}

func (s *ShapeDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinimumBandwidthInMbps != 0 {
		m["minimum_bandwidth_in_mbps"] = s.MinimumBandwidthInMbps
	}
	if s.MaximumBandwidthInMbps != 0 {
		m["maximum_bandwidth_in_mbps"] = s.MaximumBandwidthInMbps
	}
	return m
}

// SslConfiguration controls TLS/SSL settings for encrypted communication.
//
//	Used in both backend sets (backend-facing SSL) and listeners
//	(client-facing SSL).
type SslConfigurationInput struct {
	// OCIDs of OCI Certificate Service certificates.
	//  Preferred over certificate_name for certificate lifecycle management.
	CertificateIds []string `json:"certificate_ids,omitempty" jsonschema:"OCIDs of OCI Certificate Service certificates. Preferred over certificate_name for certificate lifecycle management."`
	// Name of a certificate resource defined in this load balancer's
	//  certificates list. Use certificate_ids instead for managed certificates.
	CertificateName string `json:"certificate_name,omitempty" jsonschema:"Name of a certificate resource defined in this load balancer's certificates list. Use certificate_ids instead for managed certificates."`
	// Name of the cipher suite for SSL negotiation.
	//  Example: "oci-default-ssl-cipher-suite-v1".
	CipherSuiteName string `json:"cipher_suite_name,omitempty" jsonschema:"Name of the cipher suite for SSL negotiation. Example: 'oci-default-ssl-cipher-suite-v1'."`
	// TLS protocol versions to accept.
	//  Example: ["TLSv1.2", "TLSv1.3"].
	Protocols []string `json:"protocols,omitempty" jsonschema:"TLS protocol versions to accept. Example: ['TLSv1.2'; 'TLSv1.3']."`
	// Server cipher order preference. Accepted values:
	//  "ENABLED" (server preference) or "DISABLED" (client preference).
	ServerOrderPreference string `json:"server_order_preference,omitempty" jsonschema:"Server cipher order preference. Accepted values: 'ENABLED' (server preference) or 'DISABLED' (client preference)."`
	// OCIDs of trusted CA certificates for verifying backend server
	//  certificates (backend SSL) or client certificates (mutual TLS).
	TrustedCertificateAuthorityIds []string `json:"trusted_certificate_authority_ids,omitempty" jsonschema:"OCIDs of trusted CA certificates for verifying backend server certificates (backend SSL) or client certificates (mutual TLS)."`
	// Maximum depth for certificate chain verification.
	//  When omitted, defaults to 5.
	VerifyDepth int32 `json:"verify_depth,omitempty" jsonschema:"Maximum depth for certificate chain verification. When omitted; defaults to 5."`
	// When true, the load balancer verifies the peer's certificate.
	//  For backend SSL: verifies the backend server certificate.
	//  For listener SSL with mutual TLS: verifies the client certificate.
	VerifyPeerCertificate bool `json:"verify_peer_certificate,omitempty" jsonschema:"When true; the load balancer verifies the peer's certificate. For backend SSL: verifies the backend server certificate. For listener SSL with mutual TLS: verifies the client certificate."`
	// When true, enables TLS session resumption for improved performance.
	//  Only applicable in listener SSL context. Ignored for backend set SSL.
	HasSessionResumption bool `json:"has_session_resumption,omitempty" jsonschema:"When true; enables TLS session resumption for improved performance. Only applicable in listener SSL context. Ignored for backend set SSL."`
}

func (s *SslConfigurationInput) validate() error {
	return nil
}

func (s *SslConfigurationInput) applyDefaults() {
}

func (s *SslConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.CertificateIds) > 0 {
		m["certificate_ids"] = s.CertificateIds
	}
	if s.CertificateName != "" {
		m["certificate_name"] = s.CertificateName
	}
	if s.CipherSuiteName != "" {
		m["cipher_suite_name"] = s.CipherSuiteName
	}
	if len(s.Protocols) > 0 {
		m["protocols"] = s.Protocols
	}
	if s.ServerOrderPreference != "" {
		m["server_order_preference"] = s.ServerOrderPreference
	}
	if len(s.TrustedCertificateAuthorityIds) > 0 {
		m["trusted_certificate_authority_ids"] = s.TrustedCertificateAuthorityIds
	}
	if s.VerifyDepth != 0 {
		m["verify_depth"] = s.VerifyDepth
	}
	if s.VerifyPeerCertificate {
		m["verify_peer_certificate"] = s.VerifyPeerCertificate
	}
	if s.HasSessionResumption {
		m["has_session_resumption"] = s.HasSessionResumption
	}
	return m
}

// ParseOciApplicationLoadBalancer validates and normalizes a OciApplicationLoadBalancer cloud_object.
func ParseOciApplicationLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciApplicationLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciApplicationLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
