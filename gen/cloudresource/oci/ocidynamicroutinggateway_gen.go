// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciDynamicRoutingGateway is the top-level resource representing an Oracle
//
//	Cloud Infrastructure Dynamic Routing Gateway with attachments, route tables,
//	and route distributions.
type OciDynamicRoutingGatewaySpecInput struct {
	// OCID of the compartment where the DRG will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the DRG will be created."`
	// Human-readable name for the DRG shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name for the DRG shown in the OCI Console. Falls back to metadata.name if not provided."`
	// Network attachments that connect VCNs or other network resources to this
	//  DRG. Each attachment can optionally reference a custom route table and/or
	//  a custom export route distribution defined within this component.
	Attachments []*DrgAttachmentInput `json:"attachments,omitempty" jsonschema:"Network attachments that connect VCNs or other network resources to this DRG. Each attachment can optionally reference a custom route table and/or a custom export route distribution defined within thi..."`
	// Custom DRG route tables for controlling traffic routing within the DRG.
	//  OCI automatically creates default route tables per network type; these
	//  are additional, user-defined tables. Route tables can import routes
	//  from a distribution and contain static route rules.
	RouteTables []*DrgRouteTableInput `json:"route_tables,omitempty" jsonschema:"Custom DRG route tables for controlling traffic routing within the DRG. OCI automatically creates default route tables per network type; these are additional; user-defined tables. Route tables can imp..."`
	// Custom route distributions for controlling which routes are advertised
	//  to DRG route tables (import) or to DRG attachments (export). OCI
	//  automatically creates a default export distribution; these are
	//  additional, user-defined distributions.
	RouteDistributions []*DrgRouteDistributionInput `json:"route_distributions,omitempty" jsonschema:"Custom route distributions for controlling which routes are advertised to DRG route tables (import) or to DRG attachments (export). OCI automatically creates a default export distribution; these are a..."`
}

func (s *OciDynamicRoutingGatewaySpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	for i, v := range s.Attachments {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("attachments[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RouteTables {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("route_tables[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RouteDistributions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("route_distributions[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciDynamicRoutingGatewaySpecInput) applyDefaults() {
}

func (s *OciDynamicRoutingGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if len(s.Attachments) > 0 {
		items := make([]any, len(s.Attachments))
		for i, v := range s.Attachments {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["attachments"] = items
	}
	if len(s.RouteTables) > 0 {
		items := make([]any, len(s.RouteTables))
		for i, v := range s.RouteTables {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["route_tables"] = items
	}
	if len(s.RouteDistributions) > 0 {
		items := make([]any, len(s.RouteDistributions))
		for i, v := range s.RouteDistributions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["route_distributions"] = items
	}
	return m
}

// DistributionStatement defines a single rule within a route distribution.
//
//	Each statement has a priority and match criteria. The action is always
//	ACCEPT (the only OCI-supported action) and is hardcoded in the IaC
//	modules.
type DistributionStatementInput struct {
	// Priority of this statement (1-65535). Lower numbers are evaluated
	//  first. Priorities must be unique within a distribution.
	Priority int32 `json:"priority,omitempty" jsonschema:"Priority of this statement (1-65535). Lower numbers are evaluated first. Priorities must be unique within a distribution."`
	// Criteria for matching routes. Determines which routes this
	//  statement applies to.
	MatchCriteria *MatchCriteriaInput `json:"match_criteria" jsonschema:"required,Criteria for matching routes. Determines which routes this statement applies to."`
}

func (s *DistributionStatementInput) validate() error {
	if s.MatchCriteria == nil {
		return fmt.Errorf("match_criteria is required")
	}
	if s.MatchCriteria != nil {
		if err := s.MatchCriteria.validate(); err != nil {
			return fmt.Errorf("match_criteria: %w", err)
		}
	}
	return nil
}

func (s *DistributionStatementInput) applyDefaults() {
	if s.MatchCriteria != nil {
		s.MatchCriteria.applyDefaults()
	}
}

func (s *DistributionStatementInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.MatchCriteria != nil {
		m["match_criteria"] = s.MatchCriteria.toMap()
	}
	return m
}

// DrgAttachment connects a network resource (VCN, IPSec tunnel, virtual
//
//	circuit, remote peering connection, or loopback) to the DRG.
//
//	A VCN can be attached to only one DRG at a time, but a DRG can have
//	multiple VCN attachments.
type DrgAttachmentInput struct {
	// Unique name for this attachment within the DRG component.
	//  Used by other sub-resources (route rules, distribution statements)
	//  to reference this attachment by name.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Unique name for this attachment within the DRG component. Used by other sub-resources (route rules; distribution statements) to reference this attachment by name."`
	// Details of the network being attached.
	NetworkDetails *NetworkDetailsInput `json:"network_details" jsonschema:"required,Details of the network being attached."`
	// Name of a DRG route table defined in this component's route_tables
	//  list. When set, the attachment uses this custom route table instead
	//  of the default route table for its network type.
	DrgRouteTableName string `json:"drg_route_table_name,omitempty" jsonschema:"Name of a DRG route table defined in this component's route_tables list. When set; the attachment uses this custom route table instead of the default route table for its network type."`
	// Name of a route distribution defined in this component's
	//  route_distributions list. When set, the attachment uses this
	//  distribution for exporting routes instead of the DRG's default
	//  export distribution.
	ExportDrgRouteDistributionName string `json:"export_drg_route_distribution_name,omitempty" jsonschema:"Name of a route distribution defined in this component's route_distributions list. When set; the attachment uses this distribution for exporting routes instead of the DRG's default export distribution..."`
}

func (s *DrgAttachmentInput) validate() error {
	if s.NetworkDetails == nil {
		return fmt.Errorf("network_details is required")
	}
	if s.NetworkDetails != nil {
		if err := s.NetworkDetails.validate(); err != nil {
			return fmt.Errorf("network_details: %w", err)
		}
	}
	return nil
}

func (s *DrgAttachmentInput) applyDefaults() {
	if s.NetworkDetails != nil {
		s.NetworkDetails.applyDefaults()
	}
}

func (s *DrgAttachmentInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.NetworkDetails != nil {
		m["network_details"] = s.NetworkDetails.toMap()
	}
	if s.DrgRouteTableName != "" {
		m["drg_route_table_name"] = s.DrgRouteTableName
	}
	if s.ExportDrgRouteDistributionName != "" {
		m["export_drg_route_distribution_name"] = s.ExportDrgRouteDistributionName
	}
	return m
}

// DrgRouteDistribution defines a route distribution that controls which
//
//	routes are advertised to route tables (import) or to attachments
//	(export). Distributions contain prioritized statements that match
//	against attachment criteria.
type DrgRouteDistributionInput struct {
	// Unique name for this distribution within the DRG component.
	//  Route tables and attachments reference distributions by this name.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Unique name for this distribution within the DRG component. Route tables and attachments reference distributions by this name."`
	// Whether this distribution controls route import or export.
	DistributionType string `json:"distribution_type,omitempty" jsonschema:"enum=import_routes|export_routes,Whether this distribution controls route import or export."`
	// Prioritized statements that define which routes are accepted.
	//  Statements are evaluated in priority order (lowest number first);
	//  the first matching statement determines the action.
	Statements []*DistributionStatementInput `json:"statements,omitempty" jsonschema:"Prioritized statements that define which routes are accepted. Statements are evaluated in priority order (lowest number first); the first matching statement determines the action."`
}

func (s *DrgRouteDistributionInput) validate() error {
	switch s.DistributionType {
	case "", "import_routes", "export_routes":
	default:
		return fmt.Errorf("invalid distribution_type: %q", s.DistributionType)
	}
	for i, v := range s.Statements {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("statements[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *DrgRouteDistributionInput) applyDefaults() {
}

func (s *DrgRouteDistributionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.DistributionType != "" {
		m["distribution_type"] = s.DistributionType
	}
	if len(s.Statements) > 0 {
		items := make([]any, len(s.Statements))
		for i, v := range s.Statements {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["statements"] = items
	}
	return m
}

// DrgRouteTable defines a custom route table within the DRG. Route tables
//
//	determine how traffic is forwarded between DRG attachments.
type DrgRouteTableInput struct {
	// Unique name for this route table within the DRG component.
	//  Attachments reference route tables by this name.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Unique name for this route table within the DRG component. Attachments reference route tables by this name."`
	// Name of a route distribution defined in this component's
	//  route_distributions list. When set, routes from matching
	//  attachments are automatically imported into this route table.
	ImportDrgRouteDistributionName string `json:"import_drg_route_distribution_name,omitempty" jsonschema:"Name of a route distribution defined in this component's route_distributions list. When set; routes from matching attachments are automatically imported into this route table."`
	// When true, enables Equal-Cost Multi-Path (ECMP) routing across
	//  multiple IPSec tunnels or virtual circuits. Traffic is distributed
	//  across paths with equal-cost routes.
	IsEcmpEnabled bool `json:"is_ecmp_enabled,omitempty" jsonschema:"When true; enables Equal-Cost Multi-Path (ECMP) routing across multiple IPSec tunnels or virtual circuits. Traffic is distributed across paths with equal-cost routes."`
	// Static route rules for this route table. Static routes take
	//  precedence over dynamically imported routes.
	StaticRouteRules []*StaticRouteRuleInput `json:"static_route_rules,omitempty" jsonschema:"Static route rules for this route table. Static routes take precedence over dynamically imported routes."`
}

func (s *DrgRouteTableInput) validate() error {
	for i, v := range s.StaticRouteRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("static_route_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *DrgRouteTableInput) applyDefaults() {
}

func (s *DrgRouteTableInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.ImportDrgRouteDistributionName != "" {
		m["import_drg_route_distribution_name"] = s.ImportDrgRouteDistributionName
	}
	if s.IsEcmpEnabled {
		m["is_ecmp_enabled"] = s.IsEcmpEnabled
	}
	if len(s.StaticRouteRules) > 0 {
		items := make([]any, len(s.StaticRouteRules))
		for i, v := range s.StaticRouteRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["static_route_rules"] = items
	}
	return m
}

// MatchCriteria defines how a distribution statement selects routes.
type MatchCriteriaInput struct {
	// How to match routes for this statement.
	MatchType string `json:"match_type,omitempty" jsonschema:"enum=match_all|drg_attachment_type|drg_attachment_id,How to match routes for this statement."`
	// Network attachment type to match against. Required when match_type
	//  is drg_attachment_type. Accepted values: "VCN", "IPSEC_TUNNEL",
	//  "VIRTUAL_CIRCUIT", "REMOTE_PEERING_CONNECTION".
	AttachmentType string `json:"attachment_type,omitempty" jsonschema:"Network attachment type to match against. Required when match_type is drg_attachment_type. Accepted values: 'VCN'; 'IPSEC_TUNNEL'; 'VIRTUAL_CIRCUIT'; 'REMOTE_PEERING_CONNECTION'."`
	// Name of a DRG attachment (defined in this component's attachments
	//  list) to match against. Required when match_type is
	//  drg_attachment_id.
	DrgAttachmentName string `json:"drg_attachment_name,omitempty" jsonschema:"Name of a DRG attachment (defined in this component's attachments list) to match against. Required when match_type is drg_attachment_id."`
}

func (s *MatchCriteriaInput) validate() error {
	switch s.MatchType {
	case "", "match_all", "drg_attachment_type", "drg_attachment_id":
	default:
		return fmt.Errorf("invalid match_type: %q", s.MatchType)
	}
	return nil
}

func (s *MatchCriteriaInput) applyDefaults() {
}

func (s *MatchCriteriaInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MatchType != "" {
		m["match_type"] = s.MatchType
	}
	if s.AttachmentType != "" {
		m["attachment_type"] = s.AttachmentType
	}
	if s.DrgAttachmentName != "" {
		m["drg_attachment_name"] = s.DrgAttachmentName
	}
	return m
}

// StaticRouteRule defines a static route in a DRG route table, directing
//
//	traffic for a specific CIDR block to a DRG attachment.
type StaticRouteRuleInput struct {
	// Destination CIDR block (IPv4 or IPv6) for this route.
	//  Example: "10.0.0.0/8", "192.168.1.0/24".
	Destination string `json:"destination,omitempty" jsonschema:"Destination CIDR block (IPv4 or IPv6) for this route. Example: '10.0.0.0/8'; '192.168.1.0/24'."`
	// Name of the DRG attachment (defined in this component's attachments
	//  list) that serves as the next hop for traffic matching this route.
	NextHopAttachmentName string `json:"next_hop_attachment_name,omitempty" jsonschema:"Name of the DRG attachment (defined in this component's attachments list) that serves as the next hop for traffic matching this route."`
}

func (s *StaticRouteRuleInput) validate() error {
	return nil
}

func (s *StaticRouteRuleInput) applyDefaults() {
}

func (s *StaticRouteRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Destination != "" {
		m["destination"] = s.Destination
	}
	if s.NextHopAttachmentName != "" {
		m["next_hop_attachment_name"] = s.NextHopAttachmentName
	}
	return m
}

// ParseOciDynamicRoutingGateway validates and normalizes a OciDynamicRoutingGateway cloud_object.
func ParseOciDynamicRoutingGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciDynamicRoutingGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciDynamicRoutingGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
