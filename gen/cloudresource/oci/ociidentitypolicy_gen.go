// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciIdentityPolicy is the top-level resource representing an Oracle Cloud
//
//	Infrastructure IAM policy for granting access to compartment resources.
type OciIdentityPolicySpecInput struct {
	// OCID of the compartment where this policy will be created.
	//  For tenancy-level policies, use the tenancy OCID.
	//  For compartment-scoped policies, use the target compartment's OCID.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where this policy will be created. For tenancy-level policies; use the tenancy OCID. For compartment-scoped policies; use the target compartment's OCID."`
	// Name assigned to the policy. Must be unique across all policies in the
	//  tenancy and cannot be changed after creation.
	//  Falls back to metadata.name if not provided.
	Name string `json:"name,omitempty" jsonschema:"Name assigned to the policy. Must be unique across all policies in the tenancy and cannot be changed after creation. Falls back to metadata.name if not provided."`
	// Description of the policy's purpose.
	//  Required by the OCI API. Updatable after creation.
	Description string `json:"description,omitempty" jsonschema:"Description of the policy's purpose. Required by the OCI API. Updatable after creation."`
	// Policy statements written in OCI's policy language.
	//  At least one statement is required. Each statement follows the syntax:
	//    "Allow <subject> to <verb> <resource-type> in <location> [where <conditions>]"
	//  See https://docs.oracle.com/iaas/Content/Identity/Concepts/policies.htm
	Statements []string `json:"statements,omitempty" jsonschema:"Policy statements written in OCI's policy language. At least one statement is required. Each statement follows the syntax: 'Allow <subject> to <verb> <resource-type> in <location> [where <conditions>]..."`
	// Version date for policy evaluation (YYYY-MM-DD format).
	//  When set, the policy is evaluated according to the behavior of OCI
	//  services on that date, providing a stable policy interpretation.
	//  When empty, the policy uses the current service behavior at evaluation time.
	VersionDate string `json:"version_date,omitempty" jsonschema:"Version date for policy evaluation (YYYY-MM-DD format). When set; the policy is evaluated according to the behavior of OCI services on that date; providing a stable policy interpretation. When empty; ..."`
}

func (s *OciIdentityPolicySpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if len(s.Statements) < 1 {
		return fmt.Errorf("statements requires at least 1 items, got %d", len(s.Statements))
	}
	return nil
}

func (s *OciIdentityPolicySpecInput) applyDefaults() {
}

func (s *OciIdentityPolicySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Statements) > 0 {
		m["statements"] = s.Statements
	}
	if s.VersionDate != "" {
		m["version_date"] = s.VersionDate
	}
	return m
}

// ParseOciIdentityPolicy validates and normalizes a OciIdentityPolicy cloud_object.
func ParseOciIdentityPolicy(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciIdentityPolicy"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciIdentityPolicySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
