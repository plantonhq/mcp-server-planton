// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciKmsKey is the top-level resource representing an OCI KMS Key
//
//	that provides cryptographic operations (encrypt, decrypt, sign, verify)
//	backed by a vault's HSM, software, or external key manager.
type OciKmsKeySpecInput struct {
	// OCID of the compartment where the key will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the key will be created."`
	// Display name for the key. When omitted, the metadata name is used.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Display name for the key. When omitted; the metadata name is used."`
	// Management endpoint of the vault that will contain this key.
	//  This is the vault-specific API endpoint for key management operations.
	ManagementEndpoint string `json:"management_endpoint" jsonschema:"required,Management endpoint of the vault that will contain this key. This is the vault-specific API endpoint for key management operations."`
	// Cryptographic properties of the key. Immutable after creation.
	KeyShape *KeyShapeInput `json:"key_shape" jsonschema:"required,Cryptographic properties of the key. Immutable after creation."`
	// Protection mode determines where key material is stored.
	//  When omitted, OCI defaults to HSM (hardware security module).
	//  Immutable after creation.
	ProtectionMode string `json:"protection_mode,omitempty" jsonschema:"enum=hsm|software|external,Protection mode determines where key material is stored. When omitted; OCI defaults to HSM (hardware security module). Immutable after creation."`
	// Whether automatic key rotation is enabled.
	IsAutoRotationEnabled bool `json:"is_auto_rotation_enabled,omitempty" jsonschema:"Whether automatic key rotation is enabled."`
	// Schedule configuration for automatic key rotation.
	//  Only valid when is_auto_rotation_enabled is true.
	AutoKeyRotationDetails *AutoKeyRotationDetailsInput `json:"auto_key_rotation_details,omitempty" jsonschema:"Schedule configuration for automatic key rotation. Only valid when is_auto_rotation_enabled is true."`
	// Reference to an external key on a third-party key manager.
	//  Required when protection_mode is external; must not be set otherwise.
	ExternalKeyReference *ExternalKeyReferenceInput `json:"external_key_reference,omitempty" jsonschema:"Reference to an external key on a third-party key manager. Required when protection_mode is external; must not be set otherwise."`
}

func (s *OciKmsKeySpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.ManagementEndpoint == "" {
		return fmt.Errorf("management_endpoint is required")
	}
	if s.KeyShape == nil {
		return fmt.Errorf("key_shape is required")
	}
	if s.KeyShape != nil {
		if err := s.KeyShape.validate(); err != nil {
			return fmt.Errorf("key_shape: %w", err)
		}
	}
	switch s.ProtectionMode {
	case "", "hsm", "software", "external":
	default:
		return fmt.Errorf("invalid protection_mode: %q", s.ProtectionMode)
	}
	if s.AutoKeyRotationDetails != nil {
		if err := s.AutoKeyRotationDetails.validate(); err != nil {
			return fmt.Errorf("auto_key_rotation_details: %w", err)
		}
	}
	if s.ExternalKeyReference != nil {
		if err := s.ExternalKeyReference.validate(); err != nil {
			return fmt.Errorf("external_key_reference: %w", err)
		}
	}
	return nil
}

func (s *OciKmsKeySpecInput) applyDefaults() {
	if s.KeyShape != nil {
		s.KeyShape.applyDefaults()
	}
	if s.AutoKeyRotationDetails != nil {
		s.AutoKeyRotationDetails.applyDefaults()
	}
	if s.ExternalKeyReference != nil {
		s.ExternalKeyReference.applyDefaults()
	}
}

func (s *OciKmsKeySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	m["management_endpoint"] = s.ManagementEndpoint
	if s.KeyShape != nil {
		m["key_shape"] = s.KeyShape.toMap()
	}
	if s.ProtectionMode != "" {
		m["protection_mode"] = s.ProtectionMode
	}
	if s.IsAutoRotationEnabled {
		m["is_auto_rotation_enabled"] = s.IsAutoRotationEnabled
	}
	if s.AutoKeyRotationDetails != nil {
		m["auto_key_rotation_details"] = s.AutoKeyRotationDetails.toMap()
	}
	if s.ExternalKeyReference != nil {
		m["external_key_reference"] = s.ExternalKeyReference.toMap()
	}
	return m
}

// AutoKeyRotationDetails configures the schedule for automatic
//
//	key rotation. Only the writable fields are exposed -- read-only
//	status fields (last_rotation_message, last_rotation_status,
//	time_of_last_rotation, time_of_next_rotation) are excluded.
type AutoKeyRotationDetailsInput struct {
	// Rotation interval in days. When omitted, OCI uses its default
	//  rotation interval.
	RotationIntervalInDays int32 `json:"rotation_interval_in_days,omitempty" jsonschema:"Rotation interval in days. When omitted; OCI uses its default rotation interval."`
	// RFC 3339 timestamp for when the first automatic rotation should
	//  occur. When omitted, OCI schedules based on creation time.
	TimeOfScheduleStart string `json:"time_of_schedule_start,omitempty" jsonschema:"RFC 3339 timestamp for when the first automatic rotation should occur. When omitted; OCI schedules based on creation time."`
}

func (s *AutoKeyRotationDetailsInput) validate() error {
	return nil
}

func (s *AutoKeyRotationDetailsInput) applyDefaults() {
}

func (s *AutoKeyRotationDetailsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RotationIntervalInDays != 0 {
		m["rotation_interval_in_days"] = s.RotationIntervalInDays
	}
	if s.TimeOfScheduleStart != "" {
		m["time_of_schedule_start"] = s.TimeOfScheduleStart
	}
	return m
}

// ExternalKeyReference identifies the key material on an external
//
//	key manager. Required when protection_mode is external.
type ExternalKeyReferenceInput struct {
	// Identifier of the key on the external key manager.
	ExternalKeyId string `json:"external_key_id,omitempty" jsonschema:"Identifier of the key on the external key manager."`
}

func (s *ExternalKeyReferenceInput) validate() error {
	return nil
}

func (s *ExternalKeyReferenceInput) applyDefaults() {
}

func (s *ExternalKeyReferenceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ExternalKeyId != "" {
		m["external_key_id"] = s.ExternalKeyId
	}
	return m
}

// KeyShape defines the immutable cryptographic properties of the key.
type KeyShapeInput struct {
	// Encryption algorithm. Immutable after creation.
	Algorithm string `json:"algorithm,omitempty" jsonschema:"enum=aes|rsa|ecdsa,Encryption algorithm. Immutable after creation."`
	// Key length in bytes. Valid values depend on the algorithm:
	//    AES:   16 (128-bit), 24 (192-bit), 32 (256-bit)
	//    RSA:   256 (2048-bit), 384 (3072-bit), 512 (4096-bit)
	//    ECDSA: 32 (P-256), 48 (P-384), 66 (P-521)
	Length int32 `json:"length,omitempty" jsonschema:"Key length in bytes. Valid values depend on the algorithm: AES: 16 (128-bit); 24 (192-bit); 32 (256-bit) RSA: 256 (2048-bit); 384 (3072-bit); 512 (4096-bit) ECDSA: 32 (P-256); 48 (P-384); 66 (P-521)"`
	// Elliptic curve identifier. Required for ECDSA; must not be set
	//  for AES or RSA.
	CurveId string `json:"curve_id,omitempty" jsonschema:"enum=nist_p256|nist_p384|nist_p521,Elliptic curve identifier. Required for ECDSA; must not be set for AES or RSA."`
}

func (s *KeyShapeInput) validate() error {
	switch s.Algorithm {
	case "", "aes", "rsa", "ecdsa":
	default:
		return fmt.Errorf("invalid algorithm: %q", s.Algorithm)
	}
	switch s.CurveId {
	case "", "nist_p256", "nist_p384", "nist_p521":
	default:
		return fmt.Errorf("invalid curve_id: %q", s.CurveId)
	}
	return nil
}

func (s *KeyShapeInput) applyDefaults() {
}

func (s *KeyShapeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Algorithm != "" {
		m["algorithm"] = s.Algorithm
	}
	if s.Length != 0 {
		m["length"] = s.Length
	}
	if s.CurveId != "" {
		m["curve_id"] = s.CurveId
	}
	return m
}

// ParseOciKmsKey validates and normalizes a OciKmsKey cloud_object.
func ParseOciKmsKey(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciKmsKey"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciKmsKeySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
