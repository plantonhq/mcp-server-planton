// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package oci

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OciSubnet is the top-level resource representing an Oracle Cloud Infrastructure
//
//	subnet within a Virtual Cloud Network (VCN).
type OciSubnetSpecInput struct {
	// OCID of the compartment where the subnet will be created.
	CompartmentId string `json:"compartment_id" jsonschema:"required,OCID of the compartment where the subnet will be created."`
	// OCID of the VCN that this subnet belongs to.
	VcnId string `json:"vcn_id" jsonschema:"required,OCID of the VCN that this subnet belongs to."`
	// IPv4 CIDR block for the subnet (e.g. "10.0.1.0/24").
	//  Must be within one of the VCN's CIDR blocks and not overlap with other subnets.
	CidrBlock string `json:"cidr_block" jsonschema:"required,IPv4 CIDR block for the subnet (e.g. '10.0.1.0/24'). Must be within one of the VCN's CIDR blocks and not overlap with other subnets."`
	// Human-readable name shown in the OCI Console.
	//  Falls back to metadata.name if not provided.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable name shown in the OCI Console. Falls back to metadata.name if not provided."`
	// DNS label for the subnet. Combined with the VCN and subnet domain, forms
	//  the FQDN: <dns_label>.<vcn_dns_label>.oraclevcn.com
	//  Must be alphanumeric, start with a letter, and be at most 15 characters.
	DnsLabel string `json:"dns_label,omitempty" jsonschema:"DNS label for the subnet. Combined with the VCN and subnet domain; forms the FQDN: <dns_label>.<vcn_dns_label>.oraclevcn.com Must be alphanumeric; start with a letter; and be at most 15 characters."`
	// Availability domain name (e.g. "Iocq:US-ASHBURN-AD-1").
	//  When omitted, the subnet is regional and spans all ADs in the region.
	//  When set, the subnet is scoped to a single AD.
	AvailabilityDomain string `json:"availability_domain,omitempty" jsonschema:"Availability domain name (e.g. 'Iocq:US-ASHBURN-AD-1'). When omitted; the subnet is regional and spans all ADs in the region. When set; the subnet is scoped to a single AD."`
	// When true, VNICs in this subnet cannot have public IP addresses.
	//  This is the primary control for making a subnet private.
	ProhibitPublicIpOnVnic bool `json:"prohibit_public_ip_on_vnic,omitempty" jsonschema:"When true; VNICs in this subnet cannot have public IP addresses. This is the primary control for making a subnet private."`
	// When true, the subnet blocks all inbound internet traffic to VNICs,
	//  even if a security rule or NSG would otherwise allow it.
	ProhibitInternetIngress bool `json:"prohibit_internet_ingress,omitempty" jsonschema:"When true; the subnet blocks all inbound internet traffic to VNICs; even if a security rule or NSG would otherwise allow it."`
	// OCID of custom DHCP options to use instead of the VCN's default.
	DhcpOptionsId string `json:"dhcp_options_id,omitempty" jsonschema:"OCID of custom DHCP options to use instead of the VCN's default."`
	// OCID of an existing route table to associate with this subnet.
	//  Mutually exclusive with route_rules. If neither is provided, the VCN's
	//  default route table is used.
	RouteTableId string `json:"route_table_id,omitempty" jsonschema:"OCID of an existing route table to associate with this subnet. Mutually exclusive with route_rules. If neither is provided; the VCN's default route table is used."`
	// Security list OCIDs to associate with this subnet. OCI allows a maximum
	//  of 5 security lists per subnet.
	SecurityListIds []string `json:"security_list_ids,omitempty" jsonschema:"Security list OCIDs to associate with this subnet. OCI allows a maximum of 5 security lists per subnet."`
	// IPv6 CIDR block for dual-stack subnets (e.g. "2001:0db8:0123:1111::/64").
	//  Only valid when the parent VCN has IPv6 enabled.
	Ipv6CidrBlock string `json:"ipv6_cidr_block,omitempty" jsonschema:"IPv6 CIDR block for dual-stack subnets (e.g. '2001:0db8:0123:1111::/64'). Only valid when the parent VCN has IPv6 enabled."`
	// Route rules for a custom route table that will be created and owned by
	//  this subnet. Mutually exclusive with route_table_id.
	RouteRules []*RouteRuleInput `json:"route_rules,omitempty" jsonschema:"Route rules for a custom route table that will be created and owned by this subnet. Mutually exclusive with route_table_id."`
}

func (s *OciSubnetSpecInput) validate() error {
	if s.CompartmentId == "" {
		return fmt.Errorf("compartment_id is required")
	}
	if s.VcnId == "" {
		return fmt.Errorf("vcn_id is required")
	}
	if s.CidrBlock == "" {
		return fmt.Errorf("cidr_block is required")
	}
	for i, v := range s.RouteRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("route_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OciSubnetSpecInput) applyDefaults() {
}

func (s *OciSubnetSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["compartment_id"] = s.CompartmentId
	m["vcn_id"] = s.VcnId
	m["cidr_block"] = s.CidrBlock
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.DnsLabel != "" {
		m["dns_label"] = s.DnsLabel
	}
	if s.AvailabilityDomain != "" {
		m["availability_domain"] = s.AvailabilityDomain
	}
	if s.ProhibitPublicIpOnVnic {
		m["prohibit_public_ip_on_vnic"] = s.ProhibitPublicIpOnVnic
	}
	if s.ProhibitInternetIngress {
		m["prohibit_internet_ingress"] = s.ProhibitInternetIngress
	}
	if s.DhcpOptionsId != "" {
		m["dhcp_options_id"] = s.DhcpOptionsId
	}
	if s.RouteTableId != "" {
		m["route_table_id"] = s.RouteTableId
	}
	if len(s.SecurityListIds) > 0 {
		m["security_list_ids"] = s.SecurityListIds
	}
	if s.Ipv6CidrBlock != "" {
		m["ipv6_cidr_block"] = s.Ipv6CidrBlock
	}
	if len(s.RouteRules) > 0 {
		items := make([]any, len(s.RouteRules))
		for i, v := range s.RouteRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["route_rules"] = items
	}
	return m
}

// RouteRule defines a single routing rule within a custom route table.
type RouteRuleInput struct {
	// Target IP range in CIDR notation (e.g. "0.0.0.0/0") or a service CIDR
	//  label (e.g. "all-iad-services-in-oracle-services-network").
	Destination string `json:"destination" jsonschema:"required,Target IP range in CIDR notation (e.g. '0.0.0.0/0') or a service CIDR label (e.g. 'all-iad-services-in-oracle-services-network')."`
	// Whether destination is a CIDR block or a service CIDR block.
	DestinationType string `json:"destination_type,omitempty" jsonschema:"enum=cidr_block|service_cidr_block,Whether destination is a CIDR block or a service CIDR block."`
	// OCID of the network entity to route matching traffic to
	//  (Internet Gateway, NAT Gateway, DRG, Service Gateway, Local Peering Gateway, etc.).
	NetworkEntityId string `json:"network_entity_id" jsonschema:"required,OCID of the network entity to route matching traffic to (Internet Gateway; NAT Gateway; DRG; Service Gateway; Local Peering Gateway; etc.)."`
	// Optional human-readable description for this rule.
	Description string `json:"description,omitempty" jsonschema:"Optional human-readable description for this rule."`
}

func (s *RouteRuleInput) validate() error {
	if s.Destination == "" {
		return fmt.Errorf("destination is required")
	}
	switch s.DestinationType {
	case "", "cidr_block", "service_cidr_block":
	default:
		return fmt.Errorf("invalid destination_type: %q", s.DestinationType)
	}
	if s.NetworkEntityId == "" {
		return fmt.Errorf("network_entity_id is required")
	}
	return nil
}

func (s *RouteRuleInput) applyDefaults() {
}

func (s *RouteRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["destination"] = s.Destination
	if s.DestinationType != "" {
		m["destination_type"] = s.DestinationType
	}
	m["network_entity_id"] = s.NetworkEntityId
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ParseOciSubnet validates and normalizes a OciSubnet cloud_object.
func ParseOciSubnet(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "oci.openmcf.org/v1", "OciSubnet"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OciSubnetSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
