// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesTektonOperator is the top-level resource for deploying Tekton Operator on a Kubernetes cluster.
//
//	Tekton Operator manages the lifecycle of Tekton components including Pipelines, Triggers, and Dashboard.
type KubernetesTektonOperatorSpecInput struct {
	// Target Kubernetes Cluster where the Tekton Operator will be deployed.
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster where the Tekton Operator will be deployed."`
	// The container specifications for the Tekton Operator deployment.
	Container *KubernetesTektonOperatorSpecContainerInput `json:"container" jsonschema:"required,The container specifications for the Tekton Operator deployment."`
	// Configuration for which Tekton components to install.
	Components *KubernetesTektonOperatorComponentsInput `json:"components" jsonschema:"required,Configuration for which Tekton components to install."`
	// The version of the Tekton Operator to deploy.
	//  https://github.com/tektoncd/operator/releases
	//  https://operatorhub.io/operator/tektoncd-operator
	OperatorVersion string `json:"operator_version,omitempty" jsonschema:"The version of the Tekton Operator to deploy. https://github.com/tektoncd/operator/releases https://operatorhub.io/operator/tektoncd-operator"`
	// Dashboard ingress configuration for exposing the dashboard via Gateway API.
	//  When enabled, creates Certificate, Gateway, and HTTPRoute resources.
	DashboardIngress *KubernetesTektonOperatorDashboardIngressInput `json:"dashboard_ingress,omitempty" jsonschema:"Dashboard ingress configuration for exposing the dashboard via Gateway API. When enabled; creates Certificate; Gateway; and HTTPRoute resources."`
	// CloudEvents sink URL for pipeline notifications.
	//  When configured, Tekton sends CloudEvents for TaskRun and PipelineRun lifecycle events.
	//  Example: "http://my-receiver.my-namespace.svc.cluster.local/tekton/events"
	CloudEventsSinkUrl string `json:"cloud_events_sink_url,omitempty" jsonschema:"CloudEvents sink URL for pipeline notifications. When configured; Tekton sends CloudEvents for TaskRun and PipelineRun lifecycle events. Example: 'http://my-receiver.my-namespace.svc.cluster.local/tek..."`
}

func (s *KubernetesTektonOperatorSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Components == nil {
		return fmt.Errorf("components is required")
	}
	if s.Components != nil {
		if err := s.Components.validate(); err != nil {
			return fmt.Errorf("components: %w", err)
		}
	}
	if s.DashboardIngress != nil {
		if err := s.DashboardIngress.validate(); err != nil {
			return fmt.Errorf("dashboard_ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTektonOperatorSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Components != nil {
		s.Components.applyDefaults()
	}
	if s.OperatorVersion == "" {
		s.OperatorVersion = "v0.78.0"
	}
	if s.DashboardIngress != nil {
		s.DashboardIngress.applyDefaults()
	}
}

func (s *KubernetesTektonOperatorSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Components != nil {
		m["components"] = s.Components.toMap()
	}
	if s.OperatorVersion != "" {
		m["operator_version"] = s.OperatorVersion
	}
	if s.DashboardIngress != nil {
		m["dashboard_ingress"] = s.DashboardIngress.toMap()
	}
	if s.CloudEventsSinkUrl != "" {
		m["cloud_events_sink_url"] = s.CloudEventsSinkUrl
	}
	return m
}

// KubernetesTektonOperatorComponents specifies which Tekton components should be installed by the operator.
//
//	At least one component must be enabled.
type KubernetesTektonOperatorComponentsInput struct {
	// Enable Tekton Pipelines component for running CI/CD pipelines.
	//  Pipelines is the core component and is typically always enabled.
	Pipelines bool `json:"pipelines,omitempty" jsonschema:"Enable Tekton Pipelines component for running CI/CD pipelines. Pipelines is the core component and is typically always enabled."`
	// Enable Tekton Triggers component for event-driven pipeline execution.
	//  Triggers allows pipelines to be started by external events like webhooks.
	Triggers bool `json:"triggers,omitempty" jsonschema:"Enable Tekton Triggers component for event-driven pipeline execution. Triggers allows pipelines to be started by external events like webhooks."`
	// Enable Tekton Dashboard for a web-based UI to view and manage pipelines.
	Dashboard bool `json:"dashboard,omitempty" jsonschema:"Enable Tekton Dashboard for a web-based UI to view and manage pipelines."`
}

func (s *KubernetesTektonOperatorComponentsInput) validate() error {
	return nil
}

func (s *KubernetesTektonOperatorComponentsInput) applyDefaults() {
}

func (s *KubernetesTektonOperatorComponentsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Pipelines {
		m["pipelines"] = s.Pipelines
	}
	if s.Triggers {
		m["triggers"] = s.Triggers
	}
	if s.Dashboard {
		m["dashboard"] = s.Dashboard
	}
	return m
}

// KubernetesTektonOperatorDashboardIngress configures ingress for the Tekton Dashboard.
//
//	When enabled, exposes the dashboard via Kubernetes Gateway API with TLS termination.
type KubernetesTektonOperatorDashboardIngressInput struct {
	// Enable dashboard ingress.
	//  When true, creates Certificate, Gateway, and HTTPRoute resources.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable dashboard ingress. When true; creates Certificate; Gateway; and HTTPRoute resources."`
	// Hostname for the dashboard ingress.
	//  Example: "tekton-dashboard.example.com"
	//  The ClusterIssuer name is derived from the domain portion of the hostname.
	Hostname string `json:"hostname,omitempty" jsonschema:"Hostname for the dashboard ingress. Example: 'tekton-dashboard.example.com' The ClusterIssuer name is derived from the domain portion of the hostname."`
}

func (s *KubernetesTektonOperatorDashboardIngressInput) validate() error {
	return nil
}

func (s *KubernetesTektonOperatorDashboardIngressInput) applyDefaults() {
}

func (s *KubernetesTektonOperatorDashboardIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// KubernetesTektonOperatorSpecContainer specifies the container configuration for the Tekton Operator.
//
//	It includes resource allocations for CPU and memory to ensure the operator runs efficiently.
type KubernetesTektonOperatorSpecContainerInput struct {
	// The CPU and memory resources allocated to the Tekton Operator container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Tekton Operator container."`
}

func (s *KubernetesTektonOperatorSpecContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTektonOperatorSpecContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesTektonOperatorSpecContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// ParseKubernetesTektonOperator validates and normalizes a KubernetesTektonOperator cloud_object.
func ParseKubernetesTektonOperator(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesTektonOperator"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesTektonOperatorSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
