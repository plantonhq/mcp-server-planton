// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesTekton deploys Tekton Pipelines and Dashboard on Kubernetes using official release manifests.
//
//	This is the manifest-based deployment approach (as opposed to the operator-based KubernetesTektonOperator).
//	It's simpler to understand and debug, and gives direct control over configuration.
type KubernetesTektonSpecInput struct {
	// Target Kubernetes Cluster where Tekton will be deployed.
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster where Tekton will be deployed."`
	// The version of Tekton Pipelines to deploy.
	//  This maps to release versions from https://github.com/tektoncd/pipeline/releases
	//  Examples: "latest", "v0.65.2", "v0.64.0"
	PipelineVersion string `json:"pipeline_version,omitempty" jsonschema:"The version of Tekton Pipelines to deploy. This maps to release versions from https://github.com/tektoncd/pipeline/releases Examples: 'latest'; 'v0.65.2'; 'v0.64.0'"`
	// Dashboard configuration for Tekton.
	//  The dashboard provides a web UI for viewing and managing pipelines.
	Dashboard *KubernetesTektonDashboardInput `json:"dashboard,omitempty" jsonschema:"Dashboard configuration for Tekton. The dashboard provides a web UI for viewing and managing pipelines."`
	// Cloud Events configuration for pipeline notifications.
	//  When configured, Tekton will send CloudEvents to the specified sink URL
	//  for TaskRun and PipelineRun lifecycle events.
	CloudEvents *KubernetesTektonCloudEventsInput `json:"cloud_events,omitempty" jsonschema:"Cloud Events configuration for pipeline notifications. When configured; Tekton will send CloudEvents to the specified sink URL for TaskRun and PipelineRun lifecycle events."`
}

func (s *KubernetesTektonSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Dashboard != nil {
		if err := s.Dashboard.validate(); err != nil {
			return fmt.Errorf("dashboard: %w", err)
		}
	}
	if s.CloudEvents != nil {
		if err := s.CloudEvents.validate(); err != nil {
			return fmt.Errorf("cloud_events: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTektonSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.PipelineVersion == "" {
		s.PipelineVersion = "latest"
	}
	if s.Dashboard != nil {
		s.Dashboard.applyDefaults()
	}
	if s.CloudEvents != nil {
		s.CloudEvents.applyDefaults()
	}
}

func (s *KubernetesTektonSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	if s.PipelineVersion != "" {
		m["pipeline_version"] = s.PipelineVersion
	}
	if s.Dashboard != nil {
		m["dashboard"] = s.Dashboard.toMap()
	}
	if s.CloudEvents != nil {
		m["cloud_events"] = s.CloudEvents.toMap()
	}
	return m
}

// KubernetesTektonCloudEvents configures CloudEvents integration for Tekton.
//
//	CloudEvents are sent for TaskRun and PipelineRun state changes, enabling
//	external systems to react to pipeline events.
//
//	This configuration is applied to the 'config-defaults' ConfigMap in the tekton-pipelines namespace.
//	See: https://tekton.dev/docs/pipelines/additional-configs/#configuring-cloudevents-notifications
type KubernetesTektonCloudEventsInput struct {
	// The URL where CloudEvents will be sent.
	//  Must be a valid HTTP/HTTPS URL that can receive CloudEvents.
	//  Example: "http://my-service.my-namespace.svc.cluster.local/tekton/events"
	SinkUrl string `json:"sink_url,omitempty" jsonschema:"The URL where CloudEvents will be sent. Must be a valid HTTP/HTTPS URL that can receive CloudEvents. Example: 'http://my-service.my-namespace.svc.cluster.local/tekton/events'"`
}

func (s *KubernetesTektonCloudEventsInput) validate() error {
	return nil
}

func (s *KubernetesTektonCloudEventsInput) applyDefaults() {
}

func (s *KubernetesTektonCloudEventsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SinkUrl != "" {
		m["sink_url"] = s.SinkUrl
	}
	return m
}

// KubernetesTektonDashboard configures the Tekton Dashboard deployment.
//
//	The dashboard provides a web UI for viewing pipelines, tasks, and runs.
type KubernetesTektonDashboardInput struct {
	// Flag to enable or disable dashboard deployment.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable dashboard deployment."`
	// The version of Tekton Dashboard to deploy.
	//  This maps to release versions from https://github.com/tektoncd/dashboard/releases
	//  Examples: "latest", "v0.53.0", "v0.52.0"
	Version string `json:"version,omitempty" jsonschema:"The version of Tekton Dashboard to deploy. This maps to release versions from https://github.com/tektoncd/dashboard/releases Examples: 'latest'; 'v0.53.0'; 'v0.52.0'"`
	// Ingress configuration for external access to the dashboard.
	Ingress *KubernetesTektonDashboardIngressInput `json:"ingress,omitempty" jsonschema:"Ingress configuration for external access to the dashboard."`
}

func (s *KubernetesTektonDashboardInput) validate() error {
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTektonDashboardInput) applyDefaults() {
	if s.Version == "" {
		s.Version = "latest"
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesTektonDashboardInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	return m
}

// KubernetesTektonDashboardIngress configures external access to the Tekton Dashboard
//
//	using Kubernetes Gateway API with TLS termination and HTTP-to-HTTPS redirect.
type KubernetesTektonDashboardIngressInput struct {
	// Flag to enable or disable dashboard ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable dashboard ingress."`
	// The full hostname for external access to the dashboard.
	//  Example: "tekton-dashboard.example.com"
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access to the dashboard. Example: 'tekton-dashboard.example.com' Required when enabled is true."`
}

func (s *KubernetesTektonDashboardIngressInput) validate() error {
	return nil
}

func (s *KubernetesTektonDashboardIngressInput) applyDefaults() {
}

func (s *KubernetesTektonDashboardIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// ParseKubernetesTekton validates and normalizes a KubernetesTekton cloud_object.
func ParseKubernetesTekton(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesTekton"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesTektonSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
