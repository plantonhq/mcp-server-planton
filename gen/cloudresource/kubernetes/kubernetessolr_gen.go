// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// solr-kubernetes
type KubernetesSolrSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The specifications for the Solr container deployment.
	SolrContainer *KubernetesSolrSolrContainerInput `json:"solr_container,omitempty" jsonschema:"The specifications for the Solr container deployment."`
	// The Solr-specific configuration options.
	Config *KubernetesSolrSolrConfigInput `json:"config,omitempty" jsonschema:"The Solr-specific configuration options."`
	// The specifications for the Zookeeper container deployment.
	ZookeeperContainer *KubernetesSolrZookeeperContainerInput `json:"zookeeper_container,omitempty" jsonschema:"The specifications for the Zookeeper container deployment."`
	// The ingress configuration for the Solr deployment.
	Ingress *KubernetesSolrIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the Solr deployment."`
}

func (s *KubernetesSolrSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.SolrContainer != nil {
		if err := s.SolrContainer.validate(); err != nil {
			return fmt.Errorf("solr_container: %w", err)
		}
	}
	if s.Config != nil {
		if err := s.Config.validate(); err != nil {
			return fmt.Errorf("config: %w", err)
		}
	}
	if s.ZookeeperContainer != nil {
		if err := s.ZookeeperContainer.validate(); err != nil {
			return fmt.Errorf("zookeeper_container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSolrSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.SolrContainer != nil {
		s.SolrContainer.applyDefaults()
	}
	if s.Config != nil {
		s.Config.applyDefaults()
	}
	if s.ZookeeperContainer != nil {
		s.ZookeeperContainer.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesSolrSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.SolrContainer != nil {
		m["solr_container"] = s.SolrContainer.toMap()
	}
	if s.Config != nil {
		m["config"] = s.Config.toMap()
	}
	if s.ZookeeperContainer != nil {
		m["zookeeper_container"] = s.ZookeeperContainer.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	return m
}

// *
//
//	KubernetesSolrIngress defines ingress configuration for Solr.
type KubernetesSolrIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "solr.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'solr.example.com'). Required when enabled is true."`
}

func (s *KubernetesSolrIngressInput) validate() error {
	return nil
}

func (s *KubernetesSolrIngressInput) applyDefaults() {
}

func (s *KubernetesSolrIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	**KubernetesSolrSolrConfig** specifies the configuration settings for Solr.
//	It includes JVM memory settings, custom Solr options, and garbage collection tuning parameters.
type KubernetesSolrSolrConfigInput struct {
	// JVM memory settings for Solr.
	JavaMem string `json:"java_mem,omitempty" jsonschema:"JVM memory settings for Solr."`
	// Custom Solr options (e.g., "-Dsolr.autoSoftCommit.maxTime=10000").
	Opts string `json:"opts,omitempty" jsonschema:"Custom Solr options (e.g.; '-Dsolr.autoSoftCommit.maxTime=10000')."`
	// Solr garbage collection tuning configuration (e.g., "-XX:SurvivorRatio=4 -XX:TargetSurvivorRatio=90 -XX:MaxTenuringThreshold=8").
	GarbageCollectionTuning string `json:"garbage_collection_tuning,omitempty" jsonschema:"Solr garbage collection tuning configuration (e.g.; '-XX:SurvivorRatio=4 -XX:TargetSurvivorRatio=90 -XX:MaxTenuringThreshold=8')."`
}

func (s *KubernetesSolrSolrConfigInput) validate() error {
	return nil
}

func (s *KubernetesSolrSolrConfigInput) applyDefaults() {
}

func (s *KubernetesSolrSolrConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.JavaMem != "" {
		m["java_mem"] = s.JavaMem
	}
	if s.Opts != "" {
		m["opts"] = s.Opts
	}
	if s.GarbageCollectionTuning != "" {
		m["garbage_collection_tuning"] = s.GarbageCollectionTuning
	}
	return m
}

// *
//
//	**KubernetesSolrSolrContainer** specifies the configuration for the Solr container.
//	It includes settings such as the number of replicas, container image, resource allocations,
//	disk size for data persistence, and Solr-specific configurations.
//	Proper configuration ensures optimal performance and data reliability for your Solr deployment.
type KubernetesSolrSolrContainerInput struct {
	// The number of Solr pods in the Solr Kubernetes deployment.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of Solr pods in the Solr Kubernetes deployment."`
	// The CPU and memory resources allocated to the Solr container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Solr container."`
	// The size of the persistent volume attached to each Solr pod (e.g., "1Gi").
	DiskSize string `json:"disk_size,omitempty" jsonschema:"The size of the persistent volume attached to each Solr pod (e.g.; '1Gi')."`
	// The container image for the Solr deployment.
	// Example repository: "solr", example tag: "8.7.0".
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image for the Solr deployment. Example repository: 'solr'; example tag: '8.7.0'."`
}

func (s *KubernetesSolrSolrContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSolrSolrContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesSolrSolrContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	return m
}

// *
//
//	**KubernetesSolrZookeeperContainer** specifies the configuration for the Zookeeper container used by Solr.
//	It includes settings such as the number of replicas, resource allocations, and disk size for data persistence.
//	Proper configuration ensures high availability and reliability for your Solr cluster.
type KubernetesSolrZookeeperContainerInput struct {
	// The number of Zookeeper pods in the Zookeeper cluster.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of Zookeeper pods in the Zookeeper cluster."`
	// The CPU and memory resources allocated to the Zookeeper container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Zookeeper container."`
	// The size of the persistent volume attached to each Zookeeper pod (e.g., "1Gi").
	DiskSize string `json:"disk_size,omitempty" jsonschema:"The size of the persistent volume attached to each Zookeeper pod (e.g.; '1Gi')."`
}

func (s *KubernetesSolrZookeeperContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSolrZookeeperContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesSolrZookeeperContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// ParseKubernetesSolr validates and normalizes a KubernetesSolr cloud_object.
func ParseKubernetesSolr(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesSolr"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesSolrSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
