// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// kubernetes-external-secrets
type KubernetesExternalSecretsSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// How often the controller polls the backing secret store (in seconds).
	//  Very small values can incur high cloud‑API costs.
	PollIntervalSeconds uint32 `json:"poll_interval_seconds,omitempty" jsonschema:"How often the controller polls the backing secret store (in seconds). Very small values can incur high cloud‑API costs."`
	// CPU / memory tuning for the ESO controller container.
	Container *KubernetesExternalSecretsSpecContainerInput `json:"container" jsonschema:"required,CPU / memory tuning for the ESO controller container."`
	// Google Cloud Secrets Manager + Workload Identity.
	Gke *KubernetesExternalSecretsGkeConfigInput `json:"gke,omitempty" jsonschema:"Google Cloud Secrets Manager + Workload Identity."`
	// AWS Secrets Manager + IRSA.
	Eks *KubernetesExternalSecretsEksConfigInput `json:"eks,omitempty" jsonschema:"AWS Secrets Manager + IRSA."`
	// Azure Key Vault + Workload / Managed Identity.
	Aks *KubernetesExternalSecretsAksConfigInput `json:"aks,omitempty" jsonschema:"Azure Key Vault + Workload / Managed Identity."`
}

func (s *KubernetesExternalSecretsSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Gke != nil {
		if err := s.Gke.validate(); err != nil {
			return fmt.Errorf("gke: %w", err)
		}
	}
	if s.Eks != nil {
		if err := s.Eks.validate(); err != nil {
			return fmt.Errorf("eks: %w", err)
		}
	}
	if s.Aks != nil {
		if err := s.Aks.validate(); err != nil {
			return fmt.Errorf("aks: %w", err)
		}
	}
	return nil
}

func (s *KubernetesExternalSecretsSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.PollIntervalSeconds == 0 {
		s.PollIntervalSeconds = 10
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Gke != nil {
		s.Gke.applyDefaults()
	}
	if s.Eks != nil {
		s.Eks.applyDefaults()
	}
	if s.Aks != nil {
		s.Aks.applyDefaults()
	}
}

func (s *KubernetesExternalSecretsSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.PollIntervalSeconds != 0 {
		m["poll_interval_seconds"] = s.PollIntervalSeconds
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Gke != nil {
		m["gke"] = s.Gke.toMap()
	}
	if s.Eks != nil {
		m["eks"] = s.Eks.toMap()
	}
	if s.Aks != nil {
		m["aks"] = s.Aks.toMap()
	}
	return m
}

// AKS + Azure Key Vault.
type KubernetesExternalSecretsAksConfigInput struct {
	// Azure Key Vault resource ID that stores the secrets.
	KeyVaultResourceId string `json:"key_vault_resource_id,omitempty" jsonschema:"Azure Key Vault resource ID that stores the secrets."`
	// Optional client ID of an existing managed identity to bind to ESO.
	ManagedIdentityClientId string `json:"managed_identity_client_id,omitempty" jsonschema:"Optional client ID of an existing managed identity to bind to ESO."`
}

func (s *KubernetesExternalSecretsAksConfigInput) validate() error {
	return nil
}

func (s *KubernetesExternalSecretsAksConfigInput) applyDefaults() {
}

func (s *KubernetesExternalSecretsAksConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.KeyVaultResourceId != "" {
		m["key_vault_resource_id"] = s.KeyVaultResourceId
	}
	if s.ManagedIdentityClientId != "" {
		m["managed_identity_client_id"] = s.ManagedIdentityClientId
	}
	return m
}

// EKS + AWS Secrets Manager.
type KubernetesExternalSecretsEksConfigInput struct {
	// AWS region containing the secret store (defaults to cluster region if empty).
	Region string `json:"region,omitempty" jsonschema:"AWS region containing the secret store (defaults to cluster region if empty)."`
	// Optional existing IAM role ARN for IRSA; auto‑created if left blank.
	IrsaRoleArnOverride string `json:"irsa_role_arn_override,omitempty" jsonschema:"Optional existing IAM role ARN for IRSA; auto‑created if left blank."`
}

func (s *KubernetesExternalSecretsEksConfigInput) validate() error {
	return nil
}

func (s *KubernetesExternalSecretsEksConfigInput) applyDefaults() {
}

func (s *KubernetesExternalSecretsEksConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.IrsaRoleArnOverride != "" {
		m["irsa_role_arn_override"] = s.IrsaRoleArnOverride
	}
	return m
}

// GKE + Google Cloud Secrets Manager.
type KubernetesExternalSecretsGkeConfigInput struct {
	// GCP project hosting both the secrets and the GKE cluster.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project hosting both the secrets and the GKE cluster."`
	// Google service‑account e‑mail used via Workload Identity.
	GsaEmail string `json:"gsa_email" jsonschema:"required,Google service‑account e‑mail used via Workload Identity."`
}

func (s *KubernetesExternalSecretsGkeConfigInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.GsaEmail == "" {
		return fmt.Errorf("gsa_email is required")
	}
	return nil
}

func (s *KubernetesExternalSecretsGkeConfigInput) applyDefaults() {
}

func (s *KubernetesExternalSecretsGkeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["gsa_email"] = s.GsaEmail
	return m
}

// Resource limits / requests for the controller container.
type KubernetesExternalSecretsSpecContainerInput struct {
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:""`
}

func (s *KubernetesExternalSecretsSpecContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesExternalSecretsSpecContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesExternalSecretsSpecContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// ParseKubernetesExternalSecrets validates and normalizes a KubernetesExternalSecrets cloud_object.
func ParseKubernetesExternalSecrets(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesExternalSecrets"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesExternalSecretsSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
