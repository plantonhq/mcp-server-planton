// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// *
//
//	**KubernetesNamespace** defines a Kubernetes namespace resource following the Kubernetes Resource Model (KRM).
//	This resource represents a complete namespace deployment with resource quotas, network policies,
//	and access controls configured according to the "Namespace-as-a-Service" pattern.
type KubernetesNamespaceSpecInput struct {
	// The Kubernetes cluster in which the namespace should be created
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"The Kubernetes cluster in which the namespace should be created"`
	// *
	//  The unique name of the namespace.
	//  This will be used as the Kubernetes namespace metadata.name.
	//  Must be a valid DNS label (lowercase alphanumeric and hyphens).
	Name string `json:"name,omitempty" jsonschema:"* The unique name of the namespace. This will be used as the Kubernetes namespace metadata.name. Must be a valid DNS label (lowercase alphanumeric and hyphens)."`
	// *
	//  Additional labels to be applied to the namespace.
	//  These are merged with standard labels (environment, team, cost-center) for
	//  cost allocation, monitoring, and governance.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"* Additional labels to be applied to the namespace. These are merged with standard labels (environment; team; cost-center) for cost allocation; monitoring; and governance."`
	// *
	//  Additional annotations to be applied to the namespace.
	//  Common use cases:
	//  - linkerd.io/inject: "enabled" for service mesh injection
	//  - janitor/ttl: "24h" for ephemeral namespace cleanup
	//  - scheduler.alpha.kubernetes.io/node-selector: for node affinity
	Annotations map[string]string `json:"annotations,omitempty" jsonschema:"* Additional annotations to be applied to the namespace. Common use cases: - linkerd.io/inject: 'enabled' for service mesh injection - janitor/ttl: '24h' for ephemeral namespace cleanup - scheduler.al..."`
	// *
	//  Resource allocation profile for the namespace.
	//  This abstracts ResourceQuota and LimitRange configuration into T-shirt sizes
	//  or allows custom specifications for advanced users.
	ResourceProfile *KubernetesNamespaceResourceProfileInput `json:"resource_profile,omitempty" jsonschema:"* Resource allocation profile for the namespace. This abstracts ResourceQuota and LimitRange configuration into T-shirt sizes or allows custom specifications for advanced users."`
	// *
	//  Network isolation and security configuration.
	//  Controls ingress/egress network policies to enforce zero-trust networking.
	NetworkConfig *KubernetesNamespaceNetworkConfigInput `json:"network_config,omitempty" jsonschema:"* Network isolation and security configuration. Controls ingress/egress network policies to enforce zero-trust networking."`
	// *
	//  Service mesh integration configuration.
	//  Enables automatic sidecar injection and mesh-specific features.
	ServiceMeshConfig *KubernetesNamespaceServiceMeshConfigInput `json:"service_mesh_config,omitempty" jsonschema:"* Service mesh integration configuration. Enables automatic sidecar injection and mesh-specific features."`
	// *
	//  Pod security standards enforcement level.
	//  Defines the security posture for pods running in the namespace.
	PodSecurityStandard string `json:"pod_security_standard,omitempty" jsonschema:"enum=privileged|baseline|restricted,* Pod security standards enforcement level. Defines the security posture for pods running in the namespace."`
}

func (s *KubernetesNamespaceSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.ResourceProfile != nil {
		if err := s.ResourceProfile.validate(); err != nil {
			return fmt.Errorf("resource_profile: %w", err)
		}
	}
	if s.NetworkConfig != nil {
		if err := s.NetworkConfig.validate(); err != nil {
			return fmt.Errorf("network_config: %w", err)
		}
	}
	if s.ServiceMeshConfig != nil {
		if err := s.ServiceMeshConfig.validate(); err != nil {
			return fmt.Errorf("service_mesh_config: %w", err)
		}
	}
	switch s.PodSecurityStandard {
	case "", "privileged", "baseline", "restricted":
	default:
		return fmt.Errorf("invalid pod_security_standard: %q", s.PodSecurityStandard)
	}
	return nil
}

func (s *KubernetesNamespaceSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.ResourceProfile != nil {
		s.ResourceProfile.applyDefaults()
	}
	if s.NetworkConfig != nil {
		s.NetworkConfig.applyDefaults()
	}
	if s.ServiceMeshConfig != nil {
		s.ServiceMeshConfig.applyDefaults()
	}
}

func (s *KubernetesNamespaceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Annotations) > 0 {
		m["annotations"] = s.Annotations
	}
	if s.ResourceProfile != nil {
		m["resource_profile"] = s.ResourceProfile.toMap()
	}
	if s.NetworkConfig != nil {
		m["network_config"] = s.NetworkConfig.toMap()
	}
	if s.ServiceMeshConfig != nil {
		m["service_mesh_config"] = s.ServiceMeshConfig.toMap()
	}
	if s.PodSecurityStandard != "" {
		m["pod_security_standard"] = s.PodSecurityStandard
	}
	return m
}

// *
//
//	**KubernetesNamespaceCpuQuota** defines CPU resource quotas.
type KubernetesNamespaceCpuQuotaInput struct {
	// Total CPU requests allowed (e.g., "4", "4000m")
	Requests string `json:"requests,omitempty" jsonschema:"Total CPU requests allowed (e.g.; '4'; '4000m')"`
	// Total CPU limits allowed (e.g., "8", "8000m")
	Limits string `json:"limits,omitempty" jsonschema:"Total CPU limits allowed (e.g.; '8'; '8000m')"`
}

func (s *KubernetesNamespaceCpuQuotaInput) validate() error {
	return nil
}

func (s *KubernetesNamespaceCpuQuotaInput) applyDefaults() {
}

func (s *KubernetesNamespaceCpuQuotaInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Requests != "" {
		m["requests"] = s.Requests
	}
	if s.Limits != "" {
		m["limits"] = s.Limits
	}
	return m
}

// *
//
//	**KubernetesNamespaceCustomQuotas** allows explicit specification of resource limits.
//	This is for advanced users who need precise control over quotas.
type KubernetesNamespaceCustomQuotasInput struct {
	// CPU resource limits
	Cpu *KubernetesNamespaceCpuQuotaInput `json:"cpu,omitempty" jsonschema:"CPU resource limits"`
	// Memory resource limits
	Memory *KubernetesNamespaceMemoryQuotaInput `json:"memory,omitempty" jsonschema:"Memory resource limits"`
	// Object count limits (pods, services, configmaps, secrets)
	ObjectCounts *KubernetesNamespaceObjectCountQuotasInput `json:"object_counts,omitempty" jsonschema:"Object count limits (pods; services; configmaps; secrets)"`
	// Default resource requests/limits for containers without explicit values
	DefaultLimits *KubernetesNamespaceDefaultLimitsInput `json:"default_limits,omitempty" jsonschema:"Default resource requests/limits for containers without explicit values"`
}

func (s *KubernetesNamespaceCustomQuotasInput) validate() error {
	if s.Cpu != nil {
		if err := s.Cpu.validate(); err != nil {
			return fmt.Errorf("cpu: %w", err)
		}
	}
	if s.Memory != nil {
		if err := s.Memory.validate(); err != nil {
			return fmt.Errorf("memory: %w", err)
		}
	}
	if s.ObjectCounts != nil {
		if err := s.ObjectCounts.validate(); err != nil {
			return fmt.Errorf("object_counts: %w", err)
		}
	}
	if s.DefaultLimits != nil {
		if err := s.DefaultLimits.validate(); err != nil {
			return fmt.Errorf("default_limits: %w", err)
		}
	}
	return nil
}

func (s *KubernetesNamespaceCustomQuotasInput) applyDefaults() {
	if s.Cpu != nil {
		s.Cpu.applyDefaults()
	}
	if s.Memory != nil {
		s.Memory.applyDefaults()
	}
	if s.ObjectCounts != nil {
		s.ObjectCounts.applyDefaults()
	}
	if s.DefaultLimits != nil {
		s.DefaultLimits.applyDefaults()
	}
}

func (s *KubernetesNamespaceCustomQuotasInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Cpu != nil {
		m["cpu"] = s.Cpu.toMap()
	}
	if s.Memory != nil {
		m["memory"] = s.Memory.toMap()
	}
	if s.ObjectCounts != nil {
		m["object_counts"] = s.ObjectCounts.toMap()
	}
	if s.DefaultLimits != nil {
		m["default_limits"] = s.DefaultLimits.toMap()
	}
	return m
}

// *
//
//	**KubernetesNamespaceDefaultLimits** defines default resource requests/limits.
//	These are automatically injected into containers that don't specify their own values.
//	This is implemented via LimitRange in Kubernetes.
type KubernetesNamespaceDefaultLimitsInput struct {
	// Default CPU request (e.g., "100m")
	DefaultCpuRequest string `json:"default_cpu_request,omitempty" jsonschema:"Default CPU request (e.g.; '100m')"`
	// Default CPU limit (e.g., "1000m")
	DefaultCpuLimit string `json:"default_cpu_limit,omitempty" jsonschema:"Default CPU limit (e.g.; '1000m')"`
	// Default memory request (e.g., "128Mi")
	DefaultMemoryRequest string `json:"default_memory_request,omitempty" jsonschema:"Default memory request (e.g.; '128Mi')"`
	// Default memory limit (e.g., "512Mi")
	DefaultMemoryLimit string `json:"default_memory_limit,omitempty" jsonschema:"Default memory limit (e.g.; '512Mi')"`
}

func (s *KubernetesNamespaceDefaultLimitsInput) validate() error {
	return nil
}

func (s *KubernetesNamespaceDefaultLimitsInput) applyDefaults() {
}

func (s *KubernetesNamespaceDefaultLimitsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DefaultCpuRequest != "" {
		m["default_cpu_request"] = s.DefaultCpuRequest
	}
	if s.DefaultCpuLimit != "" {
		m["default_cpu_limit"] = s.DefaultCpuLimit
	}
	if s.DefaultMemoryRequest != "" {
		m["default_memory_request"] = s.DefaultMemoryRequest
	}
	if s.DefaultMemoryLimit != "" {
		m["default_memory_limit"] = s.DefaultMemoryLimit
	}
	return m
}

// *
//
//	**KubernetesNamespaceMemoryQuota** defines memory resource quotas.
type KubernetesNamespaceMemoryQuotaInput struct {
	// Total memory requests allowed (e.g., "8Gi", "8192Mi")
	Requests string `json:"requests,omitempty" jsonschema:"Total memory requests allowed (e.g.; '8Gi'; '8192Mi')"`
	// Total memory limits allowed (e.g., "16Gi", "16384Mi")
	Limits string `json:"limits,omitempty" jsonschema:"Total memory limits allowed (e.g.; '16Gi'; '16384Mi')"`
}

func (s *KubernetesNamespaceMemoryQuotaInput) validate() error {
	return nil
}

func (s *KubernetesNamespaceMemoryQuotaInput) applyDefaults() {
}

func (s *KubernetesNamespaceMemoryQuotaInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Requests != "" {
		m["requests"] = s.Requests
	}
	if s.Limits != "" {
		m["limits"] = s.Limits
	}
	return m
}

// *
//
//	**KubernetesNamespaceNetworkConfig** defines network isolation and security policies.
//	This implements the "Default Deny" security pattern with explicit allow rules.
type KubernetesNamespaceNetworkConfigInput struct {
	// *
	//  Enable ingress network isolation.
	//  When true, creates a NetworkPolicy that denies all ingress traffic by default.
	//  Traffic must be explicitly allowed.
	IsolateIngress bool `json:"isolate_ingress,omitempty" jsonschema:"* Enable ingress network isolation. When true; creates a NetworkPolicy that denies all ingress traffic by default. Traffic must be explicitly allowed."`
	// *
	//  Enable egress network restriction.
	//  When true, blocks all egress except to kube-system (DNS) and Kubernetes API.
	//  This prevents pods from accessing external networks without explicit rules.
	RestrictEgress bool `json:"restrict_egress,omitempty" jsonschema:"* Enable egress network restriction. When true; blocks all egress except to kube-system (DNS) and Kubernetes API. This prevents pods from accessing external networks without explicit rules."`
	// *
	//  Allow ingress from specific namespaces.
	//  List of namespace names that are allowed to send traffic to this namespace.
	AllowedIngressNamespaces []string `json:"allowed_ingress_namespaces,omitempty" jsonschema:"* Allow ingress from specific namespaces. List of namespace names that are allowed to send traffic to this namespace."`
	// *
	//  Allow egress to specific external CIDR blocks.
	//  List of CIDR blocks (e.g., "10.0.0.0/8", "192.168.1.0/24") that pods can access.
	AllowedEgressCidrs []string `json:"allowed_egress_cidrs,omitempty" jsonschema:"* Allow egress to specific external CIDR blocks. List of CIDR blocks (e.g.; '10.0.0.0/8'; '192.168.1.0/24') that pods can access."`
	// *
	//  Allow egress to specific DNS domains.
	//  List of domains (e.g., "api.stripe.com", "*.github.com") that pods can access.
	//  Requires a CNI that supports DNS-based policies (like Calico or Cilium).
	AllowedEgressDomains []string `json:"allowed_egress_domains,omitempty" jsonschema:"* Allow egress to specific DNS domains. List of domains (e.g.; 'api.stripe.com'; '*.github.com') that pods can access. Requires a CNI that supports DNS-based policies (like Calico or Cilium)."`
}

func (s *KubernetesNamespaceNetworkConfigInput) validate() error {
	return nil
}

func (s *KubernetesNamespaceNetworkConfigInput) applyDefaults() {
}

func (s *KubernetesNamespaceNetworkConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsolateIngress {
		m["isolate_ingress"] = s.IsolateIngress
	}
	if s.RestrictEgress {
		m["restrict_egress"] = s.RestrictEgress
	}
	if len(s.AllowedIngressNamespaces) > 0 {
		m["allowed_ingress_namespaces"] = s.AllowedIngressNamespaces
	}
	if len(s.AllowedEgressCidrs) > 0 {
		m["allowed_egress_cidrs"] = s.AllowedEgressCidrs
	}
	if len(s.AllowedEgressDomains) > 0 {
		m["allowed_egress_domains"] = s.AllowedEgressDomains
	}
	return m
}

// *
//
//	**KubernetesNamespaceObjectCountQuotas** defines limits on Kubernetes object counts.
//	This prevents control plane exhaustion from excessive object creation.
type KubernetesNamespaceObjectCountQuotasInput struct {
	// Maximum number of pods
	Pods int32 `json:"pods,omitempty" jsonschema:"Maximum number of pods"`
	// Maximum number of services
	Services int32 `json:"services,omitempty" jsonschema:"Maximum number of services"`
	// Maximum number of configmaps
	Configmaps int32 `json:"configmaps,omitempty" jsonschema:"Maximum number of configmaps"`
	// Maximum number of secrets
	Secrets int32 `json:"secrets,omitempty" jsonschema:"Maximum number of secrets"`
	// Maximum number of persistent volume claims
	PersistentVolumeClaims int32 `json:"persistent_volume_claims,omitempty" jsonschema:"Maximum number of persistent volume claims"`
	// Maximum number of load balancers
	LoadBalancers int32 `json:"load_balancers,omitempty" jsonschema:"Maximum number of load balancers"`
}

func (s *KubernetesNamespaceObjectCountQuotasInput) validate() error {
	return nil
}

func (s *KubernetesNamespaceObjectCountQuotasInput) applyDefaults() {
}

func (s *KubernetesNamespaceObjectCountQuotasInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Pods != 0 {
		m["pods"] = s.Pods
	}
	if s.Services != 0 {
		m["services"] = s.Services
	}
	if s.Configmaps != 0 {
		m["configmaps"] = s.Configmaps
	}
	if s.Secrets != 0 {
		m["secrets"] = s.Secrets
	}
	if s.PersistentVolumeClaims != 0 {
		m["persistent_volume_claims"] = s.PersistentVolumeClaims
	}
	if s.LoadBalancers != 0 {
		m["load_balancers"] = s.LoadBalancers
	}
	return m
}

// *
//
//	**KubernetesNamespaceResourceProfile** defines resource limits and quotas for the namespace.
//	This abstracts the complexity of ResourceQuota and LimitRange into intuitive profiles.
type KubernetesNamespaceResourceProfileInput struct {
	// Pre-defined T-shirt size profiles (small, medium, large, xlarge).
	//  These provide opinionated defaults for different namespace sizes.
	Preset string `json:"preset,omitempty" jsonschema:"enum=small|medium|large|xlarge,Pre-defined T-shirt size profiles (small; medium; large; xlarge). These provide opinionated defaults for different namespace sizes."`
	// Custom resource limits for advanced users who need precise control.
	Custom *KubernetesNamespaceCustomQuotasInput `json:"custom,omitempty" jsonschema:"Custom resource limits for advanced users who need precise control."`
}

func (s *KubernetesNamespaceResourceProfileInput) validate() error {
	switch s.Preset {
	case "", "small", "medium", "large", "xlarge":
	default:
		return fmt.Errorf("invalid preset: %q", s.Preset)
	}
	if s.Custom != nil {
		if err := s.Custom.validate(); err != nil {
			return fmt.Errorf("custom: %w", err)
		}
	}
	return nil
}

func (s *KubernetesNamespaceResourceProfileInput) applyDefaults() {
	if s.Custom != nil {
		s.Custom.applyDefaults()
	}
}

func (s *KubernetesNamespaceResourceProfileInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Preset != "" {
		m["preset"] = s.Preset
	}
	if s.Custom != nil {
		m["custom"] = s.Custom.toMap()
	}
	return m
}

// *
//
//	**KubernetesNamespaceServiceMeshConfig** defines service mesh integration.
//	This supports automatic sidecar injection and mesh lifecycle management.
type KubernetesNamespaceServiceMeshConfigInput struct {
	// *
	//  Enable service mesh sidecar injection.
	//  When true, service mesh proxies are automatically injected into pods.
	Enabled bool `json:"enabled,omitempty" jsonschema:"* Enable service mesh sidecar injection. When true; service mesh proxies are automatically injected into pods."`
	// *
	//  Service mesh type.
	//  Determines which mesh to use (Istio, Linkerd, etc.).
	MeshType string `json:"mesh_type,omitempty" jsonschema:"enum=istio|linkerd|consul,* Service mesh type. Determines which mesh to use (Istio; Linkerd; etc.)."`
	// *
	//  Mesh revision tag (Istio-specific).
	//  Allows pointing to a specific control plane version without hardcoding the version.
	//  Example: "prod-stable", "canary", "1-19-5"
	//  This enables safe, granular mesh upgrades.
	RevisionTag string `json:"revision_tag,omitempty" jsonschema:"* Mesh revision tag (Istio-specific). Allows pointing to a specific control plane version without hardcoding the version. Example: 'prod-stable'; 'canary'; '1-19-5' This enables safe; granular mesh up..."`
}

func (s *KubernetesNamespaceServiceMeshConfigInput) validate() error {
	switch s.MeshType {
	case "", "istio", "linkerd", "consul":
	default:
		return fmt.Errorf("invalid mesh_type: %q", s.MeshType)
	}
	return nil
}

func (s *KubernetesNamespaceServiceMeshConfigInput) applyDefaults() {
}

func (s *KubernetesNamespaceServiceMeshConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.MeshType != "" {
		m["mesh_type"] = s.MeshType
	}
	if s.RevisionTag != "" {
		m["revision_tag"] = s.RevisionTag
	}
	return m
}

// ParseKubernetesNamespace validates and normalizes a KubernetesNamespace cloud_object.
func ParseKubernetesNamespace(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesNamespace"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesNamespaceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
