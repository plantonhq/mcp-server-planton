// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesManifest is a generic deployment component for deploying raw Kubernetes manifests.
//
//	It supports single or multi-document YAML manifests containing any valid Kubernetes resources.
type KubernetesManifestSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	//  The namespace where the manifest resources will be deployed.
	//  Note: Resources in the manifest that specify their own namespace will use their specified namespace.
	//  Resources without a namespace specified will use this namespace.
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace The namespace where the manifest resources will be deployed. Note: Resources in the manifest that specify their own namespace will use their specified namespace. Resources without..."`
	// Flag to indicate if the namespace should be created.
	//  When true, the namespace will be created before applying the manifest.
	//  When false, the namespace must already exist.
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created. When true; the namespace will be created before applying the manifest. When false; the namespace must already exist."`
	// The raw Kubernetes manifest YAML to deploy.
	//  This can be a single manifest or multiple manifests separated by "---".
	//  All valid Kubernetes resources are supported: Deployments, Services, ConfigMaps,
	//  Secrets, CRDs, Custom Resources, and any other Kubernetes resource types.
	//
	//  Example single manifest:...
	ManifestYaml string `json:"manifest_yaml" jsonschema:"required,The raw Kubernetes manifest YAML to deploy. This can be a single manifest or multiple manifests separated by '---'. All valid Kubernetes resources are supported: Deployments; Services; ConfigMaps; Sec..."`
}

func (s *KubernetesManifestSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.ManifestYaml == "" {
		return fmt.Errorf("manifest_yaml is required")
	}
	return nil
}

func (s *KubernetesManifestSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
}

func (s *KubernetesManifestSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	m["manifest_yaml"] = s.ManifestYaml
	return m
}

// ParseKubernetesManifest validates and normalizes a KubernetesManifest cloud_object.
func ParseKubernetesManifest(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesManifest"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesManifestSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
