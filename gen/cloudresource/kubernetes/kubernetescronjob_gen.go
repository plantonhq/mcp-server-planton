// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cron-job-kubernetes
type KubernetesCronJobSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// *
	//  The container image to be used for the application.
	//  The `pull_secret_name` is determined by looking up the
	//  `container_image_artifact_store_id` from the environment where the cron-job is deployed.
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"* The container image to be used for the application. The 'pull_secret_name' is determined by looking up the 'container_image_artifact_store_id' from the environment where the cron-job is deployed."`
	// *
	//  The CPU and memory resources allocated to the cron-job container.
	//  If not specified, default container resources (limits.cpu=1000m, limits.memory=1Gi,
	//  requests.cpu=50m, requests.memory=100Mi) are applied.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"* The CPU and memory resources allocated to the cron-job container. If not specified; default container resources (limits.cpu=1000m; limits.memory=1Gi; requests.cpu=50m; requests.memory=100Mi) are app..."`
	// *
	//  Environment variables and secrets for the cron-job container.
	//  This includes both straightforward environment variables (key=value)
	//  and references to secrets.
	Env *KubernetesCronJobContainerAppEnvInput `json:"env,omitempty" jsonschema:"* Environment variables and secrets for the cron-job container. This includes both straightforward environment variables (key=value) and references to secrets."`
	// *
	//  A cron schedule expression in standard Cron format, e.g. "0 0 * * *".
	//  This field is required.
	Schedule string `json:"schedule" jsonschema:"required,* A cron schedule expression in standard Cron format; e.g. '0 0 * * *'. This field is required."`
	// *
	//  Optional deadline in seconds for starting the job if it misses its scheduled time.
	//  If set to 0, no deadline is enforced.
	StartingDeadlineSeconds uint64 `json:"starting_deadline_seconds,omitempty" jsonschema:"* Optional deadline in seconds for starting the job if it misses its scheduled time. If set to 0; no deadline is enforced."`
	// *
	//  Concurrency policy specifies how concurrent job runs are handled.
	//  Allowed values are: "Allow", "Forbid", "Replace".
	//  Default is "Forbid".
	ConcurrencyPolicy string `json:"concurrency_policy,omitempty" jsonschema:"* Concurrency policy specifies how concurrent job runs are handled. Allowed values are: 'Allow'; 'Forbid'; 'Replace'. Default is 'Forbid'."`
	// *
	//  If true, no subsequent runs are scheduled.
	//  Default is false.
	Suspend bool `json:"suspend,omitempty" jsonschema:"* If true; no subsequent runs are scheduled. Default is false."`
	// *
	//  Number of successful finished jobs to retain.
	//  Default is 3.
	SuccessfulJobsHistoryLimit uint32 `json:"successful_jobs_history_limit,omitempty" jsonschema:"* Number of successful finished jobs to retain. Default is 3."`
	// *
	//  Number of failed finished jobs to retain.
	//  Default is 1.
	FailedJobsHistoryLimit uint32 `json:"failed_jobs_history_limit,omitempty" jsonschema:"* Number of failed finished jobs to retain. Default is 1."`
	// *
	//  Number of retries before marking this job as failed.
	//  Default is 6.
	BackoffLimit uint32 `json:"backoff_limit,omitempty" jsonschema:"* Number of retries before marking this job as failed. Default is 6."`
	// *
	//  Pod restart policy.
	//  Allowed values: "Always", "OnFailure", "Never".
	//  Default is "Never".
	RestartPolicy string `json:"restart_policy,omitempty" jsonschema:"* Pod restart policy. Allowed values: 'Always'; 'OnFailure'; 'Never'. Default is 'Never'."`
	// *
	//  An optional list of commands (equivalent to an ENTRYPOINT override) for the cron-job container.
	//  If omitted, the default ENTRYPOINT in the image will be used.
	//  Example: ["sh","-c","echo Hello from Cron"]
	Command []string `json:"command,omitempty" jsonschema:"* An optional list of commands (equivalent to an ENTRYPOINT override) for the cron-job container. If omitted; the default ENTRYPOINT in the image will be used. Example: ['sh';'-c';'echo Hello from Cro..."`
	// *
	//  An optional list of arguments passed to the container command or the image's default ENTRYPOINT.
	//  If omitted, the default CMD in the image will be used.
	//  Example: ["-f","/path/to/config.yaml"]
	Args []string `json:"args,omitempty" jsonschema:"* An optional list of arguments passed to the container command or the image's default ENTRYPOINT. If omitted; the default CMD in the image will be used. Example: ['-f';'/path/to/config.yaml']"`
	// *
	//  ConfigMaps to create alongside the CronJob.
	//  Key is the ConfigMap name, value is the content.
	//  These ConfigMaps can be referenced in volume mounts.
	//
	//  Example:
	//    config_maps:
	//      backup-script: |
	//        #!/bin/bash
	//        echo "Running backup..."
	//        pg_dump $DATABASE_URL > /backup/dump.sql
	ConfigMaps map[string]string `json:"config_maps,omitempty" jsonschema:"* ConfigMaps to create alongside the CronJob. Key is the ConfigMap name; value is the content. These ConfigMaps can be referenced in volume mounts. Example: config_maps: backup-script: | #!/bin/bash e..."`
	// *
	//  Volume mounts for the CronJob container.
	//  Supports mounting ConfigMaps, Secrets, HostPaths, EmptyDirs, and PVCs.
	//  ConfigMaps defined in spec.config_maps can be referenced here.
	//
	//  Example:
	//    volume_mounts:
	//      - name: backup-script
	//        mountPath: /scripts/backup.sh
	//        configMap:
	//          ...
	VolumeMounts []*VolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"* Volume mounts for the CronJob container. Supports mounting ConfigMaps; Secrets; HostPaths; EmptyDirs; and PVCs. ConfigMaps defined in spec.config_maps can be referenced here. Example: volume_mounts:..."`
}

func (s *KubernetesCronJobSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	if s.Schedule == "" {
		return fmt.Errorf("schedule is required")
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesCronJobSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.StartingDeadlineSeconds == 0 {
		s.StartingDeadlineSeconds = 0
	}
	if s.ConcurrencyPolicy == "" {
		s.ConcurrencyPolicy = "Forbid"
	}
	if s.SuccessfulJobsHistoryLimit == 0 {
		s.SuccessfulJobsHistoryLimit = 3
	}
	if s.FailedJobsHistoryLimit == 0 {
		s.FailedJobsHistoryLimit = 1
	}
	if s.BackoffLimit == 0 {
		s.BackoffLimit = 6
	}
	if s.RestartPolicy == "" {
		s.RestartPolicy = "Never"
	}
}

func (s *KubernetesCronJobSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	m["schedule"] = s.Schedule
	if s.StartingDeadlineSeconds != 0 {
		m["starting_deadline_seconds"] = s.StartingDeadlineSeconds
	}
	if s.ConcurrencyPolicy != "" {
		m["concurrency_policy"] = s.ConcurrencyPolicy
	}
	if s.Suspend {
		m["suspend"] = s.Suspend
	}
	if s.SuccessfulJobsHistoryLimit != 0 {
		m["successful_jobs_history_limit"] = s.SuccessfulJobsHistoryLimit
	}
	if s.FailedJobsHistoryLimit != 0 {
		m["failed_jobs_history_limit"] = s.FailedJobsHistoryLimit
	}
	if s.BackoffLimit != 0 {
		m["backoff_limit"] = s.BackoffLimit
	}
	if s.RestartPolicy != "" {
		m["restart_policy"] = s.RestartPolicy
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	if len(s.ConfigMaps) > 0 {
		m["config_maps"] = s.ConfigMaps
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	return m
}

// *
//
//	KubernetesCronJobContainerAppEnv defines the environment variables
//	and secrets for the cron-job container.
type KubernetesCronJobContainerAppEnvInput struct {
	// *
	//  A map of environment variable names to their values.
	//  Each variable can be provided either as a literal string value or as a reference
	//  to another OpenMCF resource's field.
	//
	//  **Option 1: Direct string value**
	//  ```yaml
	//  variables:
	//    BACKUP_RETENTION_DAYS:
	//      value: "30"
	//  ```
	//
	//  **Option 2: Refer...
	Variables map[string]string `json:"variables,omitempty" jsonschema:"* A map of environment variable names to their values. Each variable can be provided either as a literal string value or as a reference to another OpenMCF resource's field. **Option 1: Direct string v..."`
	// *
	//  A map of secret environment variable names to their values.
	//  Each secret can be provided either as a literal string value or as a reference
	//  to an existing Kubernetes Secret.
	//
	//  Using secret references is recommended for production deployments.
	Secrets map[string]*KubernetesSensitiveValueInput `json:"secrets,omitempty" jsonschema:"* A map of secret environment variable names to their values. Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret. Using secret references i..."`
}

func (s *KubernetesCronJobContainerAppEnvInput) validate() error {
	for k, v := range s.Secrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secrets[%s]: %w", k, err)
			}
		}
	}
	return nil
}

func (s *KubernetesCronJobContainerAppEnvInput) applyDefaults() {
}

func (s *KubernetesCronJobContainerAppEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		result := make(map[string]any, len(s.Secrets))
		for k, v := range s.Secrets {
			if v != nil {
				result[k] = v.toMap()
			}
		}
		m["secrets"] = result
	}
	return m
}

// ParseKubernetesCronJob validates and normalizes a KubernetesCronJob cloud_object.
func ParseKubernetesCronJob(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesCronJob"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesCronJobSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
