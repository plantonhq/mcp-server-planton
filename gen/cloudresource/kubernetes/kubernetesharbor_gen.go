// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// harbor-kubernetes
type KubernetesHarborSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The container specifications for Harbor Core (API server, authentication, webhook).
	CoreContainer *KubernetesHarborContainerInput `json:"core_container,omitempty" jsonschema:"The container specifications for Harbor Core (API server; authentication; webhook)."`
	// The container specifications for Harbor Portal (web UI).
	PortalContainer *KubernetesHarborContainerInput `json:"portal_container,omitempty" jsonschema:"The container specifications for Harbor Portal (web UI)."`
	// The container specifications for Harbor Registry (Docker/OCI registry backend).
	RegistryContainer *KubernetesHarborContainerInput `json:"registry_container,omitempty" jsonschema:"The container specifications for Harbor Registry (Docker/OCI registry backend)."`
	// The container specifications for Harbor Jobservice (background job execution).
	JobserviceContainer *KubernetesHarborContainerInput `json:"jobservice_container,omitempty" jsonschema:"The container specifications for Harbor Jobservice (background job execution)."`
	// The database configuration for Harbor, supporting both self-managed and external PostgreSQL.
	Database *KubernetesHarborDatabaseConfigInput `json:"database" jsonschema:"required,The database configuration for Harbor; supporting both self-managed and external PostgreSQL."`
	// The cache configuration for Harbor, supporting both self-managed and external Redis.
	Cache *KubernetesHarborCacheConfigInput `json:"cache" jsonschema:"required,The cache configuration for Harbor; supporting both self-managed and external Redis."`
	// The object storage configuration for Harbor artifact storage.
	Storage *KubernetesHarborStorageConfigInput `json:"storage" jsonschema:"required,The object storage configuration for Harbor artifact storage."`
	// The ingress configuration for Harbor UI and registry endpoints.
	Ingress *KubernetesHarborIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for Harbor UI and registry endpoints."`
	// *
	//  A map of key-value pairs that provide additional customization options for the Harbor Helm chart.
	//  These values allow for further refinement of the deployment, such as enabling Trivy scanner,
	//  configuring Notary for image signing, or customizing authentication providers.
	//  For detailed information...
	HelmValues map[string]string `json:"helm_values,omitempty" jsonschema:"* A map of key-value pairs that provide additional customization options for the Harbor Helm chart. These values allow for further refinement of the deployment; such as enabling Trivy scanner; configu..."`
}

func (s *KubernetesHarborSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.CoreContainer != nil {
		if err := s.CoreContainer.validate(); err != nil {
			return fmt.Errorf("core_container: %w", err)
		}
	}
	if s.PortalContainer != nil {
		if err := s.PortalContainer.validate(); err != nil {
			return fmt.Errorf("portal_container: %w", err)
		}
	}
	if s.RegistryContainer != nil {
		if err := s.RegistryContainer.validate(); err != nil {
			return fmt.Errorf("registry_container: %w", err)
		}
	}
	if s.JobserviceContainer != nil {
		if err := s.JobserviceContainer.validate(); err != nil {
			return fmt.Errorf("jobservice_container: %w", err)
		}
	}
	if s.Database == nil {
		return fmt.Errorf("database is required")
	}
	if s.Database != nil {
		if err := s.Database.validate(); err != nil {
			return fmt.Errorf("database: %w", err)
		}
	}
	if s.Cache == nil {
		return fmt.Errorf("cache is required")
	}
	if s.Cache != nil {
		if err := s.Cache.validate(); err != nil {
			return fmt.Errorf("cache: %w", err)
		}
	}
	if s.Storage == nil {
		return fmt.Errorf("storage is required")
	}
	if s.Storage != nil {
		if err := s.Storage.validate(); err != nil {
			return fmt.Errorf("storage: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.CoreContainer != nil {
		s.CoreContainer.applyDefaults()
	}
	if s.PortalContainer != nil {
		s.PortalContainer.applyDefaults()
	}
	if s.RegistryContainer != nil {
		s.RegistryContainer.applyDefaults()
	}
	if s.JobserviceContainer != nil {
		s.JobserviceContainer.applyDefaults()
	}
	if s.Database != nil {
		s.Database.applyDefaults()
	}
	if s.Cache != nil {
		s.Cache.applyDefaults()
	}
	if s.Storage != nil {
		s.Storage.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesHarborSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.CoreContainer != nil {
		m["core_container"] = s.CoreContainer.toMap()
	}
	if s.PortalContainer != nil {
		m["portal_container"] = s.PortalContainer.toMap()
	}
	if s.RegistryContainer != nil {
		m["registry_container"] = s.RegistryContainer.toMap()
	}
	if s.JobserviceContainer != nil {
		m["jobservice_container"] = s.JobserviceContainer.toMap()
	}
	if s.Database != nil {
		m["database"] = s.Database.toMap()
	}
	if s.Cache != nil {
		m["cache"] = s.Cache.toMap()
	}
	if s.Storage != nil {
		m["storage"] = s.Storage.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if len(s.HelmValues) > 0 {
		m["helm_values"] = s.HelmValues
	}
	return m
}

// *
//
//	**KubernetesHarborAzureStorage** defines Azure Blob Storage configuration.
type KubernetesHarborAzureStorageInput struct {
	// The Azure storage account name.
	AccountName string `json:"account_name" jsonschema:"required,The Azure storage account name."`
	// The Azure storage account key.
	AccountKey string `json:"account_key" jsonschema:"required,The Azure storage account key."`
	// The Azure blob container name.
	Container string `json:"container" jsonschema:"required,The Azure blob container name."`
	// The root directory path within the container.
	RootDirectory string `json:"root_directory,omitempty" jsonschema:"The root directory path within the container."`
}

func (s *KubernetesHarborAzureStorageInput) validate() error {
	if s.AccountName == "" {
		return fmt.Errorf("account_name is required")
	}
	if s.AccountKey == "" {
		return fmt.Errorf("account_key is required")
	}
	if s.Container == "" {
		return fmt.Errorf("container is required")
	}
	return nil
}

func (s *KubernetesHarborAzureStorageInput) applyDefaults() {
}

func (s *KubernetesHarborAzureStorageInput) toMap() map[string]any {
	m := make(map[string]any)
	m["account_name"] = s.AccountName
	m["account_key"] = s.AccountKey
	m["container"] = s.Container
	if s.RootDirectory != "" {
		m["root_directory"] = s.RootDirectory
	}
	return m
}

// *
//
//	**KubernetesHarborCacheConfig** defines the Redis cache configuration for Harbor.
//	It supports two deployment modes:
//	1. Self-managed: Deploy Redis within the Kubernetes cluster (default).
//	2. External: Connect to an existing external Redis instance.
type KubernetesHarborCacheConfigInput struct {
	// *
	//  Flag to enable using an external Redis cache.
	//  When false (default), Harbor will deploy and manage its own Redis instance.
	//  When true, the external_cache field must be configured.
	IsExternal bool `json:"is_external,omitempty" jsonschema:"* Flag to enable using an external Redis cache. When false (default); Harbor will deploy and manage its own Redis instance. When true; the external_cache field must be configured."`
	// *
	//  External Redis cache connection details.
	//  This field is required when is_external is true and ignored when false.
	ExternalCache *KubernetesHarborExternalRedisInput `json:"external_cache,omitempty" jsonschema:"* External Redis cache connection details. This field is required when is_external is true and ignored when false."`
	// *
	//  Self-managed Redis configuration.
	//  This field is used when is_external is false and configures the in-cluster Redis deployment.
	ManagedCache *KubernetesHarborManagedRedisInput `json:"managed_cache,omitempty" jsonschema:"* Self-managed Redis configuration. This field is used when is_external is false and configures the in-cluster Redis deployment."`
}

func (s *KubernetesHarborCacheConfigInput) validate() error {
	if s.ExternalCache != nil {
		if err := s.ExternalCache.validate(); err != nil {
			return fmt.Errorf("external_cache: %w", err)
		}
	}
	if s.ManagedCache != nil {
		if err := s.ManagedCache.validate(); err != nil {
			return fmt.Errorf("managed_cache: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborCacheConfigInput) applyDefaults() {
	if s.ExternalCache != nil {
		s.ExternalCache.applyDefaults()
	}
	if s.ManagedCache != nil {
		s.ManagedCache.applyDefaults()
	}
}

func (s *KubernetesHarborCacheConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsExternal {
		m["is_external"] = s.IsExternal
	}
	if s.ExternalCache != nil {
		m["external_cache"] = s.ExternalCache.toMap()
	}
	if s.ManagedCache != nil {
		m["managed_cache"] = s.ManagedCache.toMap()
	}
	return m
}

// *
//
//	**KubernetesHarborContainer** specifies the container configuration for various Harbor components.
//	It includes settings such as the number of replicas, container image, and resource allocations.
type KubernetesHarborContainerInput struct {
	// The number of pods to deploy for this component.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of pods to deploy for this component."`
	// The CPU and memory resources allocated to the container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the container."`
	// The container image configuration (repository and tag).
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image configuration (repository and tag)."`
}

func (s *KubernetesHarborContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesHarborContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	return m
}

// *
//
//	**KubernetesHarborDatabaseConfig** defines the PostgreSQL database configuration for Harbor.
//	It supports two deployment modes:
//	1. Self-managed: Deploy PostgreSQL within the Kubernetes cluster (default).
//	2. External: Connect to an existing external PostgreSQL instance.
type KubernetesHarborDatabaseConfigInput struct {
	// *
	//  Flag to enable using an external PostgreSQL database.
	//  When false (default), Harbor will deploy and manage its own PostgreSQL instance.
	//  When true, the external_database field must be configured.
	IsExternal bool `json:"is_external,omitempty" jsonschema:"* Flag to enable using an external PostgreSQL database. When false (default); Harbor will deploy and manage its own PostgreSQL instance. When true; the external_database field must be configured."`
	// *
	//  External PostgreSQL database connection details.
	//  This field is required when is_external is true and ignored when false.
	ExternalDatabase *KubernetesHarborExternalPostgresqlInput `json:"external_database,omitempty" jsonschema:"* External PostgreSQL database connection details. This field is required when is_external is true and ignored when false."`
	// *
	//  Self-managed PostgreSQL configuration.
	//  This field is used when is_external is false and configures the in-cluster PostgreSQL deployment.
	ManagedDatabase *KubernetesHarborManagedPostgresqlInput `json:"managed_database,omitempty" jsonschema:"* Self-managed PostgreSQL configuration. This field is used when is_external is false and configures the in-cluster PostgreSQL deployment."`
}

func (s *KubernetesHarborDatabaseConfigInput) validate() error {
	if s.ExternalDatabase != nil {
		if err := s.ExternalDatabase.validate(); err != nil {
			return fmt.Errorf("external_database: %w", err)
		}
	}
	if s.ManagedDatabase != nil {
		if err := s.ManagedDatabase.validate(); err != nil {
			return fmt.Errorf("managed_database: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborDatabaseConfigInput) applyDefaults() {
	if s.ExternalDatabase != nil {
		s.ExternalDatabase.applyDefaults()
	}
	if s.ManagedDatabase != nil {
		s.ManagedDatabase.applyDefaults()
	}
}

func (s *KubernetesHarborDatabaseConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsExternal {
		m["is_external"] = s.IsExternal
	}
	if s.ExternalDatabase != nil {
		m["external_database"] = s.ExternalDatabase.toMap()
	}
	if s.ManagedDatabase != nil {
		m["managed_database"] = s.ManagedDatabase.toMap()
	}
	return m
}

// *
//
//	**KubernetesHarborExternalPostgresql** defines connection parameters for an external PostgreSQL instance.
//	This allows Harbor to use a pre-existing PostgreSQL database instead of deploying one within the cluster.
type KubernetesHarborExternalPostgresqlInput struct {
	// The hostname or endpoint of the external PostgreSQL instance.
	Host string `json:"host" jsonschema:"required,The hostname or endpoint of the external PostgreSQL instance."`
	// The port for PostgreSQL (default is 5432).
	Port int32 `json:"port,omitempty" jsonschema:"The port for PostgreSQL (default is 5432)."`
	// The username for authenticating to PostgreSQL.
	Username string `json:"username" jsonschema:"required,The username for authenticating to PostgreSQL."`
	// The password for authenticating to PostgreSQL.
	Password string `json:"password" jsonschema:"required,The password for authenticating to PostgreSQL."`
	// The name of the database for Harbor Core (default is "registry").
	CoreDatabase string `json:"core_database,omitempty" jsonschema:"The name of the database for Harbor Core (default is 'registry')."`
	// The name of the database for Clair (vulnerability scanner).
	ClairDatabase string `json:"clair_database,omitempty" jsonschema:"The name of the database for Clair (vulnerability scanner)."`
	// The name of the database for Notary Server (image signing).
	NotaryServerDatabase string `json:"notary_server_database,omitempty" jsonschema:"The name of the database for Notary Server (image signing)."`
	// The name of the database for Notary Signer (image signing).
	NotarySignerDatabase string `json:"notary_signer_database,omitempty" jsonschema:"The name of the database for Notary Signer (image signing)."`
	// Whether to use SSL/TLS connection to PostgreSQL.
	UseSsl bool `json:"use_ssl,omitempty" jsonschema:"Whether to use SSL/TLS connection to PostgreSQL."`
}

func (s *KubernetesHarborExternalPostgresqlInput) validate() error {
	if s.Host == "" {
		return fmt.Errorf("host is required")
	}
	if s.Username == "" {
		return fmt.Errorf("username is required")
	}
	if s.Password == "" {
		return fmt.Errorf("password is required")
	}
	return nil
}

func (s *KubernetesHarborExternalPostgresqlInput) applyDefaults() {
	if s.Port == 0 {
		s.Port = 5432
	}
	if s.CoreDatabase == "" {
		s.CoreDatabase = "registry"
	}
	if s.ClairDatabase == "" {
		s.ClairDatabase = "clair"
	}
	if s.NotaryServerDatabase == "" {
		s.NotaryServerDatabase = "notary_server"
	}
	if s.NotarySignerDatabase == "" {
		s.NotarySignerDatabase = "notary_signer"
	}
}

func (s *KubernetesHarborExternalPostgresqlInput) toMap() map[string]any {
	m := make(map[string]any)
	m["host"] = s.Host
	if s.Port != 0 {
		m["port"] = s.Port
	}
	m["username"] = s.Username
	m["password"] = s.Password
	if s.CoreDatabase != "" {
		m["core_database"] = s.CoreDatabase
	}
	if s.ClairDatabase != "" {
		m["clair_database"] = s.ClairDatabase
	}
	if s.NotaryServerDatabase != "" {
		m["notary_server_database"] = s.NotaryServerDatabase
	}
	if s.NotarySignerDatabase != "" {
		m["notary_signer_database"] = s.NotarySignerDatabase
	}
	if s.UseSsl {
		m["use_ssl"] = s.UseSsl
	}
	return m
}

// *
//
//	**KubernetesHarborExternalRedis** defines connection parameters for an external Redis instance.
//	This allows Harbor to use a pre-existing Redis cache instead of deploying one within the cluster.
type KubernetesHarborExternalRedisInput struct {
	// The hostname or endpoint of the external Redis instance (e.g., "redis.example.com:6379").
	Host string `json:"host" jsonschema:"required,The hostname or endpoint of the external Redis instance (e.g.; 'redis.example.com:6379')."`
	// The port for Redis (default is 6379).
	Port int32 `json:"port,omitempty" jsonschema:"The port for Redis (default is 6379)."`
	// The username for authenticating to Redis (if ACLs are enabled).
	Username string `json:"username,omitempty" jsonschema:"The username for authenticating to Redis (if ACLs are enabled)."`
	// The password for authenticating to Redis.
	Password string `json:"password,omitempty" jsonschema:"The password for authenticating to Redis."`
	// The Redis database index to use (default is 0).
	DatabaseIndex int32 `json:"database_index,omitempty" jsonschema:"The Redis database index to use (default is 0)."`
	// Whether to use Sentinel for high availability.
	UseSentinel bool `json:"use_sentinel,omitempty" jsonschema:"Whether to use Sentinel for high availability."`
	// The Sentinel master set name (required if use_sentinel is true).
	SentinelMasterSet string `json:"sentinel_master_set,omitempty" jsonschema:"The Sentinel master set name (required if use_sentinel is true)."`
}

func (s *KubernetesHarborExternalRedisInput) validate() error {
	if s.Host == "" {
		return fmt.Errorf("host is required")
	}
	return nil
}

func (s *KubernetesHarborExternalRedisInput) applyDefaults() {
	if s.Port == 0 {
		s.Port = 6379
	}
	if s.DatabaseIndex == 0 {
		s.DatabaseIndex = 0
	}
}

func (s *KubernetesHarborExternalRedisInput) toMap() map[string]any {
	m := make(map[string]any)
	m["host"] = s.Host
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	if s.DatabaseIndex != 0 {
		m["database_index"] = s.DatabaseIndex
	}
	if s.UseSentinel {
		m["use_sentinel"] = s.UseSentinel
	}
	if s.SentinelMasterSet != "" {
		m["sentinel_master_set"] = s.SentinelMasterSet
	}
	return m
}

// *
//
//	**KubernetesHarborFilesystemStorage** defines filesystem (PVC) storage configuration.
//	Note: This is not suitable for production high-availability deployments.
type KubernetesHarborFilesystemStorageInput struct {
	// *
	//  The size of the persistent volume for storing artifacts (e.g., "100Gi").
	//  Note: This value cannot be modified after creation due to Kubernetes PVC limitations.
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The size of the persistent volume for storing artifacts (e.g.; '100Gi'). Note: This value cannot be modified after creation due to Kubernetes PVC limitations."`
	// The storage class to use for the PVC.
	StorageClass string `json:"storage_class,omitempty" jsonschema:"The storage class to use for the PVC."`
}

func (s *KubernetesHarborFilesystemStorageInput) validate() error {
	return nil
}

func (s *KubernetesHarborFilesystemStorageInput) applyDefaults() {
}

func (s *KubernetesHarborFilesystemStorageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	if s.StorageClass != "" {
		m["storage_class"] = s.StorageClass
	}
	return m
}

// *
//
//	**KubernetesHarborGcsStorage** defines Google Cloud Storage configuration.
type KubernetesHarborGcsStorageInput struct {
	// The GCS bucket name.
	Bucket string `json:"bucket" jsonschema:"required,The GCS bucket name."`
	// The base64-encoded service account key JSON.
	KeyData string `json:"key_data" jsonschema:"required,The base64-encoded service account key JSON."`
	// The root directory path within the bucket.
	RootDirectory string `json:"root_directory,omitempty" jsonschema:"The root directory path within the bucket."`
	// The chunk size for upload (default is 5242880 bytes).
	ChunkSize int32 `json:"chunk_size,omitempty" jsonschema:"The chunk size for upload (default is 5242880 bytes)."`
}

func (s *KubernetesHarborGcsStorageInput) validate() error {
	if s.Bucket == "" {
		return fmt.Errorf("bucket is required")
	}
	if s.KeyData == "" {
		return fmt.Errorf("key_data is required")
	}
	return nil
}

func (s *KubernetesHarborGcsStorageInput) applyDefaults() {
	if s.ChunkSize == 0 {
		s.ChunkSize = 5242880
	}
}

func (s *KubernetesHarborGcsStorageInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket"] = s.Bucket
	m["key_data"] = s.KeyData
	if s.RootDirectory != "" {
		m["root_directory"] = s.RootDirectory
	}
	if s.ChunkSize != 0 {
		m["chunk_size"] = s.ChunkSize
	}
	return m
}

// *
//
//	**KubernetesHarborIngress** defines the ingress configuration for Harbor endpoints.
//	It provides separate ingress settings for the Core/Portal UI and Notary service.
type KubernetesHarborIngressInput struct {
	// Ingress configuration for Harbor Core and Portal (web UI and API).
	Core *KubernetesHarborIngressEndpointInput `json:"core,omitempty" jsonschema:"Ingress configuration for Harbor Core and Portal (web UI and API)."`
	// Ingress configuration for Notary service (image signing).
	Notary *KubernetesHarborIngressEndpointInput `json:"notary,omitempty" jsonschema:"Ingress configuration for Notary service (image signing)."`
}

func (s *KubernetesHarborIngressInput) validate() error {
	if s.Core != nil {
		if err := s.Core.validate(); err != nil {
			return fmt.Errorf("core: %w", err)
		}
	}
	if s.Notary != nil {
		if err := s.Notary.validate(); err != nil {
			return fmt.Errorf("notary: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborIngressInput) applyDefaults() {
	if s.Core != nil {
		s.Core.applyDefaults()
	}
	if s.Notary != nil {
		s.Notary.applyDefaults()
	}
}

func (s *KubernetesHarborIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Core != nil {
		m["core"] = s.Core.toMap()
	}
	if s.Notary != nil {
		m["notary"] = s.Notary.toMap()
	}
	return m
}

// *
//
//	**KubernetesHarborIngressEndpoint** defines ingress configuration for a specific Harbor endpoint.
type KubernetesHarborIngressEndpointInput struct {
	// Flag to enable or disable ingress for this endpoint.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress for this endpoint."`
	// The full hostname for external access (e.g., "harbor.example.com").
	//  This hostname will be configured via Gateway API resources.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'harbor.example.com'). This hostname will be configured via Gateway API resources. Required when enabled is true."`
}

func (s *KubernetesHarborIngressEndpointInput) validate() error {
	return nil
}

func (s *KubernetesHarborIngressEndpointInput) applyDefaults() {
}

func (s *KubernetesHarborIngressEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	**KubernetesHarborManagedPostgresql** defines configuration for a self-managed PostgreSQL deployment.
//	This supports simple single-node deployments suitable for development and testing.
type KubernetesHarborManagedPostgresqlInput struct {
	// The container specifications for PostgreSQL.
	Container *KubernetesHarborPostgresqlContainerInput `json:"container,omitempty" jsonschema:"The container specifications for PostgreSQL."`
}

func (s *KubernetesHarborManagedPostgresqlInput) validate() error {
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborManagedPostgresqlInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
}

func (s *KubernetesHarborManagedPostgresqlInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	return m
}

// *
//
//	**KubernetesHarborManagedRedis** defines configuration for a self-managed Redis deployment.
//	This supports simple single-node deployments suitable for development and testing.
type KubernetesHarborManagedRedisInput struct {
	// The container specifications for Redis.
	Container *KubernetesHarborRedisContainerInput `json:"container,omitempty" jsonschema:"The container specifications for Redis."`
}

func (s *KubernetesHarborManagedRedisInput) validate() error {
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborManagedRedisInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
}

func (s *KubernetesHarborManagedRedisInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	return m
}

// *
//
//	**KubernetesHarborOssStorage** defines Alibaba Cloud OSS configuration.
type KubernetesHarborOssStorageInput struct {
	// The OSS bucket name.
	Bucket string `json:"bucket" jsonschema:"required,The OSS bucket name."`
	// The OSS endpoint (e.g., "oss-cn-hangzhou.aliyuncs.com").
	Endpoint string `json:"endpoint" jsonschema:"required,The OSS endpoint (e.g.; 'oss-cn-hangzhou.aliyuncs.com')."`
	// The access key ID.
	AccessKeyId string `json:"access_key_id" jsonschema:"required,The access key ID."`
	// The access key secret.
	AccessKeySecret string `json:"access_key_secret" jsonschema:"required,The access key secret."`
	// The root directory path within the bucket.
	RootDirectory string `json:"root_directory,omitempty" jsonschema:"The root directory path within the bucket."`
	// Whether to use HTTPS.
	Secure bool `json:"secure,omitempty" jsonschema:"Whether to use HTTPS."`
}

func (s *KubernetesHarborOssStorageInput) validate() error {
	if s.Bucket == "" {
		return fmt.Errorf("bucket is required")
	}
	if s.Endpoint == "" {
		return fmt.Errorf("endpoint is required")
	}
	if s.AccessKeyId == "" {
		return fmt.Errorf("access_key_id is required")
	}
	if s.AccessKeySecret == "" {
		return fmt.Errorf("access_key_secret is required")
	}
	return nil
}

func (s *KubernetesHarborOssStorageInput) applyDefaults() {
}

func (s *KubernetesHarborOssStorageInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket"] = s.Bucket
	m["endpoint"] = s.Endpoint
	m["access_key_id"] = s.AccessKeyId
	m["access_key_secret"] = s.AccessKeySecret
	if s.RootDirectory != "" {
		m["root_directory"] = s.RootDirectory
	}
	if s.Secure {
		m["secure"] = s.Secure
	}
	return m
}

// *
//
//	**KubernetesHarborPostgresqlContainer** specifies the container configuration for PostgreSQL.
//	It includes replica count, resource allocations, and persistence settings.
type KubernetesHarborPostgresqlContainerInput struct {
	// The number of PostgreSQL pods to deploy.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of PostgreSQL pods to deploy."`
	// The CPU and memory resources allocated to the PostgreSQL container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the PostgreSQL container."`
	// The container image configuration for PostgreSQL.
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image configuration for PostgreSQL."`
	// *
	//  Flag to enable or disable data persistence for PostgreSQL.
	//  When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	//  Defaults to true.
	PersistenceEnabled bool `json:"persistence_enabled,omitempty" jsonschema:"* Flag to enable or disable data persistence for PostgreSQL. When enabled; data is persisted to a storage volume; allowing data to survive pod restarts. Defaults to true."`
	// *
	//  The size of the persistent volume attached to each PostgreSQL pod (e.g., "20Gi").
	//  This attribute is ignored when persistence is not enabled.
	//  Note: This value cannot be modified after creation due to Kubernetes StatefulSet limitations.
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The size of the persistent volume attached to each PostgreSQL pod (e.g.; '20Gi'). This attribute is ignored when persistence is not enabled. Note: This value cannot be modified after creation due to..."`
}

func (s *KubernetesHarborPostgresqlContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborPostgresqlContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesHarborPostgresqlContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.PersistenceEnabled {
		m["persistence_enabled"] = s.PersistenceEnabled
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// *
//
//	**KubernetesHarborRedisContainer** specifies the container configuration for Redis.
//	It includes replica count, resource allocations, and persistence settings.
type KubernetesHarborRedisContainerInput struct {
	// The number of Redis pods to deploy.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of Redis pods to deploy."`
	// The CPU and memory resources allocated to the Redis container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Redis container."`
	// The container image configuration for Redis.
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image configuration for Redis."`
	// *
	//  Flag to enable or disable data persistence for Redis.
	//  When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	//  Defaults to true.
	PersistenceEnabled bool `json:"persistence_enabled,omitempty" jsonschema:"* Flag to enable or disable data persistence for Redis. When enabled; data is persisted to a storage volume; allowing data to survive pod restarts. Defaults to true."`
	// *
	//  The size of the persistent volume attached to each Redis pod (e.g., "8Gi").
	//  This attribute is ignored when persistence is not enabled.
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The size of the persistent volume attached to each Redis pod (e.g.; '8Gi'). This attribute is ignored when persistence is not enabled."`
}

func (s *KubernetesHarborRedisContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborRedisContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesHarborRedisContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.PersistenceEnabled {
		m["persistence_enabled"] = s.PersistenceEnabled
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// *
//
//	**KubernetesHarborS3Storage** defines S3-compatible object storage configuration.
type KubernetesHarborS3StorageInput struct {
	// The S3 bucket name.
	Bucket string `json:"bucket" jsonschema:"required,The S3 bucket name."`
	// The AWS region (e.g., "us-west-2").
	Region string `json:"region" jsonschema:"required,The AWS region (e.g.; 'us-west-2')."`
	// The AWS access key ID.
	AccessKey string `json:"access_key" jsonschema:"required,The AWS access key ID."`
	// The AWS secret access key.
	SecretKey string `json:"secret_key" jsonschema:"required,The AWS secret access key."`
	// Whether to use regional endpoint (default is false for global endpoint).
	RegionEndpoint bool `json:"region_endpoint,omitempty" jsonschema:"Whether to use regional endpoint (default is false for global endpoint)."`
	// Whether to encrypt objects using server-side encryption.
	Encrypt bool `json:"encrypt,omitempty" jsonschema:"Whether to encrypt objects using server-side encryption."`
	// Whether to use secure (HTTPS) connection.
	Secure bool `json:"secure,omitempty" jsonschema:"Whether to use secure (HTTPS) connection."`
	// The root directory path within the bucket.
	RootDirectory string `json:"root_directory,omitempty" jsonschema:"The root directory path within the bucket."`
	// Custom S3 endpoint URL (for S3-compatible services like MinIO).
	EndpointUrl string `json:"endpoint_url,omitempty" jsonschema:"Custom S3 endpoint URL (for S3-compatible services like MinIO)."`
}

func (s *KubernetesHarborS3StorageInput) validate() error {
	if s.Bucket == "" {
		return fmt.Errorf("bucket is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.AccessKey == "" {
		return fmt.Errorf("access_key is required")
	}
	if s.SecretKey == "" {
		return fmt.Errorf("secret_key is required")
	}
	return nil
}

func (s *KubernetesHarborS3StorageInput) applyDefaults() {
}

func (s *KubernetesHarborS3StorageInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket"] = s.Bucket
	m["region"] = s.Region
	m["access_key"] = s.AccessKey
	m["secret_key"] = s.SecretKey
	if s.RegionEndpoint {
		m["region_endpoint"] = s.RegionEndpoint
	}
	if s.Encrypt {
		m["encrypt"] = s.Encrypt
	}
	if s.Secure {
		m["secure"] = s.Secure
	}
	if s.RootDirectory != "" {
		m["root_directory"] = s.RootDirectory
	}
	if s.EndpointUrl != "" {
		m["endpoint_url"] = s.EndpointUrl
	}
	return m
}

// *
//
//	**KubernetesHarborStorageConfig** defines the storage configuration for Harbor artifacts.
//	For production high-availability deployments, external object storage (S3, GCS, Azure) is required.
type KubernetesHarborStorageConfigInput struct {
	// The type of storage backend to use.
	Type string `json:"type" jsonschema:"required,enum=filesystem|s3|gcs|azure|oss,The type of storage backend to use."`
	// S3-compatible storage configuration (required when type is s3).
	S3 *KubernetesHarborS3StorageInput `json:"s3,omitempty" jsonschema:"S3-compatible storage configuration (required when type is s3)."`
	// Google Cloud Storage configuration (required when type is gcs).
	Gcs *KubernetesHarborGcsStorageInput `json:"gcs,omitempty" jsonschema:"Google Cloud Storage configuration (required when type is gcs)."`
	// Azure Blob Storage configuration (required when type is azure).
	Azure *KubernetesHarborAzureStorageInput `json:"azure,omitempty" jsonschema:"Azure Blob Storage configuration (required when type is azure)."`
	// Alibaba Cloud OSS configuration (required when type is oss).
	Oss *KubernetesHarborOssStorageInput `json:"oss,omitempty" jsonschema:"Alibaba Cloud OSS configuration (required when type is oss)."`
	// Filesystem storage configuration (required when type is filesystem).
	Filesystem *KubernetesHarborFilesystemStorageInput `json:"filesystem,omitempty" jsonschema:"Filesystem storage configuration (required when type is filesystem)."`
}

func (s *KubernetesHarborStorageConfigInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "filesystem", "s3", "gcs", "azure", "oss":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.S3 != nil {
		if err := s.S3.validate(); err != nil {
			return fmt.Errorf("s3: %w", err)
		}
	}
	if s.Gcs != nil {
		if err := s.Gcs.validate(); err != nil {
			return fmt.Errorf("gcs: %w", err)
		}
	}
	if s.Azure != nil {
		if err := s.Azure.validate(); err != nil {
			return fmt.Errorf("azure: %w", err)
		}
	}
	if s.Oss != nil {
		if err := s.Oss.validate(); err != nil {
			return fmt.Errorf("oss: %w", err)
		}
	}
	if s.Filesystem != nil {
		if err := s.Filesystem.validate(); err != nil {
			return fmt.Errorf("filesystem: %w", err)
		}
	}
	return nil
}

func (s *KubernetesHarborStorageConfigInput) applyDefaults() {
	if s.S3 != nil {
		s.S3.applyDefaults()
	}
	if s.Gcs != nil {
		s.Gcs.applyDefaults()
	}
	if s.Azure != nil {
		s.Azure.applyDefaults()
	}
	if s.Oss != nil {
		s.Oss.applyDefaults()
	}
	if s.Filesystem != nil {
		s.Filesystem.applyDefaults()
	}
}

func (s *KubernetesHarborStorageConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.S3 != nil {
		m["s3"] = s.S3.toMap()
	}
	if s.Gcs != nil {
		m["gcs"] = s.Gcs.toMap()
	}
	if s.Azure != nil {
		m["azure"] = s.Azure.toMap()
	}
	if s.Oss != nil {
		m["oss"] = s.Oss.toMap()
	}
	if s.Filesystem != nil {
		m["filesystem"] = s.Filesystem.toMap()
	}
	return m
}

// ParseKubernetesHarbor validates and normalizes a KubernetesHarbor cloud_object.
func ParseKubernetesHarbor(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesHarbor"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesHarborSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
