// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// kubernetes-helm-release
type KubernetesHelmReleaseSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The repository URL where the Helm chart is hosted.
	//  For example, "https://charts.helm.sh/stable".
	//  an example for chart-repo (redis chart) can be found in https://artifacthub.io/packages/helm/bitnami/redis?modal=install
	Repo string `json:"repo" jsonschema:"required,The repository URL where the Helm chart is hosted. For example; 'https://charts.helm.sh/stable'. an example for chart-repo (redis chart) can be found in https://artifacthub.io/packages/helm/bitnami/re..."`
	// The name of the Helm chart to deploy.
	//  For example, "nginx-ingress".
	Name string `json:"name" jsonschema:"required,The name of the Helm chart to deploy. For example; 'nginx-ingress'."`
	// The version of the Helm chart to deploy.
	//  For example, "1.41.3".
	Version string `json:"version" jsonschema:"required,The version of the Helm chart to deploy. For example; '1.41.3'."`
	// A map of key-value pairs representing custom values for the Helm chart.
	//  These values override the default settings in the chart's values.yaml file.
	Values map[string]string `json:"values,omitempty" jsonschema:"A map of key-value pairs representing custom values for the Helm chart. These values override the default settings in the chart's values.yaml file."`
}

func (s *KubernetesHelmReleaseSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Repo == "" {
		return fmt.Errorf("repo is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Version == "" {
		return fmt.Errorf("version is required")
	}
	return nil
}

func (s *KubernetesHelmReleaseSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
}

func (s *KubernetesHelmReleaseSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	m["repo"] = s.Repo
	m["name"] = s.Name
	m["version"] = s.Version
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	return m
}

// ParseKubernetesHelmRelease validates and normalizes a KubernetesHelmRelease cloud_object.
func ParseKubernetesHelmRelease(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesHelmRelease"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesHelmReleaseSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
