// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesStatefulSet is a deployment component for running stateful applications on Kubernetes.
//
//	StatefulSets are used for applications that require stable, unique network identifiers,
//	stable persistent storage, ordered graceful deployment and scaling, and ordered automated rolling updates.
type KubernetesStatefulSetSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// Flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created"`
	// The container specifications for the stateful set.
	//  This includes configurations for the main application container and any sidecar containers.
	Container *KubernetesStatefulSetContainerInput `json:"container" jsonschema:"required,The container specifications for the stateful set. This includes configurations for the main application container and any sidecar containers."`
	// The ingress configuration for the stateful set.
	//  This defines how the stateful set can be accessed externally.
	Ingress *KubernetesStatefulSetIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the stateful set. This defines how the stateful set can be accessed externally."`
	// The availability configuration for the stateful set.
	//  This includes settings for replicas and pod management policy.
	Availability *KubernetesStatefulSetAvailabilityInput `json:"availability,omitempty" jsonschema:"The availability configuration for the stateful set. This includes settings for replicas and pod management policy."`
	// Persistent volume claims for the stateful set.
	//  Each pod in the stateful set gets its own PVC based on these templates.
	VolumeClaimTemplates []*KubernetesStatefulSetVolumeClaimTemplateInput `json:"volume_claim_templates,omitempty" jsonschema:"Persistent volume claims for the stateful set. Each pod in the stateful set gets its own PVC based on these templates."`
	// Pod management policy for the stateful set.
	//  "OrderedReady" (default): Pods are created in order and wait for previous pod to be ready.
	//  "Parallel": All pods are created/deleted simultaneously.
	PodManagementPolicy string `json:"pod_management_policy,omitempty" jsonschema:"Pod management policy for the stateful set. 'OrderedReady' (default): Pods are created in order and wait for previous pod to be ready. 'Parallel': All pods are created/deleted simultaneously."`
	// *
	//  ConfigMaps to create alongside the StatefulSet.
	//  Key is the ConfigMap name, value is the content.
	//  These ConfigMaps can be referenced in volume mounts.
	//
	//  Example:
	//    config_maps:
	//      app-config: |
	//        database:
	//          host: localhost
	//          port: 5432
	ConfigMaps map[string]string `json:"config_maps,omitempty" jsonschema:"* ConfigMaps to create alongside the StatefulSet. Key is the ConfigMap name; value is the content. These ConfigMaps can be referenced in volume mounts. Example: config_maps: app-config: | database: ho..."`
}

func (s *KubernetesStatefulSetSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.Availability != nil {
		if err := s.Availability.validate(); err != nil {
			return fmt.Errorf("availability: %w", err)
		}
	}
	for i, v := range s.VolumeClaimTemplates {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_claim_templates[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesStatefulSetSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.Availability != nil {
		s.Availability.applyDefaults()
	}
}

func (s *KubernetesStatefulSetSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.Availability != nil {
		m["availability"] = s.Availability.toMap()
	}
	if len(s.VolumeClaimTemplates) > 0 {
		items := make([]any, len(s.VolumeClaimTemplates))
		for i, v := range s.VolumeClaimTemplates {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_claim_templates"] = items
	}
	if s.PodManagementPolicy != "" {
		m["pod_management_policy"] = s.PodManagementPolicy
	}
	if len(s.ConfigMaps) > 0 {
		m["config_maps"] = s.ConfigMaps
	}
	return m
}

// *
//
//	**KubernetesStatefulSetAvailability** specifies the availability configuration for the stateful set.
type KubernetesStatefulSetAvailabilityInput struct {
	// The number of pod replicas to maintain.
	//  Default is 1.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of pod replicas to maintain. Default is 1."`
	// Pod disruption budget configuration.
	//  Ensures minimum availability during voluntary disruptions.
	PodDisruptionBudget *KubernetesStatefulSetPodDisruptionBudgetInput `json:"pod_disruption_budget,omitempty" jsonschema:"Pod disruption budget configuration. Ensures minimum availability during voluntary disruptions."`
}

func (s *KubernetesStatefulSetAvailabilityInput) validate() error {
	if s.PodDisruptionBudget != nil {
		if err := s.PodDisruptionBudget.validate(); err != nil {
			return fmt.Errorf("pod_disruption_budget: %w", err)
		}
	}
	return nil
}

func (s *KubernetesStatefulSetAvailabilityInput) applyDefaults() {
	if s.PodDisruptionBudget != nil {
		s.PodDisruptionBudget.applyDefaults()
	}
}

func (s *KubernetesStatefulSetAvailabilityInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.PodDisruptionBudget != nil {
		m["pod_disruption_budget"] = s.PodDisruptionBudget.toMap()
	}
	return m
}

// *
//
//	**KubernetesStatefulSetContainer** specifies the container configuration for the stateful set.
//	It includes the main application container and any sidecar containers that need to run alongside it.
type KubernetesStatefulSetContainerInput struct {
	// The main application container specifications.
	App *KubernetesStatefulSetContainerAppInput `json:"app" jsonschema:"required,The main application container specifications."`
	// A list of sidecar containers to be deployed alongside the main application container.
	Sidecars []*ContainerInput `json:"sidecars,omitempty" jsonschema:"A list of sidecar containers to be deployed alongside the main application container."`
}

func (s *KubernetesStatefulSetContainerInput) validate() error {
	if s.App == nil {
		return fmt.Errorf("app is required")
	}
	if s.App != nil {
		if err := s.App.validate(); err != nil {
			return fmt.Errorf("app: %w", err)
		}
	}
	for i, v := range s.Sidecars {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("sidecars[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesStatefulSetContainerInput) applyDefaults() {
	if s.App != nil {
		s.App.applyDefaults()
	}
}

func (s *KubernetesStatefulSetContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.App != nil {
		m["app"] = s.App.toMap()
	}
	if len(s.Sidecars) > 0 {
		items := make([]any, len(s.Sidecars))
		for i, v := range s.Sidecars {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["sidecars"] = items
	}
	return m
}

// *
//
//	**KubernetesStatefulSetContainerApp** specifies the configuration for the main application container.
//	It includes the container image, resource allocations, environment variables, ports, volume mounts, and health probes.
type KubernetesStatefulSetContainerAppInput struct {
	// *
	//  The container image to be used for the application.
	//  The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes StatefulSet resource.
	Image *ContainerImageInput `json:"image" jsonschema:"required,* The container image to be used for the application. The 'pull_secret_name' is the name of the image pull secret to be configured in the Kubernetes StatefulSet resource."`
	// The CPU and memory resources allocated to the application container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the application container."`
	// *
	//  The environment variables and secrets for the application container.
	Env *KubernetesStatefulSetContainerAppEnvInput `json:"env,omitempty" jsonschema:"* The environment variables and secrets for the application container."`
	// *
	//  A list of ports to be configured for the application container.
	Ports []*KubernetesStatefulSetContainerAppPortInput `json:"ports,omitempty" jsonschema:"* A list of ports to be configured for the application container."`
	// *
	//  Volume mounts for the application container.
	//  Supports mounting ConfigMaps, Secrets, HostPaths, EmptyDirs, and PVCs.
	//  For PVC mounts, reference volume_claim_template names or existing PVCs.
	//  ConfigMaps defined in spec.config_maps can be referenced here.
	//
	//  Example:
	//    volume_mounts:
	//      - name: d...
	VolumeMounts []*VolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"* Volume mounts for the application container. Supports mounting ConfigMaps; Secrets; HostPaths; EmptyDirs; and PVCs. For PVC mounts; reference volume_claim_template names or existing PVCs. ConfigMaps..."`
	// *
	//  Liveness probe configuration.
	//  Periodic probe of container liveness. Container will be restarted if the probe fails.
	//  Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
	LivenessProbe *ProbeInput `json:"liveness_probe,omitempty" jsonschema:"* Liveness probe configuration. Periodic probe of container liveness. Container will be restarted if the probe fails. Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#conta..."`
	// *
	//  Readiness probe configuration.
	//  Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails.
	//  Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
	ReadinessProbe *ProbeInput `json:"readiness_probe,omitempty" jsonschema:"* Readiness probe configuration. Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Reference: https://kubernetes.io/docs/concepts/work..."`
	// *
	//  Startup probe configuration.
	//  Indicates whether the application within the container is started.
	//  Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
	StartupProbe *ProbeInput `json:"startup_probe,omitempty" jsonschema:"* Startup probe configuration. Indicates whether the application within the container is started. Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes"`
	// *
	//  Optional command to run instead of the image's default entrypoint.
	Command []string `json:"command,omitempty" jsonschema:"* Optional command to run instead of the image's default entrypoint."`
	// *
	//  Optional arguments to pass to the command or the image's default entrypoint.
	Args []string `json:"args,omitempty" jsonschema:"* Optional arguments to pass to the command or the image's default entrypoint."`
}

func (s *KubernetesStatefulSetContainerAppInput) validate() error {
	if s.Image == nil {
		return fmt.Errorf("image is required")
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	for i, v := range s.Ports {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ports[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	if s.LivenessProbe != nil {
		if err := s.LivenessProbe.validate(); err != nil {
			return fmt.Errorf("liveness_probe: %w", err)
		}
	}
	if s.ReadinessProbe != nil {
		if err := s.ReadinessProbe.validate(); err != nil {
			return fmt.Errorf("readiness_probe: %w", err)
		}
	}
	if s.StartupProbe != nil {
		if err := s.StartupProbe.validate(); err != nil {
			return fmt.Errorf("startup_probe: %w", err)
		}
	}
	return nil
}

func (s *KubernetesStatefulSetContainerAppInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.LivenessProbe != nil {
		s.LivenessProbe.applyDefaults()
	}
	if s.ReadinessProbe != nil {
		s.ReadinessProbe.applyDefaults()
	}
	if s.StartupProbe != nil {
		s.StartupProbe.applyDefaults()
	}
}

func (s *KubernetesStatefulSetContainerAppInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	if len(s.Ports) > 0 {
		items := make([]any, len(s.Ports))
		for i, v := range s.Ports {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ports"] = items
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	if s.LivenessProbe != nil {
		m["liveness_probe"] = s.LivenessProbe.toMap()
	}
	if s.ReadinessProbe != nil {
		m["readiness_probe"] = s.ReadinessProbe.toMap()
	}
	if s.StartupProbe != nil {
		m["startup_probe"] = s.StartupProbe.toMap()
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	return m
}

// *
//
//	**KubernetesStatefulSetContainerAppEnv** defines the environment variables and secrets for the application container.
type KubernetesStatefulSetContainerAppEnvInput struct {
	// *
	//  A map of environment variable names to their values.
	//  Each variable can be provided either as a literal string value or as a reference
	//  to another OpenMCF resource's field.
	//
	//  **Option 1: Direct string value**
	//  ```yaml
	//  variables:
	//    DATABASE_PORT:
	//      value: "5432"
	//  ```
	//
	//  **Option 2: Reference t...
	Variables map[string]string `json:"variables,omitempty" jsonschema:"* A map of environment variable names to their values. Each variable can be provided either as a literal string value or as a reference to another OpenMCF resource's field. **Option 1: Direct string v..."`
	// *
	//  A map of secret environment variable names to their values.
	//  Each secret can be provided either as a literal string value or as a reference
	//  to an existing Kubernetes Secret.
	//
	//  Using secret references is recommended for production deployments.
	Secrets map[string]*KubernetesSensitiveValueInput `json:"secrets,omitempty" jsonschema:"* A map of secret environment variable names to their values. Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret. Using secret references i..."`
}

func (s *KubernetesStatefulSetContainerAppEnvInput) validate() error {
	for k, v := range s.Secrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secrets[%s]: %w", k, err)
			}
		}
	}
	return nil
}

func (s *KubernetesStatefulSetContainerAppEnvInput) applyDefaults() {
}

func (s *KubernetesStatefulSetContainerAppEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		result := make(map[string]any, len(s.Secrets))
		for k, v := range s.Secrets {
			if v != nil {
				result[k] = v.toMap()
			}
		}
		m["secrets"] = result
	}
	return m
}

// *
//
//	**KubernetesStatefulSetContainerAppPort** specifies the port configuration for the application container.
type KubernetesStatefulSetContainerAppPortInput struct {
	// The name of the port (e.g., "http", "grpc").
	//  The name must only contain lowercase alphanumeric characters and hyphens.
	//  Port names must also start and end with an alphanumeric character.
	Name string `json:"name" jsonschema:"required,The name of the port (e.g.; 'http'; 'grpc'). The name must only contain lowercase alphanumeric characters and hyphens. Port names must also start and end with an alphanumeric character."`
	// The port number on the container.
	ContainerPort int32 `json:"container_port" jsonschema:"required,The port number on the container."`
	// The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
	NetworkProtocol string `json:"network_protocol" jsonschema:"required,The network protocol used by the port (e.g.; 'TCP'; 'UDP'; 'SCTP')."`
	// The application protocol for the service (e.g., "http").
	AppProtocol string `json:"app_protocol" jsonschema:"required,The application protocol for the service (e.g.; 'http')."`
	// The port number on the Kubernetes service.
	ServicePort int32 `json:"service_port" jsonschema:"required,The port number on the Kubernetes service."`
	// A flag indicating whether this port should be exposed via ingress.
	IsIngressPort bool `json:"is_ingress_port,omitempty" jsonschema:"A flag indicating whether this port should be exposed via ingress."`
}

func (s *KubernetesStatefulSetContainerAppPortInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.NetworkProtocol == "" {
		return fmt.Errorf("network_protocol is required")
	}
	if s.AppProtocol == "" {
		return fmt.Errorf("app_protocol is required")
	}
	return nil
}

func (s *KubernetesStatefulSetContainerAppPortInput) applyDefaults() {
}

func (s *KubernetesStatefulSetContainerAppPortInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["container_port"] = s.ContainerPort
	m["network_protocol"] = s.NetworkProtocol
	m["app_protocol"] = s.AppProtocol
	m["service_port"] = s.ServicePort
	if s.IsIngressPort {
		m["is_ingress_port"] = s.IsIngressPort
	}
	return m
}

// *
//
//	KubernetesStatefulSetIngress defines ingress configuration for the stateful set.
type KubernetesStatefulSetIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "myapp.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'myapp.example.com'). Required when enabled is true."`
}

func (s *KubernetesStatefulSetIngressInput) validate() error {
	return nil
}

func (s *KubernetesStatefulSetIngressInput) applyDefaults() {
}

func (s *KubernetesStatefulSetIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	**KubernetesStatefulSetPodDisruptionBudget** configures a PodDisruptionBudget for the stateful set.
type KubernetesStatefulSetPodDisruptionBudgetInput struct {
	// Enable or disable PodDisruptionBudget creation.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable or disable PodDisruptionBudget creation."`
	// Minimum number of pods that must be available during voluntary disruptions.
	//  Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
	MinAvailable string `json:"min_available,omitempty" jsonschema:"Minimum number of pods that must be available during voluntary disruptions. Can be an absolute number (e.g.; 1) or a percentage (e.g.; '50%')."`
	// Maximum number of pods that can be unavailable during voluntary disruptions.
	//  Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
	//  Cannot be used together with min_available.
	MaxUnavailable string `json:"max_unavailable,omitempty" jsonschema:"Maximum number of pods that can be unavailable during voluntary disruptions. Can be an absolute number (e.g.; 1) or a percentage (e.g.; '50%'). Cannot be used together with min_available."`
}

func (s *KubernetesStatefulSetPodDisruptionBudgetInput) validate() error {
	return nil
}

func (s *KubernetesStatefulSetPodDisruptionBudgetInput) applyDefaults() {
}

func (s *KubernetesStatefulSetPodDisruptionBudgetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.MinAvailable != "" {
		m["min_available"] = s.MinAvailable
	}
	if s.MaxUnavailable != "" {
		m["max_unavailable"] = s.MaxUnavailable
	}
	return m
}

// *
//
//	**KubernetesStatefulSetVolumeClaimTemplate** defines a PVC template for persistent storage.
//	Each pod in the StatefulSet gets a unique PVC based on this template.
type KubernetesStatefulSetVolumeClaimTemplateInput struct {
	// The name of the volume claim template.
	//  This name is used to reference the volume in container volume mounts.
	Name string `json:"name" jsonschema:"required,The name of the volume claim template. This name is used to reference the volume in container volume mounts."`
	// The storage class to use for the PVC.
	//  If not specified, the default storage class is used.
	StorageClass string `json:"storage_class,omitempty" jsonschema:"The storage class to use for the PVC. If not specified; the default storage class is used."`
	// The requested storage size (e.g., "10Gi", "100Gi").
	Size string `json:"size" jsonschema:"required,The requested storage size (e.g.; '10Gi'; '100Gi')."`
	// Access modes for the PVC.
	//  Common values: "ReadWriteOnce", "ReadOnlyMany", "ReadWriteMany", "ReadWriteOncePod"
	//  Default: ["ReadWriteOnce"]
	AccessModes []string `json:"access_modes,omitempty" jsonschema:"Access modes for the PVC. Common values: 'ReadWriteOnce'; 'ReadOnlyMany'; 'ReadWriteMany'; 'ReadWriteOncePod' Default: ['ReadWriteOnce']"`
}

func (s *KubernetesStatefulSetVolumeClaimTemplateInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	return nil
}

func (s *KubernetesStatefulSetVolumeClaimTemplateInput) applyDefaults() {
}

func (s *KubernetesStatefulSetVolumeClaimTemplateInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.StorageClass != "" {
		m["storage_class"] = s.StorageClass
	}
	m["size"] = s.Size
	if len(s.AccessModes) > 0 {
		m["access_modes"] = s.AccessModes
	}
	return m
}

// ParseKubernetesStatefulSet validates and normalizes a KubernetesStatefulSet cloud_object.
func ParseKubernetesStatefulSet(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesStatefulSet"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesStatefulSetSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
