// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// open-fga-kubernetes
type KubernetesOpenFgaSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The container specifications for the OpenFGA deployment.
	Container *KubernetesOpenFgaContainerInput `json:"container,omitempty" jsonschema:"The container specifications for the OpenFGA deployment."`
	// *
	//  The ingress configuration for the OpenFGA deployment.
	Ingress *KubernetesOpenFgaIngressInput `json:"ingress,omitempty" jsonschema:"* The ingress configuration for the OpenFGA deployment."`
	// *
	//  The data store configuration for OpenFGA.
	//  This specifies the backend database engine and connection details.
	Datastore *KubernetesOpenFgaDataStoreInput `json:"datastore" jsonschema:"required,* The data store configuration for OpenFGA. This specifies the backend database engine and connection details."`
}

func (s *KubernetesOpenFgaSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.Datastore == nil {
		return fmt.Errorf("datastore is required")
	}
	if s.Datastore != nil {
		if err := s.Datastore.validate(); err != nil {
			return fmt.Errorf("datastore: %w", err)
		}
	}
	return nil
}

func (s *KubernetesOpenFgaSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.Datastore != nil {
		s.Datastore.applyDefaults()
	}
}

func (s *KubernetesOpenFgaSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.Datastore != nil {
		m["datastore"] = s.Datastore.toMap()
	}
	return m
}

// *
//
//	**KubernetesOpenFgaContainer** specifies the container configuration for the OpenFGA application.
//	It includes resource allocations for CPU and memory to ensure the application runs efficiently,
//	and the number of replicas for scaling purposes.
//	Recommended defaults: CPU requests - 50m, Memory requests - 256Mi, CPU limits - 1, Memory limits - 1Gi.
type KubernetesOpenFgaContainerInput struct {
	// The number of OpenFGA replicas to deploy. This determines the level of concurrency and availability.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of OpenFGA replicas to deploy. This determines the level of concurrency and availability."`
	// The CPU and memory resources allocated to the OpenFGA container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the OpenFGA container."`
}

func (s *KubernetesOpenFgaContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesOpenFgaContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesOpenFgaContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// *
//
//	**KubernetesOpenFgaDataStore** represents the configuration for the OpenFGA data store in a Kubernetes deployment.
//	It specifies the type of database engine to use and connection details for connecting to the database.
//	The URI is constructed from these fields in the deployment modules, enabling secure password handling
//	via Kubernetes Secrets.
type KubernetesOpenFgaDataStoreInput struct {
	// *
	//  Specifies the type of data store engine to use.
	//  Allowed values are "mysql" for MySQL database and "postgres" for PostgreSQL database.
	Engine string `json:"engine" jsonschema:"required,* Specifies the type of data store engine to use. Allowed values are 'mysql' for MySQL database and 'postgres' for PostgreSQL database."`
	// *
	//  The hostname or endpoint of the database server.
	Host string `json:"host" jsonschema:"required,* The hostname or endpoint of the database server."`
	// *
	//  The port number of the database server.
	//  Defaults to 5432 for PostgreSQL and 3306 for MySQL.
	Port int32 `json:"port,omitempty" jsonschema:"* The port number of the database server. Defaults to 5432 for PostgreSQL and 3306 for MySQL."`
	// *
	//  The name of the database to connect to.
	Database string `json:"database" jsonschema:"required,* The name of the database to connect to."`
	// *
	//  The username for authenticating to the database.
	Username string `json:"username" jsonschema:"required,* The username for authenticating to the database."`
	// *
	//  The password for authenticating to the database.
	//  Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret.
	//
	//  Using a secret reference is recommended for production deployments:
	//  ```yaml
	//  password:
	//    secretRef:
	//      name: openfga-db-credentials
	//      key: ...
	Password *KubernetesSensitiveValueInput `json:"password" jsonschema:"required,* The password for authenticating to the database. Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret. Using a secret reference is recommended for produc..."`
	// *
	//  Whether to use SSL/TLS connection to the database.
	//  When enabled, adds sslmode=require (for PostgreSQL) or tls=true (for MySQL) to the connection string.
	IsSecure bool `json:"is_secure,omitempty" jsonschema:"* Whether to use SSL/TLS connection to the database. When enabled; adds sslmode=require (for PostgreSQL) or tls=true (for MySQL) to the connection string."`
}

func (s *KubernetesOpenFgaDataStoreInput) validate() error {
	if s.Engine == "" {
		return fmt.Errorf("engine is required")
	}
	if s.Host == "" {
		return fmt.Errorf("host is required")
	}
	if s.Database == "" {
		return fmt.Errorf("database is required")
	}
	if s.Username == "" {
		return fmt.Errorf("username is required")
	}
	if s.Password == nil {
		return fmt.Errorf("password is required")
	}
	if s.Password != nil {
		if err := s.Password.validate(); err != nil {
			return fmt.Errorf("password: %w", err)
		}
	}
	return nil
}

func (s *KubernetesOpenFgaDataStoreInput) applyDefaults() {
	if s.Password != nil {
		s.Password.applyDefaults()
	}
}

func (s *KubernetesOpenFgaDataStoreInput) toMap() map[string]any {
	m := make(map[string]any)
	m["engine"] = s.Engine
	m["host"] = s.Host
	if s.Port != 0 {
		m["port"] = s.Port
	}
	m["database"] = s.Database
	m["username"] = s.Username
	if s.Password != nil {
		m["password"] = s.Password.toMap()
	}
	if s.IsSecure {
		m["is_secure"] = s.IsSecure
	}
	return m
}

// *
//
//	KubernetesOpenFgaIngress defines the ingress configuration for OpenFGA.
type KubernetesOpenFgaIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "openfga.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'openfga.example.com'). Required when enabled is true."`
}

func (s *KubernetesOpenFgaIngressInput) validate() error {
	return nil
}

func (s *KubernetesOpenFgaIngressInput) applyDefaults() {
}

func (s *KubernetesOpenFgaIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// ParseKubernetesOpenFga validates and normalizes a KubernetesOpenFga cloud_object.
func ParseKubernetesOpenFga(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesOpenFga"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesOpenFgaSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
