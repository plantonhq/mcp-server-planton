// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// microservice-kubernetes
type KubernetesDeploymentSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The version of the microservice being deployed.
	// This is usually either "main" (the default git branch name) or "review-<id>" where <id> is the merge request number.
	// It must be between 1 and 30 characters and can only contain lowercase letters, numbers, and hyphens.
	Version string `json:"version,omitempty" jsonschema:"The version of the microservice being deployed. This is usually either 'main' (the default git branch name) or 'review-<id>' where <id> is the merge request number. It must be between 1 and 30 charact..."`
	// The container specifications for the microservice deployment.
	// This includes configurations for the main application container and any sidecar containers.
	Container *KubernetesDeploymentContainerInput `json:"container" jsonschema:"required,The container specifications for the microservice deployment. This includes configurations for the main application container and any sidecar containers."`
	// The ingress configuration for the microservice.
	// This defines how the microservice can be accessed externally.
	Ingress *KubernetesDeploymentIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the microservice. This defines how the microservice can be accessed externally."`
	// The availability configuration for the microservice.
	// This includes settings for replicas, autoscaling, deployment strategy, and pod disruption budgets.
	Availability *KubernetesDeploymentAvailabilityInput `json:"availability,omitempty" jsonschema:"The availability configuration for the microservice. This includes settings for replicas; autoscaling; deployment strategy; and pod disruption budgets."`
	// *
	//  ConfigMaps to create alongside the deployment.
	//  Key is the ConfigMap name, value is the content.
	//  For multi-key ConfigMaps, use YAML format in the value.
	//  These ConfigMaps can be referenced in volume mounts.
	//
	//  Example:
	//    config_maps:
	//      app-config: |
	//        key1: value1
	//        key2: value2
	//    ...
	ConfigMaps map[string]string `json:"config_maps,omitempty" jsonschema:"* ConfigMaps to create alongside the deployment. Key is the ConfigMap name; value is the content. For multi-key ConfigMaps; use YAML format in the value. These ConfigMaps can be referenced in volume m..."`
}

func (s *KubernetesDeploymentSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.Availability != nil {
		if err := s.Availability.validate(); err != nil {
			return fmt.Errorf("availability: %w", err)
		}
	}
	return nil
}

func (s *KubernetesDeploymentSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.Availability != nil {
		s.Availability.applyDefaults()
	}
}

func (s *KubernetesDeploymentSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.Availability != nil {
		m["availability"] = s.Availability.toMap()
	}
	if len(s.ConfigMaps) > 0 {
		m["config_maps"] = s.ConfigMaps
	}
	return m
}

// *
//
//	**KubernetesDeploymentAvailability** specifies the availability configuration for the microservice.
//	Groups all settings related to high availability: replicas, autoscaling, deployment strategy, and disruption budgets.
//	Proper configuration of these fields enables zero-downtime deployments and resilient operations.
type KubernetesDeploymentAvailabilityInput struct {
	// The minimum number of pod replicas to maintain.
	MinReplicas int32 `json:"min_replicas,omitempty" jsonschema:"The minimum number of pod replicas to maintain."`
	// The configuration for horizontal pod autoscaling.
	HorizontalPodAutoscaling *KubernetesDeploymentAvailabilityHpaInput `json:"horizontal_pod_autoscaling,omitempty" jsonschema:"The configuration for horizontal pod autoscaling."`
	// Deployment strategy configuration for rolling updates.
	//  Controls how pod updates are rolled out to achieve zero-downtime deployments.
	//  If not specified, uses Kubernetes default (maxUnavailable: 25%, maxSurge: 25%).
	DeploymentStrategy *KubernetesDeploymentDeploymentStrategyInput `json:"deployment_strategy,omitempty" jsonschema:"Deployment strategy configuration for rolling updates. Controls how pod updates are rolled out to achieve zero-downtime deployments. If not specified; uses Kubernetes default (maxUnavailable: 25%; max..."`
	// Pod disruption budget configuration.
	//  Ensures minimum availability during voluntary disruptions (node maintenance, cluster upgrades).
	//  Helps prevent service outages during infrastructure operations.
	PodDisruptionBudget *KubernetesDeploymentPodDisruptionBudgetInput `json:"pod_disruption_budget,omitempty" jsonschema:"Pod disruption budget configuration. Ensures minimum availability during voluntary disruptions (node maintenance; cluster upgrades). Helps prevent service outages during infrastructure operations."`
}

func (s *KubernetesDeploymentAvailabilityInput) validate() error {
	if s.HorizontalPodAutoscaling != nil {
		if err := s.HorizontalPodAutoscaling.validate(); err != nil {
			return fmt.Errorf("horizontal_pod_autoscaling: %w", err)
		}
	}
	if s.DeploymentStrategy != nil {
		if err := s.DeploymentStrategy.validate(); err != nil {
			return fmt.Errorf("deployment_strategy: %w", err)
		}
	}
	if s.PodDisruptionBudget != nil {
		if err := s.PodDisruptionBudget.validate(); err != nil {
			return fmt.Errorf("pod_disruption_budget: %w", err)
		}
	}
	return nil
}

func (s *KubernetesDeploymentAvailabilityInput) applyDefaults() {
	if s.HorizontalPodAutoscaling != nil {
		s.HorizontalPodAutoscaling.applyDefaults()
	}
	if s.DeploymentStrategy != nil {
		s.DeploymentStrategy.applyDefaults()
	}
	if s.PodDisruptionBudget != nil {
		s.PodDisruptionBudget.applyDefaults()
	}
}

func (s *KubernetesDeploymentAvailabilityInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinReplicas != 0 {
		m["min_replicas"] = s.MinReplicas
	}
	if s.HorizontalPodAutoscaling != nil {
		m["horizontal_pod_autoscaling"] = s.HorizontalPodAutoscaling.toMap()
	}
	if s.DeploymentStrategy != nil {
		m["deployment_strategy"] = s.DeploymentStrategy.toMap()
	}
	if s.PodDisruptionBudget != nil {
		m["pod_disruption_budget"] = s.PodDisruptionBudget.toMap()
	}
	return m
}

// *
//
//	**KubernetesDeploymentAvailabilityHpa** specifies the horizontal pod autoscaling configuration.
//	It includes settings to enable autoscaling based on CPU and memory utilization.
type KubernetesDeploymentAvailabilityHpaInput struct {
	// A flag to enable or disable horizontal pod autoscaling.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"A flag to enable or disable horizontal pod autoscaling."`
	// The target CPU utilization percentage to trigger autoscaling (e.g., 60.0).
	TargetCpuUtilizationPercent float64 `json:"target_cpu_utilization_percent,omitempty" jsonschema:"The target CPU utilization percentage to trigger autoscaling (e.g.; 60.0)."`
	// The target memory utilization to trigger autoscaling (e.g., "1Gi").
	TargetMemoryUtilization string `json:"target_memory_utilization,omitempty" jsonschema:"The target memory utilization to trigger autoscaling (e.g.; '1Gi')."`
}

func (s *KubernetesDeploymentAvailabilityHpaInput) validate() error {
	return nil
}

func (s *KubernetesDeploymentAvailabilityHpaInput) applyDefaults() {
}

func (s *KubernetesDeploymentAvailabilityHpaInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.TargetCpuUtilizationPercent != 0 {
		m["target_cpu_utilization_percent"] = s.TargetCpuUtilizationPercent
	}
	if s.TargetMemoryUtilization != "" {
		m["target_memory_utilization"] = s.TargetMemoryUtilization
	}
	return m
}

// *
//
//	**KubernetesDeploymentContainer** specifies the container configuration for the microservice.
//	It includes the main application container and any sidecar containers that need to run alongside it.
type KubernetesDeploymentContainerInput struct {
	// The main application container specifications.
	App *KubernetesDeploymentContainerAppInput `json:"app" jsonschema:"required,The main application container specifications."`
	// A list of sidecar containers to be deployed alongside the main application container.
	Sidecars []*ContainerInput `json:"sidecars,omitempty" jsonschema:"A list of sidecar containers to be deployed alongside the main application container."`
}

func (s *KubernetesDeploymentContainerInput) validate() error {
	if s.App == nil {
		return fmt.Errorf("app is required")
	}
	if s.App != nil {
		if err := s.App.validate(); err != nil {
			return fmt.Errorf("app: %w", err)
		}
	}
	for i, v := range s.Sidecars {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("sidecars[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesDeploymentContainerInput) applyDefaults() {
	if s.App != nil {
		s.App.applyDefaults()
	}
}

func (s *KubernetesDeploymentContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.App != nil {
		m["app"] = s.App.toMap()
	}
	if len(s.Sidecars) > 0 {
		items := make([]any, len(s.Sidecars))
		for i, v := range s.Sidecars {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["sidecars"] = items
	}
	return m
}

// *
//
//	**KubernetesDeploymentContainerApp** specifies the configuration for the main application container.
//	It includes the container image, resource allocations, environment variables, ports, and health probes.
type KubernetesDeploymentContainerAppInput struct {
	// *
	//  The container image to be used for the application.
	//  This value is computed during creation but can be updated.
	//  It is derived by combining the Docker repository of the artifact store configured for the environment and the code project path.
	//  The `pull_secret_name` is the name of the image pull s...
	Image *ContainerImageInput `json:"image" jsonschema:"required,* The container image to be used for the application. This value is computed during creation but can be updated. It is derived by combining the Docker repository of the artifact store configured for t..."`
	// The CPU and memory resources allocated to the application container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the application container."`
	// *
	//  The environment variables and secrets for the application container.
	Env *KubernetesDeploymentContainerAppEnvInput `json:"env,omitempty" jsonschema:"* The environment variables and secrets for the application container."`
	// *
	//  A list of ports to be configured for the application container.
	Ports []*KubernetesDeploymentContainerAppPortInput `json:"ports,omitempty" jsonschema:"* A list of ports to be configured for the application container."`
	// *
	//  Liveness probe configuration.
	//  Periodic probe of container liveness. Container will be restarted if the probe fails.
	//  This helps detect and recover from deadlocks or unresponsive applications.
	//  Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
	LivenessProbe *ProbeInput `json:"liveness_probe,omitempty" jsonschema:"* Liveness probe configuration. Periodic probe of container liveness. Container will be restarted if the probe fails. This helps detect and recover from deadlocks or unresponsive applications. Referen..."`
	// *
	//  Readiness probe configuration.
	//  Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails.
	//  This ensures traffic is only routed to pods that are ready to handle requests.
	//  Essential for zero-downtime deployments.
	//  Reference: https://kuberne...
	ReadinessProbe *ProbeInput `json:"readiness_probe,omitempty" jsonschema:"* Readiness probe configuration. Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. This ensures traffic is only routed to pods that ar..."`
	// *
	//  Startup probe configuration.
	//  Indicates whether the application within the container is started.
	//  All other probes are disabled if a startup probe is provided, until it succeeds.
	//  Useful for slow-starting containers to avoid them getting killed by liveness probes before they are up.
	//  Reference: h...
	StartupProbe *ProbeInput `json:"startup_probe,omitempty" jsonschema:"* Startup probe configuration. Indicates whether the application within the container is started. All other probes are disabled if a startup probe is provided; until it succeeds. Useful for slow-start..."`
	// *
	//  Volume mounts for the application container.
	//  Supports mounting ConfigMaps, Secrets, HostPaths, EmptyDirs, and PVCs.
	//  ConfigMaps defined in spec.config_maps can be referenced here.
	//
	//  Example:
	//    volume_mounts:
	//      - name: config-volume
	//        mount_path: /etc/app/config.yaml
	//        config_map:
	//  ...
	VolumeMounts []*VolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"* Volume mounts for the application container. Supports mounting ConfigMaps; Secrets; HostPaths; EmptyDirs; and PVCs. ConfigMaps defined in spec.config_maps can be referenced here. Example: volume_mou..."`
	// *
	//  Command to run in the container (overrides the container image's ENTRYPOINT).
	//  Example: ["/bin/sh", "-c"]
	Command []string `json:"command,omitempty" jsonschema:"* Command to run in the container (overrides the container image's ENTRYPOINT). Example: ['/bin/sh'; '-c']"`
	// *
	//  Arguments to pass to the command (overrides the container image's CMD).
	//  Example: ["echo hello"]
	Args []string `json:"args,omitempty" jsonschema:"* Arguments to pass to the command (overrides the container image's CMD). Example: ['echo hello']"`
}

func (s *KubernetesDeploymentContainerAppInput) validate() error {
	if s.Image == nil {
		return fmt.Errorf("image is required")
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	for i, v := range s.Ports {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ports[%d]: %w", i, err)
			}
		}
	}
	if s.LivenessProbe != nil {
		if err := s.LivenessProbe.validate(); err != nil {
			return fmt.Errorf("liveness_probe: %w", err)
		}
	}
	if s.ReadinessProbe != nil {
		if err := s.ReadinessProbe.validate(); err != nil {
			return fmt.Errorf("readiness_probe: %w", err)
		}
	}
	if s.StartupProbe != nil {
		if err := s.StartupProbe.validate(); err != nil {
			return fmt.Errorf("startup_probe: %w", err)
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesDeploymentContainerAppInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.LivenessProbe != nil {
		s.LivenessProbe.applyDefaults()
	}
	if s.ReadinessProbe != nil {
		s.ReadinessProbe.applyDefaults()
	}
	if s.StartupProbe != nil {
		s.StartupProbe.applyDefaults()
	}
}

func (s *KubernetesDeploymentContainerAppInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	if len(s.Ports) > 0 {
		items := make([]any, len(s.Ports))
		for i, v := range s.Ports {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ports"] = items
	}
	if s.LivenessProbe != nil {
		m["liveness_probe"] = s.LivenessProbe.toMap()
	}
	if s.ReadinessProbe != nil {
		m["readiness_probe"] = s.ReadinessProbe.toMap()
	}
	if s.StartupProbe != nil {
		m["startup_probe"] = s.StartupProbe.toMap()
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	return m
}

// *
//
//	**KubernetesDeploymentContainerAppEnv** defines the environment variables and secrets for the application container.
type KubernetesDeploymentContainerAppEnvInput struct {
	// *
	//  A map of environment variable names to their values.
	//  Each variable can be provided either as a literal string value or as a reference
	//  to another OpenMCF resource's field.
	//
	//  **Option 1: Direct string value**
	//  ```yaml
	//  variables:
	//    DATABASE_PORT:
	//      value: "5432"
	//  ```
	//
	//  **Option 2: Reference t...
	Variables map[string]string `json:"variables,omitempty" jsonschema:"* A map of environment variable names to their values. Each variable can be provided either as a literal string value or as a reference to another OpenMCF resource's field. **Option 1: Direct string v..."`
	// *
	//  A map of secret environment variable names to their values.
	//  Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret.
	//
	//  Using secret references is recommended for production deployments to avoid storing
	//  sensitive values in plain text within...
	Secrets map[string]*KubernetesSensitiveValueInput `json:"secrets,omitempty" jsonschema:"* A map of secret environment variable names to their values. Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret. Using secret references i..."`
}

func (s *KubernetesDeploymentContainerAppEnvInput) validate() error {
	for k, v := range s.Secrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secrets[%s]: %w", k, err)
			}
		}
	}
	return nil
}

func (s *KubernetesDeploymentContainerAppEnvInput) applyDefaults() {
}

func (s *KubernetesDeploymentContainerAppEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		result := make(map[string]any, len(s.Secrets))
		for k, v := range s.Secrets {
			if v != nil {
				result[k] = v.toMap()
			}
		}
		m["secrets"] = result
	}
	return m
}

// *
//
//	**KubernetesDeploymentContainerAppPort** specifies the port configuration for the application container.
//	It includes details such as the port name, container port, network protocol, application protocol, and service port.
type KubernetesDeploymentContainerAppPortInput struct {
	// The name of the port (e.g., "http", "grpc").
	// The name must only contain lowercase alphanumeric characters and hyphens.
	// Port names must also start and end with an alphanumeric character.
	// For example, "123-abc" and "web" are valid, but "123_abc" and "-web" are not.
	Name string `json:"name" jsonschema:"required,The name of the port (e.g.; 'http'; 'grpc'). The name must only contain lowercase alphanumeric characters and hyphens. Port names must also start and end with an alphanumeric character. For example; '..."`
	// The port number on the container.
	ContainerPort int32 `json:"container_port" jsonschema:"required,The port number on the container."`
	// The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
	// Must be one of "TCP", "UDP", or "SCTP".
	NetworkProtocol string `json:"network_protocol" jsonschema:"required,The network protocol used by the port (e.g.; 'TCP'; 'UDP'; 'SCTP'). Must be one of 'TCP'; 'UDP'; or 'SCTP'."`
	// The application protocol for the microservice (e.g., "http").
	// This field is used for setting up the name of the service port in Kubernetes.
	// It is used during microservice deployment and is relevant for deployment and stateful set pod managers.
	// Refer to: https://kubernetes.io/docs/concepts/services-n...
	AppProtocol string `json:"app_protocol" jsonschema:"required,The application protocol for the microservice (e.g.; 'http'). This field is used for setting up the name of the service port in Kubernetes. It is used during microservice deployment and is relevant fo..."`
	// The port number on the Kubernetes service.
	ServicePort int32 `json:"service_port" jsonschema:"required,The port number on the Kubernetes service."`
	// A flag indicating whether this port should be exposed via ingress.
	IsIngressPort bool `json:"is_ingress_port,omitempty" jsonschema:"A flag indicating whether this port should be exposed via ingress."`
}

func (s *KubernetesDeploymentContainerAppPortInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.NetworkProtocol == "" {
		return fmt.Errorf("network_protocol is required")
	}
	if s.AppProtocol == "" {
		return fmt.Errorf("app_protocol is required")
	}
	return nil
}

func (s *KubernetesDeploymentContainerAppPortInput) applyDefaults() {
}

func (s *KubernetesDeploymentContainerAppPortInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["container_port"] = s.ContainerPort
	m["network_protocol"] = s.NetworkProtocol
	m["app_protocol"] = s.AppProtocol
	m["service_port"] = s.ServicePort
	if s.IsIngressPort {
		m["is_ingress_port"] = s.IsIngressPort
	}
	return m
}

// *
//
//	**KubernetesDeploymentDeploymentStrategy** defines the deployment strategy for rolling updates.
//	This controls how Kubernetes replaces old pods with new ones during updates.
//	Proper configuration enables zero-downtime deployments.
//	Reference: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
type KubernetesDeploymentDeploymentStrategyInput struct {
	// *
	//  The maximum number of pods that can be unavailable during the update.
	//  Can be an absolute number (e.g., 0) or a percentage of desired pods (e.g., "25%").
	//
	//  For zero-downtime deployments, set to 0 or "0%".
	//  This ensures at least the desired number of pods are always available.
	//
	//  Defaults to 25% if...
	MaxUnavailable string `json:"max_unavailable,omitempty" jsonschema:"* The maximum number of pods that can be unavailable during the update. Can be an absolute number (e.g.; 0) or a percentage of desired pods (e.g.; '25%'). For zero-downtime deployments; set to 0 or '0..."`
	// *
	//  The maximum number of pods that can be created above the desired number of pods.
	//  Can be an absolute number (e.g., 1) or a percentage of desired pods (e.g., "25%").
	//
	//  For zero-downtime deployments with max_unavailable=0, set to at least 1 or "100%".
	//  This allows new pods to be created before old ...
	MaxSurge string `json:"max_surge,omitempty" jsonschema:"* The maximum number of pods that can be created above the desired number of pods. Can be an absolute number (e.g.; 1) or a percentage of desired pods (e.g.; '25%'). For zero-downtime deployments with..."`
}

func (s *KubernetesDeploymentDeploymentStrategyInput) validate() error {
	return nil
}

func (s *KubernetesDeploymentDeploymentStrategyInput) applyDefaults() {
}

func (s *KubernetesDeploymentDeploymentStrategyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MaxUnavailable != "" {
		m["max_unavailable"] = s.MaxUnavailable
	}
	if s.MaxSurge != "" {
		m["max_surge"] = s.MaxSurge
	}
	return m
}

// *
//
//	KubernetesDeploymentIngress defines ingress configuration for the deployment.
type KubernetesDeploymentIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "myapp.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'myapp.example.com'). Required when enabled is true."`
}

func (s *KubernetesDeploymentIngressInput) validate() error {
	return nil
}

func (s *KubernetesDeploymentIngressInput) applyDefaults() {
}

func (s *KubernetesDeploymentIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	**KubernetesDeploymentPodDisruptionBudget** configures a PodDisruptionBudget (PDB) to ensure
//	minimum availability during voluntary disruptions like node maintenance or cluster upgrades.
//	Reference: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
type KubernetesDeploymentPodDisruptionBudgetInput struct {
	// *
	//  Enable or disable PodDisruptionBudget creation.
	//  When disabled, no PDB is created and the cluster can evict pods freely.
	//  When enabled, the cluster must respect the min_available constraint.
	Enabled bool `json:"enabled,omitempty" jsonschema:"* Enable or disable PodDisruptionBudget creation. When disabled; no PDB is created and the cluster can evict pods freely. When enabled; the cluster must respect the min_available constraint."`
	// *
	//  Minimum number of pods that must be available during voluntary disruptions.
	//  Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
	//
	//  For high availability, typically set to:
	//  - 1 for single-replica services (ensures at least one pod always available)
	//  - N-1 for N-replica services (al...
	MinAvailable string `json:"min_available,omitempty" jsonschema:"* Minimum number of pods that must be available during voluntary disruptions. Can be an absolute number (e.g.; 1) or a percentage (e.g.; '50%'). For high availability; typically set to: - 1 for single..."`
	// *
	//  Maximum number of pods that can be unavailable during voluntary disruptions.
	//  Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
	//
	//  This is an alternative to min_available.
	//  Cannot be used together with min_available.
	MaxUnavailable string `json:"max_unavailable,omitempty" jsonschema:"* Maximum number of pods that can be unavailable during voluntary disruptions. Can be an absolute number (e.g.; 1) or a percentage (e.g.; '50%'). This is an alternative to min_available. Cannot be use..."`
}

func (s *KubernetesDeploymentPodDisruptionBudgetInput) validate() error {
	return nil
}

func (s *KubernetesDeploymentPodDisruptionBudgetInput) applyDefaults() {
}

func (s *KubernetesDeploymentPodDisruptionBudgetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.MinAvailable != "" {
		m["min_available"] = s.MinAvailable
	}
	if s.MaxUnavailable != "" {
		m["max_unavailable"] = s.MaxUnavailable
	}
	return m
}

// ParseKubernetesDeployment validates and normalizes a KubernetesDeployment cloud_object.
func ParseKubernetesDeployment(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesDeployment"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesDeploymentSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
