// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// locust-kubernetes
type KubernetesLocustSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The master container specifications for the Locust cluster.
	//  This defines the resource allocation and number of replicas for the master node.
	MasterContainer *KubernetesLocustContainerInput `json:"master_container,omitempty" jsonschema:"The master container specifications for the Locust cluster. This defines the resource allocation and number of replicas for the master node."`
	// The worker container specifications for the Locust cluster.
	//  This defines the resource allocation and number of replicas for the worker nodes.
	WorkerContainer *KubernetesLocustContainerInput `json:"worker_container,omitempty" jsonschema:"The worker container specifications for the Locust cluster. This defines the resource allocation and number of replicas for the worker nodes."`
	// The ingress configuration for the Locust deployment.
	Ingress *KubernetesLocustIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the Locust deployment."`
	// The load test parameters, including the main test script, additional library files,
	//  and extra Python pip packages needed for test execution.
	//  This specifies how the Locust nodes will simulate traffic and interact with the target application.
	LoadTest *KubernetesLocustLoadTestInput `json:"load_test" jsonschema:"required,The load test parameters; including the main test script; additional library files; and extra Python pip packages needed for test execution. This specifies how the Locust nodes will simulate traffic a..."`
	// A map of key-value pairs providing additional customization options for the Helm chart used
	//  to deploy the Locust cluster. These values allow for further refinement of the deployment,
	//  such as customizing resource limits, setting environment variables, or specifying version tags.
	//  For detailed infor...
	HelmValues map[string]string `json:"helm_values,omitempty" jsonschema:"A map of key-value pairs providing additional customization options for the Helm chart used to deploy the Locust cluster. These values allow for further refinement of the deployment; such as customizi..."`
}

func (s *KubernetesLocustSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.MasterContainer != nil {
		if err := s.MasterContainer.validate(); err != nil {
			return fmt.Errorf("master_container: %w", err)
		}
	}
	if s.WorkerContainer != nil {
		if err := s.WorkerContainer.validate(); err != nil {
			return fmt.Errorf("worker_container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.LoadTest == nil {
		return fmt.Errorf("load_test is required")
	}
	if s.LoadTest != nil {
		if err := s.LoadTest.validate(); err != nil {
			return fmt.Errorf("load_test: %w", err)
		}
	}
	return nil
}

func (s *KubernetesLocustSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.MasterContainer != nil {
		s.MasterContainer.applyDefaults()
	}
	if s.WorkerContainer != nil {
		s.WorkerContainer.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.LoadTest != nil {
		s.LoadTest.applyDefaults()
	}
}

func (s *KubernetesLocustSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.MasterContainer != nil {
		m["master_container"] = s.MasterContainer.toMap()
	}
	if s.WorkerContainer != nil {
		m["worker_container"] = s.WorkerContainer.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.LoadTest != nil {
		m["load_test"] = s.LoadTest.toMap()
	}
	if len(s.HelmValues) > 0 {
		m["helm_values"] = s.HelmValues
	}
	return m
}

// **KubernetesLocustContainer** specifies the container configuration for Locust master and worker nodes.
//
//	It includes resource allocations for CPU and memory, as well as the number of replicas to deploy.
//	Proper configuration ensures optimal performance and scalability of your load testing environment.
type KubernetesLocustContainerInput struct {
	// The number of replicas for the container.
	//  This determines the level of concurrency and load generation capabilities.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of replicas for the container. This determines the level of concurrency and load generation capabilities."`
	// The CPU and memory resources allocated to the Locust container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Locust container."`
}

func (s *KubernetesLocustContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesLocustContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesLocustContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// *
//
//	KubernetesLocustIngress defines ingress configuration for Locust.
type KubernetesLocustIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "locust.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'locust.example.com'). Required when enabled is true."`
}

func (s *KubernetesLocustIngressInput) validate() error {
	return nil
}

func (s *KubernetesLocustIngressInput) applyDefaults() {
}

func (s *KubernetesLocustIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// **KubernetesLocustLoadTest** defines the specification for a load test using a Locust cluster.
//
//	This message includes the primary Python script for Locust and any additional library files
//	necessary to execute the load test. By providing these details, you can define the behavior
//	of simulated users and customize the load test according to your application's requirements.
type KubernetesLocustLoadTestInput struct {
	// A unique identifier or name for this particular load test specification.
	//  It is used to reference or distinguish this test configuration among others within a testing suite or environment.
	Name string `json:"name" jsonschema:"required,A unique identifier or name for this particular load test specification. It is used to reference or distinguish this test configuration among others within a testing suite or environment."`
	// The Python code for the main Locust test script.
	//  This script defines the behavior of the simulated users and is crucial for executing the load test.
	MainPyContent string `json:"main_py_content" jsonschema:"required,The Python code for the main Locust test script. This script defines the behavior of the simulated users and is crucial for executing the load test."`
	// A map where each entry consists of a filename and its associated Python code content.
	//  These files typically contain additional classes or functions required by the main_py_content script.
	//  The key of the map is the filename, and the value is the file content.
	LibFilesContent map[string]string `json:"lib_files_content" jsonschema:"required,A map where each entry consists of a filename and its associated Python code content. These files typically contain additional classes or functions required by the main_py_content script. The key of t..."`
	// A list of extra Python pip packages that are required for the load test.
	//  These packages will be installed in the environment where the load test is executed,
	//  allowing for extended functionality or custom dependencies to be included easily.
	PipPackages []string `json:"pip_packages,omitempty" jsonschema:"A list of extra Python pip packages that are required for the load test. These packages will be installed in the environment where the load test is executed; allowing for extended functionality or cus..."`
}

func (s *KubernetesLocustLoadTestInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.MainPyContent == "" {
		return fmt.Errorf("main_py_content is required")
	}
	return nil
}

func (s *KubernetesLocustLoadTestInput) applyDefaults() {
}

func (s *KubernetesLocustLoadTestInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["main_py_content"] = s.MainPyContent
	if len(s.LibFilesContent) > 0 {
		m["lib_files_content"] = s.LibFilesContent
	}
	if len(s.PipPackages) > 0 {
		m["pip_packages"] = s.PipPackages
	}
	return m
}

// ParseKubernetesLocust validates and normalizes a KubernetesLocust cloud_object.
func ParseKubernetesLocust(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesLocust"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesLocustSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
