// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesOpenBao is a Kubernetes-based deployment of OpenBao, an open-source secrets management solution.
//
//	OpenBao is a fork of HashiCorp Vault, providing secure secret storage, dynamic secrets, data encryption,
//	leasing/renewal, and revocation capabilities.
type KubernetesOpenBaoSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// Flag to indicate if the namespace should be created.
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created."`
	// Helm chart version override.
	//  Default: 0.23.3
	HelmChartVersion string `json:"helm_chart_version,omitempty" jsonschema:"Helm chart version override. Default: 0.23.3"`
	// Server container specifications for the OpenBao deployment.
	ServerContainer *KubernetesOpenBaoServerContainerInput `json:"server_container,omitempty" jsonschema:"Server container specifications for the OpenBao deployment."`
	// High Availability configuration.
	//  When enabled, OpenBao runs in HA mode with Raft integrated storage.
	HighAvailability *KubernetesOpenBaoHighAvailabilityInput `json:"high_availability,omitempty" jsonschema:"High Availability configuration. When enabled; OpenBao runs in HA mode with Raft integrated storage."`
	// Ingress configuration for external access to OpenBao.
	Ingress *KubernetesOpenBaoIngressInput `json:"ingress,omitempty" jsonschema:"Ingress configuration for external access to OpenBao."`
	// Enable OpenBao UI.
	//  Default: true
	UiEnabled bool `json:"ui_enabled,omitempty" jsonschema:"Enable OpenBao UI. Default: true"`
	// OpenBao Agent Injector configuration.
	//  When enabled, deploys the injector for automatic sidecar injection.
	Injector *KubernetesOpenBaoInjectorInput `json:"injector,omitempty" jsonschema:"OpenBao Agent Injector configuration. When enabled; deploys the injector for automatic sidecar injection."`
	// TLS configuration.
	//  Default: TLS is disabled (tlsDisable: true in Helm values).
	TlsEnabled bool `json:"tls_enabled,omitempty" jsonschema:"TLS configuration. Default: TLS is disabled (tlsDisable: true in Helm values)."`
}

func (s *KubernetesOpenBaoSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.ServerContainer != nil {
		if err := s.ServerContainer.validate(); err != nil {
			return fmt.Errorf("server_container: %w", err)
		}
	}
	if s.HighAvailability != nil {
		if err := s.HighAvailability.validate(); err != nil {
			return fmt.Errorf("high_availability: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.Injector != nil {
		if err := s.Injector.validate(); err != nil {
			return fmt.Errorf("injector: %w", err)
		}
	}
	return nil
}

func (s *KubernetesOpenBaoSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.HelmChartVersion == "" {
		s.HelmChartVersion = "0.23.3"
	}
	if s.ServerContainer != nil {
		s.ServerContainer.applyDefaults()
	}
	if s.HighAvailability != nil {
		s.HighAvailability.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	// default: UiEnabled = true (applied at zero-value)
	if s.Injector != nil {
		s.Injector.applyDefaults()
	}
}

func (s *KubernetesOpenBaoSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.HelmChartVersion != "" {
		m["helm_chart_version"] = s.HelmChartVersion
	}
	if s.ServerContainer != nil {
		m["server_container"] = s.ServerContainer.toMap()
	}
	if s.HighAvailability != nil {
		m["high_availability"] = s.HighAvailability.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.UiEnabled {
		m["ui_enabled"] = s.UiEnabled
	}
	if s.Injector != nil {
		m["injector"] = s.Injector.toMap()
	}
	if s.TlsEnabled {
		m["tls_enabled"] = s.TlsEnabled
	}
	return m
}

// *
//
//	KubernetesOpenBaoHighAvailability defines HA configuration with Raft integrated storage.
type KubernetesOpenBaoHighAvailabilityInput struct {
	// Enable High Availability mode with Raft integrated storage.
	//  When enabled, OpenBao uses Raft for both storage and leader election.
	//  Requires at least 3 replicas for proper Raft consensus.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable High Availability mode with Raft integrated storage. When enabled; OpenBao uses Raft for both storage and leader election. Requires at least 3 replicas for proper Raft consensus."`
	// Number of HA replicas.
	//  Should be an odd number (3, 5, 7) for proper Raft consensus.
	//  Default: 3
	Replicas int32 `json:"replicas,omitempty" jsonschema:"Number of HA replicas. Should be an odd number (3; 5; 7) for proper Raft consensus. Default: 3"`
}

func (s *KubernetesOpenBaoHighAvailabilityInput) validate() error {
	return nil
}

func (s *KubernetesOpenBaoHighAvailabilityInput) applyDefaults() {
	if s.Replicas == 0 {
		s.Replicas = 3
	}
}

func (s *KubernetesOpenBaoHighAvailabilityInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	return m
}

// *
//
//	KubernetesOpenBaoIngress defines ingress configuration for OpenBao.
//	When enabled, deploys Istio Gateway API resources (Certificate, Gateway, HTTPRoutes)
//	for TLS-terminated external access with automatic HTTP-to-HTTPS redirect.
type KubernetesOpenBaoIngressInput struct {
	// Enable ingress for external access.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable ingress for external access."`
	// The full hostname for external access (e.g., "openbao.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'openbao.example.com'). Required when enabled is true."`
}

func (s *KubernetesOpenBaoIngressInput) validate() error {
	return nil
}

func (s *KubernetesOpenBaoIngressInput) applyDefaults() {
}

func (s *KubernetesOpenBaoIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	KubernetesOpenBaoInjector defines the Agent Injector configuration.
//	The injector enables automatic sidecar injection of OpenBao Agent containers into pods.
type KubernetesOpenBaoInjectorInput struct {
	// Enable the OpenBao Agent Injector.
	//  When enabled, deploys a mutating webhook for automatic secret injection.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable the OpenBao Agent Injector. When enabled; deploys a mutating webhook for automatic secret injection."`
	// Number of injector replicas.
	//  Default: 1
	Replicas int32 `json:"replicas,omitempty" jsonschema:"Number of injector replicas. Default: 1"`
}

func (s *KubernetesOpenBaoInjectorInput) validate() error {
	return nil
}

func (s *KubernetesOpenBaoInjectorInput) applyDefaults() {
	if s.Replicas == 0 {
		s.Replicas = 1
	}
}

func (s *KubernetesOpenBaoInjectorInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	return m
}

// *
//
//	KubernetesOpenBaoServerContainer defines the container specifications for the OpenBao server.
type KubernetesOpenBaoServerContainerInput struct {
	// Number of OpenBao server replicas.
	//  For standalone mode, this is typically 1.
	//  For HA mode, this should be 3 or more (odd numbers recommended for Raft consensus).
	Replicas int32 `json:"replicas,omitempty" jsonschema:"Number of OpenBao server replicas. For standalone mode; this is typically 1. For HA mode; this should be 3 or more (odd numbers recommended for Raft consensus)."`
	// CPU and memory resources allocated to the OpenBao server container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"CPU and memory resources allocated to the OpenBao server container."`
	// Size of the persistent volume for OpenBao data storage.
	//  Used for both standalone (file storage) and HA (Raft storage) modes.
	//  Example values: "10Gi", "50Gi", "100Gi"
	//  Must match Kubernetes storage size format.
	DataStorageSize string `json:"data_storage_size,omitempty" jsonschema:"Size of the persistent volume for OpenBao data storage. Used for both standalone (file storage) and HA (Raft storage) modes. Example values: '10Gi'; '50Gi'; '100Gi' Must match Kubernetes storage size ..."`
}

func (s *KubernetesOpenBaoServerContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesOpenBaoServerContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesOpenBaoServerContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.DataStorageSize != "" {
		m["data_storage_size"] = s.DataStorageSize
	}
	return m
}

// ParseKubernetesOpenBao validates and normalizes a KubernetesOpenBao cloud_object.
func ParseKubernetesOpenBao(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesOpenBao"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesOpenBaoSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
