// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesGhaRunnerScaleSetController is a deployment component that installs the GitHub Actions
//
//	Runner Scale Set Controller on a Kubernetes cluster. The controller manages AutoScalingRunnerSets
//	and EphemeralRunners, enabling dynamic scaling of self-hosted GitHub Actions runners based on
//	workflow demand.
//
//	Use this component to deploy the controller first, then deploy runner scale sets using the
//	separate gha-runner-scale-set Helm chart (or a corresponding OpenMCF component).
type KubernetesGhaRunnerScaleSetControllerSpecInput struct {
	// Target Kubernetes Cluster where the controller will be deployed.
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster where the controller will be deployed."`
	// Kubernetes Namespace where the controller will be installed.
	//  The controller watches for AutoScalingRunnerSet resources across all namespaces by default,
	//  or can be restricted to a single namespace via flags.watch_single_namespace.
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace where the controller will be installed. The controller watches for AutoScalingRunnerSet resources across all namespaces by default; or can be restricted to a single namespace via ..."`
	// Flag to indicate if the namespace should be created.
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created."`
	// Version of the Helm chart to deploy.
	//  Chart versions match the controller image versions.
	//  https://github.com/actions/actions-runner-controller/releases
	HelmChartVersion string `json:"helm_chart_version,omitempty" jsonschema:"Version of the Helm chart to deploy. Chart versions match the controller image versions. https://github.com/actions/actions-runner-controller/releases"`
	// Number of controller replicas.
	//  When replicaCount > 1, leader election is automatically enabled.
	ReplicaCount int32 `json:"replica_count,omitempty" jsonschema:"Number of controller replicas. When replicaCount > 1; leader election is automatically enabled."`
	// Container specifications for the controller.
	Container *KubernetesGhaRunnerScaleSetControllerContainerInput `json:"container" jsonschema:"required,Container specifications for the controller."`
	// Controller behavior flags.
	Flags *KubernetesGhaRunnerScaleSetControllerFlagsInput `json:"flags,omitempty" jsonschema:"Controller behavior flags."`
	// Metrics configuration for monitoring.
	//  When not specified, metrics are disabled.
	Metrics *KubernetesGhaRunnerScaleSetControllerMetricsInput `json:"metrics,omitempty" jsonschema:"Metrics configuration for monitoring. When not specified; metrics are disabled."`
	// Image pull secrets for private container registries.
	//  These secrets are also passed to the auto-scaler for pulling listener images.
	ImagePullSecrets []string `json:"image_pull_secrets,omitempty" jsonschema:"Image pull secrets for private container registries. These secrets are also passed to the auto-scaler for pulling listener images."`
	// Priority class name for the controller pods.
	//  Use "system-cluster-critical" to ensure controller survives resource pressure.
	PriorityClassName string `json:"priority_class_name,omitempty" jsonschema:"Priority class name for the controller pods. Use 'system-cluster-critical' to ensure controller survives resource pressure."`
}

func (s *KubernetesGhaRunnerScaleSetControllerSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Flags != nil {
		if err := s.Flags.validate(); err != nil {
			return fmt.Errorf("flags: %w", err)
		}
	}
	if s.Metrics != nil {
		if err := s.Metrics.validate(); err != nil {
			return fmt.Errorf("metrics: %w", err)
		}
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetControllerSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.HelmChartVersion == "" {
		s.HelmChartVersion = "0.13.1"
	}
	if s.ReplicaCount == 0 {
		s.ReplicaCount = 1
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Flags != nil {
		s.Flags.applyDefaults()
	}
	if s.Metrics != nil {
		s.Metrics.applyDefaults()
	}
}

func (s *KubernetesGhaRunnerScaleSetControllerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.HelmChartVersion != "" {
		m["helm_chart_version"] = s.HelmChartVersion
	}
	if s.ReplicaCount != 0 {
		m["replica_count"] = s.ReplicaCount
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Flags != nil {
		m["flags"] = s.Flags.toMap()
	}
	if s.Metrics != nil {
		m["metrics"] = s.Metrics.toMap()
	}
	if len(s.ImagePullSecrets) > 0 {
		m["image_pull_secrets"] = s.ImagePullSecrets
	}
	if s.PriorityClassName != "" {
		m["priority_class_name"] = s.PriorityClassName
	}
	return m
}

// KubernetesGhaRunnerScaleSetControllerContainer specifies container configuration for the controller.
type KubernetesGhaRunnerScaleSetControllerContainerInput struct {
	// CPU and memory resources for the controller container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"CPU and memory resources for the controller container."`
	// Custom container image configuration.
	//  When not specified, uses the default image from the Helm chart.
	Image *KubernetesGhaRunnerScaleSetControllerImageInput `json:"image,omitempty" jsonschema:"Custom container image configuration. When not specified; uses the default image from the Helm chart."`
}

func (s *KubernetesGhaRunnerScaleSetControllerContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetControllerContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesGhaRunnerScaleSetControllerContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	return m
}

// KubernetesGhaRunnerScaleSetControllerFlags configures controller behavior.
type KubernetesGhaRunnerScaleSetControllerFlagsInput struct {
	// Log level for the controller.
	//  Valid values: debug, info, warn, error
	LogLevel string `json:"log_level,omitempty" jsonschema:"enum=debug|info|warn|error,Log level for the controller. Valid values: debug; info; warn; error"`
	// Log format for the controller.
	//  Valid values: text, json
	LogFormat string `json:"log_format,omitempty" jsonschema:"enum=text|json,Log format for the controller. Valid values: text; json"`
	// When set, restricts the controller to watch only the specified namespace.
	//  By default (empty), watches all namespaces.
	WatchSingleNamespace string `json:"watch_single_namespace,omitempty" jsonschema:"When set; restricts the controller to watch only the specified namespace. By default (empty); watches all namespaces."`
	// Maximum concurrent reconciles for the EphemeralRunner controller.
	//  Increase to improve throughput at the cost of higher API server load.
	RunnerMaxConcurrentReconciles int32 `json:"runner_max_concurrent_reconciles,omitempty" jsonschema:"Maximum concurrent reconciles for the EphemeralRunner controller. Increase to improve throughput at the cost of higher API server load."`
	// Strategy for handling upgrades while jobs are running.
	UpdateStrategy string `json:"update_strategy,omitempty" jsonschema:"enum=immediate|eventual,Strategy for handling upgrades while jobs are running."`
	// Label prefixes to exclude from propagation to internal resources.
	//  Useful for labels used by external tools (e.g., ArgoCD) that shouldn't
	//  be propagated to listener pods.
	ExcludeLabelPropagationPrefixes []string `json:"exclude_label_propagation_prefixes,omitempty" jsonschema:"Label prefixes to exclude from propagation to internal resources. Useful for labels used by external tools (e.g.; ArgoCD) that shouldn't be propagated to listener pods."`
	// Kubernetes API client rate limiter QPS.
	K8sClientRateLimiterQps int32 `json:"k8s_client_rate_limiter_qps,omitempty" jsonschema:"Kubernetes API client rate limiter QPS."`
	// Kubernetes API client rate limiter burst.
	K8sClientRateLimiterBurst int32 `json:"k8s_client_rate_limiter_burst,omitempty" jsonschema:"Kubernetes API client rate limiter burst."`
}

func (s *KubernetesGhaRunnerScaleSetControllerFlagsInput) validate() error {
	switch s.LogLevel {
	case "", "debug", "info", "warn", "error":
	default:
		return fmt.Errorf("invalid log_level: %q", s.LogLevel)
	}
	switch s.LogFormat {
	case "", "text", "json":
	default:
		return fmt.Errorf("invalid log_format: %q", s.LogFormat)
	}
	switch s.UpdateStrategy {
	case "", "immediate", "eventual":
	default:
		return fmt.Errorf("invalid update_strategy: %q", s.UpdateStrategy)
	}
	return nil
}

func (s *KubernetesGhaRunnerScaleSetControllerFlagsInput) applyDefaults() {
	if s.RunnerMaxConcurrentReconciles == 0 {
		s.RunnerMaxConcurrentReconciles = 2
	}
}

func (s *KubernetesGhaRunnerScaleSetControllerFlagsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.LogLevel != "" {
		m["log_level"] = s.LogLevel
	}
	if s.LogFormat != "" {
		m["log_format"] = s.LogFormat
	}
	if s.WatchSingleNamespace != "" {
		m["watch_single_namespace"] = s.WatchSingleNamespace
	}
	if s.RunnerMaxConcurrentReconciles != 0 {
		m["runner_max_concurrent_reconciles"] = s.RunnerMaxConcurrentReconciles
	}
	if s.UpdateStrategy != "" {
		m["update_strategy"] = s.UpdateStrategy
	}
	if len(s.ExcludeLabelPropagationPrefixes) > 0 {
		m["exclude_label_propagation_prefixes"] = s.ExcludeLabelPropagationPrefixes
	}
	if s.K8sClientRateLimiterQps != 0 {
		m["k8s_client_rate_limiter_qps"] = s.K8sClientRateLimiterQps
	}
	if s.K8sClientRateLimiterBurst != 0 {
		m["k8s_client_rate_limiter_burst"] = s.K8sClientRateLimiterBurst
	}
	return m
}

// KubernetesGhaRunnerScaleSetControllerImage configures a custom controller image.
type KubernetesGhaRunnerScaleSetControllerImageInput struct {
	// Container image repository.
	//  Default: ghcr.io/actions/gha-runner-scale-set-controller
	Repository string `json:"repository,omitempty" jsonschema:"Container image repository. Default: ghcr.io/actions/gha-runner-scale-set-controller"`
	// Image tag. When not specified, uses the chart appVersion.
	Tag string `json:"tag,omitempty" jsonschema:"Image tag. When not specified; uses the chart appVersion."`
	// Image pull policy: Always, IfNotPresent, or Never.
	PullPolicy string `json:"pull_policy,omitempty" jsonschema:"Image pull policy: Always; IfNotPresent; or Never."`
}

func (s *KubernetesGhaRunnerScaleSetControllerImageInput) validate() error {
	return nil
}

func (s *KubernetesGhaRunnerScaleSetControllerImageInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetControllerImageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Repository != "" {
		m["repository"] = s.Repository
	}
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	if s.PullPolicy != "" {
		m["pull_policy"] = s.PullPolicy
	}
	return m
}

// KubernetesGhaRunnerScaleSetControllerMetrics configures metrics endpoints.
type KubernetesGhaRunnerScaleSetControllerMetricsInput struct {
	// Metrics address for the controller manager (e.g., ":8080").
	ControllerManagerAddr string `json:"controller_manager_addr,omitempty" jsonschema:"Metrics address for the controller manager (e.g.; ':8080')."`
	// Metrics address for the listener (e.g., ":8080").
	ListenerAddr string `json:"listener_addr,omitempty" jsonschema:"Metrics address for the listener (e.g.; ':8080')."`
	// Metrics endpoint path for the listener (e.g., "/metrics").
	ListenerEndpoint string `json:"listener_endpoint,omitempty" jsonschema:"Metrics endpoint path for the listener (e.g.; '/metrics')."`
}

func (s *KubernetesGhaRunnerScaleSetControllerMetricsInput) validate() error {
	return nil
}

func (s *KubernetesGhaRunnerScaleSetControllerMetricsInput) applyDefaults() {
}

func (s *KubernetesGhaRunnerScaleSetControllerMetricsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ControllerManagerAddr != "" {
		m["controller_manager_addr"] = s.ControllerManagerAddr
	}
	if s.ListenerAddr != "" {
		m["listener_addr"] = s.ListenerAddr
	}
	if s.ListenerEndpoint != "" {
		m["listener_endpoint"] = s.ListenerEndpoint
	}
	return m
}

// ParseKubernetesGhaRunnerScaleSetController validates and normalizes a KubernetesGhaRunnerScaleSetController cloud_object.
func ParseKubernetesGhaRunnerScaleSetController(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesGhaRunnerScaleSetController"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesGhaRunnerScaleSetControllerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
