// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// neo4j-kubernetes
type KubernetesNeo4jSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The specifications for the Neo4j container deployment.
	Container *KubernetesNeo4jContainerInput `json:"container,omitempty" jsonschema:"The specifications for the Neo4j container deployment."`
	// Optional extra memory config for Neo4j (heap, page cache).
	//  By default, we rely on Neo4j's internal defaults if unset.
	MemoryConfig *KubernetesNeo4jMemoryConfigInput `json:"memory_config,omitempty" jsonschema:"Optional extra memory config for Neo4j (heap; page cache). By default; we rely on Neo4j's internal defaults if unset."`
	// The ingress configuration for the Neo4j deployment.
	Ingress *KubernetesNeo4jIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the Neo4j deployment."`
}

func (s *KubernetesNeo4jSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.MemoryConfig != nil {
		if err := s.MemoryConfig.validate(); err != nil {
			return fmt.Errorf("memory_config: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesNeo4jSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.MemoryConfig != nil {
		s.MemoryConfig.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesNeo4jSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.MemoryConfig != nil {
		m["memory_config"] = s.MemoryConfig.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	return m
}

// KubernetesNeo4jContainer defines the container specifications for the Neo4j deployment.
type KubernetesNeo4jContainerInput struct {
	// The CPU and memory resources allocated to the Neo4j container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Neo4j container."`
	// A flag to enable or disable data persistence for Neo4j.
	//  When enabled, Neo4j stores its database files on a persistent volume,
	//  allowing data to survive pod restarts.
	//  Defaults to `false`.
	PersistenceEnabled bool `json:"persistence_enabled,omitempty" jsonschema:"A flag to enable or disable data persistence for Neo4j. When enabled; Neo4j stores its database files on a persistent volume; allowing data to survive pod restarts. Defaults to 'false'."`
	// Size of the persistent volume if persistence_enabled=true (e.g., "10Gi").
	//  If persistence_enabled=false, this may be ignored or left empty.
	DiskSize string `json:"disk_size,omitempty" jsonschema:"Size of the persistent volume if persistence_enabled=true (e.g.; '10Gi'). If persistence_enabled=false; this may be ignored or left empty."`
}

func (s *KubernetesNeo4jContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesNeo4jContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesNeo4jContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.PersistenceEnabled {
		m["persistence_enabled"] = s.PersistenceEnabled
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// KubernetesNeo4jIngress defines the ingress configuration for Neo4j.
type KubernetesNeo4jIngressInput struct {
	// Flag to enable or disable ingress.
	//  When enabled, creates a LoadBalancer service with external-dns annotations.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress. When enabled; creates a LoadBalancer service with external-dns annotations."`
	// The full hostname for external access (e.g., "neo4j.example.com").
	//  This hostname will be configured automatically via external-dns.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'neo4j.example.com'). This hostname will be configured automatically via external-dns. Required when enabled is true."`
}

func (s *KubernetesNeo4jIngressInput) validate() error {
	return nil
}

func (s *KubernetesNeo4jIngressInput) applyDefaults() {
}

func (s *KubernetesNeo4jIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// KubernetesNeo4jMemoryConfig sets optional memory parameters for the database.
type KubernetesNeo4jMemoryConfigInput struct {
	// Sets the maximum Java heap size (e.g., "1Gi" or "512m").
	//  If omitted, Neo4j uses its default (~512m or auto-detect).
	HeapMax string `json:"heap_max,omitempty" jsonschema:"Sets the maximum Java heap size (e.g.; '1Gi' or '512m'). If omitted; Neo4j uses its default (~512m or auto-detect)."`
	// Sets the page cache size for on-disk data (e.g., "512m").
	//  If omitted, Neo4j uses a default or auto-detection.
	PageCache string `json:"page_cache,omitempty" jsonschema:"Sets the page cache size for on-disk data (e.g.; '512m'). If omitted; Neo4j uses a default or auto-detection."`
}

func (s *KubernetesNeo4jMemoryConfigInput) validate() error {
	return nil
}

func (s *KubernetesNeo4jMemoryConfigInput) applyDefaults() {
}

func (s *KubernetesNeo4jMemoryConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HeapMax != "" {
		m["heap_max"] = s.HeapMax
	}
	if s.PageCache != "" {
		m["page_cache"] = s.PageCache
	}
	return m
}

// ParseKubernetesNeo4j validates and normalizes a KubernetesNeo4j cloud_object.
func ParseKubernetesNeo4j(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesNeo4j"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesNeo4jSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
