// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// kubernetes-external-dns
type KubernetesExternalDnsSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// ExternalDNS version such as "v0.19.0". Used to set the image tag.
	ExternalDnsVersion string `json:"external_dns_version,omitempty" jsonschema:"ExternalDNS version such as 'v0.19.0'. Used to set the image tag."`
	// Helm chart version to deploy. If not specified, uses the default version.
	HelmChartVersion string                                      `json:"helm_chart_version,omitempty" jsonschema:"Helm chart version to deploy. If not specified; uses the default version."`
	Gke              *KubernetesExternalDnsGkeConfigInput        `json:"gke,omitempty" jsonschema:""`
	Eks              *KubernetesExternalDnsEksConfigInput        `json:"eks,omitempty" jsonschema:""`
	Aks              *KubernetesExternalDnsAksConfigInput        `json:"aks,omitempty" jsonschema:""`
	Cloudflare       *KubernetesExternalDnsCloudflareConfigInput `json:"cloudflare,omitempty" jsonschema:""`
}

func (s *KubernetesExternalDnsSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Gke != nil {
		if err := s.Gke.validate(); err != nil {
			return fmt.Errorf("gke: %w", err)
		}
	}
	if s.Eks != nil {
		if err := s.Eks.validate(); err != nil {
			return fmt.Errorf("eks: %w", err)
		}
	}
	if s.Aks != nil {
		if err := s.Aks.validate(); err != nil {
			return fmt.Errorf("aks: %w", err)
		}
	}
	if s.Cloudflare != nil {
		if err := s.Cloudflare.validate(); err != nil {
			return fmt.Errorf("cloudflare: %w", err)
		}
	}
	return nil
}

func (s *KubernetesExternalDnsSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.ExternalDnsVersion == "" {
		s.ExternalDnsVersion = "v0.19.0"
	}
	if s.HelmChartVersion == "" {
		s.HelmChartVersion = "1.19.0"
	}
	if s.Gke != nil {
		s.Gke.applyDefaults()
	}
	if s.Eks != nil {
		s.Eks.applyDefaults()
	}
	if s.Aks != nil {
		s.Aks.applyDefaults()
	}
	if s.Cloudflare != nil {
		s.Cloudflare.applyDefaults()
	}
}

func (s *KubernetesExternalDnsSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.ExternalDnsVersion != "" {
		m["external_dns_version"] = s.ExternalDnsVersion
	}
	if s.HelmChartVersion != "" {
		m["helm_chart_version"] = s.HelmChartVersion
	}
	if s.Gke != nil {
		m["gke"] = s.Gke.toMap()
	}
	if s.Eks != nil {
		m["eks"] = s.Eks.toMap()
	}
	if s.Aks != nil {
		m["aks"] = s.Aks.toMap()
	}
	if s.Cloudflare != nil {
		m["cloudflare"] = s.Cloudflare.toMap()
	}
	return m
}

// KubernetesExternalDnsAksConfig defines configuration for ExternalDNS on AKS with Azure DNS.
type KubernetesExternalDnsAksConfigInput struct {
	// The Azure DNS zone ID to use for ExternalDNS.
	DnsZoneId string `json:"dns_zone_id" jsonschema:"required,The Azure DNS zone ID to use for ExternalDNS."`
	// The Azure Managed Identity client ID to use for ExternalDNS.
	ManagedIdentityClientId string `json:"managed_identity_client_id,omitempty" jsonschema:"The Azure Managed Identity client ID to use for ExternalDNS."`
}

func (s *KubernetesExternalDnsAksConfigInput) validate() error {
	if s.DnsZoneId == "" {
		return fmt.Errorf("dns_zone_id is required")
	}
	return nil
}

func (s *KubernetesExternalDnsAksConfigInput) applyDefaults() {
}

func (s *KubernetesExternalDnsAksConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["dns_zone_id"] = s.DnsZoneId
	if s.ManagedIdentityClientId != "" {
		m["managed_identity_client_id"] = s.ManagedIdentityClientId
	}
	return m
}

// KubernetesExternalDnsCloudflareConfig defines configuration for ExternalDNS with Cloudflare DNS.
type KubernetesExternalDnsCloudflareConfigInput struct {
	// Cloudflare API token for authentication (scoped with Zone:Zone:Read and Zone:DNS:Edit permissions).
	ApiToken string `json:"api_token" jsonschema:"required,Cloudflare API token for authentication (scoped with Zone:Zone:Read and Zone:DNS:Edit permissions)."`
	// Cloudflare DNS zone ID to manage. ExternalDNS will only manage records in this zone.
	DnsZoneId string `json:"dns_zone_id" jsonschema:"required,Cloudflare DNS zone ID to manage. ExternalDNS will only manage records in this zone."`
	// Enable Cloudflare proxy (orange cloud) for all managed DNS records.
	//  When enabled, traffic routes through Cloudflare's edge network for DDoS protection, WAF, and CDN.
	//  Default: false
	IsProxied bool `json:"is_proxied,omitempty" jsonschema:"Enable Cloudflare proxy (orange cloud) for all managed DNS records. When enabled; traffic routes through Cloudflare's edge network for DDoS protection; WAF; and CDN. Default: false"`
}

func (s *KubernetesExternalDnsCloudflareConfigInput) validate() error {
	if s.ApiToken == "" {
		return fmt.Errorf("api_token is required")
	}
	if s.DnsZoneId == "" {
		return fmt.Errorf("dns_zone_id is required")
	}
	return nil
}

func (s *KubernetesExternalDnsCloudflareConfigInput) applyDefaults() {
}

func (s *KubernetesExternalDnsCloudflareConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["api_token"] = s.ApiToken
	m["dns_zone_id"] = s.DnsZoneId
	if s.IsProxied {
		m["is_proxied"] = s.IsProxied
	}
	return m
}

// KubernetesExternalDnsEksConfig defines configuration for ExternalDNS on EKS with AWS Route53 .
type KubernetesExternalDnsEksConfigInput struct {
	Route53ZoneId string `json:"route53_zone_id" jsonschema:"required"`
	// Optional existing IAM role ARN for IRSA; auto-created if blank.
	IrsaRoleArnOverride string `json:"irsa_role_arn_override,omitempty" jsonschema:"Optional existing IAM role ARN for IRSA; auto-created if blank."`
}

func (s *KubernetesExternalDnsEksConfigInput) validate() error {
	if s.Route53ZoneId == "" {
		return fmt.Errorf("route53_zone_id is required")
	}
	return nil
}

func (s *KubernetesExternalDnsEksConfigInput) applyDefaults() {
}

func (s *KubernetesExternalDnsEksConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["route53_zone_id"] = s.Route53ZoneId
	if s.IrsaRoleArnOverride != "" {
		m["irsa_role_arn_override"] = s.IrsaRoleArnOverride
	}
	return m
}

// KubernetesExternalDnsGkeConfig defines configuration for ExternalDNS on GKE with Google Cloud DNS.
type KubernetesExternalDnsGkeConfigInput struct {
	// The GCP project that hosts the DNS zone and the GKE cluster.
	ProjectId string `json:"project_id" jsonschema:"required,The GCP project that hosts the DNS zone and the GKE cluster."`
	// The GCP DNS zone ID to use for ExternalDNS.
	DnsZoneId string `json:"dns_zone_id" jsonschema:"required,The GCP DNS zone ID to use for ExternalDNS."`
}

func (s *KubernetesExternalDnsGkeConfigInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.DnsZoneId == "" {
		return fmt.Errorf("dns_zone_id is required")
	}
	return nil
}

func (s *KubernetesExternalDnsGkeConfigInput) applyDefaults() {
}

func (s *KubernetesExternalDnsGkeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["dns_zone_id"] = s.DnsZoneId
	return m
}

// ParseKubernetesExternalDns validates and normalizes a KubernetesExternalDns cloud_object.
func ParseKubernetesExternalDns(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesExternalDns"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesExternalDnsSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
