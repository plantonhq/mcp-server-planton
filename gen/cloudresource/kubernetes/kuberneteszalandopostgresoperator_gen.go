// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// kubernetes-zalando-postgres-operator
type KubernetesZalandoPostgresOperatorSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The container specifications for the operator deployment.
	Container *KubernetesZalandoPostgresOperatorSpecContainerInput `json:"container" jsonschema:"required,The container specifications for the operator deployment."`
	// Optional: Backup configuration for all databases managed by this operator
	BackupConfig *KubernetesZalandoPostgresOperatorBackupConfigInput `json:"backup_config,omitempty" jsonschema:"Optional: Backup configuration for all databases managed by this operator"`
}

func (s *KubernetesZalandoPostgresOperatorSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.BackupConfig != nil {
		if err := s.BackupConfig.validate(); err != nil {
			return fmt.Errorf("backup_config: %w", err)
		}
	}
	return nil
}

func (s *KubernetesZalandoPostgresOperatorSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.BackupConfig != nil {
		s.BackupConfig.applyDefaults()
	}
}

func (s *KubernetesZalandoPostgresOperatorSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.BackupConfig != nil {
		m["backup_config"] = s.BackupConfig.toMap()
	}
	return m
}

// Zalando-specific backup configuration for all PostgreSQL databases managed by this operator.
//
//	This configures the pod_environment_configmap used by Zalando operator for WAL-G backups.
//	The Pulumi module will automatically create a Kubernetes Secret from the R2 credentials.
type KubernetesZalandoPostgresOperatorBackupConfigInput struct {
	// Cloudflare R2 storage configuration (includes credentials)
	R2Config *KubernetesZalandoPostgresOperatorBackupR2ConfigInput `json:"r2_config" jsonschema:"required,Cloudflare R2 storage configuration (includes credentials)"`
	// Optional: Custom S3 prefix template for WAL-G
	//  Default: "backups/$(SCOPE)/$(PGVERSION)"
	//  Zalando variables: $(SCOPE) = cluster name, $(PGVERSION) = postgres version
	S3PrefixTemplate string `json:"s3_prefix_template,omitempty" jsonschema:"Optional: Custom S3 prefix template for WAL-G Default: 'backups/$(SCOPE)/$(PGVERSION)' Zalando variables: $(SCOPE) = cluster name; $(PGVERSION) = postgres version"`
	// Cron schedule for base backups (e.g., "0 2 * * *" for 2 AM daily)
	//  This maps to Zalando's BACKUP_SCHEDULE environment variable
	BackupSchedule string `json:"backup_schedule" jsonschema:"required,Cron schedule for base backups (e.g.; '0 2 * * *' for 2 AM daily) This maps to Zalando's BACKUP_SCHEDULE environment variable"`
	// Enable WAL-G for backups (default: true)
	//  Maps to USE_WALG_BACKUP environment variable
	EnableWalGBackup bool `json:"enable_wal_g_backup,omitempty" jsonschema:"Enable WAL-G for backups (default: true) Maps to USE_WALG_BACKUP environment variable"`
	// Enable WAL-G for restores (default: true)
	//  Maps to USE_WALG_RESTORE environment variable
	EnableWalGRestore bool `json:"enable_wal_g_restore,omitempty" jsonschema:"Enable WAL-G for restores (default: true) Maps to USE_WALG_RESTORE environment variable"`
	// Enable WAL-G for clone operations (default: true)
	//  Maps to CLONE_USE_WALG_RESTORE environment variable
	EnableCloneWalGRestore bool `json:"enable_clone_wal_g_restore,omitempty" jsonschema:"Enable WAL-G for clone operations (default: true) Maps to CLONE_USE_WALG_RESTORE environment variable"`
}

func (s *KubernetesZalandoPostgresOperatorBackupConfigInput) validate() error {
	if s.R2Config == nil {
		return fmt.Errorf("r2_config is required")
	}
	if s.R2Config != nil {
		if err := s.R2Config.validate(); err != nil {
			return fmt.Errorf("r2_config: %w", err)
		}
	}
	if s.BackupSchedule == "" {
		return fmt.Errorf("backup_schedule is required")
	}
	return nil
}

func (s *KubernetesZalandoPostgresOperatorBackupConfigInput) applyDefaults() {
	if s.R2Config != nil {
		s.R2Config.applyDefaults()
	}
}

func (s *KubernetesZalandoPostgresOperatorBackupConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.R2Config != nil {
		m["r2_config"] = s.R2Config.toMap()
	}
	if s.S3PrefixTemplate != "" {
		m["s3_prefix_template"] = s.S3PrefixTemplate
	}
	m["backup_schedule"] = s.BackupSchedule
	if s.EnableWalGBackup {
		m["enable_wal_g_backup"] = s.EnableWalGBackup
	}
	if s.EnableWalGRestore {
		m["enable_wal_g_restore"] = s.EnableWalGRestore
	}
	if s.EnableCloneWalGRestore {
		m["enable_clone_wal_g_restore"] = s.EnableCloneWalGRestore
	}
	return m
}

// Cloudflare R2-specific storage configuration for PostgreSQL backups.
//
//	This is separate to allow future support for other S3-compatible backends.
type KubernetesZalandoPostgresOperatorBackupR2ConfigInput struct {
	// Cloudflare R2 account ID (used to construct endpoint URL)
	//  The endpoint will be: https://<account_id>.r2.cloudflarestorage.com
	CloudflareAccountId string `json:"cloudflare_account_id" jsonschema:"required,Cloudflare R2 account ID (used to construct endpoint URL) The endpoint will be: https://<account_id>.r2.cloudflarestorage.com"`
	// R2 bucket name for storing backups
	BucketName string `json:"bucket_name" jsonschema:"required,R2 bucket name for storing backups"`
	// R2 Access Key ID
	//  The Pulumi module will create a Kubernetes Secret from these credentials
	AccessKeyId string `json:"access_key_id" jsonschema:"required,R2 Access Key ID The Pulumi module will create a Kubernetes Secret from these credentials"`
	// R2 Secret Access Key
	//  The Pulumi module will create a Kubernetes Secret from these credentials
	SecretAccessKey string `json:"secret_access_key" jsonschema:"required,R2 Secret Access Key The Pulumi module will create a Kubernetes Secret from these credentials"`
}

func (s *KubernetesZalandoPostgresOperatorBackupR2ConfigInput) validate() error {
	if s.CloudflareAccountId == "" {
		return fmt.Errorf("cloudflare_account_id is required")
	}
	if s.BucketName == "" {
		return fmt.Errorf("bucket_name is required")
	}
	if s.AccessKeyId == "" {
		return fmt.Errorf("access_key_id is required")
	}
	if s.SecretAccessKey == "" {
		return fmt.Errorf("secret_access_key is required")
	}
	return nil
}

func (s *KubernetesZalandoPostgresOperatorBackupR2ConfigInput) applyDefaults() {
}

func (s *KubernetesZalandoPostgresOperatorBackupR2ConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cloudflare_account_id"] = s.CloudflareAccountId
	m["bucket_name"] = s.BucketName
	m["access_key_id"] = s.AccessKeyId
	m["secret_access_key"] = s.SecretAccessKey
	return m
}

// **KubernetesZalandoPostgresOperatorSpecContainer** specifies the container configuration for the Zalando Postgres Operator.
//
//	It includes resource allocations for CPU and memory to ensure the operator runs efficiently.
type KubernetesZalandoPostgresOperatorSpecContainerInput struct {
	// The CPU and memory resources allocated to the operator container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the operator container."`
}

func (s *KubernetesZalandoPostgresOperatorSpecContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesZalandoPostgresOperatorSpecContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesZalandoPostgresOperatorSpecContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// ParseKubernetesZalandoPostgresOperator validates and normalizes a KubernetesZalandoPostgresOperator cloud_object.
func ParseKubernetesZalandoPostgresOperator(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesZalandoPostgresOperator"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesZalandoPostgresOperatorSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
