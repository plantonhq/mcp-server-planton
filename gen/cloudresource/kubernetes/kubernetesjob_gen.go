// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// KubernetesJob is a Kubernetes resource that creates a one-shot Job workload.
//
//	Unlike Deployments which run continuously, or CronJobs which run on a schedule,
//	a Job runs pods to completion and then stops. Jobs are ideal for batch processing,
//	data migrations, one-time tasks, and any workflow that needs to run to completion.
//
//	Example use cases:
//	- Database migrations
//	- Data processing pipelines
//	- Backup and restore operations
//	- ETL (Extract, Transform, Load) jobs
//	- One-time setup or cleanup tasks
type KubernetesJobSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// Flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"Flag to indicate if the namespace should be created"`
	// *
	//  The container image to be used for the job.
	//  The pull_secret_name is determined by looking up the
	//  container_image_artifact_store_id from the environment where the job is deployed.
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"* The container image to be used for the job. The pull_secret_name is determined by looking up the container_image_artifact_store_id from the environment where the job is deployed."`
	// *
	//  The CPU and memory resources allocated to the job container.
	//  If not specified, default container resources (limits.cpu=1000m, limits.memory=1Gi,
	//  requests.cpu=50m, requests.memory=100Mi) are applied.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"* The CPU and memory resources allocated to the job container. If not specified; default container resources (limits.cpu=1000m; limits.memory=1Gi; requests.cpu=50m; requests.memory=100Mi) are applied."`
	// *
	//  Environment variables and secrets for the job container.
	//  This includes both straightforward environment variables (key=value)
	//  and references to secrets.
	Env *KubernetesJobContainerAppEnvInput `json:"env,omitempty" jsonschema:"* Environment variables and secrets for the job container. This includes both straightforward environment variables (key=value) and references to secrets."`
	// *
	//  Number of parallel pods to run for the job.
	//  Default is 1 (sequential execution).
	//  Set higher for parallel batch processing.
	Parallelism uint32 `json:"parallelism,omitempty" jsonschema:"* Number of parallel pods to run for the job. Default is 1 (sequential execution). Set higher for parallel batch processing."`
	// *
	//  Number of successful completions required before the job is considered complete.
	//  Default is 1.
	//  For parallel jobs, this specifies the total number of successful pods needed.
	//  For indexed jobs, this equals the number of indexes (0 to completions-1).
	Completions uint32 `json:"completions,omitempty" jsonschema:"* Number of successful completions required before the job is considered complete. Default is 1. For parallel jobs; this specifies the total number of successful pods needed. For indexed jobs; this eq..."`
	// *
	//  Number of retries before marking this job as failed.
	//  Default is 6.
	BackoffLimit uint32 `json:"backoff_limit,omitempty" jsonschema:"* Number of retries before marking this job as failed. Default is 6."`
	// *
	//  Maximum duration in seconds for the job to run.
	//  If the job runs longer than this, it will be terminated.
	//  Set to 0 for no deadline (default).
	//  Useful for preventing runaway jobs.
	ActiveDeadlineSeconds uint64 `json:"active_deadline_seconds,omitempty" jsonschema:"* Maximum duration in seconds for the job to run. If the job runs longer than this; it will be terminated. Set to 0 for no deadline (default). Useful for preventing runaway jobs."`
	// *
	//  Time in seconds to retain the job after completion (either success or failure).
	//  After this duration, the job and its pods will be automatically deleted.
	//  Useful for cleanup of completed jobs.
	//  Default is 0 (no automatic cleanup).
	TtlSecondsAfterFinished uint32 `json:"ttl_seconds_after_finished,omitempty" jsonschema:"* Time in seconds to retain the job after completion (either success or failure). After this duration; the job and its pods will be automatically deleted. Useful for cleanup of completed jobs. Default..."`
	// *
	//  Completion mode for the job.
	//  "NonIndexed" (default): All pods are equivalent, job completes when 'completions' pods succeed.
	//  "Indexed": Each pod gets an index (0 to completions-1), job completes when each index has one successful pod.
	//  Indexed mode is useful for parallel processing of partition...
	CompletionMode string `json:"completion_mode,omitempty" jsonschema:"* Completion mode for the job. 'NonIndexed' (default): All pods are equivalent; job completes when 'completions' pods succeed. 'Indexed': Each pod gets an index (0 to completions-1); job completes whe..."`
	// *
	//  Pod restart policy.
	//  Allowed values: "OnFailure", "Never".
	//  Default is "Never".
	//  Note: "Always" is not allowed for Jobs.
	RestartPolicy string `json:"restart_policy,omitempty" jsonschema:"* Pod restart policy. Allowed values: 'OnFailure'; 'Never'. Default is 'Never'. Note: 'Always' is not allowed for Jobs."`
	// *
	//  An optional list of commands (equivalent to an ENTRYPOINT override) for the job container.
	//  If omitted, the default ENTRYPOINT in the image will be used.
	//  Example: ["sh", "-c", "python process_data.py"]
	Command []string `json:"command,omitempty" jsonschema:"* An optional list of commands (equivalent to an ENTRYPOINT override) for the job container. If omitted; the default ENTRYPOINT in the image will be used. Example: ['sh'; '-c'; 'python process_data.py..."`
	// *
	//  An optional list of arguments passed to the container command or the image's default ENTRYPOINT.
	//  If omitted, the default CMD in the image will be used.
	//  Example: ["--input", "/data/input.csv", "--output", "/data/output.csv"]
	Args []string `json:"args,omitempty" jsonschema:"* An optional list of arguments passed to the container command or the image's default ENTRYPOINT. If omitted; the default CMD in the image will be used. Example: ['--input'; '/data/input.csv'; '--out..."`
	// *
	//  ConfigMaps to create alongside the Job.
	//  Key is the ConfigMap name, value is the content.
	//  These ConfigMaps can be referenced in volume mounts.
	//
	//  Example:
	//    config_maps:
	//      processing-script: |
	//        #!/bin/bash
	//        echo "Processing data..."
	//        python /scripts/process.py
	ConfigMaps map[string]string `json:"config_maps,omitempty" jsonschema:"* ConfigMaps to create alongside the Job. Key is the ConfigMap name; value is the content. These ConfigMaps can be referenced in volume mounts. Example: config_maps: processing-script: | #!/bin/bash e..."`
	// *
	//  Volume mounts for the Job container.
	//  Supports mounting ConfigMaps, Secrets, HostPaths, EmptyDirs, and PVCs.
	//  ConfigMaps defined in spec.config_maps can be referenced here.
	//
	//  Example:
	//    volume_mounts:
	//      - name: processing-script
	//        mountPath: /scripts/process.sh
	//        configMap:
	//         ...
	VolumeMounts []*VolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"* Volume mounts for the Job container. Supports mounting ConfigMaps; Secrets; HostPaths; EmptyDirs; and PVCs. ConfigMaps defined in spec.config_maps can be referenced here. Example: volume_mounts: - n..."`
	// *
	//  If true, no pods are created for this job.
	//  Existing pods are not affected.
	//  Default is false.
	Suspend bool `json:"suspend,omitempty" jsonschema:"* If true; no pods are created for this job. Existing pods are not affected. Default is false."`
}

func (s *KubernetesJobSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesJobSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.Parallelism == 0 {
		s.Parallelism = 1
	}
	if s.Completions == 0 {
		s.Completions = 1
	}
	if s.BackoffLimit == 0 {
		s.BackoffLimit = 6
	}
	if s.ActiveDeadlineSeconds == 0 {
		s.ActiveDeadlineSeconds = 0
	}
	if s.TtlSecondsAfterFinished == 0 {
		s.TtlSecondsAfterFinished = 0
	}
	if s.CompletionMode == "" {
		s.CompletionMode = "NonIndexed"
	}
	if s.RestartPolicy == "" {
		s.RestartPolicy = "Never"
	}
}

func (s *KubernetesJobSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	if s.Parallelism != 0 {
		m["parallelism"] = s.Parallelism
	}
	if s.Completions != 0 {
		m["completions"] = s.Completions
	}
	if s.BackoffLimit != 0 {
		m["backoff_limit"] = s.BackoffLimit
	}
	if s.ActiveDeadlineSeconds != 0 {
		m["active_deadline_seconds"] = s.ActiveDeadlineSeconds
	}
	if s.TtlSecondsAfterFinished != 0 {
		m["ttl_seconds_after_finished"] = s.TtlSecondsAfterFinished
	}
	if s.CompletionMode != "" {
		m["completion_mode"] = s.CompletionMode
	}
	if s.RestartPolicy != "" {
		m["restart_policy"] = s.RestartPolicy
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	if len(s.ConfigMaps) > 0 {
		m["config_maps"] = s.ConfigMaps
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	if s.Suspend {
		m["suspend"] = s.Suspend
	}
	return m
}

// *
//
//	KubernetesJobContainerAppEnv defines the environment variables
//	and secrets for the job container.
type KubernetesJobContainerAppEnvInput struct {
	// *
	//  A map of environment variable names to their values.
	//  Each variable can be provided either as a literal string value or as a reference
	//  to another OpenMCF resource's field.
	//
	//  **Option 1: Direct string value**
	//  ```yaml
	//  variables:
	//    BATCH_SIZE:
	//      value: "1000"
	//  ```
	//
	//  **Option 2: Reference to a...
	Variables map[string]string `json:"variables,omitempty" jsonschema:"* A map of environment variable names to their values. Each variable can be provided either as a literal string value or as a reference to another OpenMCF resource's field. **Option 1: Direct string v..."`
	// *
	//  A map of secret environment variable names to their values.
	//  Each secret can be provided either as a literal string value or as a reference
	//  to an existing Kubernetes Secret.
	//
	//  Using secret references is recommended for production deployments.
	Secrets map[string]*KubernetesSensitiveValueInput `json:"secrets,omitempty" jsonschema:"* A map of secret environment variable names to their values. Each secret can be provided either as a literal string value or as a reference to an existing Kubernetes Secret. Using secret references i..."`
}

func (s *KubernetesJobContainerAppEnvInput) validate() error {
	for k, v := range s.Secrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secrets[%s]: %w", k, err)
			}
		}
	}
	return nil
}

func (s *KubernetesJobContainerAppEnvInput) applyDefaults() {
}

func (s *KubernetesJobContainerAppEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		result := make(map[string]any, len(s.Secrets))
		for k, v := range s.Secrets {
			if v != nil {
				result[k] = v.toMap()
			}
		}
		m["secrets"] = result
	}
	return m
}

// ParseKubernetesJob validates and normalizes a KubernetesJob cloud_object.
func ParseKubernetesJob(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesJob"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesJobSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
