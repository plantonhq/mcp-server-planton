// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// elasticsearch-kubernetes
type KubernetesElasticsearchSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The elasticsearch configuration.
	Elasticsearch *KubernetesElasticsearchElasticsearchSpecInput `json:"elasticsearch,omitempty" jsonschema:"The elasticsearch configuration."`
	// The kibana configuration.
	Kibana *KubernetesElasticsearchKibanaSpecInput `json:"kibana,omitempty" jsonschema:"The kibana configuration."`
}

func (s *KubernetesElasticsearchSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Elasticsearch != nil {
		if err := s.Elasticsearch.validate(); err != nil {
			return fmt.Errorf("elasticsearch: %w", err)
		}
	}
	if s.Kibana != nil {
		if err := s.Kibana.validate(); err != nil {
			return fmt.Errorf("kibana: %w", err)
		}
	}
	return nil
}

func (s *KubernetesElasticsearchSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Elasticsearch != nil {
		s.Elasticsearch.applyDefaults()
	}
	if s.Kibana != nil {
		s.Kibana.applyDefaults()
	}
}

func (s *KubernetesElasticsearchSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Elasticsearch != nil {
		m["elasticsearch"] = s.Elasticsearch.toMap()
	}
	if s.Kibana != nil {
		m["kibana"] = s.Kibana.toMap()
	}
	return m
}

// **KubernetesElasticsearchElasticsearchContainer** specifies the configuration for the Elasticsearch container.
//
//	It includes settings such as the number of replicas, resource allocations, data persistence options, and disk size.
//	Proper configuration ensures optimal performance and data reliability for your Elasticsearch deployment.
type KubernetesElasticsearchElasticsearchContainerInput struct {
	// The number of Elasticsearch pods to deploy
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of Elasticsearch pods to deploy"`
	// The CPU and memory resources allocated to the Elasticsearch container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Elasticsearch container."`
	// A flag to enable or disable data persistence for Elasticsearch.
	//  When enabled, in-memory data is persisted to a storage volume, allowing data to survive pod restarts.
	PersistenceEnabled bool   `json:"persistence_enabled,omitempty" jsonschema:"A flag to enable or disable data persistence for Elasticsearch. When enabled; in-memory data is persisted to a storage volume; allowing data to survive pod restarts."`
	DiskSize           string `json:"disk_size,omitempty" jsonschema:""`
}

func (s *KubernetesElasticsearchElasticsearchContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesElasticsearchElasticsearchContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesElasticsearchElasticsearchContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.PersistenceEnabled {
		m["persistence_enabled"] = s.PersistenceEnabled
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// **KubernetesElasticsearchElasticsearchSpec** groups Elasticsearch container and ingress configuration.
type KubernetesElasticsearchElasticsearchSpecInput struct {
	// Container configuration for Elasticsearch.
	Container *KubernetesElasticsearchElasticsearchContainerInput `json:"container,omitempty" jsonschema:"Container configuration for Elasticsearch."`
	// Ingress configuration for Elasticsearch.
	Ingress *KubernetesElasticsearchIngressInput `json:"ingress,omitempty" jsonschema:"Ingress configuration for Elasticsearch."`
}

func (s *KubernetesElasticsearchElasticsearchSpecInput) validate() error {
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesElasticsearchElasticsearchSpecInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesElasticsearchElasticsearchSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	return m
}

// **KubernetesElasticsearchIngress** defines the ingress configuration for Elasticsearch or Kibana.
//
//	It allows you to enable external access and specify the hostname.
type KubernetesElasticsearchIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "elasticsearch.example.com").
	//  This hostname will be configured automatically via external-dns.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'elasticsearch.example.com'). This hostname will be configured automatically via external-dns. Required when enabled is true."`
}

func (s *KubernetesElasticsearchIngressInput) validate() error {
	return nil
}

func (s *KubernetesElasticsearchIngressInput) applyDefaults() {
}

func (s *KubernetesElasticsearchIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// **KubernetesElasticsearchKibanaContainer** specifies the configuration for the Kibana container.
//
//	Kibana provides visualization capabilities for data stored in Elasticsearch.
//	This message allows you to set the number of replicas and allocate resources accordingly.
type KubernetesElasticsearchKibanaContainerInput struct {
	// The number of Kibana pods to deploy.
	//  Recommended default is 1.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of Kibana pods to deploy. Recommended default is 1."`
	// The CPU and memory resources allocated to the Kibana container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Kibana container."`
}

func (s *KubernetesElasticsearchKibanaContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesElasticsearchKibanaContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesElasticsearchKibanaContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// **KubernetesElasticsearchKibanaSpec** groups Kibana enabled flag, container and ingress configuration.
type KubernetesElasticsearchKibanaSpecInput struct {
	// Flag to enable or disable Kibana deployment. Defaults to false.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable Kibana deployment. Defaults to false."`
	// Container configuration for Kibana.
	Container *KubernetesElasticsearchKibanaContainerInput `json:"container,omitempty" jsonschema:"Container configuration for Kibana."`
	// Ingress configuration for Kibana.
	Ingress *KubernetesElasticsearchIngressInput `json:"ingress,omitempty" jsonschema:"Ingress configuration for Kibana."`
}

func (s *KubernetesElasticsearchKibanaSpecInput) validate() error {
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesElasticsearchKibanaSpecInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesElasticsearchKibanaSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	return m
}

// ParseKubernetesElasticsearch validates and normalizes a KubernetesElasticsearch cloud_object.
func ParseKubernetesElasticsearch(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesElasticsearch"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesElasticsearchSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
