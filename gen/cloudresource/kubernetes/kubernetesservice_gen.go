// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// *
//
//	**KubernetesService** defines a Kubernetes Service resource following the Kubernetes Resource Model (KRM).
//	This resource represents a standalone Kubernetes Service for service discovery, load balancing,
//	and external access to workloads running in a Kubernetes cluster.
type KubernetesServiceSpecInput struct {
	// The Kubernetes cluster in which the service should be created.
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"The Kubernetes cluster in which the service should be created."`
	// *
	//  The namespace in which the service will be created.
	//  Must be a valid DNS label (lowercase alphanumeric and hyphens, max 63 characters).
	//  The namespace must already exist in the target cluster.
	Namespace string `json:"namespace,omitempty" jsonschema:"* The namespace in which the service will be created. Must be a valid DNS label (lowercase alphanumeric and hyphens; max 63 characters). The namespace must already exist in the target cluster."`
	// *
	//  The name of the Kubernetes Service.
	//  Used as `metadata.name` on the created Service resource.
	//  Must be a valid DNS label (lowercase alphanumeric and hyphens, max 63 characters).
	Name string `json:"name,omitempty" jsonschema:"* The name of the Kubernetes Service. Used as 'metadata.name' on the created Service resource. Must be a valid DNS label (lowercase alphanumeric and hyphens; max 63 characters)."`
	// *
	//  Additional labels to apply to the Service resource.
	//  These are merged with standard OpenMCF labels for governance and discoverability.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"* Additional labels to apply to the Service resource. These are merged with standard OpenMCF labels for governance and discoverability."`
	// *
	//  Annotations to apply to the Service resource.
	//  Annotations are critical for configuring cloud-provider-specific load balancer behavior.
	//  Common use cases:
	//  - `service.beta.kubernetes.io/aws-load-balancer-type: "nlb"` for AWS NLB
	//  - `cloud.google.com/neg: '{"ingress": true}'` for GCP NEG
	//  - `servi...
	Annotations map[string]string `json:"annotations,omitempty" jsonschema:"* Annotations to apply to the Service resource. Annotations are critical for configuring cloud-provider-specific load balancer behavior. Common use cases: - 'service.beta.kubernetes.io/aws-load-balanc..."`
	// *
	//  The type of Kubernetes Service to create.
	//  Default: cluster_ip
	Type string `json:"type,omitempty" jsonschema:"enum=cluster_ip|node_port|load_balancer|external_name,* The type of Kubernetes Service to create. Default: cluster_ip"`
	// *
	//  Label selector for identifying the pods that this service routes traffic to.
	//  The service will route traffic to pods whose labels match all key-value pairs
	//  in this selector.
	//
	//  Not required for ExternalName services or services with manually managed endpoints.
	Selector map[string]string `json:"selector,omitempty" jsonschema:"* Label selector for identifying the pods that this service routes traffic to. The service will route traffic to pods whose labels match all key-value pairs in this selector. Not required for External..."`
	// *
	//  The list of ports exposed by this service.
	//  At least one port must be specified for all service types except ExternalName.
	Ports []*KubernetesServicePortInput `json:"ports,omitempty" jsonschema:"* The list of ports exposed by this service. At least one port must be specified for all service types except ExternalName."`
	// *
	//  Whether to create a headless service (clusterIP: None).
	//  Headless services do not allocate a cluster IP; DNS queries return the pod IPs directly.
	//  Useful for StatefulSets and custom service discovery mechanisms.
	//
	//  Cannot be combined with service types NodePort or LoadBalancer.
	Headless bool `json:"headless,omitempty" jsonschema:"* Whether to create a headless service (clusterIP: None). Headless services do not allocate a cluster IP; DNS queries return the pod IPs directly. Useful for StatefulSets and custom service discovery ..."`
	// *
	//  The external DNS name for ExternalName-type services.
	//  This must be a valid DNS name (e.g., "my-database.example.com").
	//  Only used when type is set to external_name.
	ExternalDnsName string `json:"external_dns_name,omitempty" jsonschema:"* The external DNS name for ExternalName-type services. This must be a valid DNS name (e.g.; 'my-database.example.com'). Only used when type is set to external_name."`
	// *
	//  External traffic policy for NodePort and LoadBalancer services.
	//  Controls whether traffic is routed to node-local endpoints only or across all nodes.
	//  Only applicable when type is node_port or load_balancer.
	//  Default: cluster
	ExternalTrafficPolicy string `json:"external_traffic_policy,omitempty" jsonschema:"enum=cluster|local,* External traffic policy for NodePort and LoadBalancer services. Controls whether traffic is routed to node-local endpoints only or across all nodes. Only applicable when type is node_port or load_ba..."`
	// *
	//  Session affinity configuration.
	//  Determines whether requests from the same client are routed to the same backend pod.
	//  Default: none
	SessionAffinity string `json:"session_affinity,omitempty" jsonschema:"enum=none|client_ip,* Session affinity configuration. Determines whether requests from the same client are routed to the same backend pod. Default: none"`
	// *
	//  Restrict access to the load balancer by source IP ranges.
	//  Only applicable when type is load_balancer.
	//  Each entry must be a valid CIDR notation (e.g., "203.0.113.0/24", "10.0.0.0/8").
	//
	//  An empty list means the load balancer is accessible from any source IP.
	LoadBalancerSourceRanges []string `json:"load_balancer_source_ranges,omitempty" jsonschema:"* Restrict access to the load balancer by source IP ranges. Only applicable when type is load_balancer. Each entry must be a valid CIDR notation (e.g.; '203.0.113.0/24'; '10.0.0.0/8'). An empty list m..."`
}

func (s *KubernetesServiceSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	switch s.Type {
	case "", "cluster_ip", "node_port", "load_balancer", "external_name":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	for i, v := range s.Ports {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ports[%d]: %w", i, err)
			}
		}
	}
	switch s.ExternalTrafficPolicy {
	case "", "cluster", "local":
	default:
		return fmt.Errorf("invalid external_traffic_policy: %q", s.ExternalTrafficPolicy)
	}
	switch s.SessionAffinity {
	case "", "none", "client_ip":
	default:
		return fmt.Errorf("invalid session_affinity: %q", s.SessionAffinity)
	}
	return nil
}

func (s *KubernetesServiceSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
}

func (s *KubernetesServiceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Annotations) > 0 {
		m["annotations"] = s.Annotations
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if len(s.Selector) > 0 {
		m["selector"] = s.Selector
	}
	if len(s.Ports) > 0 {
		items := make([]any, len(s.Ports))
		for i, v := range s.Ports {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ports"] = items
	}
	if s.Headless {
		m["headless"] = s.Headless
	}
	if s.ExternalDnsName != "" {
		m["external_dns_name"] = s.ExternalDnsName
	}
	if s.ExternalTrafficPolicy != "" {
		m["external_traffic_policy"] = s.ExternalTrafficPolicy
	}
	if s.SessionAffinity != "" {
		m["session_affinity"] = s.SessionAffinity
	}
	if len(s.LoadBalancerSourceRanges) > 0 {
		m["load_balancer_source_ranges"] = s.LoadBalancerSourceRanges
	}
	return m
}

// *
//
//	**KubernetesServicePort** defines a port exposed by the Kubernetes Service.
type KubernetesServicePortInput struct {
	// *
	//  Optional name for this port. Must be unique within the list of ports.
	//  Required when the service exposes more than one port.
	//  Must be a valid IANA service name (lowercase alphanumeric and hyphens).
	Name string `json:"name,omitempty" jsonschema:"* Optional name for this port. Must be unique within the list of ports. Required when the service exposes more than one port. Must be a valid IANA service name (lowercase alphanumeric and hyphens)."`
	// *
	//  The IP protocol for this port.
	//  Default: TCP
	Protocol string `json:"protocol,omitempty" jsonschema:"enum=TCP|UDP|SCTP,* The IP protocol for this port. Default: TCP"`
	// *
	//  The port number exposed by the service.
	//  This is the port that clients use to access the service.
	//  Must be in the range 1-65535.
	Port int32 `json:"port,omitempty" jsonschema:"* The port number exposed by the service. This is the port that clients use to access the service. Must be in the range 1-65535."`
	// *
	//  The port on the target pod to route traffic to.
	//  Can be a numeric port (e.g., "8080") or a named port (e.g., "http") defined
	//  in the container's port list.
	//  If not specified, defaults to the same value as port.
	TargetPort string `json:"target_port,omitempty" jsonschema:"* The port on the target pod to route traffic to. Can be a numeric port (e.g.; '8080') or a named port (e.g.; 'http') defined in the container's port list. If not specified; defaults to the same value..."`
	// *
	//  The port on each node to expose for NodePort and LoadBalancer services.
	//  If not specified, Kubernetes allocates a port from the node port range (default 30000-32767).
	//  Must be in the range 30000-32767 when specified.
	//  Only applicable when the service type is node_port or load_balancer.
	NodePort int32 `json:"node_port,omitempty" jsonschema:"* The port on each node to expose for NodePort and LoadBalancer services. If not specified; Kubernetes allocates a port from the node port range (default 30000-32767). Must be in the range 30000-32767..."`
}

func (s *KubernetesServicePortInput) validate() error {
	switch s.Protocol {
	case "", "TCP", "UDP", "SCTP":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	return nil
}

func (s *KubernetesServicePortInput) applyDefaults() {
	if s.Protocol == "" {
		s.Protocol = "TCP"
	}
}

func (s *KubernetesServicePortInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.TargetPort != "" {
		m["target_port"] = s.TargetPort
	}
	if s.NodePort != 0 {
		m["node_port"] = s.NodePort
	}
	return m
}

// ParseKubernetesService validates and normalizes a KubernetesService cloud_object.
func ParseKubernetesService(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesService"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesServiceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
