// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30
// Shared types used by multiple providers in the kubernetes package.

package kubernetes

import "fmt"

var _ = fmt.Errorf

// *
//
//	ConfigMapVolumeSource mounts a ConfigMap as a volume.
//	The ConfigMap can be one defined in spec.config_maps or an existing ConfigMap in the namespace.
//
//	When 'key' is specified, only that key is mounted as a single file.
//	When 'key' is not specified, all keys are mounted as files in the directory.
//
//	Example - Mount entire ConfigMap as directory:
//	  configMap:
//	    name: app-config
//
//	Example - Mount single key as file:
//	  configMap:
//	    name: app-config
//	    key: database.yaml
//	    path: db-config.yaml
type ConfigMapVolumeSourceInput struct {
	// Name of the ConfigMap to mount.
	//  Can reference a ConfigMap defined in spec.config_maps or an existing one in the namespace.
	Name string `json:"name" jsonschema:"required,Name of the ConfigMap to mount. Can reference a ConfigMap defined in spec.config_maps or an existing one in the namespace."`
	// Specific key from the ConfigMap to mount as a single file.
	//  If not specified, all keys are mounted as files in the directory.
	Key string `json:"key,omitempty" jsonschema:"Specific key from the ConfigMap to mount as a single file. If not specified; all keys are mounted as files in the directory."`
	// If key is specified, this is the filename to use for the mounted file.
	//  Defaults to the key name if not specified.
	//  Example: key="config" path="app.yaml" mounts the "config" key as "app.yaml"
	Path string `json:"path,omitempty" jsonschema:"If key is specified; this is the filename to use for the mounted file. Defaults to the key name if not specified. Example: key='config' path='app.yaml' mounts the 'config' key as 'app.yaml'"`
	// Mode bits to use on created files. Must be a value between 0 and 0777.
	//  Defaults to 0644.
	//  Use 0755 (493 in decimal) for executable scripts.
	DefaultMode int32 `json:"default_mode,omitempty" jsonschema:"Mode bits to use on created files. Must be a value between 0 and 0777. Defaults to 0644. Use 0755 (493 in decimal) for executable scripts."`
}

func (s *ConfigMapVolumeSourceInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *ConfigMapVolumeSourceInput) applyDefaults() {
}

func (s *ConfigMapVolumeSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.DefaultMode != 0 {
		m["default_mode"] = s.DefaultMode
	}
	return m
}

// **Container** defines the specifications for a container within a microservice deployment configuration.
//
//	This message mirrors the Kubernetes container spec (https://pkg.go.dev/k8s.io/api/core/v1#Container),
//	allowing you to specify container attributes such as the image, ports, resources, and environment variables.
//	**Warning:** The sidecar feature currently does not support all features of a Kubernetes container spec.
type ContainerInput struct {
	// The name of the container.
	Name string `json:"name,omitempty" jsonschema:"The name of the container."`
	// The container image to be used.
	Image string `json:"image,omitempty" jsonschema:"The container image to be used."`
	// A list of ports exposed by the container.
	Ports []*ContainerPortInput `json:"ports,omitempty" jsonschema:"A list of ports exposed by the container."`
	// Resource specifications for the container, including CPU and memory limits and requests.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"Resource specifications for the container; including CPU and memory limits and requests."`
	// A list of environment variables to be set in the container.
	Env []*ContainerEnvVarInput `json:"env,omitempty" jsonschema:"A list of environment variables to be set in the container."`
}

func (s *ContainerInput) validate() error {
	for i, v := range s.Ports {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ports[%d]: %w", i, err)
			}
		}
	}
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	for i, v := range s.Env {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("env[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *ContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Image != "" {
		m["image"] = s.Image
	}
	if len(s.Ports) > 0 {
		items := make([]any, len(s.Ports))
		for i, v := range s.Ports {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ports"] = items
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if len(s.Env) > 0 {
		items := make([]any, len(s.Env))
		for i, v := range s.Env {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["env"] = items
	}
	return m
}

// **ContainerEnvVar** represents an environment variable to be set in the container.
//
//	It allows you to pass configuration or sensitive information to the container at runtime.
type ContainerEnvVarInput struct {
	// The name of the environment variable.
	Name string `json:"name,omitempty" jsonschema:"The name of the environment variable."`
	// The value of the environment variable.
	Value string `json:"value,omitempty" jsonschema:"The value of the environment variable."`
}

func (s *ContainerEnvVarInput) validate() error {
	return nil
}

func (s *ContainerEnvVarInput) applyDefaults() {
}

func (s *ContainerEnvVarInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// **ContainerImage** represents the container image information.
//
//	It includes the repository, tag, and optional image pull secret for private registries.
type ContainerImageInput struct {
	// The repository of the image (e.g., "gcr.io/project/image").
	Repo string `json:"repo,omitempty" jsonschema:"The repository of the image (e.g.; 'gcr.io/project/image')."`
	// The tag of the image (e.g., "latest" or "1.0.0").
	Tag string `json:"tag,omitempty" jsonschema:"The tag of the image (e.g.; 'latest' or '1.0.0')."`
	// The name of the image pull secret for private image repositories.
	PullSecretName string `json:"pull_secret_name,omitempty" jsonschema:"The name of the image pull secret for private image repositories."`
}

func (s *ContainerImageInput) validate() error {
	return nil
}

func (s *ContainerImageInput) applyDefaults() {
}

func (s *ContainerImageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Repo != "" {
		m["repo"] = s.Repo
	}
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	if s.PullSecretName != "" {
		m["pull_secret_name"] = s.PullSecretName
	}
	return m
}

// **ContainerPort** specifies a network port in a single container.
//
//	It allows you to expose ports for communication with other services or the external network.
type ContainerPortInput struct {
	// The name of the port.
	Name string `json:"name,omitempty" jsonschema:"The name of the port."`
	// The port number on the container.
	ContainerPort int32 `json:"container_port,omitempty" jsonschema:"The port number on the container."`
	// The protocol used by the port (e.g., "TCP" or "UDP").
	Protocol string `json:"protocol,omitempty" jsonschema:"The protocol used by the port (e.g.; 'TCP' or 'UDP')."`
}

func (s *ContainerPortInput) validate() error {
	return nil
}

func (s *ContainerPortInput) applyDefaults() {
}

func (s *ContainerPortInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.ContainerPort != 0 {
		m["container_port"] = s.ContainerPort
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	return m
}

// **ContainerResources** specifies the CPU and memory resources for a container.
//
//	It allows you to define resource limits and requests to manage resource allocation and ensure optimal performance.
type ContainerResourcesInput struct {
	// The resource limits for the container.
	//  Specify the maximum amount of CPU and memory that the container can use.
	Limits *CpuMemoryInput `json:"limits,omitempty" jsonschema:"The resource limits for the container. Specify the maximum amount of CPU and memory that the container can use."`
	// The resource requests for the container.
	//  Specify the minimum amount of CPU and memory that the container is guaranteed.
	Requests *CpuMemoryInput `json:"requests,omitempty" jsonschema:"The resource requests for the container. Specify the minimum amount of CPU and memory that the container is guaranteed."`
}

func (s *ContainerResourcesInput) validate() error {
	if s.Limits != nil {
		if err := s.Limits.validate(); err != nil {
			return fmt.Errorf("limits: %w", err)
		}
	}
	if s.Requests != nil {
		if err := s.Requests.validate(); err != nil {
			return fmt.Errorf("requests: %w", err)
		}
	}
	return nil
}

func (s *ContainerResourcesInput) applyDefaults() {
	if s.Limits != nil {
		s.Limits.applyDefaults()
	}
	if s.Requests != nil {
		s.Requests.applyDefaults()
	}
}

func (s *ContainerResourcesInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Limits != nil {
		m["limits"] = s.Limits.toMap()
	}
	if s.Requests != nil {
		m["requests"] = s.Requests.toMap()
	}
	return m
}

// **CpuMemory** defines CPU and memory resource quantities for a container.
//
//	It is used to specify the limits and requests for CPU and memory resources.
type CpuMemoryInput struct {
	Cpu    string `json:"cpu,omitempty" jsonschema:""`
	Memory string `json:"memory,omitempty" jsonschema:""`
}

func (s *CpuMemoryInput) validate() error {
	return nil
}

func (s *CpuMemoryInput) applyDefaults() {
}

func (s *CpuMemoryInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Cpu != "" {
		m["cpu"] = s.Cpu
	}
	if s.Memory != "" {
		m["memory"] = s.Memory
	}
	return m
}

// *
//
//	EmptyDirVolumeSource creates an empty directory for temporary storage.
//	The directory is created when a pod is assigned to a node and exists as long as the pod runs.
//	Data is deleted when the pod is removed.
//
//	Use cases:
//	- Scratch space for computations
//	- Checkpoint storage for crash recovery
//	- Shared space between containers in a pod
//
//	Example - Default (disk-backed):
//	  emptyDir: {}
//
//	Example - Memory-backed (faster, but uses RAM):
//	  emptyDir:
//	    medium: Memory
//	    sizeLimit: 256Mi
type EmptyDirVolumeSourceInput struct {
	// Medium for the empty directory.
	//  "" (default) uses the node's default medium (typically disk).
	//  "Memory" uses a tmpfs (RAM-backed filesystem).
	//
	//  Memory-backed volumes are faster but:
	//  - Count against container memory limits
	//  - Are lost on node restart
	//  - Should have sizeLimit set to prevent OOM
	Medium string `json:"medium,omitempty" jsonschema:"Medium for the empty directory. '' (default) uses the node's default medium (typically disk). 'Memory' uses a tmpfs (RAM-backed filesystem). Memory-backed volumes are faster but: - Count against conta..."`
	// Size limit for the empty directory.
	//  Format: Kubernetes quantity (e.g., "1Gi", "500Mi").
	//  Only strictly enforced when medium is "Memory".
	//  For disk-backed volumes, this is a best-effort limit.
	SizeLimit string `json:"size_limit,omitempty" jsonschema:"Size limit for the empty directory. Format: Kubernetes quantity (e.g.; '1Gi'; '500Mi'). Only strictly enforced when medium is 'Memory'. For disk-backed volumes; this is a best-effort limit."`
}

func (s *EmptyDirVolumeSourceInput) validate() error {
	return nil
}

func (s *EmptyDirVolumeSourceInput) applyDefaults() {
}

func (s *EmptyDirVolumeSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Medium != "" {
		m["medium"] = s.Medium
	}
	if s.SizeLimit != "" {
		m["size_limit"] = s.SizeLimit
	}
	return m
}

// **ExecAction** describes a command-based health check.
type ExecActionInput struct {
	// Command is the command line to execute inside the container.
	//  The command is run in the container's root filesystem.
	//  The command's exit status is used to determine the health:
	//  - 0: Success
	//  - Non-zero: Failure
	Command []string `json:"command,omitempty" jsonschema:"Command is the command line to execute inside the container. The command is run in the container's root filesystem. The command's exit status is used to determine the health: - 0: Success - Non-zero: ..."`
}

func (s *ExecActionInput) validate() error {
	return nil
}

func (s *ExecActionInput) applyDefaults() {
}

func (s *ExecActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	return m
}

// **GRPCAction** describes an action based on gRPC health checking protocol.
//
//	Reference: https://github.com/grpc/grpc/blob/master/doc/health-checking.md
type GRPCActionInput struct {
	// Port number of the gRPC service.
	//  Number must be in the range 1 to 65535.
	Port int32 `json:"port,omitempty" jsonschema:"Port number of the gRPC service. Number must be in the range 1 to 65535."`
	// Service is the name of the service to check.
	//  If not specified, the default behavior defined by gRPC is used.
	//  For standard gRPC health checks, leave empty to check overall server health.
	Service string `json:"service,omitempty" jsonschema:"Service is the name of the service to check. If not specified; the default behavior defined by gRPC is used. For standard gRPC health checks; leave empty to check overall server health."`
}

func (s *GRPCActionInput) validate() error {
	return nil
}

func (s *GRPCActionInput) applyDefaults() {
}

func (s *GRPCActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Service != "" {
		m["service"] = s.Service
	}
	return m
}

// **HTTPGetAction** describes an action based on HTTP Get requests.
type HTTPGetActionInput struct {
	// Path to access on the HTTP server.
	//  Defaults to '/'.
	Path       string `json:"path,omitempty" jsonschema:"Path to access on the HTTP server. Defaults to '/'."`
	PortNumber int32  `json:"port_number,omitempty" jsonschema:""`
	PortName   string `json:"port_name,omitempty" jsonschema:""`
	// Host name to connect to, defaults to the pod IP.
	//  You probably want to set "Host" in http_headers instead.
	Host string `json:"host,omitempty" jsonschema:"Host name to connect to; defaults to the pod IP. You probably want to set 'Host' in http_headers instead."`
	// Scheme to use for connecting to the host (HTTP or HTTPS).
	//  Defaults to HTTP.
	Scheme string `json:"scheme,omitempty" jsonschema:"Scheme to use for connecting to the host (HTTP or HTTPS). Defaults to HTTP."`
	// Custom headers to set in the request.
	//  HTTP allows repeated headers.
	HttpHeaders []*HTTPHeaderInput `json:"http_headers,omitempty" jsonschema:"Custom headers to set in the request. HTTP allows repeated headers."`
}

func (s *HTTPGetActionInput) validate() error {
	for i, v := range s.HttpHeaders {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("http_headers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *HTTPGetActionInput) applyDefaults() {
}

func (s *HTTPGetActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.PortNumber != 0 {
		m["port_number"] = s.PortNumber
	}
	if s.PortName != "" {
		m["port_name"] = s.PortName
	}
	if s.Host != "" {
		m["host"] = s.Host
	}
	if s.Scheme != "" {
		m["scheme"] = s.Scheme
	}
	if len(s.HttpHeaders) > 0 {
		items := make([]any, len(s.HttpHeaders))
		for i, v := range s.HttpHeaders {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["http_headers"] = items
	}
	return m
}

// **HTTPHeader** describes a custom header to be used in HTTP probes.
type HTTPHeaderInput struct {
	// The header field name.
	Name string `json:"name,omitempty" jsonschema:"The header field name."`
	// The header field value.
	Value string `json:"value,omitempty" jsonschema:"The header field value."`
}

func (s *HTTPHeaderInput) validate() error {
	return nil
}

func (s *HTTPHeaderInput) applyDefaults() {
}

func (s *HTTPHeaderInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// *
//
//	HostPathVolumeSource mounts a file or directory from the host node's filesystem.
//	Use with caution as it ties pods to specific nodes.
//
//	Common use cases:
//	- Log collection DaemonSets mounting /var/log
//	- Node monitoring agents mounting /sys or /proc
//	- Container runtime sockets (e.g., /var/run/docker.sock)
//
//	Example:
//	  hostPath:
//	    path: /var/log
//	    type: Directory
type HostPathVolumeSourceInput struct {
	// Path on the host to mount.
	Path string `json:"path" jsonschema:"required,Path on the host to mount."`
	// Type of the host path.
	//  Valid values:
	//    "" - Empty string (default) means no check is performed before mounting
	//    "DirectoryOrCreate" - Create directory if it doesn't exist
	//    "Directory" - Directory must exist
	//    "FileOrCreate" - Create file if it doesn't exist
	//    "File" - File must exist
	//    "Soc...
	Type string `json:"type,omitempty" jsonschema:"Type of the host path. Valid values: '' - Empty string (default) means no check is performed before mounting 'DirectoryOrCreate' - Create directory if it doesn't exist 'Directory' - Directory must exi..."`
}

func (s *HostPathVolumeSourceInput) validate() error {
	if s.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

func (s *HostPathVolumeSourceInput) applyDefaults() {
}

func (s *HostPathVolumeSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["path"] = s.Path
	if s.Type != "" {
		m["type"] = s.Type
	}
	return m
}

// **KubernetesClusterSelector** defines a selector for a Kubernetes cluster in the same environment as the addon.
type KubernetesClusterSelectorInput struct {
	// can be one of the supported kubernetes cluster kinds
	ClusterKind string `json:"cluster_kind,omitempty" jsonschema:"can be one of the supported kubernetes cluster kinds"`
	// name of the kubernetes cluster in the same environment as the addon
	//  if the name is different from slug, use the value of slug here.
	//  for the purposes of readbility, this field is named as cluster_name vs cluster_slug but the expected value is always slug.
	//  the provided value is automatically conver...
	ClusterName string `json:"cluster_name,omitempty" jsonschema:"name of the kubernetes cluster in the same environment as the addon if the name is different from slug; use the value of slug here. for the purposes of readbility; this field is named as cluster_name ..."`
}

func (s *KubernetesClusterSelectorInput) validate() error {
	return nil
}

func (s *KubernetesClusterSelectorInput) applyDefaults() {
}

func (s *KubernetesClusterSelectorInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ClusterKind != "" {
		m["cluster_kind"] = s.ClusterKind
	}
	if s.ClusterName != "" {
		m["cluster_name"] = s.ClusterName
	}
	return m
}

// *
//
//	**KubernetesSecretKeyRef** is a reference to a specific key within a Kubernetes Secret.
//	This allows components to retrieve sensitive values from existing secrets rather than
//	storing them as plain text in the configuration.
type KubernetesSecretKeyRefInput struct {
	// *
	//  The namespace of the Kubernetes Secret.
	//  If not specified, defaults to the namespace where the component is deployed.
	//  Note: Cross-namespace secret references may not be supported by all Helm charts.
	Namespace string `json:"namespace,omitempty" jsonschema:"* The namespace of the Kubernetes Secret. If not specified; defaults to the namespace where the component is deployed. Note: Cross-namespace secret references may not be supported by all Helm charts."`
	// *
	//  The name of the Kubernetes Secret.
	Name string `json:"name" jsonschema:"required,* The name of the Kubernetes Secret."`
	// *
	//  The key within the Kubernetes Secret that contains the value.
	Key string `json:"key" jsonschema:"required,* The key within the Kubernetes Secret that contains the value."`
}

func (s *KubernetesSecretKeyRefInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Key == "" {
		return fmt.Errorf("key is required")
	}
	return nil
}

func (s *KubernetesSecretKeyRefInput) applyDefaults() {
}

func (s *KubernetesSecretKeyRefInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}
	m["name"] = s.Name
	m["key"] = s.Key
	return m
}

// *
//
//	**KubernetesSensitiveValue** represents a sensitive value that can be provided either
//	as a literal string or as a reference to a Kubernetes Secret.
//
//	Using secret references is recommended for production deployments to avoid storing
//	sensitive values in plain text within configuration files or version control.
type KubernetesSensitiveValueInput struct {
	// *
	//  A literal string value.
	//  Warning: Using plain text for sensitive values is not recommended for production.
	//  Consider using secret_ref instead.
	Value string `json:"value,omitempty" jsonschema:"* A literal string value. Warning: Using plain text for sensitive values is not recommended for production. Consider using secret_ref instead."`
	// *
	//  A reference to a key within a Kubernetes Secret.
	//  The secret must exist in the cluster before the component is deployed.
	SecretRef *KubernetesSecretKeyRefInput `json:"secret_ref,omitempty" jsonschema:"* A reference to a key within a Kubernetes Secret. The secret must exist in the cluster before the component is deployed."`
}

func (s *KubernetesSensitiveValueInput) validate() error {
	if s.SecretRef != nil {
		if err := s.SecretRef.validate(); err != nil {
			return fmt.Errorf("secret_ref: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSensitiveValueInput) applyDefaults() {
	if s.SecretRef != nil {
		s.SecretRef.applyDefaults()
	}
}

func (s *KubernetesSensitiveValueInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.SecretRef != nil {
		m["secret_ref"] = s.SecretRef.toMap()
	}
	return m
}

// **Probe** defines a health check to be performed against a container to determine whether it is
//
//	alive, ready, or has started successfully. Probes are essential for zero-downtime deployments.
//	Reference: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
type ProbeInput struct {
	// Number of seconds after the container has started before liveness or readiness probes are initiated.
	//  Defaults to 0 seconds. Minimum value is 0.
	InitialDelaySeconds int32 `json:"initial_delay_seconds,omitempty" jsonschema:"Number of seconds after the container has started before liveness or readiness probes are initiated. Defaults to 0 seconds. Minimum value is 0."`
	// How often (in seconds) to perform the probe.
	//  Default to 10 seconds. Minimum value is 1.
	PeriodSeconds int32 `json:"period_seconds,omitempty" jsonschema:"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1."`
	// Number of seconds after which the probe times out.
	//  Defaults to 1 second. Minimum value is 1.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1."`
	// Minimum consecutive successes for the probe to be considered successful after having failed.
	//  Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
	SuccessThreshold int32 `json:"success_threshold,omitempty" jsonschema:"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1."`
	// Minimum consecutive failures for the probe to be considered failed after having succeeded.
	//  Defaults to 3. Minimum value is 1.
	FailureThreshold int32 `json:"failure_threshold,omitempty" jsonschema:"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1."`
	// HTTPGet specifies the http request to perform.
	HttpGet *HTTPGetActionInput `json:"http_get,omitempty" jsonschema:"HTTPGet specifies the http request to perform."`
	// GRPC specifies an action involving a GRPC port.
	Grpc *GRPCActionInput `json:"grpc,omitempty" jsonschema:"GRPC specifies an action involving a GRPC port."`
	// TCPSocket specifies an action involving a TCP port.
	TcpSocket *TCPSocketActionInput `json:"tcp_socket,omitempty" jsonschema:"TCPSocket specifies an action involving a TCP port."`
	// Exec specifies a command to execute inside the container.
	Exec *ExecActionInput `json:"exec,omitempty" jsonschema:"Exec specifies a command to execute inside the container."`
}

func (s *ProbeInput) validate() error {
	if s.HttpGet != nil {
		if err := s.HttpGet.validate(); err != nil {
			return fmt.Errorf("http_get: %w", err)
		}
	}
	if s.Grpc != nil {
		if err := s.Grpc.validate(); err != nil {
			return fmt.Errorf("grpc: %w", err)
		}
	}
	if s.TcpSocket != nil {
		if err := s.TcpSocket.validate(); err != nil {
			return fmt.Errorf("tcp_socket: %w", err)
		}
	}
	if s.Exec != nil {
		if err := s.Exec.validate(); err != nil {
			return fmt.Errorf("exec: %w", err)
		}
	}
	return nil
}

func (s *ProbeInput) applyDefaults() {
	if s.HttpGet != nil {
		s.HttpGet.applyDefaults()
	}
	if s.Grpc != nil {
		s.Grpc.applyDefaults()
	}
	if s.TcpSocket != nil {
		s.TcpSocket.applyDefaults()
	}
	if s.Exec != nil {
		s.Exec.applyDefaults()
	}
}

func (s *ProbeInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.InitialDelaySeconds != 0 {
		m["initial_delay_seconds"] = s.InitialDelaySeconds
	}
	if s.PeriodSeconds != 0 {
		m["period_seconds"] = s.PeriodSeconds
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.SuccessThreshold != 0 {
		m["success_threshold"] = s.SuccessThreshold
	}
	if s.FailureThreshold != 0 {
		m["failure_threshold"] = s.FailureThreshold
	}
	if s.HttpGet != nil {
		m["http_get"] = s.HttpGet.toMap()
	}
	if s.Grpc != nil {
		m["grpc"] = s.Grpc.toMap()
	}
	if s.TcpSocket != nil {
		m["tcp_socket"] = s.TcpSocket.toMap()
	}
	if s.Exec != nil {
		m["exec"] = s.Exec.toMap()
	}
	return m
}

// *
//
//	PvcVolumeSource mounts an existing PersistentVolumeClaim.
//
//	For StatefulSets: The claimName can reference a volumeClaimTemplate name,
//	and the StatefulSet controller will automatically handle per-pod PVC binding.
//
//	Example:
//	  pvc:
//	    claimName: data-volume
//	    readOnly: false
type PvcVolumeSourceInput struct {
	// Name of the PersistentVolumeClaim to mount.
	//  For StatefulSets, this can be the name of a volumeClaimTemplate.
	ClaimName string `json:"claim_name" jsonschema:"required,Name of the PersistentVolumeClaim to mount. For StatefulSets; this can be the name of a volumeClaimTemplate."`
	// Whether the PVC should be mounted read-only.
	//  Default is false.
	ReadOnly bool `json:"read_only,omitempty" jsonschema:"Whether the PVC should be mounted read-only. Default is false."`
}

func (s *PvcVolumeSourceInput) validate() error {
	if s.ClaimName == "" {
		return fmt.Errorf("claim_name is required")
	}
	return nil
}

func (s *PvcVolumeSourceInput) applyDefaults() {
}

func (s *PvcVolumeSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["claim_name"] = s.ClaimName
	if s.ReadOnly {
		m["read_only"] = s.ReadOnly
	}
	return m
}

// *
//
//	SecretVolumeSource mounts a Secret as a volume.
//	Works similarly to ConfigMapVolumeSource but for sensitive data.
//
//	Example:
//	  secret:
//	    name: tls-certs
//	    key: tls.crt
//	    path: server.crt
type SecretVolumeSourceInput struct {
	// Name of the Secret to mount.
	Name string `json:"name" jsonschema:"required,Name of the Secret to mount."`
	// Specific key from the Secret to mount as a single file.
	//  If not specified, all keys are mounted as files in the directory.
	Key string `json:"key,omitempty" jsonschema:"Specific key from the Secret to mount as a single file. If not specified; all keys are mounted as files in the directory."`
	// If key is specified, this is the filename to use for the mounted file.
	//  Defaults to the key name if not specified.
	Path string `json:"path,omitempty" jsonschema:"If key is specified; this is the filename to use for the mounted file. Defaults to the key name if not specified."`
	// Mode bits to use on created files. Must be a value between 0 and 0777.
	//  Defaults to 0644.
	DefaultMode int32 `json:"default_mode,omitempty" jsonschema:"Mode bits to use on created files. Must be a value between 0 and 0777. Defaults to 0644."`
}

func (s *SecretVolumeSourceInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *SecretVolumeSourceInput) applyDefaults() {
}

func (s *SecretVolumeSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.DefaultMode != 0 {
		m["default_mode"] = s.DefaultMode
	}
	return m
}

// **TCPSocketAction** describes an action based on opening a socket.
type TCPSocketActionInput struct {
	PortNumber int32  `json:"port_number,omitempty" jsonschema:""`
	PortName   string `json:"port_name,omitempty" jsonschema:""`
	// Host name to connect to, defaults to the pod IP.
	Host string `json:"host,omitempty" jsonschema:"Host name to connect to; defaults to the pod IP."`
}

func (s *TCPSocketActionInput) validate() error {
	return nil
}

func (s *TCPSocketActionInput) applyDefaults() {
}

func (s *TCPSocketActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.PortNumber != 0 {
		m["port_number"] = s.PortNumber
	}
	if s.PortName != "" {
		m["port_name"] = s.PortName
	}
	if s.Host != "" {
		m["host"] = s.Host
	}
	return m
}

// *
//
//	VolumeMount defines how to mount a volume into a container.
//	Supports multiple volume types: ConfigMap, Secret, HostPath, EmptyDir, and PVC.
//	Only one volume source should be specified per mount.
//
//	Example usage:
//	  volumeMounts:
//	    - name: config
//	      mountPath: /etc/app/config.yaml
//	      configMap:
//	        name: app-config
//	        key: config.yaml
//	    - name: logs
//	      mountPath: /var/log
//	      hostPath:
//	        path: /var/log
//	        type: Directory
type VolumeMountInput struct {
	// Name of the volume mount. Must be unique within the container.
	//  Used to correlate with the volume definition.
	Name string `json:"name" jsonschema:"required,Name of the volume mount. Must be unique within the container. Used to correlate with the volume definition."`
	// Path within the container at which the volume should be mounted.
	//  Must be an absolute path.
	MountPath string `json:"mount_path" jsonschema:"required,Path within the container at which the volume should be mounted. Must be an absolute path."`
	// Whether the volume should be mounted read-only.
	//  Default is false.
	ReadOnly bool `json:"read_only,omitempty" jsonschema:"Whether the volume should be mounted read-only. Default is false."`
	// Path within the volume from which the container's volume should be mounted.
	//  Defaults to "" (volume's root).
	//  Useful for mounting a subdirectory of a volume.
	SubPath string `json:"sub_path,omitempty" jsonschema:"Path within the volume from which the container's volume should be mounted. Defaults to '' (volume's root). Useful for mounting a subdirectory of a volume."`
	// ConfigMap volume source.
	//  Use this to mount a ConfigMap as a file or directory.
	ConfigMap *ConfigMapVolumeSourceInput `json:"config_map,omitempty" jsonschema:"ConfigMap volume source. Use this to mount a ConfigMap as a file or directory."`
	// Secret volume source.
	//  Use this to mount a Secret as a file or directory.
	Secret *SecretVolumeSourceInput `json:"secret,omitempty" jsonschema:"Secret volume source. Use this to mount a Secret as a file or directory."`
	// HostPath volume source.
	//  Use this to mount a file or directory from the host node's filesystem.
	//  Common for DaemonSets that need access to node-level resources.
	HostPath *HostPathVolumeSourceInput `json:"host_path,omitempty" jsonschema:"HostPath volume source. Use this to mount a file or directory from the host node's filesystem. Common for DaemonSets that need access to node-level resources."`
	// EmptyDir volume source.
	//  Use this for temporary storage that is erased when the pod is removed.
	//  Useful for scratch space, caching, or sharing data between containers.
	EmptyDir *EmptyDirVolumeSourceInput `json:"empty_dir,omitempty" jsonschema:"EmptyDir volume source. Use this for temporary storage that is erased when the pod is removed. Useful for scratch space; caching; or sharing data between containers."`
	// PersistentVolumeClaim volume source.
	//  Use this to mount an existing PVC.
	//  For StatefulSets, this can reference a volumeClaimTemplate.
	Pvc *PvcVolumeSourceInput `json:"pvc,omitempty" jsonschema:"PersistentVolumeClaim volume source. Use this to mount an existing PVC. For StatefulSets; this can reference a volumeClaimTemplate."`
}

func (s *VolumeMountInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.MountPath == "" {
		return fmt.Errorf("mount_path is required")
	}
	if s.ConfigMap != nil {
		if err := s.ConfigMap.validate(); err != nil {
			return fmt.Errorf("config_map: %w", err)
		}
	}
	if s.Secret != nil {
		if err := s.Secret.validate(); err != nil {
			return fmt.Errorf("secret: %w", err)
		}
	}
	if s.HostPath != nil {
		if err := s.HostPath.validate(); err != nil {
			return fmt.Errorf("host_path: %w", err)
		}
	}
	if s.EmptyDir != nil {
		if err := s.EmptyDir.validate(); err != nil {
			return fmt.Errorf("empty_dir: %w", err)
		}
	}
	if s.Pvc != nil {
		if err := s.Pvc.validate(); err != nil {
			return fmt.Errorf("pvc: %w", err)
		}
	}
	return nil
}

func (s *VolumeMountInput) applyDefaults() {
	if s.ConfigMap != nil {
		s.ConfigMap.applyDefaults()
	}
	if s.Secret != nil {
		s.Secret.applyDefaults()
	}
	if s.HostPath != nil {
		s.HostPath.applyDefaults()
	}
	if s.EmptyDir != nil {
		s.EmptyDir.applyDefaults()
	}
	if s.Pvc != nil {
		s.Pvc.applyDefaults()
	}
}

func (s *VolumeMountInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["mount_path"] = s.MountPath
	if s.ReadOnly {
		m["read_only"] = s.ReadOnly
	}
	if s.SubPath != "" {
		m["sub_path"] = s.SubPath
	}
	if s.ConfigMap != nil {
		m["config_map"] = s.ConfigMap.toMap()
	}
	if s.Secret != nil {
		m["secret"] = s.Secret.toMap()
	}
	if s.HostPath != nil {
		m["host_path"] = s.HostPath.toMap()
	}
	if s.EmptyDir != nil {
		m["empty_dir"] = s.EmptyDir.toMap()
	}
	if s.Pvc != nil {
		m["pvc"] = s.Pvc.toMap()
	}
	return m
}
