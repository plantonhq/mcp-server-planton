// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// signoz-kubernetes
type KubernetesSignozSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The container specifications for the main SigNoz binary (UI, API server, Ruler, Alertmanager).
	SignozContainer *KubernetesSignozContainerInput `json:"signoz_container,omitempty" jsonschema:"The container specifications for the main SigNoz binary (UI; API server; Ruler; Alertmanager)."`
	// The container specifications for the OpenTelemetry Collector (data ingestion gateway).
	OtelCollectorContainer *KubernetesSignozContainerInput `json:"otel_collector_container,omitempty" jsonschema:"The container specifications for the OpenTelemetry Collector (data ingestion gateway)."`
	// The database configuration for SigNoz, supporting both self-managed and external ClickHouse.
	Database *KubernetesSignozDatabaseConfigInput `json:"database" jsonschema:"required,The database configuration for SigNoz; supporting both self-managed and external ClickHouse."`
	// The ingress configuration for SigNoz UI and OpenTelemetry Collector endpoints.
	Ingress *KubernetesSignozIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for SigNoz UI and OpenTelemetry Collector endpoints."`
	// *
	//  A map of key-value pairs that provide additional customization options for the SigNoz Helm chart.
	//  These values allow for further refinement of the deployment, such as setting environment variables,
	//  configuring alerting integrations, or customizing retention policies.
	//  For detailed information o...
	HelmValues map[string]string `json:"helm_values,omitempty" jsonschema:"* A map of key-value pairs that provide additional customization options for the SigNoz Helm chart. These values allow for further refinement of the deployment; such as setting environment variables; ..."`
}

func (s *KubernetesSignozSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.SignozContainer != nil {
		if err := s.SignozContainer.validate(); err != nil {
			return fmt.Errorf("signoz_container: %w", err)
		}
	}
	if s.OtelCollectorContainer != nil {
		if err := s.OtelCollectorContainer.validate(); err != nil {
			return fmt.Errorf("otel_collector_container: %w", err)
		}
	}
	if s.Database == nil {
		return fmt.Errorf("database is required")
	}
	if s.Database != nil {
		if err := s.Database.validate(); err != nil {
			return fmt.Errorf("database: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.SignozContainer != nil {
		s.SignozContainer.applyDefaults()
	}
	if s.OtelCollectorContainer != nil {
		s.OtelCollectorContainer.applyDefaults()
	}
	if s.Database != nil {
		s.Database.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesSignozSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.SignozContainer != nil {
		m["signoz_container"] = s.SignozContainer.toMap()
	}
	if s.OtelCollectorContainer != nil {
		m["otel_collector_container"] = s.OtelCollectorContainer.toMap()
	}
	if s.Database != nil {
		m["database"] = s.Database.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if len(s.HelmValues) > 0 {
		m["helm_values"] = s.HelmValues
	}
	return m
}

// *
//
//	**KubernetesSignozClickhouseCluster** defines the clustering configuration for ClickHouse.
//	Clustering enables distributed data storage and high availability through sharding and replication.
//	Note: Clustering requires Zookeeper to be configured.
type KubernetesSignozClickhouseClusterInput struct {
	// *
	//  Flag to enable or disable clustering mode for ClickHouse.
	//  When enabled, ClickHouse will be deployed in a distributed cluster configuration.
	//  Defaults to false.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"* Flag to enable or disable clustering mode for ClickHouse. When enabled; ClickHouse will be deployed in a distributed cluster configuration. Defaults to false."`
	// *
	//  The number of shards in the ClickHouse cluster.
	//  Sharding distributes data across multiple nodes for horizontal scaling.
	//  Recommended: 2 or more for production.
	//  This value is ignored if clustering is not enabled.
	ShardCount int32 `json:"shard_count,omitempty" jsonschema:"* The number of shards in the ClickHouse cluster. Sharding distributes data across multiple nodes for horizontal scaling. Recommended: 2 or more for production. This value is ignored if clustering is ..."`
	// *
	//  The number of replicas for each shard.
	//  Replication provides data redundancy and high availability.
	//  Recommended: 2 for production.
	//  This value is ignored if clustering is not enabled.
	ReplicaCount int32 `json:"replica_count,omitempty" jsonschema:"* The number of replicas for each shard. Replication provides data redundancy and high availability. Recommended: 2 for production. This value is ignored if clustering is not enabled."`
}

func (s *KubernetesSignozClickhouseClusterInput) validate() error {
	return nil
}

func (s *KubernetesSignozClickhouseClusterInput) applyDefaults() {
}

func (s *KubernetesSignozClickhouseClusterInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.ShardCount != 0 {
		m["shard_count"] = s.ShardCount
	}
	if s.ReplicaCount != 0 {
		m["replica_count"] = s.ReplicaCount
	}
	return m
}

// *
//
//	**KubernetesSignozClickhouseContainer** specifies the container configuration for ClickHouse.
//	It includes replica count, resource allocations, and persistence settings.
type KubernetesSignozClickhouseContainerInput struct {
	// The number of ClickHouse pods to deploy.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of ClickHouse pods to deploy."`
	// The CPU and memory resources allocated to the ClickHouse container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the ClickHouse container."`
	// The container image configuration for ClickHouse.
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image configuration for ClickHouse."`
	// *
	//  Flag to enable or disable data persistence for ClickHouse.
	//  When enabled, data is persisted to a storage volume, allowing data to survive pod restarts.
	//  Defaults to true.
	PersistenceEnabled bool `json:"persistence_enabled,omitempty" jsonschema:"* Flag to enable or disable data persistence for ClickHouse. When enabled; data is persisted to a storage volume; allowing data to survive pod restarts. Defaults to true."`
	// *
	//  The size of the persistent volume attached to each ClickHouse pod (e.g., "20Gi").
	//  This attribute is ignored when persistence is not enabled.
	//  Note: This value cannot be modified after creation due to Kubernetes StatefulSet limitations.
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The size of the persistent volume attached to each ClickHouse pod (e.g.; '20Gi'). This attribute is ignored when persistence is not enabled. Note: This value cannot be modified after creation due to..."`
}

func (s *KubernetesSignozClickhouseContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozClickhouseContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesSignozClickhouseContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.PersistenceEnabled {
		m["persistence_enabled"] = s.PersistenceEnabled
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// *
//
//	**KubernetesSignozContainer** specifies the container configuration for various SigNoz components.
//	It includes settings such as the number of replicas, container image, and resource allocations.
type KubernetesSignozContainerInput struct {
	// The number of pods to deploy for this component.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of pods to deploy for this component."`
	// The CPU and memory resources allocated to the container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the container."`
	// The container image configuration (repository and tag).
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image configuration (repository and tag)."`
}

func (s *KubernetesSignozContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesSignozContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	return m
}

// *
//
//	**KubernetesSignozDatabaseConfig** defines the ClickHouse database configuration for SigNoz.
//	It supports two deployment modes:
//	1. Self-managed: Deploy ClickHouse and Zookeeper within the Kubernetes cluster (default).
//	2. External: Connect to an existing external ClickHouse instance.
type KubernetesSignozDatabaseConfigInput struct {
	// *
	//  Flag to enable using an external ClickHouse database.
	//  When false (default), SigNoz will deploy and manage its own ClickHouse instance.
	//  When true, the external_database field must be configured.
	IsExternal bool `json:"is_external,omitempty" jsonschema:"* Flag to enable using an external ClickHouse database. When false (default); SigNoz will deploy and manage its own ClickHouse instance. When true; the external_database field must be configured."`
	// *
	//  External ClickHouse database connection details.
	//  This field is required when is_external is true and ignored when false.
	ExternalDatabase *KubernetesSignozExternalClickhouseInput `json:"external_database,omitempty" jsonschema:"* External ClickHouse database connection details. This field is required when is_external is true and ignored when false."`
	// *
	//  Self-managed ClickHouse configuration.
	//  This field is used when is_external is false and configures the in-cluster ClickHouse deployment.
	ManagedDatabase *KubernetesSignozManagedClickhouseInput `json:"managed_database,omitempty" jsonschema:"* Self-managed ClickHouse configuration. This field is used when is_external is false and configures the in-cluster ClickHouse deployment."`
}

func (s *KubernetesSignozDatabaseConfigInput) validate() error {
	if s.ExternalDatabase != nil {
		if err := s.ExternalDatabase.validate(); err != nil {
			return fmt.Errorf("external_database: %w", err)
		}
	}
	if s.ManagedDatabase != nil {
		if err := s.ManagedDatabase.validate(); err != nil {
			return fmt.Errorf("managed_database: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozDatabaseConfigInput) applyDefaults() {
	if s.ExternalDatabase != nil {
		s.ExternalDatabase.applyDefaults()
	}
	if s.ManagedDatabase != nil {
		s.ManagedDatabase.applyDefaults()
	}
}

func (s *KubernetesSignozDatabaseConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsExternal {
		m["is_external"] = s.IsExternal
	}
	if s.ExternalDatabase != nil {
		m["external_database"] = s.ExternalDatabase.toMap()
	}
	if s.ManagedDatabase != nil {
		m["managed_database"] = s.ManagedDatabase.toMap()
	}
	return m
}

// *
//
//	**KubernetesSignozExternalClickhouse** defines connection parameters for an external ClickHouse instance.
//	This allows SigNoz to use a pre-existing ClickHouse database instead of deploying one within the cluster.
type KubernetesSignozExternalClickhouseInput struct {
	// The hostname or endpoint of the external ClickHouse instance.
	Host string `json:"host" jsonschema:"required,The hostname or endpoint of the external ClickHouse instance."`
	// The HTTP port for ClickHouse (default is 8123).
	HttpPort int32 `json:"http_port,omitempty" jsonschema:"The HTTP port for ClickHouse (default is 8123)."`
	// The TCP port for ClickHouse native protocol (default is 9000).
	TcpPort int32 `json:"tcp_port,omitempty" jsonschema:"The TCP port for ClickHouse native protocol (default is 9000)."`
	// The name of the distributed cluster in ClickHouse configuration.
	ClusterName string `json:"cluster_name,omitempty" jsonschema:"The name of the distributed cluster in ClickHouse configuration."`
	// Whether to use secure (TLS) connection to ClickHouse.
	IsSecure bool `json:"is_secure,omitempty" jsonschema:"Whether to use secure (TLS) connection to ClickHouse."`
	// The username for authenticating to ClickHouse.
	Username string `json:"username" jsonschema:"required,The username for authenticating to ClickHouse."`
	// *
	//  The password for authenticating to ClickHouse.
	//  Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret.
	//
	//  Using a secret reference is recommended for production deployments:
	//  ```yaml
	//  password:
	//    secretRef:
	//      name: clickhouse-credentials
	//      key: pa...
	Password *KubernetesSensitiveValueInput `json:"password" jsonschema:"required,* The password for authenticating to ClickHouse. Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret. Using a secret reference is recommended for producti..."`
}

func (s *KubernetesSignozExternalClickhouseInput) validate() error {
	if s.Host == "" {
		return fmt.Errorf("host is required")
	}
	if s.Username == "" {
		return fmt.Errorf("username is required")
	}
	if s.Password == nil {
		return fmt.Errorf("password is required")
	}
	if s.Password != nil {
		if err := s.Password.validate(); err != nil {
			return fmt.Errorf("password: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozExternalClickhouseInput) applyDefaults() {
	if s.HttpPort == 0 {
		s.HttpPort = 8123
	}
	if s.TcpPort == 0 {
		s.TcpPort = 9000
	}
	if s.ClusterName == "" {
		s.ClusterName = "cluster"
	}
	if s.Password != nil {
		s.Password.applyDefaults()
	}
}

func (s *KubernetesSignozExternalClickhouseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["host"] = s.Host
	if s.HttpPort != 0 {
		m["http_port"] = s.HttpPort
	}
	if s.TcpPort != 0 {
		m["tcp_port"] = s.TcpPort
	}
	if s.ClusterName != "" {
		m["cluster_name"] = s.ClusterName
	}
	if s.IsSecure {
		m["is_secure"] = s.IsSecure
	}
	m["username"] = s.Username
	if s.Password != nil {
		m["password"] = s.Password.toMap()
	}
	return m
}

// *
//
//	**KubernetesSignozIngress** defines the ingress configuration for SigNoz components.
//	It provides separate ingress settings for the UI and OpenTelemetry Collector endpoints.
type KubernetesSignozIngressInput struct {
	// Ingress configuration for SigNoz UI and API.
	Ui *KubernetesSignozIngressEndpointInput `json:"ui,omitempty" jsonschema:"Ingress configuration for SigNoz UI and API."`
	// Ingress configuration for OpenTelemetry Collector data ingestion endpoint.
	OtelCollector *KubernetesSignozIngressEndpointInput `json:"otel_collector,omitempty" jsonschema:"Ingress configuration for OpenTelemetry Collector data ingestion endpoint."`
}

func (s *KubernetesSignozIngressInput) validate() error {
	if s.Ui != nil {
		if err := s.Ui.validate(); err != nil {
			return fmt.Errorf("ui: %w", err)
		}
	}
	if s.OtelCollector != nil {
		if err := s.OtelCollector.validate(); err != nil {
			return fmt.Errorf("otel_collector: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozIngressInput) applyDefaults() {
	if s.Ui != nil {
		s.Ui.applyDefaults()
	}
	if s.OtelCollector != nil {
		s.OtelCollector.applyDefaults()
	}
}

func (s *KubernetesSignozIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Ui != nil {
		m["ui"] = s.Ui.toMap()
	}
	if s.OtelCollector != nil {
		m["otel_collector"] = s.OtelCollector.toMap()
	}
	return m
}

// *
//
//	**KubernetesSignozIngressEndpoint** defines ingress configuration for a specific SigNoz endpoint.
type KubernetesSignozIngressEndpointInput struct {
	// Flag to enable or disable ingress for this endpoint.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress for this endpoint."`
	// The full hostname for external access (e.g., "signoz.example.com").
	//  This hostname will be configured via Gateway API resources.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'signoz.example.com'). This hostname will be configured via Gateway API resources. Required when enabled is true."`
}

func (s *KubernetesSignozIngressEndpointInput) validate() error {
	return nil
}

func (s *KubernetesSignozIngressEndpointInput) applyDefaults() {
}

func (s *KubernetesSignozIngressEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// *
//
//	**KubernetesSignozManagedClickhouse** defines configuration for a self-managed ClickHouse deployment.
//	This supports both simple single-node deployments and production-grade distributed clusters with high availability.
type KubernetesSignozManagedClickhouseInput struct {
	// The container specifications for ClickHouse.
	Container *KubernetesSignozClickhouseContainerInput `json:"container,omitempty" jsonschema:"The container specifications for ClickHouse."`
	// The cluster configuration for ClickHouse (sharding and replication).
	Cluster *KubernetesSignozClickhouseClusterInput `json:"cluster,omitempty" jsonschema:"The cluster configuration for ClickHouse (sharding and replication)."`
	// The Zookeeper configuration (required for distributed ClickHouse clusters).
	Zookeeper *KubernetesSignozZookeeperConfigInput `json:"zookeeper,omitempty" jsonschema:"The Zookeeper configuration (required for distributed ClickHouse clusters)."`
}

func (s *KubernetesSignozManagedClickhouseInput) validate() error {
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Cluster != nil {
		if err := s.Cluster.validate(); err != nil {
			return fmt.Errorf("cluster: %w", err)
		}
	}
	if s.Zookeeper != nil {
		if err := s.Zookeeper.validate(); err != nil {
			return fmt.Errorf("zookeeper: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozManagedClickhouseInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Cluster != nil {
		s.Cluster.applyDefaults()
	}
	if s.Zookeeper != nil {
		s.Zookeeper.applyDefaults()
	}
}

func (s *KubernetesSignozManagedClickhouseInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Cluster != nil {
		m["cluster"] = s.Cluster.toMap()
	}
	if s.Zookeeper != nil {
		m["zookeeper"] = s.Zookeeper.toMap()
	}
	return m
}

// *
//
//	**KubernetesSignozZookeeperConfig** defines the Zookeeper configuration for ClickHouse coordination.
//	Zookeeper is required for distributed ClickHouse deployments to manage replica metadata and leader election.
type KubernetesSignozZookeeperConfigInput struct {
	// *
	//  Flag to enable or disable Zookeeper deployment.
	//  This must be true if ClickHouse clustering is enabled.
	//  Defaults to false.
	IsEnabled bool `json:"is_enabled,omitempty" jsonschema:"* Flag to enable or disable Zookeeper deployment. This must be true if ClickHouse clustering is enabled. Defaults to false."`
	// The container specifications for Zookeeper.
	Container *KubernetesSignozZookeeperContainerInput `json:"container,omitempty" jsonschema:"The container specifications for Zookeeper."`
}

func (s *KubernetesSignozZookeeperConfigInput) validate() error {
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozZookeeperConfigInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
}

func (s *KubernetesSignozZookeeperConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IsEnabled {
		m["is_enabled"] = s.IsEnabled
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	return m
}

// *
//
//	**KubernetesSignozZookeeperContainer** specifies the container configuration for Zookeeper.
type KubernetesSignozZookeeperContainerInput struct {
	// *
	//  The number of Zookeeper pods to deploy.
	//  For production, this should be an odd number (3 or 5) to maintain quorum.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"* The number of Zookeeper pods to deploy. For production; this should be an odd number (3 or 5) to maintain quorum."`
	// The CPU and memory resources allocated to the Zookeeper container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Zookeeper container."`
	// The container image configuration for Zookeeper.
	Image *ContainerImageInput `json:"image,omitempty" jsonschema:"The container image configuration for Zookeeper."`
	// *
	//  The size of the persistent volume attached to each Zookeeper pod (e.g., "8Gi").
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The size of the persistent volume attached to each Zookeeper pod (e.g.; '8Gi')."`
}

func (s *KubernetesSignozZookeeperContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	return nil
}

func (s *KubernetesSignozZookeeperContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
	if s.Image != nil {
		s.Image.applyDefaults()
	}
}

func (s *KubernetesSignozZookeeperContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// ParseKubernetesSignoz validates and normalizes a KubernetesSignoz cloud_object.
func ParseKubernetesSignoz(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesSignoz"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesSignozSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
