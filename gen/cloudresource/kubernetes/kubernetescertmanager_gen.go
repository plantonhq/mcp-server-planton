// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// kubernetes-cert-manager
type KubernetesCertManagerSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// kubernetes-cert-manager version such as "v1.19.1". Used to set the image tag.
	//  Minimum version v1.16.4 is enforced for Cloudflare API compatibility.
	KubernetesCertManagerVersion string `json:"kubernetes_cert_manager_version,omitempty" jsonschema:"kubernetes-cert-manager version such as 'v1.19.1'. Used to set the image tag. Minimum version v1.16.4 is enforced for Cloudflare API compatibility."`
	// Helm chart version to deploy. If not specified, uses the default version.
	HelmChartVersion string `json:"helm_chart_version,omitempty" jsonschema:"Helm chart version to deploy. If not specified; uses the default version."`
	// skip installation of self-signed issuer.
	SkipInstallSelfSignedIssuer bool `json:"skip_install_self_signed_issuer,omitempty" jsonschema:"skip installation of self-signed issuer."`
	// Global ACME configuration used for all DNS providers.
	Acme *AcmeConfigInput `json:"acme" jsonschema:"required,Global ACME configuration used for all DNS providers."`
	// List of DNS provider configurations. Each provider can manage multiple DNS zones.
	//  The addon will create a single ClusterIssuer with multiple solvers based on these configurations.
	DnsProviders []*DnsProviderConfigInput `json:"dns_providers,omitempty" jsonschema:"List of DNS provider configurations. Each provider can manage multiple DNS zones. The addon will create a single ClusterIssuer with multiple solvers based on these configurations."`
}

func (s *KubernetesCertManagerSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Acme == nil {
		return fmt.Errorf("acme is required")
	}
	if s.Acme != nil {
		if err := s.Acme.validate(); err != nil {
			return fmt.Errorf("acme: %w", err)
		}
	}
	if len(s.DnsProviders) < 1 {
		return fmt.Errorf("dns_providers requires at least 1 items, got %d", len(s.DnsProviders))
	}
	for i, v := range s.DnsProviders {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("dns_providers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesCertManagerSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.KubernetesCertManagerVersion == "" {
		s.KubernetesCertManagerVersion = "v1.19.1"
	}
	if s.HelmChartVersion == "" {
		s.HelmChartVersion = "v1.19.1"
	}
	if s.Acme != nil {
		s.Acme.applyDefaults()
	}
}

func (s *KubernetesCertManagerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.KubernetesCertManagerVersion != "" {
		m["kubernetes_cert_manager_version"] = s.KubernetesCertManagerVersion
	}
	if s.HelmChartVersion != "" {
		m["helm_chart_version"] = s.HelmChartVersion
	}
	if s.SkipInstallSelfSignedIssuer {
		m["skip_install_self_signed_issuer"] = s.SkipInstallSelfSignedIssuer
	}
	if s.Acme != nil {
		m["acme"] = s.Acme.toMap()
	}
	if len(s.DnsProviders) > 0 {
		items := make([]any, len(s.DnsProviders))
		for i, v := range s.DnsProviders {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["dns_providers"] = items
	}
	return m
}

// AcmeConfig defines global ACME settings for certificate issuance.
//
//	These settings apply to all DNS providers configured in the addon.
type AcmeConfigInput struct {
	// ACME account email for registration and expiry notifications.
	//  This email will be used by the Certificate Authority (e.g., Let's Encrypt).
	Email string `json:"email" jsonschema:"required,ACME account email for registration and expiry notifications. This email will be used by the Certificate Authority (e.g.; Let's Encrypt)."`
	// ACME server URL.
	//  Use https://acme-v02.api.letsencrypt.org/directory for production.
	//  Use https://acme-staging-v02.api.letsencrypt.org/directory for testing.
	Server string `json:"server,omitempty" jsonschema:"ACME server URL. Use https://acme-v02.api.letsencrypt.org/directory for production. Use https://acme-staging-v02.api.letsencrypt.org/directory for testing."`
}

func (s *AcmeConfigInput) validate() error {
	if s.Email == "" {
		return fmt.Errorf("email is required")
	}
	return nil
}

func (s *AcmeConfigInput) applyDefaults() {
	if s.Server == "" {
		s.Server = "https://acme-v02.api.letsencrypt.org/directory"
	}
}

func (s *AcmeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["email"] = s.Email
	if s.Server != "" {
		m["server"] = s.Server
	}
	return m
}

// AwsRoute53Provider configures AWS Route53 with IAM Roles for Service Accounts (IRSA).
//
//	The addon will configure the kubernetes-cert-manager ServiceAccount with the appropriate IRSA annotation.
type AwsRoute53ProviderInput struct {
	// AWS region where Route53 is configured.
	Region string `json:"region" jsonschema:"required,AWS region where Route53 is configured."`
	// IAM Role ARN for IRSA.
	//  This role must have permissions to modify Route53 records in the specified zones.
	RoleArn string `json:"role_arn" jsonschema:"required,IAM Role ARN for IRSA. This role must have permissions to modify Route53 records in the specified zones."`
}

func (s *AwsRoute53ProviderInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.RoleArn == "" {
		return fmt.Errorf("role_arn is required")
	}
	return nil
}

func (s *AwsRoute53ProviderInput) applyDefaults() {
}

func (s *AwsRoute53ProviderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["role_arn"] = s.RoleArn
	return m
}

// AzureDnsProvider configures Azure DNS with Managed Identity.
//
//	The addon will configure the kubernetes-cert-manager ServiceAccount with the appropriate Managed Identity annotation.
type AzureDnsProviderInput struct {
	// Azure subscription ID that contains the DNS zones.
	SubscriptionId string `json:"subscription_id" jsonschema:"required,Azure subscription ID that contains the DNS zones."`
	// Azure resource group containing the DNS zones.
	ResourceGroup string `json:"resource_group" jsonschema:"required,Azure resource group containing the DNS zones."`
	// Managed Identity Client ID.
	//  This identity must have DNS Zone Contributor role on the specified resource group.
	ClientId string `json:"client_id" jsonschema:"required,Managed Identity Client ID. This identity must have DNS Zone Contributor role on the specified resource group."`
}

func (s *AzureDnsProviderInput) validate() error {
	if s.SubscriptionId == "" {
		return fmt.Errorf("subscription_id is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.ClientId == "" {
		return fmt.Errorf("client_id is required")
	}
	return nil
}

func (s *AzureDnsProviderInput) applyDefaults() {
}

func (s *AzureDnsProviderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subscription_id"] = s.SubscriptionId
	m["resource_group"] = s.ResourceGroup
	m["client_id"] = s.ClientId
	return m
}

// CloudflareProvider configures Cloudflare DNS for DNS-01 ACME challenges.
//
//	The addon will create a Kubernetes Secret containing the API token in the kubernetes-cert-manager namespace.
type CloudflareProviderInput struct {
	// Cloudflare API token for DNS-01 challenge authentication.
	//  Required permissions: Zone:Zone:Read and Zone:DNS:Edit
	//  The token should be scoped to the specific zones listed in dns_zones for security best practices.
	ApiToken string `json:"api_token" jsonschema:"required,Cloudflare API token for DNS-01 challenge authentication. Required permissions: Zone:Zone:Read and Zone:DNS:Edit The token should be scoped to the specific zones listed in dns_zones for security best ..."`
}

func (s *CloudflareProviderInput) validate() error {
	if s.ApiToken == "" {
		return fmt.Errorf("api_token is required")
	}
	return nil
}

func (s *CloudflareProviderInput) applyDefaults() {
}

func (s *CloudflareProviderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["api_token"] = s.ApiToken
	return m
}

// DnsProviderConfig defines a DNS provider configuration with credentials and domain mappings.
//
//	Each configuration represents a single DNS provider account/identity that manages one or more DNS zones.
type DnsProviderConfigInput struct {
	// Unique identifier for this provider configuration.
	//  Used for generating Kubernetes secret names (e.g., "cloudflare-prod", "gcp-internal").
	//  Must be unique within the dns_providers list.
	Name string `json:"name" jsonschema:"required,Unique identifier for this provider configuration. Used for generating Kubernetes secret names (e.g.; 'cloudflare-prod'; 'gcp-internal'). Must be unique within the dns_providers list."`
	// List of DNS zones this provider is responsible for managing.
	//  kubernetes-cert-manager will use this provider's solver for any certificate requests matching these zones.
	//  Examples: ["example.com", "example.org"] or ["internal.example.net"]
	DnsZones []string `json:"dns_zones,omitempty" jsonschema:"List of DNS zones this provider is responsible for managing. kubernetes-cert-manager will use this provider's solver for any certificate requests matching these zones. Examples: ['example.com'; 'examp..."`
	// Google Cloud DNS provider configuration.
	GcpCloudDns *GcpCloudDnsProviderInput `json:"gcp_cloud_dns,omitempty" jsonschema:"Google Cloud DNS provider configuration."`
	// AWS Route53 provider configuration.
	AwsRoute53 *AwsRoute53ProviderInput `json:"aws_route53,omitempty" jsonschema:"AWS Route53 provider configuration."`
	// Azure DNS provider configuration.
	AzureDns *AzureDnsProviderInput `json:"azure_dns,omitempty" jsonschema:"Azure DNS provider configuration."`
	// Cloudflare DNS provider configuration.
	Cloudflare *CloudflareProviderInput `json:"cloudflare,omitempty" jsonschema:"Cloudflare DNS provider configuration."`
}

func (s *DnsProviderConfigInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.DnsZones) < 1 {
		return fmt.Errorf("dns_zones requires at least 1 items, got %d", len(s.DnsZones))
	}
	if s.GcpCloudDns != nil {
		if err := s.GcpCloudDns.validate(); err != nil {
			return fmt.Errorf("gcp_cloud_dns: %w", err)
		}
	}
	if s.AwsRoute53 != nil {
		if err := s.AwsRoute53.validate(); err != nil {
			return fmt.Errorf("aws_route53: %w", err)
		}
	}
	if s.AzureDns != nil {
		if err := s.AzureDns.validate(); err != nil {
			return fmt.Errorf("azure_dns: %w", err)
		}
	}
	if s.Cloudflare != nil {
		if err := s.Cloudflare.validate(); err != nil {
			return fmt.Errorf("cloudflare: %w", err)
		}
	}
	return nil
}

func (s *DnsProviderConfigInput) applyDefaults() {
	if s.GcpCloudDns != nil {
		s.GcpCloudDns.applyDefaults()
	}
	if s.AwsRoute53 != nil {
		s.AwsRoute53.applyDefaults()
	}
	if s.AzureDns != nil {
		s.AzureDns.applyDefaults()
	}
	if s.Cloudflare != nil {
		s.Cloudflare.applyDefaults()
	}
}

func (s *DnsProviderConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if len(s.DnsZones) > 0 {
		m["dns_zones"] = s.DnsZones
	}
	if s.GcpCloudDns != nil {
		m["gcp_cloud_dns"] = s.GcpCloudDns.toMap()
	}
	if s.AwsRoute53 != nil {
		m["aws_route53"] = s.AwsRoute53.toMap()
	}
	if s.AzureDns != nil {
		m["azure_dns"] = s.AzureDns.toMap()
	}
	if s.Cloudflare != nil {
		m["cloudflare"] = s.Cloudflare.toMap()
	}
	return m
}

// GcpCloudDnsProvider configures Google Cloud DNS with Workload Identity.
//
//	The addon will configure the kubernetes-cert-manager ServiceAccount with the appropriate Workload Identity annotation.
type GcpCloudDnsProviderInput struct {
	// GCP project ID that contains the DNS zones.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project ID that contains the DNS zones."`
	// GCP Service Account email for Workload Identity.
	//  This service account must have the dns.admin role on the specified project.
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,GCP Service Account email for Workload Identity. This service account must have the dns.admin role on the specified project."`
}

func (s *GcpCloudDnsProviderInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	return nil
}

func (s *GcpCloudDnsProviderInput) applyDefaults() {
}

func (s *GcpCloudDnsProviderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["service_account_email"] = s.ServiceAccountEmail
	return m
}

// ParseKubernetesCertManager validates and normalizes a KubernetesCertManager cloud_object.
func ParseKubernetesCertManager(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesCertManager"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesCertManagerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
