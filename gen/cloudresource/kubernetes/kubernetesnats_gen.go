// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// nats-kubernetes
type KubernetesNatsSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// server container settings (replicas, resources, disk).
	ServerContainer *KubernetesNatsServerContainerInput `json:"server_container,omitempty" jsonschema:"server container settings (replicas; resources; disk)."`
	// disable jet-stream persistence
	DisableJetStream bool `json:"disable_jet_stream,omitempty" jsonschema:"disable jet-stream persistence"`
	// authentication settings for the nats cluster.
	Auth *KubernetesNatsAuthInput `json:"auth,omitempty" jsonschema:"authentication settings for the nats cluster."`
	// tls settings for the nats cluster.
	TlsEnabled bool `json:"tls_enabled,omitempty" jsonschema:"tls settings for the nats cluster."`
	// optional ingress configuration for external access.
	Ingress *KubernetesNatsIngressInput `json:"ingress,omitempty" jsonschema:"optional ingress configuration for external access."`
	// toggle to deploy the nats-box utility pod.
	DisableNatsBox bool `json:"disable_nats_box,omitempty" jsonschema:"toggle to deploy the nats-box utility pod."`
	// NACK JetStream controller configuration (opt-in).
	//  When enabled, deploys the NACK controller alongside NATS for managing
	//  streams and consumers via Kubernetes CRDs.
	NackController *KubernetesNatsNackControllerInput `json:"nack_controller,omitempty" jsonschema:"NACK JetStream controller configuration (opt-in). When enabled; deploys the NACK controller alongside NATS for managing streams and consumers via Kubernetes CRDs."`
	// JetStream streams to create.
	//  Requires nack_controller.enabled = true.
	//  Streams are created as Kubernetes custom resources managed by NACK.
	Streams []*KubernetesNatsStreamInput `json:"streams,omitempty" jsonschema:"JetStream streams to create. Requires nack_controller.enabled = true. Streams are created as Kubernetes custom resources managed by NACK."`
	// NATS Helm chart version.
	//  To check available versions: helm search repo nats/nats --versions
	//  Chart repository: https://nats-io.github.io/k8s/
	NatsHelmChartVersion string `json:"nats_helm_chart_version,omitempty" jsonschema:"NATS Helm chart version. To check available versions: helm search repo nats/nats --versions Chart repository: https://nats-io.github.io/k8s/"`
}

func (s *KubernetesNatsSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.ServerContainer != nil {
		if err := s.ServerContainer.validate(); err != nil {
			return fmt.Errorf("server_container: %w", err)
		}
	}
	if s.Auth != nil {
		if err := s.Auth.validate(); err != nil {
			return fmt.Errorf("auth: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.NackController != nil {
		if err := s.NackController.validate(); err != nil {
			return fmt.Errorf("nack_controller: %w", err)
		}
	}
	for i, v := range s.Streams {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("streams[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesNatsSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.ServerContainer != nil {
		s.ServerContainer.applyDefaults()
	}
	if s.Auth != nil {
		s.Auth.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.NackController != nil {
		s.NackController.applyDefaults()
	}
	if s.NatsHelmChartVersion == "" {
		s.NatsHelmChartVersion = "2.12.3"
	}
}

func (s *KubernetesNatsSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.ServerContainer != nil {
		m["server_container"] = s.ServerContainer.toMap()
	}
	if s.DisableJetStream {
		m["disable_jet_stream"] = s.DisableJetStream
	}
	if s.Auth != nil {
		m["auth"] = s.Auth.toMap()
	}
	if s.TlsEnabled {
		m["tls_enabled"] = s.TlsEnabled
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.DisableNatsBox {
		m["disable_nats_box"] = s.DisableNatsBox
	}
	if s.NackController != nil {
		m["nack_controller"] = s.NackController.toMap()
	}
	if len(s.Streams) > 0 {
		items := make([]any, len(s.Streams))
		for i, v := range s.Streams {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["streams"] = items
	}
	if s.NatsHelmChartVersion != "" {
		m["nats_helm_chart_version"] = s.NatsHelmChartVersion
	}
	return m
}

// KubernetesNatsAuth holds the authentication configuration for the nats cluster.
type KubernetesNatsAuthInput struct {
	// toggle to enable authentication for the nats cluster.
	Enabled bool `json:"enabled,omitempty" jsonschema:"toggle to enable authentication for the nats cluster."`
	// authentication scheme for the nats cluster.
	Scheme string `json:"scheme,omitempty" jsonschema:"enum=bearer_token|basic_auth,authentication scheme for the nats cluster."`
	// optional no-auth user configuration.
	NoAuthUser *KubernetesNatsNoAuthUserInput `json:"no_auth_user,omitempty" jsonschema:"optional no-auth user configuration."`
}

func (s *KubernetesNatsAuthInput) validate() error {
	switch s.Scheme {
	case "", "bearer_token", "basic_auth":
	default:
		return fmt.Errorf("invalid scheme: %q", s.Scheme)
	}
	if s.NoAuthUser != nil {
		if err := s.NoAuthUser.validate(); err != nil {
			return fmt.Errorf("no_auth_user: %w", err)
		}
	}
	return nil
}

func (s *KubernetesNatsAuthInput) applyDefaults() {
	if s.NoAuthUser != nil {
		s.NoAuthUser.applyDefaults()
	}
}

func (s *KubernetesNatsAuthInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Scheme != "" {
		m["scheme"] = s.Scheme
	}
	if s.NoAuthUser != nil {
		m["no_auth_user"] = s.NoAuthUser.toMap()
	}
	return m
}

// KubernetesNatsConsumer configures a JetStream consumer.
//
//	Consumers define how messages are delivered and acknowledged from a stream.
type KubernetesNatsConsumerInput struct {
	// The durable name of the consumer.
	//  Must be unique within the stream.
	DurableName string `json:"durable_name" jsonschema:"required,The durable name of the consumer. Must be unique within the stream."`
	// Delivery policy for the consumer (all, last, or new).
	DeliverPolicy string `json:"deliver_policy,omitempty" jsonschema:"enum=all|last|new_msgs,Delivery policy for the consumer (all; last; or new)."`
	// Acknowledgment policy for the consumer (none, all, or explicit).
	AckPolicy string `json:"ack_policy,omitempty" jsonschema:"enum=none|all|explicit,Acknowledgment policy for the consumer (none; all; or explicit)."`
	// Filter subject for the consumer (supports wildcards).
	//  Only messages matching this subject will be delivered.
	FilterSubject string `json:"filter_subject,omitempty" jsonschema:"Filter subject for the consumer (supports wildcards). Only messages matching this subject will be delivered."`
	// Deliver subject for push-based consumers.
	//  If empty, creates a pull-based consumer.
	DeliverSubject string `json:"deliver_subject,omitempty" jsonschema:"Deliver subject for push-based consumers. If empty; creates a pull-based consumer."`
	// Queue group name for load balancing across multiple consumers.
	DeliverGroup string `json:"deliver_group,omitempty" jsonschema:"Queue group name for load balancing across multiple consumers."`
	// Maximum number of unacknowledged messages.
	MaxAckPending int32 `json:"max_ack_pending,omitempty" jsonschema:"Maximum number of unacknowledged messages."`
	// Maximum number of delivery attempts. -1 for unlimited.
	MaxDeliver int32 `json:"max_deliver,omitempty" jsonschema:"Maximum number of delivery attempts. -1 for unlimited."`
	// Time to wait for acknowledgment (e.g., "30s", "1m").
	AckWait string `json:"ack_wait,omitempty" jsonschema:"Time to wait for acknowledgment (e.g.; '30s'; '1m')."`
	// Replay policy for the consumer (original or instant).
	ReplayPolicy string `json:"replay_policy,omitempty" jsonschema:"enum=original|instant,Replay policy for the consumer (original or instant)."`
	// Description of the consumer.
	Description string `json:"description,omitempty" jsonschema:"Description of the consumer."`
}

func (s *KubernetesNatsConsumerInput) validate() error {
	if s.DurableName == "" {
		return fmt.Errorf("durable_name is required")
	}
	switch s.DeliverPolicy {
	case "", "all", "last", "new_msgs":
	default:
		return fmt.Errorf("invalid deliver_policy: %q", s.DeliverPolicy)
	}
	switch s.AckPolicy {
	case "", "none", "all", "explicit":
	default:
		return fmt.Errorf("invalid ack_policy: %q", s.AckPolicy)
	}
	switch s.ReplayPolicy {
	case "", "original", "instant":
	default:
		return fmt.Errorf("invalid replay_policy: %q", s.ReplayPolicy)
	}
	return nil
}

func (s *KubernetesNatsConsumerInput) applyDefaults() {
}

func (s *KubernetesNatsConsumerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["durable_name"] = s.DurableName
	if s.DeliverPolicy != "" {
		m["deliver_policy"] = s.DeliverPolicy
	}
	if s.AckPolicy != "" {
		m["ack_policy"] = s.AckPolicy
	}
	if s.FilterSubject != "" {
		m["filter_subject"] = s.FilterSubject
	}
	if s.DeliverSubject != "" {
		m["deliver_subject"] = s.DeliverSubject
	}
	if s.DeliverGroup != "" {
		m["deliver_group"] = s.DeliverGroup
	}
	if s.MaxAckPending != 0 {
		m["max_ack_pending"] = s.MaxAckPending
	}
	if s.MaxDeliver != 0 {
		m["max_deliver"] = s.MaxDeliver
	}
	if s.AckWait != "" {
		m["ack_wait"] = s.AckWait
	}
	if s.ReplayPolicy != "" {
		m["replay_policy"] = s.ReplayPolicy
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// KubernetesNatsIngress defines ingress configuration for NATS external access.
type KubernetesNatsIngressInput struct {
	// Flag to enable or disable ingress.
	//  When enabled, creates a LoadBalancer service for external access.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress. When enabled; creates a LoadBalancer service for external access."`
	// The full hostname for external access (e.g., "nats.example.com").
	//  This hostname will be configured via external-dns annotations.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'nats.example.com'). This hostname will be configured via external-dns annotations. Required when enabled is true."`
}

func (s *KubernetesNatsIngressInput) validate() error {
	return nil
}

func (s *KubernetesNatsIngressInput) applyDefaults() {
}

func (s *KubernetesNatsIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// KubernetesNatsNackController configures the NACK JetStream controller.
//
//	NACK (NATS Controllers for Kubernetes) is the official operator for managing
//	JetStream resources (Streams, Consumers, KeyValue, ObjectStore) via CRDs.
type KubernetesNatsNackControllerInput struct {
	// Enable the NACK JetStream controller.
	//  When enabled, NACK will be deployed alongside NATS and can manage
	//  Stream/Consumer resources declaratively via Kubernetes CRDs.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable the NACK JetStream controller. When enabled; NACK will be deployed alongside NATS and can manage Stream/Consumer resources declaratively via Kubernetes CRDs."`
	// Enable control-loop mode for the NACK controller.
	//  Required for KeyValue and ObjectStore support.
	//  Also provides more reliable state enforcement.
	EnableControlLoop bool `json:"enable_control_loop,omitempty" jsonschema:"Enable control-loop mode for the NACK controller. Required for KeyValue and ObjectStore support. Also provides more reliable state enforcement."`
	// NACK Helm chart version.
	//  To check available versions: helm search repo nats/nack --versions
	//  Chart repository: https://nats-io.github.io/k8s/
	HelmChartVersion string `json:"helm_chart_version,omitempty" jsonschema:"NACK Helm chart version. To check available versions: helm search repo nats/nack --versions Chart repository: https://nats-io.github.io/k8s/"`
	// NACK app version (GitHub release tag).
	//  Used for fetching CRDs from: https://github.com/nats-io/nack/releases
	//  Note: App version differs from chart version. Check "APP VERSION" column in:
	//  helm search repo nats/nack --versions
	AppVersion string `json:"app_version,omitempty" jsonschema:"NACK app version (GitHub release tag). Used for fetching CRDs from: https://github.com/nats-io/nack/releases Note: App version differs from chart version. Check 'APP VERSION' column in: helm search re..."`
}

func (s *KubernetesNatsNackControllerInput) validate() error {
	return nil
}

func (s *KubernetesNatsNackControllerInput) applyDefaults() {
	if s.HelmChartVersion == "" {
		s.HelmChartVersion = "0.31.1"
	}
	if s.AppVersion == "" {
		s.AppVersion = "0.21.1"
	}
}

func (s *KubernetesNatsNackControllerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.EnableControlLoop {
		m["enable_control_loop"] = s.EnableControlLoop
	}
	if s.HelmChartVersion != "" {
		m["helm_chart_version"] = s.HelmChartVersion
	}
	if s.AppVersion != "" {
		m["app_version"] = s.AppVersion
	}
	return m
}

// configuration for an unauthenticated ("no-auth") user.
type KubernetesNatsNoAuthUserInput struct {
	// enables the unauthenticated user when true.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enables the unauthenticated user when true."`
	// subjects on which the unauthenticated user may publish.
	//  at least one subject must be specified when enabled is true.
	PublishSubjects []string `json:"publish_subjects,omitempty" jsonschema:"subjects on which the unauthenticated user may publish. at least one subject must be specified when enabled is true."`
}

func (s *KubernetesNatsNoAuthUserInput) validate() error {
	return nil
}

func (s *KubernetesNatsNoAuthUserInput) applyDefaults() {
}

func (s *KubernetesNatsNoAuthUserInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if len(s.PublishSubjects) > 0 {
		m["publish_subjects"] = s.PublishSubjects
	}
	return m
}

// server container settings for the nats stateful-set.
type KubernetesNatsServerContainerInput struct {
	// number of nats replicas; use an odd value for quorum.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"number of nats replicas; use an odd value for quorum."`
	// cpu and memory resources for each pod.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"cpu and memory resources for each pod."`
	// pvc size for jet-stream file store (e.g. "10Gi").
	DiskSize string `json:"disk_size" jsonschema:"required,pvc size for jet-stream file store (e.g. '10Gi')."`
}

func (s *KubernetesNatsServerContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	if s.DiskSize == "" {
		return fmt.Errorf("disk_size is required")
	}
	return nil
}

func (s *KubernetesNatsServerContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesNatsServerContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	m["disk_size"] = s.DiskSize
	return m
}

// KubernetesNatsStream configures a JetStream stream.
//
//	Streams are the core storage layer in JetStream, capturing and storing messages
//	published to specific subjects.
type KubernetesNatsStreamInput struct {
	// A unique name for the stream.
	//  Must be between 1-255 characters, alphanumeric with allowed: - _ .
	Name string `json:"name" jsonschema:"required,A unique name for the stream. Must be between 1-255 characters; alphanumeric with allowed: - _ ."`
	// List of subjects to consume, supports wildcards (e.g., "orders.*", "events.>").
	Subjects []string `json:"subjects,omitempty" jsonschema:"List of subjects to consume; supports wildcards (e.g.; 'orders.*'; 'events.>')."`
	// Storage backend for the stream (file or memory).
	Storage string `json:"storage,omitempty" jsonschema:"enum=file|memory,Storage backend for the stream (file or memory)."`
	// Number of replicas for the stream (odd number recommended for quorum).
	Replicas int32 `json:"replicas,omitempty" jsonschema:"Number of replicas for the stream (odd number recommended for quorum)."`
	// Retention policy for the stream (limits, interest, or workqueue).
	Retention string `json:"retention,omitempty" jsonschema:"enum=limits|interest|workqueue,Retention policy for the stream (limits; interest; or workqueue)."`
	// Maximum age of messages in the stream (e.g., "24h", "7d").
	//  Empty string means unlimited.
	MaxAge string `json:"max_age,omitempty" jsonschema:"Maximum age of messages in the stream (e.g.; '24h'; '7d'). Empty string means unlimited."`
	// Maximum size of the stream in bytes. -1 for unlimited.
	MaxBytes int64 `json:"max_bytes,omitempty" jsonschema:"Maximum size of the stream in bytes. -1 for unlimited."`
	// Maximum number of messages in the stream. -1 for unlimited.
	MaxMsgs int64 `json:"max_msgs,omitempty" jsonschema:"Maximum number of messages in the stream. -1 for unlimited."`
	// Maximum message size in bytes. -1 for unlimited.
	MaxMsgSize int32 `json:"max_msg_size,omitempty" jsonschema:"Maximum message size in bytes. -1 for unlimited."`
	// Maximum number of consumers allowed. -1 for unlimited.
	MaxConsumers int32 `json:"max_consumers,omitempty" jsonschema:"Maximum number of consumers allowed. -1 for unlimited."`
	// Discard policy when limits are reached (old or new).
	Discard string `json:"discard,omitempty" jsonschema:"enum=old|new_msgs,Discard policy when limits are reached (old or new)."`
	// Description of the stream.
	Description string `json:"description,omitempty" jsonschema:"Description of the stream."`
	// Consumers for this stream.
	Consumers []*KubernetesNatsConsumerInput `json:"consumers,omitempty" jsonschema:"Consumers for this stream."`
}

func (s *KubernetesNatsStreamInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.Subjects) < 1 {
		return fmt.Errorf("subjects requires at least 1 items, got %d", len(s.Subjects))
	}
	switch s.Storage {
	case "", "file", "memory":
	default:
		return fmt.Errorf("invalid storage: %q", s.Storage)
	}
	switch s.Retention {
	case "", "limits", "interest", "workqueue":
	default:
		return fmt.Errorf("invalid retention: %q", s.Retention)
	}
	switch s.Discard {
	case "", "old", "new_msgs":
	default:
		return fmt.Errorf("invalid discard: %q", s.Discard)
	}
	for i, v := range s.Consumers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("consumers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesNatsStreamInput) applyDefaults() {
}

func (s *KubernetesNatsStreamInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if len(s.Subjects) > 0 {
		m["subjects"] = s.Subjects
	}
	if s.Storage != "" {
		m["storage"] = s.Storage
	}
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Retention != "" {
		m["retention"] = s.Retention
	}
	if s.MaxAge != "" {
		m["max_age"] = s.MaxAge
	}
	if s.MaxBytes != 0 {
		m["max_bytes"] = s.MaxBytes
	}
	if s.MaxMsgs != 0 {
		m["max_msgs"] = s.MaxMsgs
	}
	if s.MaxMsgSize != 0 {
		m["max_msg_size"] = s.MaxMsgSize
	}
	if s.MaxConsumers != 0 {
		m["max_consumers"] = s.MaxConsumers
	}
	if s.Discard != "" {
		m["discard"] = s.Discard
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Consumers) > 0 {
		items := make([]any, len(s.Consumers))
		for i, v := range s.Consumers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["consumers"] = items
	}
	return m
}

// ParseKubernetesNats validates and normalizes a KubernetesNats cloud_object.
func ParseKubernetesNats(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesNats"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesNatsSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
