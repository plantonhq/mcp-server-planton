// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// temporal-kubernetes
type KubernetesTemporalSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// database configuration
	Database *KubernetesTemporalDatabaseConfigInput `json:"database" jsonschema:"required,database configuration"`
	// disables temporal web ui
	DisableWebUi bool `json:"disable_web_ui,omitempty" jsonschema:"disables temporal web ui"`
	// enables embedded elasticsearch for temporal
	//  this is ignored if external elasticsearch is set
	EnableEmbeddedElasticsearch bool `json:"enable_embedded_elasticsearch,omitempty" jsonschema:"enables embedded elasticsearch for temporal this is ignored if external elasticsearch is set"`
	// enables monitoring stack for temporal
	//  enabling this will deploy prometheus and grafana
	EnableMonitoringStack bool `json:"enable_monitoring_stack,omitempty" jsonschema:"enables monitoring stack for temporal enabling this will deploy prometheus and grafana"`
	// number of cassandra nodes to be deployed
	// this is only honored when the backend is cassandra, and no external database is provided.
	CassandraReplicas int32 `json:"cassandra_replicas,omitempty" jsonschema:"number of cassandra nodes to be deployed this is only honored when the backend is cassandra; and no external database is provided."`
	// The ingress configuration for the temporal deployment.
	// if enabled, the frontend will be exposed using a load-balancer
	//  and also if web ui is enabled it will be exposed using the kubernetes ingress controller.
	Ingress *KubernetesTemporalIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the temporal deployment. if enabled; the frontend will be exposed using a load-balancer and also if web ui is enabled it will be exposed using the kubernetes ingress cont..."`
	// external elasticsearch configuration to be used by temporal for configuring observability.
	ExternalElasticsearch *KubernetesTemporalExternalElasticsearchInput `json:"external_elasticsearch,omitempty" jsonschema:"external elasticsearch configuration to be used by temporal for configuring observability."`
	// version of the Temporal Helm chart to deploy (e.g., "0.62.0")
	//  if not specified, the default version configured in the Pulumi module will be used
	Version string `json:"version,omitempty" jsonschema:"version of the Temporal Helm chart to deploy (e.g.; '0.62.0') if not specified; the default version configured in the Pulumi module will be used"`
	// Dynamic configuration values for Temporal server runtime behavior.
	//  These settings control workflow execution limits and can be adjusted without server restart.
	DynamicConfig *KubernetesTemporalDynamicConfigInput `json:"dynamic_config,omitempty" jsonschema:"Dynamic configuration values for Temporal server runtime behavior. These settings control workflow execution limits and can be adjusted without server restart."`
	// *
	//  Number of history shards for the Temporal cluster.
	//  This is an IMMUTABLE setting that must be decided at cluster creation time.
	//  Higher values enable better parallelism and throughput but require more resources.
	//  Default: 512 (safe for most production workloads).
	//  WARNING: Cannot be changed after...
	NumHistoryShards int32 `json:"num_history_shards,omitempty" jsonschema:"* Number of history shards for the Temporal cluster. This is an IMMUTABLE setting that must be decided at cluster creation time. Higher values enable better parallelism and throughput but require more..."`
	// Per-service replica and resource configuration for Temporal services.
	//  Allows fine-tuning resources for frontend, history, matching, and worker services.
	Services *KubernetesTemporalServicesInput `json:"services,omitempty" jsonschema:"Per-service replica and resource configuration for Temporal services. Allows fine-tuning resources for frontend; history; matching; and worker services."`
}

func (s *KubernetesTemporalSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Database == nil {
		return fmt.Errorf("database is required")
	}
	if s.Database != nil {
		if err := s.Database.validate(); err != nil {
			return fmt.Errorf("database: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.ExternalElasticsearch != nil {
		if err := s.ExternalElasticsearch.validate(); err != nil {
			return fmt.Errorf("external_elasticsearch: %w", err)
		}
	}
	if s.DynamicConfig != nil {
		if err := s.DynamicConfig.validate(); err != nil {
			return fmt.Errorf("dynamic_config: %w", err)
		}
	}
	if s.Services != nil {
		if err := s.Services.validate(); err != nil {
			return fmt.Errorf("services: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Database != nil {
		s.Database.applyDefaults()
	}
	if s.CassandraReplicas == 0 {
		s.CassandraReplicas = 1
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.ExternalElasticsearch != nil {
		s.ExternalElasticsearch.applyDefaults()
	}
	if s.DynamicConfig != nil {
		s.DynamicConfig.applyDefaults()
	}
	if s.Services != nil {
		s.Services.applyDefaults()
	}
}

func (s *KubernetesTemporalSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Database != nil {
		m["database"] = s.Database.toMap()
	}
	if s.DisableWebUi {
		m["disable_web_ui"] = s.DisableWebUi
	}
	if s.EnableEmbeddedElasticsearch {
		m["enable_embedded_elasticsearch"] = s.EnableEmbeddedElasticsearch
	}
	if s.EnableMonitoringStack {
		m["enable_monitoring_stack"] = s.EnableMonitoringStack
	}
	if s.CassandraReplicas != 0 {
		m["cassandra_replicas"] = s.CassandraReplicas
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.ExternalElasticsearch != nil {
		m["external_elasticsearch"] = s.ExternalElasticsearch.toMap()
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.DynamicConfig != nil {
		m["dynamic_config"] = s.DynamicConfig.toMap()
	}
	if s.NumHistoryShards != 0 {
		m["num_history_shards"] = s.NumHistoryShards
	}
	if s.Services != nil {
		m["services"] = s.Services.toMap()
	}
	return m
}

// groups database configuration settings.
type KubernetesTemporalDatabaseConfigInput struct {
	// selected database backend
	Backend string `json:"backend" jsonschema:"required,enum=cassandra|postgresql|mysql,selected database backend"`
	// external database configuration, if this is not set, in-cluster cassandra would be created
	ExternalDatabase *KubernetesTemporalExternalDatabaseInput `json:"external_database,omitempty" jsonschema:"external database configuration; if this is not set; in-cluster cassandra would be created"`
	// primary database or keyspace name
	DatabaseName string `json:"database_name,omitempty" jsonschema:"primary database or keyspace name"`
	// visibility database or keyspace name
	VisibilityName string `json:"visibility_name,omitempty" jsonschema:"visibility database or keyspace name"`
	// disables automatic schema creation
	DisableAutoSchemaSetup bool `json:"disable_auto_schema_setup,omitempty" jsonschema:"disables automatic schema creation"`
}

func (s *KubernetesTemporalDatabaseConfigInput) validate() error {
	if s.Backend == "" {
		return fmt.Errorf("backend is required")
	}
	switch s.Backend {
	case "cassandra", "postgresql", "mysql":
	default:
		return fmt.Errorf("invalid backend: %q", s.Backend)
	}
	if s.ExternalDatabase != nil {
		if err := s.ExternalDatabase.validate(); err != nil {
			return fmt.Errorf("external_database: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalDatabaseConfigInput) applyDefaults() {
	if s.ExternalDatabase != nil {
		s.ExternalDatabase.applyDefaults()
	}
	if s.DatabaseName == "" {
		s.DatabaseName = "temporal"
	}
	if s.VisibilityName == "" {
		s.VisibilityName = "temporal_visibility"
	}
}

func (s *KubernetesTemporalDatabaseConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["backend"] = s.Backend
	if s.ExternalDatabase != nil {
		m["external_database"] = s.ExternalDatabase.toMap()
	}
	if s.DatabaseName != "" {
		m["database_name"] = s.DatabaseName
	}
	if s.VisibilityName != "" {
		m["visibility_name"] = s.VisibilityName
	}
	if s.DisableAutoSchemaSetup {
		m["disable_auto_schema_setup"] = s.DisableAutoSchemaSetup
	}
	return m
}

// *
//
//	Dynamic configuration values for Temporal server runtime behavior.
//	These settings control workflow execution limits without requiring server restart.
//	When not specified, Temporal uses its default values.
//
//	Two types of limits:
//	- **History limits**: Control total workflow history size and event count
//	- **Blob limits**: Control individual payload sizes (markers, signals, activity I/O)
//
//	Example:
//	```yaml
//	dynamic_config:
//	  history_size_limit_error: 104857600  # 100 MB total history
//	  history_count_limit_error: 102400    # 100K events
//	  blob_size_limit_error: 10485760      # 10 MB per payload (for large IaC diffs)
//	  blob_size_limit_warn: 5242880        # 5 MB warning threshold
//	```
type KubernetesTemporalDynamicConfigInput struct {
	// *
	//  Maximum size in bytes for workflow execution history.
	//  When a workflow exceeds this limit, Temporal terminates it with reason "Workflow history size exceeds limit."
	//  Default: 52428800 (50 MB). Increase for workflows with large payloads.
	HistorySizeLimitError int64 `json:"history_size_limit_error,omitempty" jsonschema:"* Maximum size in bytes for workflow execution history. When a workflow exceeds this limit; Temporal terminates it with reason 'Workflow history size exceeds limit.' Default: 52428800 (50 MB). Increas..."`
	// *
	//  Maximum number of events in workflow execution history.
	//  When a workflow exceeds this limit, Temporal terminates it with reason "Workflow history size exceeds limit."
	//  Default: 51200 events. Increase for workflows with many activities/signals.
	//  Consider using ContinueAsNew pattern as an alternati...
	HistoryCountLimitError int64 `json:"history_count_limit_error,omitempty" jsonschema:"* Maximum number of events in workflow execution history. When a workflow exceeds this limit; Temporal terminates it with reason 'Workflow history size exceeds limit.' Default: 51200 events. Increase ..."`
	// *
	//  Warning threshold for history size in bytes.
	//  Temporal logs warnings when workflows approach this limit.
	//  Default: 10485760 (10 MB, ~20% of error limit).
	HistorySizeLimitWarn int64 `json:"history_size_limit_warn,omitempty" jsonschema:"* Warning threshold for history size in bytes. Temporal logs warnings when workflows approach this limit. Default: 10485760 (10 MB; ~20% of error limit)."`
	// *
	//  Warning threshold for history event count.
	//  Temporal logs warnings when workflows approach this limit.
	//  Default: 10240 (~20% of error limit).
	HistoryCountLimitWarn int64 `json:"history_count_limit_warn,omitempty" jsonschema:"* Warning threshold for history event count. Temporal logs warnings when workflows approach this limit. Default: 10240 (~20% of error limit)."`
	// *
	//  Maximum size in bytes for a single blob/payload (marker details, signal data, activity I/O).
	//  When a payload exceeds this limit, Temporal rejects it with "exceeds size limit" error.
	//  This is different from history_size_limit which controls total workflow history size.
	//  Default: 2097152 (2 MB). In...
	BlobSizeLimitError int64 `json:"blob_size_limit_error,omitempty" jsonschema:"* Maximum size in bytes for a single blob/payload (marker details; signal data; activity I/O). When a payload exceeds this limit; Temporal rejects it with 'exceeds size limit' error. This is different..."`
	// *
	//  Warning threshold for blob/payload size in bytes.
	//  Temporal logs warnings when payloads approach this limit.
	//  Default: 524288 (512 KB, ~25% of error limit).
	BlobSizeLimitWarn int64 `json:"blob_size_limit_warn,omitempty" jsonschema:"* Warning threshold for blob/payload size in bytes. Temporal logs warnings when payloads approach this limit. Default: 524288 (512 KB; ~25% of error limit)."`
}

func (s *KubernetesTemporalDynamicConfigInput) validate() error {
	return nil
}

func (s *KubernetesTemporalDynamicConfigInput) applyDefaults() {
}

func (s *KubernetesTemporalDynamicConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HistorySizeLimitError != 0 {
		m["history_size_limit_error"] = s.HistorySizeLimitError
	}
	if s.HistoryCountLimitError != 0 {
		m["history_count_limit_error"] = s.HistoryCountLimitError
	}
	if s.HistorySizeLimitWarn != 0 {
		m["history_size_limit_warn"] = s.HistorySizeLimitWarn
	}
	if s.HistoryCountLimitWarn != 0 {
		m["history_count_limit_warn"] = s.HistoryCountLimitWarn
	}
	if s.BlobSizeLimitError != 0 {
		m["blob_size_limit_error"] = s.BlobSizeLimitError
	}
	if s.BlobSizeLimitWarn != 0 {
		m["blob_size_limit_warn"] = s.BlobSizeLimitWarn
	}
	return m
}

// describes an external database that temporal can use
type KubernetesTemporalExternalDatabaseInput struct {
	// hostname for external database
	Host string `json:"host,omitempty" jsonschema:"hostname for external database"`
	// port for external database
	Port int32 `json:"port,omitempty" jsonschema:"port for external database"`
	// username for database
	Username string `json:"username,omitempty" jsonschema:"username for database"`
	// *
	//  The password for authenticating to the database.
	//  Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret.
	//
	//  Using a secret reference is recommended for production deployments:
	//  ```yaml
	//  password:
	//    secretRef:
	//      name: db-credentials
	//      key: password...
	Password *KubernetesSensitiveValueInput `json:"password,omitempty" jsonschema:"* The password for authenticating to the database. Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret. Using a secret reference is recommended for produc..."`
}

func (s *KubernetesTemporalExternalDatabaseInput) validate() error {
	if s.Password != nil {
		if err := s.Password.validate(); err != nil {
			return fmt.Errorf("password: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalExternalDatabaseInput) applyDefaults() {
	if s.Password != nil {
		s.Password.applyDefaults()
	}
}

func (s *KubernetesTemporalExternalDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Host != "" {
		m["host"] = s.Host
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != nil {
		m["password"] = s.Password.toMap()
	}
	return m
}

// describes an external elasticsearch cluster that temporal can use
//
//	for advanced visibility instead of deploying an in-cluster es chart.
type KubernetesTemporalExternalElasticsearchInput struct {
	// the host address of the existing elasticsearch cluster
	Host string `json:"host,omitempty" jsonschema:"the host address of the existing elasticsearch cluster"`
	// the port for the existing elasticsearch cluster
	Port int32 `json:"port,omitempty" jsonschema:"the port for the existing elasticsearch cluster"`
	// optional username, if the external cluster requires auth
	User string `json:"user,omitempty" jsonschema:"optional username; if the external cluster requires auth"`
	// *
	//  Optional password for authenticating to the external Elasticsearch cluster.
	//  Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret.
	//
	//  Using a secret reference is recommended for production deployments:
	//  ```yaml
	//  password:
	//    secretRef:
	//      name: es-cre...
	Password *KubernetesSensitiveValueInput `json:"password,omitempty" jsonschema:"* Optional password for authenticating to the external Elasticsearch cluster. Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret. Using a secret referenc..."`
}

func (s *KubernetesTemporalExternalElasticsearchInput) validate() error {
	if s.Password != nil {
		if err := s.Password.validate(); err != nil {
			return fmt.Errorf("password: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalExternalElasticsearchInput) applyDefaults() {
	if s.Password != nil {
		s.Password.applyDefaults()
	}
}

func (s *KubernetesTemporalExternalElasticsearchInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Host != "" {
		m["host"] = s.Host
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.User != "" {
		m["user"] = s.User
	}
	if s.Password != nil {
		m["password"] = s.Password.toMap()
	}
	return m
}

// frontend ingress endpoint configuration supporting both gRPC and HTTP protocols
type KubernetesTemporalFrontendIngressEndpointInput struct {
	// flag to enable or disable frontend ingress
	Enabled bool `json:"enabled,omitempty" jsonschema:"flag to enable or disable frontend ingress"`
	// the full hostname for gRPC access via LoadBalancer (e.g., "temporal-frontend-grpc.example.com")
	//  required when enabled is true
	GrpcHostname string `json:"grpc_hostname,omitempty" jsonschema:"the full hostname for gRPC access via LoadBalancer (e.g.; 'temporal-frontend-grpc.example.com') required when enabled is true"`
	// the full hostname for HTTP access via Gateway API (e.g., "temporal-frontend-http.example.com")
	//  optional - only creates Gateway/HTTPRoute resources if provided
	HttpHostname string `json:"http_hostname,omitempty" jsonschema:"the full hostname for HTTP access via Gateway API (e.g.; 'temporal-frontend-http.example.com') optional - only creates Gateway/HTTPRoute resources if provided"`
}

func (s *KubernetesTemporalFrontendIngressEndpointInput) validate() error {
	return nil
}

func (s *KubernetesTemporalFrontendIngressEndpointInput) applyDefaults() {
}

func (s *KubernetesTemporalFrontendIngressEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.GrpcHostname != "" {
		m["grpc_hostname"] = s.GrpcHostname
	}
	if s.HttpHostname != "" {
		m["http_hostname"] = s.HttpHostname
	}
	return m
}

// ingress configuration for temporal deployment with separate frontend and web ui endpoints
type KubernetesTemporalIngressInput struct {
	// frontend (gRPC + HTTP) ingress configuration
	Frontend *KubernetesTemporalFrontendIngressEndpointInput `json:"frontend,omitempty" jsonschema:"frontend (gRPC + HTTP) ingress configuration"`
	// web ui ingress configuration
	WebUi *KubernetesTemporalWebUiIngressEndpointInput `json:"web_ui,omitempty" jsonschema:"web ui ingress configuration"`
}

func (s *KubernetesTemporalIngressInput) validate() error {
	if s.Frontend != nil {
		if err := s.Frontend.validate(); err != nil {
			return fmt.Errorf("frontend: %w", err)
		}
	}
	if s.WebUi != nil {
		if err := s.WebUi.validate(); err != nil {
			return fmt.Errorf("web_ui: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalIngressInput) applyDefaults() {
	if s.Frontend != nil {
		s.Frontend.applyDefaults()
	}
	if s.WebUi != nil {
		s.WebUi.applyDefaults()
	}
}

func (s *KubernetesTemporalIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Frontend != nil {
		m["frontend"] = s.Frontend.toMap()
	}
	if s.WebUi != nil {
		m["web_ui"] = s.WebUi.toMap()
	}
	return m
}

// *
//
//	Per-service replica and resource configuration for a Temporal service.
//	Allows configuring replicas and CPU/memory resources independently for each service.
//
//	Example:
//	```yaml
//	replicas: 3
//	resources:
//	  limits:
//	    cpu: "2000m"
//	    memory: "4Gi"
//	  requests:
//	    cpu: "500m"
//	    memory: "1Gi"
//	```
type KubernetesTemporalServiceConfigInput struct {
	// *
	//  Number of replicas for this service.
	//  Higher replica counts provide better availability and throughput.
	//  Default: 1 for development, recommend 3+ for production.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"* Number of replicas for this service. Higher replica counts provide better availability and throughput. Default: 1 for development; recommend 3+ for production."`
	// *
	//  Container resources (CPU and memory) for this service.
	//  Resource requirements vary by service type:
	//  - history: Most resource-intensive, handles workflow state
	//  - matching: Task dispatch, moderate resources
	//  - frontend: API gateway, moderate resources
	//  - worker: Internal workflows, light resource...
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"* Container resources (CPU and memory) for this service. Resource requirements vary by service type: - history: Most resource-intensive; handles workflow state - matching: Task dispatch; moderate reso..."`
}

func (s *KubernetesTemporalServiceConfigInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalServiceConfigInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesTemporalServiceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	return m
}

// *
//
//	Service-level configuration for all Temporal services.
//	Allows fine-tuning replica counts and resources for each Temporal service independently.
//
//	Temporal consists of four core services:
//	- **frontend**: API gateway for client requests (gRPC/HTTP)
//	- **history**: Manages workflow state and execution (most resource-intensive)
//	- **matching**: Task queue management and worker dispatch
//	- **worker**: Runs internal Temporal system workflows
//
//	Example:
//	```yaml
//	services:
//	  frontend:
//	    replicas: 2
//	    resources:
//	      requests:
//	        cpu: "200m"
//	        memory: "512Mi"
//	  history:
//	    replicas: 3
//	    resources:
//	      requests:
//	        cpu: "500m"
//	        memory: "1Gi"
//	      limits:
//	        cpu: "2000m"
//	        memory: "4Gi"
//	```
type KubernetesTemporalServicesInput struct {
	// Frontend service configuration (API gateway for gRPC/HTTP requests)
	Frontend *KubernetesTemporalServiceConfigInput `json:"frontend,omitempty" jsonschema:"Frontend service configuration (API gateway for gRPC/HTTP requests)"`
	// History service configuration (manages workflow state, most resource-intensive)
	History *KubernetesTemporalServiceConfigInput `json:"history,omitempty" jsonschema:"History service configuration (manages workflow state; most resource-intensive)"`
	// Matching service configuration (task queue management and dispatch)
	Matching *KubernetesTemporalServiceConfigInput `json:"matching,omitempty" jsonschema:"Matching service configuration (task queue management and dispatch)"`
	// Worker service configuration (internal Temporal system workflows)
	Worker *KubernetesTemporalServiceConfigInput `json:"worker,omitempty" jsonschema:"Worker service configuration (internal Temporal system workflows)"`
}

func (s *KubernetesTemporalServicesInput) validate() error {
	if s.Frontend != nil {
		if err := s.Frontend.validate(); err != nil {
			return fmt.Errorf("frontend: %w", err)
		}
	}
	if s.History != nil {
		if err := s.History.validate(); err != nil {
			return fmt.Errorf("history: %w", err)
		}
	}
	if s.Matching != nil {
		if err := s.Matching.validate(); err != nil {
			return fmt.Errorf("matching: %w", err)
		}
	}
	if s.Worker != nil {
		if err := s.Worker.validate(); err != nil {
			return fmt.Errorf("worker: %w", err)
		}
	}
	return nil
}

func (s *KubernetesTemporalServicesInput) applyDefaults() {
	if s.Frontend != nil {
		s.Frontend.applyDefaults()
	}
	if s.History != nil {
		s.History.applyDefaults()
	}
	if s.Matching != nil {
		s.Matching.applyDefaults()
	}
	if s.Worker != nil {
		s.Worker.applyDefaults()
	}
}

func (s *KubernetesTemporalServicesInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Frontend != nil {
		m["frontend"] = s.Frontend.toMap()
	}
	if s.History != nil {
		m["history"] = s.History.toMap()
	}
	if s.Matching != nil {
		m["matching"] = s.Matching.toMap()
	}
	if s.Worker != nil {
		m["worker"] = s.Worker.toMap()
	}
	return m
}

// web ui ingress endpoint configuration for HTTP-only access
type KubernetesTemporalWebUiIngressEndpointInput struct {
	// flag to enable or disable web ui ingress
	Enabled bool `json:"enabled,omitempty" jsonschema:"flag to enable or disable web ui ingress"`
	// the full hostname for HTTP access via Gateway API (e.g., "temporal-ui.example.com")
	//  required when enabled is true
	Hostname string `json:"hostname,omitempty" jsonschema:"the full hostname for HTTP access via Gateway API (e.g.; 'temporal-ui.example.com') required when enabled is true"`
}

func (s *KubernetesTemporalWebUiIngressEndpointInput) validate() error {
	return nil
}

func (s *KubernetesTemporalWebUiIngressEndpointInput) applyDefaults() {
}

func (s *KubernetesTemporalWebUiIngressEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// ParseKubernetesTemporal validates and normalizes a KubernetesTemporal cloud_object.
func ParseKubernetesTemporal(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesTemporal"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesTemporalSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
