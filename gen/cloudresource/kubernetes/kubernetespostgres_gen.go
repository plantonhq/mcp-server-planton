// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// postgres-kubernetes
type KubernetesPostgresSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The container specifications for the PostgreSQL deployment.
	Container *KubernetesPostgresContainerInput `json:"container,omitempty" jsonschema:"The container specifications for the PostgreSQL deployment."`
	// The ingress configuration for the PostgreSQL deployment.
	Ingress *KubernetesPostgresIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the PostgreSQL deployment."`
	// Optional: Per-database backup configuration
	//  When specified, these settings override the operator-level backup configuration
	//  If not specified, the database inherits operator-level backup settings
	BackupConfig *KubernetesPostgresBackupConfigInput `json:"backup_config,omitempty" jsonschema:"Optional: Per-database backup configuration When specified; these settings override the operator-level backup configuration If not specified; the database inherits operator-level backup settings"`
	// List of databases to create.
	//  The operator will create these databases during cluster initialization.
	//  If not specified, only the default "postgres" database will be available.
	//  Note: Owner roles must be declared in the 'users' field before being referenced here.
	//  Example:
	//    databases:
	//      - name:...
	Databases []*KubernetesPostgresDatabaseInput `json:"databases,omitempty" jsonschema:"List of databases to create. The operator will create these databases during cluster initialization. If not specified; only the default 'postgres' database will be available. Note: Owner roles must be..."`
	// List of PostgreSQL users/roles to create.
	//  Users must be declared here before being used as database owners in the 'databases' field.
	//  The operator creates these users during cluster initialization.
	Users []*KubernetesPostgresUserInput `json:"users,omitempty" jsonschema:"List of PostgreSQL users/roles to create. Users must be declared here before being used as database owners in the 'databases' field. The operator creates these users during cluster initialization."`
}

func (s *KubernetesPostgresSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.BackupConfig != nil {
		if err := s.BackupConfig.validate(); err != nil {
			return fmt.Errorf("backup_config: %w", err)
		}
	}
	for i, v := range s.Databases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("databases[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Users {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("users[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *KubernetesPostgresSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.BackupConfig != nil {
		s.BackupConfig.applyDefaults()
	}
}

func (s *KubernetesPostgresSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.BackupConfig != nil {
		m["backup_config"] = s.BackupConfig.toMap()
	}
	if len(s.Databases) > 0 {
		items := make([]any, len(s.Databases))
		for i, v := range s.Databases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["databases"] = items
	}
	if len(s.Users) > 0 {
		items := make([]any, len(s.Users))
		for i, v := range s.Users {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["users"] = items
	}
	return m
}

// Manager-agnostic backup configuration for a PostgreSQL database.
//
//	This configuration allows per-database backup overrides independent of the operator implementation.
//	When specified, these settings override operator-level backup configuration.
type KubernetesPostgresBackupConfigInput struct {
	// Optional: Custom S3/R2 prefix path for this database's backups
	//  If not specified, uses operator-level default or standard naming
	//  Example: "backups/my-app/production/postgres/$(PGVERSION)"
	//  Note: $(PGVERSION) will be replaced by the Postgres version
	S3Prefix string `json:"s3_prefix,omitempty" jsonschema:"Optional: Custom S3/R2 prefix path for this database's backups If not specified; uses operator-level default or standard naming Example: 'backups/my-app/production/postgres/$(PGVERSION)' Note: $(PGVER..."`
	// Optional: Custom backup schedule in cron format
	//  If not specified, uses operator-level schedule
	//  Example: "0 3 * * *" for 3 AM daily backups
	BackupSchedule string `json:"backup_schedule,omitempty" jsonschema:"Optional: Custom backup schedule in cron format If not specified; uses operator-level schedule Example: '0 3 * * *' for 3 AM daily backups"`
	// Optional: Enable or disable backups for this specific database
	//  If true, backups are explicitly enabled (overrides operator setting)
	//  If false, backups are explicitly disabled for this database
	//  If not specified, uses operator-level setting
	EnableBackup bool `json:"enable_backup,omitempty" jsonschema:"Optional: Enable or disable backups for this specific database If true; backups are explicitly enabled (overrides operator setting) If false; backups are explicitly disabled for this database If not s..."`
	// Disaster recovery restore configuration
	//  When set, enables cross-cluster database restoration from backup files
	Restore *KubernetesPostgresRestoreConfigInput `json:"restore,omitempty" jsonschema:"Disaster recovery restore configuration When set; enables cross-cluster database restoration from backup files"`
}

func (s *KubernetesPostgresBackupConfigInput) validate() error {
	if s.Restore != nil {
		if err := s.Restore.validate(); err != nil {
			return fmt.Errorf("restore: %w", err)
		}
	}
	return nil
}

func (s *KubernetesPostgresBackupConfigInput) applyDefaults() {
	if s.Restore != nil {
		s.Restore.applyDefaults()
	}
}

func (s *KubernetesPostgresBackupConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.S3Prefix != "" {
		m["s3_prefix"] = s.S3Prefix
	}
	if s.BackupSchedule != "" {
		m["backup_schedule"] = s.BackupSchedule
	}
	if s.EnableBackup {
		m["enable_backup"] = s.EnableBackup
	}
	if s.Restore != nil {
		m["restore"] = s.Restore.toMap()
	}
	return m
}

// *
//
//	**KubernetesPostgresContainer** specifies the container configuration for the PostgreSQL application.
//	It includes resource allocations for CPU and memory, the number of replicas, and disk size for data persistence.
//	Proper configuration ensures optimal performance and data reliability for your PostgreSQL deployment.
type KubernetesPostgresContainerInput struct {
	// The number of replicas of PostgreSQL pods.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"The number of replicas of PostgreSQL pods."`
	// The CPU and memory resources allocated to the PostgreSQL container.
	Resources *ContainerResourcesInput `json:"resources,omitempty" jsonschema:"The CPU and memory resources allocated to the PostgreSQL container."`
	// *
	//  The storage size to allocate for each PostgreSQL instance (e.g., "1Gi").
	//  A default value is set if the client does not provide a value.
	DiskSize string `json:"disk_size,omitempty" jsonschema:"* The storage size to allocate for each PostgreSQL instance (e.g.; '1Gi'). A default value is set if the client does not provide a value."`
}

func (s *KubernetesPostgresContainerInput) validate() error {
	if s.Resources != nil {
		if err := s.Resources.validate(); err != nil {
			return fmt.Errorf("resources: %w", err)
		}
	}
	return nil
}

func (s *KubernetesPostgresContainerInput) applyDefaults() {
	if s.Resources != nil {
		s.Resources.applyDefaults()
	}
}

func (s *KubernetesPostgresContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	if s.Resources != nil {
		m["resources"] = s.Resources.toMap()
	}
	if s.DiskSize != "" {
		m["disk_size"] = s.DiskSize
	}
	return m
}

// PostgreSQL database definition
type KubernetesPostgresDatabaseInput struct {
	// Database name (e.g., "app_database", "analytics_db")
	//  The operator will create this database during cluster initialization.
	Name string `json:"name" jsonschema:"required,Database name (e.g.; 'app_database'; 'analytics_db') The operator will create this database during cluster initialization."`
	// Owner role name (e.g., "app_user", "analytics_role")
	//  This role must be declared in the 'users' field before being referenced here.
	//  If not specified, the database will be owned by the default postgres user.
	OwnerRole string `json:"owner_role,omitempty" jsonschema:"Owner role name (e.g.; 'app_user'; 'analytics_role') This role must be declared in the 'users' field before being referenced here. If not specified; the database will be owned by the default postgres ..."`
}

func (s *KubernetesPostgresDatabaseInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *KubernetesPostgresDatabaseInput) applyDefaults() {
}

func (s *KubernetesPostgresDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.OwnerRole != "" {
		m["owner_role"] = s.OwnerRole
	}
	return m
}

// *
//
//	**KubernetesPostgresIngress** defines the ingress configuration for PostgreSQL.
//	It allows enabling external access via LoadBalancer with hostname-based routing.
type KubernetesPostgresIngressInput struct {
	// Flag to enable or disable ingress.
	//  When enabled, creates a LoadBalancer service with external-dns annotations.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress. When enabled; creates a LoadBalancer service with external-dns annotations."`
	// The full hostname for external access (e.g., "postgres.example.com").
	//  This hostname will be configured automatically via external-dns.
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'postgres.example.com'). This hostname will be configured automatically via external-dns. Required when enabled is true."`
}

func (s *KubernetesPostgresIngressInput) validate() error {
	return nil
}

func (s *KubernetesPostgresIngressInput) applyDefaults() {
}

func (s *KubernetesPostgresIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// R2/S3-compatible storage credentials for restore operations
type KubernetesPostgresR2ConfigInput struct {
	// Cloudflare account ID for R2 endpoint construction
	//  Used to build: https://<account_id>.r2.cloudflarestorage.com
	CloudflareAccountId string `json:"cloudflare_account_id" jsonschema:"required,Cloudflare account ID for R2 endpoint construction Used to build: https://<account_id>.r2.cloudflarestorage.com"`
	// R2 Access Key ID
	AccessKeyId string `json:"access_key_id" jsonschema:"required,R2 Access Key ID"`
	// R2 Secret Access Key
	SecretAccessKey string `json:"secret_access_key" jsonschema:"required,R2 Secret Access Key"`
}

func (s *KubernetesPostgresR2ConfigInput) validate() error {
	if s.CloudflareAccountId == "" {
		return fmt.Errorf("cloudflare_account_id is required")
	}
	if s.AccessKeyId == "" {
		return fmt.Errorf("access_key_id is required")
	}
	if s.SecretAccessKey == "" {
		return fmt.Errorf("secret_access_key is required")
	}
	return nil
}

func (s *KubernetesPostgresR2ConfigInput) applyDefaults() {
}

func (s *KubernetesPostgresR2ConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cloudflare_account_id"] = s.CloudflareAccountId
	m["access_key_id"] = s.AccessKeyId
	m["secret_access_key"] = s.SecretAccessKey
	return m
}

// Technology-agnostic disaster recovery restore configuration
//
//	Enables database restoration from S3/R2 backup files independent of source cluster
//
//	Usage Pattern (Two-Stage Workflow):
//	Stage 1 - Bootstrap from Backup:
//	  Set enabled=true to restore from backup (read-only validation mode)
//	Stage 2 - Promote to Primary:
//	  Set enabled=false to promote to read-write primary
//
//	Operator Implementation:
//	- Zalando: enabled=true → spec:standby, enabled=false → remove spec:standby
//	- Percona: enabled=true → spec:dataSource, enabled=false → normal bootstrap
//	- CloudNativePG: enabled=true → spec:bootstrap.recovery, enabled=false → normal start
type KubernetesPostgresRestoreConfigInput struct {
	// Enable or disable restore mode
	//  When enabled: Database bootstraps from backup (implementation varies by operator)
	//  When disabled or unset: Database runs as normal primary
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable or disable restore mode When enabled: Database bootstraps from backup (implementation varies by operator) When disabled or unset: Database runs as normal primary"`
	// S3/R2 bucket name for backup source
	//  Optional: If not specified, uses operator-level bucket configuration
	//  If operator-level bucket also not configured, deployment will fail
	BucketName string `json:"bucket_name,omitempty" jsonschema:"S3/R2 bucket name for backup source Optional: If not specified; uses operator-level bucket configuration If operator-level bucket also not configured; deployment will fail"`
	// S3 path to backup directory (without s3:// prefix or bucket name)
	//  Required when enabled=true
	//  Example: "backups/db-app-prod-main/14"
	//  Path should contain operator-specific backup structure (e.g., basebackups_005/, wal_005/)
	S3Path string `json:"s3_path,omitempty" jsonschema:"S3 path to backup directory (without s3:// prefix or bucket name) Required when enabled=true Example: 'backups/db-app-prod-main/14' Path should contain operator-specific backup structure (e.g.; baseba..."`
	// R2/S3 credentials for restore access
	//  Optional: Allows per-database independent credentials for disaster recovery
	//  If not specified, operators may use shared credentials or fail
	//  Recommended: Provide credentials for true cross-cluster independence
	R2Config *KubernetesPostgresR2ConfigInput `json:"r2_config,omitempty" jsonschema:"R2/S3 credentials for restore access Optional: Allows per-database independent credentials for disaster recovery If not specified; operators may use shared credentials or fail Recommended: Provide cre..."`
}

func (s *KubernetesPostgresRestoreConfigInput) validate() error {
	if s.R2Config != nil {
		if err := s.R2Config.validate(); err != nil {
			return fmt.Errorf("r2_config: %w", err)
		}
	}
	return nil
}

func (s *KubernetesPostgresRestoreConfigInput) applyDefaults() {
	if s.R2Config != nil {
		s.R2Config.applyDefaults()
	}
}

func (s *KubernetesPostgresRestoreConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.BucketName != "" {
		m["bucket_name"] = s.BucketName
	}
	if s.S3Path != "" {
		m["s3_path"] = s.S3Path
	}
	if s.R2Config != nil {
		m["r2_config"] = s.R2Config.toMap()
	}
	return m
}

// PostgreSQL user/role definition
type KubernetesPostgresUserInput struct {
	// Username/role name (e.g., "app_user", "openfga")
	//  This name can be referenced as a database owner in the databases field
	Name string `json:"name" jsonschema:"required,Username/role name (e.g.; 'app_user'; 'openfga') This name can be referenced as a database owner in the databases field"`
	// User permission flags. Common values:
	//  - "createdb": Can create databases
	//  - "superuser": Superuser privileges (use with caution)
	//  - "createrole": Can create other roles
	//  - "inherit": Inherits privileges of roles it is a member of
	//  - "login": Can log in (default for users)
	//  - "replication": Can init...
	Flags []string `json:"flags,omitempty" jsonschema:"User permission flags. Common values: - 'createdb': Can create databases - 'superuser': Superuser privileges (use with caution) - 'createrole': Can create other roles - 'inherit': Inherits privileges ..."`
}

func (s *KubernetesPostgresUserInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *KubernetesPostgresUserInput) applyDefaults() {
}

func (s *KubernetesPostgresUserInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if len(s.Flags) > 0 {
		m["flags"] = s.Flags
	}
	return m
}

// ParseKubernetesPostgres validates and normalizes a KubernetesPostgres cloud_object.
func ParseKubernetesPostgres(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesPostgres"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesPostgresSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
