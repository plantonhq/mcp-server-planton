// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package kubernetes

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// jenkins-kubernetes
type KubernetesJenkinsSpecInput struct {
	// Target Kubernetes Cluster
	TargetCluster *KubernetesClusterSelectorInput `json:"target_cluster,omitempty" jsonschema:"Target Kubernetes Cluster"`
	// Kubernetes Namespace
	Namespace string `json:"namespace" jsonschema:"required,Kubernetes Namespace"`
	// flag to indicate if the namespace should be created
	CreateNamespace bool `json:"create_namespace,omitempty" jsonschema:"flag to indicate if the namespace should be created"`
	// The CPU and memory resources allocated to the Jenkins container.
	ContainerResources *ContainerResourcesInput `json:"container_resources,omitempty" jsonschema:"The CPU and memory resources allocated to the Jenkins container."`
	// A map of key-value pairs that provide additional customization options for the Helm chart used to deploy Jenkins.
	//  These values allow for further refinement of the deployment, such as customizing resource limits, setting environment variables,
	//  or specifying version tags. For detailed information on...
	HelmValues map[string]string `json:"helm_values,omitempty" jsonschema:"A map of key-value pairs that provide additional customization options for the Helm chart used to deploy Jenkins. These values allow for further refinement of the deployment; such as customizing resou..."`
	// The ingress configuration for the Jenkins deployment.
	Ingress *KubernetesJenkinsIngressInput `json:"ingress,omitempty" jsonschema:"The ingress configuration for the Jenkins deployment."`
}

func (s *KubernetesJenkinsSpecInput) validate() error {
	if s.TargetCluster != nil {
		if err := s.TargetCluster.validate(); err != nil {
			return fmt.Errorf("target_cluster: %w", err)
		}
	}
	if s.Namespace == "" {
		return fmt.Errorf("namespace is required")
	}
	if s.ContainerResources != nil {
		if err := s.ContainerResources.validate(); err != nil {
			return fmt.Errorf("container_resources: %w", err)
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	return nil
}

func (s *KubernetesJenkinsSpecInput) applyDefaults() {
	if s.TargetCluster != nil {
		s.TargetCluster.applyDefaults()
	}
	if s.ContainerResources != nil {
		s.ContainerResources.applyDefaults()
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
}

func (s *KubernetesJenkinsSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TargetCluster != nil {
		m["target_cluster"] = s.TargetCluster.toMap()
	}
	m["namespace"] = s.Namespace
	if s.CreateNamespace {
		m["create_namespace"] = s.CreateNamespace
	}
	if s.ContainerResources != nil {
		m["container_resources"] = s.ContainerResources.toMap()
	}
	if len(s.HelmValues) > 0 {
		m["helm_values"] = s.HelmValues
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	return m
}

// *
//
//	KubernetesJenkinsIngress defines ingress configuration for Jenkins.
type KubernetesJenkinsIngressInput struct {
	// Flag to enable or disable ingress.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Flag to enable or disable ingress."`
	// The full hostname for external access (e.g., "jenkins.example.com").
	//  Required when enabled is true.
	Hostname string `json:"hostname,omitempty" jsonschema:"The full hostname for external access (e.g.; 'jenkins.example.com'). Required when enabled is true."`
}

func (s *KubernetesJenkinsIngressInput) validate() error {
	return nil
}

func (s *KubernetesJenkinsIngressInput) applyDefaults() {
}

func (s *KubernetesJenkinsIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	return m
}

// ParseKubernetesJenkins validates and normalizes a KubernetesJenkins cloud_object.
func ParseKubernetesJenkins(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "kubernetes.openmcf.org/v1", "KubernetesJenkins"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec KubernetesJenkinsSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
