// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cloudflare-zero-trust-access-application
type CloudflareZeroTrustAccessApplicationSpecInput struct {
	// The display name of the Zero Trust Access Application.
	ApplicationName string `json:"application_name,omitempty" jsonschema:"The display name of the Zero Trust Access Application."`
	// The Cloudflare DNS zone ID (from a CloudflareDnsZone resource) for the domain.
	ZoneId string `json:"zone_id" jsonschema:"required,The Cloudflare DNS zone ID (from a CloudflareDnsZone resource) for the domain."`
	// The fully qualified domain name to protect (e.g., "app.example.com").
	Hostname string `json:"hostname" jsonschema:"required,The fully qualified domain name to protect (e.g.; 'app.example.com')."`
	// The type of access policy for this application (ALLOW or BLOCK). Defaults to ALLOW if unspecified.
	PolicyType string `json:"policy_type,omitempty" jsonschema:"enum=BLOCK,The type of access policy for this application (ALLOW or BLOCK). Defaults to ALLOW if unspecified."`
	// A list of email addresses that are allowed access (applicable only when policy_type = ALLOW).
	AllowedEmails []string `json:"allowed_emails,omitempty" jsonschema:"A list of email addresses that are allowed access (applicable only when policy_type = ALLOW)."`
	// The duration of each authenticated session, in minutes (default: 1440 minutes, i.e., 24 hours).
	SessionDurationMinutes int32 `json:"session_duration_minutes,omitempty" jsonschema:"The duration of each authenticated session; in minutes (default: 1440 minutes; i.e.; 24 hours)."`
	// Whether multi-factor authentication (MFA) is required for access.
	RequireMfa bool `json:"require_mfa,omitempty" jsonschema:"Whether multi-factor authentication (MFA) is required for access."`
	// A list of allowed Google Workspace group email addresses (optional).
	AllowedGoogleGroups []string `json:"allowed_google_groups,omitempty" jsonschema:"A list of allowed Google Workspace group email addresses (optional)."`
}

func (s *CloudflareZeroTrustAccessApplicationSpecInput) validate() error {
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	if s.Hostname == "" {
		return fmt.Errorf("hostname is required")
	}
	switch s.PolicyType {
	case "", "BLOCK":
	default:
		return fmt.Errorf("invalid policy_type: %q", s.PolicyType)
	}
	return nil
}

func (s *CloudflareZeroTrustAccessApplicationSpecInput) applyDefaults() {
}

func (s *CloudflareZeroTrustAccessApplicationSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ApplicationName != "" {
		m["application_name"] = s.ApplicationName
	}
	m["zone_id"] = s.ZoneId
	m["hostname"] = s.Hostname
	if s.PolicyType != "" {
		m["policy_type"] = s.PolicyType
	}
	if len(s.AllowedEmails) > 0 {
		m["allowed_emails"] = s.AllowedEmails
	}
	if s.SessionDurationMinutes != 0 {
		m["session_duration_minutes"] = s.SessionDurationMinutes
	}
	if s.RequireMfa {
		m["require_mfa"] = s.RequireMfa
	}
	if len(s.AllowedGoogleGroups) > 0 {
		m["allowed_google_groups"] = s.AllowedGoogleGroups
	}
	return m
}

// ParseCloudflareZeroTrustAccessApplication validates and normalizes a CloudflareZeroTrustAccessApplication cloud_object.
func ParseCloudflareZeroTrustAccessApplication(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareZeroTrustAccessApplication"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareZeroTrustAccessApplicationSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
