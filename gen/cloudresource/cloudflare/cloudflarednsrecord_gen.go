// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// CloudflareDnsRecord is a Kubernetes Resource Model (KRM) style resource for managing
//
//	individual DNS records within a Cloudflare DNS zone.
type CloudflareDnsRecordSpecInput struct {
	// The Cloudflare Zone ID where this DNS record will be created.
	//  Can be provided as a literal string or as a reference to a CloudflareDnsZone resource.
	//  When using value_from, defaults to CloudflareDnsZone kind and status.outputs.zone_id field path.
	ZoneId string `json:"zone_id" jsonschema:"required,The Cloudflare Zone ID where this DNS record will be created. Can be provided as a literal string or as a reference to a CloudflareDnsZone resource. When using value_from; defaults to CloudflareDnsZon..."`
	// The name of the DNS record (e.g., "www", "api", "@" for root).
	//  Use "@" to create a record at the zone apex (root domain).
	Name string `json:"name" jsonschema:"required,The name of the DNS record (e.g.; 'www'; 'api'; '@' for root). Use '@' to create a record at the zone apex (root domain)."`
	// The type of DNS record to create.
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|CNAME|MX|TXT|SRV|NS|CAA,The type of DNS record to create."`
	// The value/target of the DNS record.
	//  For A records: IPv4 address (e.g., "192.0.2.1")
	//  For AAAA records: IPv6 address (e.g., "2001:db8::1")
	//  For CNAME records: target hostname (e.g., "example.com")
	//  For MX records: mail server hostname (e.g., "mail.example.com")
	//  For TXT records: text value (e.g., "v...
	Value string `json:"value" jsonschema:"required,The value/target of the DNS record. For A records: IPv4 address (e.g.; '192.0.2.1') For AAAA records: IPv6 address (e.g.; '2001:db8::1') For CNAME records: target hostname (e.g.; 'example.com') For MX..."`
	// Whether the record is proxied through Cloudflare (orange cloud).
	//  When true: traffic flows through Cloudflare's CDN/WAF (hides origin IP).
	//  When false: DNS-only resolution (grey cloud, reveals origin IP).
	//  Only applicable to A, AAAA, and CNAME records.
	//  Defaults to false.
	Proxied bool `json:"proxied,omitempty" jsonschema:"Whether the record is proxied through Cloudflare (orange cloud). When true: traffic flows through Cloudflare's CDN/WAF (hides origin IP). When false: DNS-only resolution (grey cloud; reveals origin IP..."`
	// Time to live (TTL) for the DNS record in seconds.
	//  Set to 1 for automatic TTL (recommended for proxied records).
	//  Valid values: 1 (auto), or 60-86400 seconds.
	//  Defaults to 1 (automatic).
	Ttl int32 `json:"ttl,omitempty" jsonschema:"Time to live (TTL) for the DNS record in seconds. Set to 1 for automatic TTL (recommended for proxied records). Valid values: 1 (auto); or 60-86400 seconds. Defaults to 1 (automatic)."`
	// Priority for MX and SRV records.
	//  Lower values indicate higher priority.
	//  Required for MX records, optional for SRV records.
	//  Range: 0-65535.
	Priority int32 `json:"priority,omitempty" jsonschema:"Priority for MX and SRV records. Lower values indicate higher priority. Required for MX records; optional for SRV records. Range: 0-65535."`
	// Optional comment/note for the DNS record.
	//  Useful for documenting the purpose of the record.
	//  Maximum 100 characters.
	Comment string `json:"comment,omitempty" jsonschema:"Optional comment/note for the DNS record. Useful for documenting the purpose of the record. Maximum 100 characters."`
}

func (s *CloudflareDnsRecordSpecInput) validate() error {
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "NS", "CAA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *CloudflareDnsRecordSpecInput) applyDefaults() {
}

func (s *CloudflareDnsRecordSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone_id"] = s.ZoneId
	m["name"] = s.Name
	m["type"] = s.Type
	m["value"] = s.Value
	if s.Proxied {
		m["proxied"] = s.Proxied
	}
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Comment != "" {
		m["comment"] = s.Comment
	}
	return m
}

// ParseCloudflareDnsRecord validates and normalizes a CloudflareDnsRecord cloud_object.
func ParseCloudflareDnsRecord(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareDnsRecord"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareDnsRecordSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
