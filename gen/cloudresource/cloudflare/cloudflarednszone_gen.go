// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cloudflare-dns-zone
type CloudflareDnsZoneSpecInput struct {
	// The fully qualified domain name of the DNS zone (e.g., "example.com").
	ZoneName string `json:"zone_name" jsonschema:"required,The fully qualified domain name of the DNS zone (e.g.; 'example.com')."`
	// The Cloudflare account identifier under which to create the zone.
	AccountId string `json:"account_id" jsonschema:"required,The Cloudflare account identifier under which to create the zone."`
	// The subscription plan for the zone (e.g., free, pro, business, enterprise).
	//  Defaults to the Free plan if unspecified.
	Plan string `json:"plan,omitempty" jsonschema:"enum=PRO|BUSINESS|ENTERPRISE,The subscription plan for the zone (e.g.; free; pro; business; enterprise). Defaults to the Free plan if unspecified."`
	// Indicates if the zone is created in a paused state (DNS-only mode with no security or performance features).
	//  If true, the zone will not receive Cloudflare's proxy/CDN services. Defaults to false.
	Paused bool `json:"paused,omitempty" jsonschema:"Indicates if the zone is created in a paused state (DNS-only mode with no security or performance features). If true; the zone will not receive Cloudflare's proxy/CDN services. Defaults to false."`
	// If true, new DNS records in this zone will default to being proxied (orange-cloud) through Cloudflare.
	//  Defaults to false.
	DefaultProxied bool `json:"default_proxied,omitempty" jsonschema:"If true; new DNS records in this zone will default to being proxied (orange-cloud) through Cloudflare. Defaults to false."`
	// DNS records to create in this zone.
	//  This allows managing DNS records as part of the zone configuration.
	Records []*CloudflareDnsZoneRecordInput `json:"records,omitempty" jsonschema:"DNS records to create in this zone. This allows managing DNS records as part of the zone configuration."`
}

func (s *CloudflareDnsZoneSpecInput) validate() error {
	if s.ZoneName == "" {
		return fmt.Errorf("zone_name is required")
	}
	if s.AccountId == "" {
		return fmt.Errorf("account_id is required")
	}
	switch s.Plan {
	case "", "PRO", "BUSINESS", "ENTERPRISE":
	default:
		return fmt.Errorf("invalid plan: %q", s.Plan)
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *CloudflareDnsZoneSpecInput) applyDefaults() {
}

func (s *CloudflareDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone_name"] = s.ZoneName
	m["account_id"] = s.AccountId
	if s.Plan != "" {
		m["plan"] = s.Plan
	}
	if s.Paused {
		m["paused"] = s.Paused
	}
	if s.DefaultProxied {
		m["default_proxied"] = s.DefaultProxied
	}
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// CloudflareDnsZoneRecord defines the configuration for a DNS record within a Cloudflare zone.
//
//	This message supports creating individual DNS records with common record types.
type CloudflareDnsZoneRecordInput struct {
	// The name of the DNS record (e.g., "www", "api", "@" for root).
	//  Use "@" to create a record at the zone apex (root domain).
	Name string `json:"name" jsonschema:"required,The name of the DNS record (e.g.; 'www'; 'api'; '@' for root). Use '@' to create a record at the zone apex (root domain)."`
	// The type of DNS record to create.
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|CNAME|MX|TXT|SRV|NS|CAA,The type of DNS record to create."`
	// The value/target of the DNS record.
	//  For A records: IPv4 address (e.g., "192.0.2.1")
	//  For AAAA records: IPv6 address (e.g., "2001:db8::1")
	//  For CNAME records: target hostname (e.g., "example.com")
	//  For MX records: mail server hostname (e.g., "mail.example.com")
	//  For TXT records: text value (e.g., "v...
	Value string `json:"value" jsonschema:"required,The value/target of the DNS record. For A records: IPv4 address (e.g.; '192.0.2.1') For AAAA records: IPv6 address (e.g.; '2001:db8::1') For CNAME records: target hostname (e.g.; 'example.com') For MX..."`
	// Whether the record is proxied through Cloudflare (orange cloud).
	//  When true: traffic flows through Cloudflare's CDN/WAF (hides origin IP).
	//  When false: DNS-only resolution (grey cloud, reveals origin IP).
	//  Only applicable to A, AAAA, and CNAME records.
	//  Defaults to false.
	Proxied bool `json:"proxied,omitempty" jsonschema:"Whether the record is proxied through Cloudflare (orange cloud). When true: traffic flows through Cloudflare's CDN/WAF (hides origin IP). When false: DNS-only resolution (grey cloud; reveals origin IP..."`
	// Time to live (TTL) for the DNS record in seconds.
	//  Set to 1 for automatic TTL (recommended for proxied records).
	//  Valid values: 1 (auto), or 60-86400 seconds.
	//  Defaults to 1 (automatic).
	Ttl int32 `json:"ttl,omitempty" jsonschema:"Time to live (TTL) for the DNS record in seconds. Set to 1 for automatic TTL (recommended for proxied records). Valid values: 1 (auto); or 60-86400 seconds. Defaults to 1 (automatic)."`
	// Priority for MX and SRV records.
	//  Lower values indicate higher priority.
	//  Required for MX records, optional for SRV records.
	//  Range: 0-65535.
	Priority int32 `json:"priority,omitempty" jsonschema:"Priority for MX and SRV records. Lower values indicate higher priority. Required for MX records; optional for SRV records. Range: 0-65535."`
	// Optional comment/note for the DNS record.
	//  Useful for documenting the purpose of the record.
	//  Maximum 100 characters.
	Comment string `json:"comment,omitempty" jsonschema:"Optional comment/note for the DNS record. Useful for documenting the purpose of the record. Maximum 100 characters."`
}

func (s *CloudflareDnsZoneRecordInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "NS", "CAA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *CloudflareDnsZoneRecordInput) applyDefaults() {
}

func (s *CloudflareDnsZoneRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["type"] = s.Type
	m["value"] = s.Value
	if s.Proxied {
		m["proxied"] = s.Proxied
	}
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Comment != "" {
		m["comment"] = s.Comment
	}
	return m
}

// ParseCloudflareDnsZone validates and normalizes a CloudflareDnsZone cloud_object.
func ParseCloudflareDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
