// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cloudflare-r2-bucket
type CloudflareR2BucketSpecInput struct {
	// bucket name (DNS-compatible, 3–63 characters)
	BucketName string `json:"bucket_name" jsonschema:"required,bucket name (DNS-compatible; 3–63 characters)"`
	// The Cloudflare account ID in which to create the bucket.
	AccountId string `json:"account_id" jsonschema:"required,The Cloudflare account ID in which to create the bucket."`
	// primary region for the bucket (location hint)
	Location string `json:"location" jsonschema:"required,enum=WNAM|ENAM|WEUR|EEUR|APAC|OC,primary region for the bucket (location hint)"`
	// expose bucket via public URL (Cloudflare-managed r2.dev domain; default: false)
	PublicAccess bool `json:"public_access,omitempty" jsonschema:"expose bucket via public URL (Cloudflare-managed r2.dev domain; default: false)"`
	// custom domain configuration for the bucket
	CustomDomain *CloudflareR2BucketCustomDomainConfigInput `json:"custom_domain,omitempty" jsonschema:"custom domain configuration for the bucket"`
}

func (s *CloudflareR2BucketSpecInput) validate() error {
	if s.BucketName == "" {
		return fmt.Errorf("bucket_name is required")
	}
	if s.AccountId == "" {
		return fmt.Errorf("account_id is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	switch s.Location {
	case "WNAM", "ENAM", "WEUR", "EEUR", "APAC", "OC":
	default:
		return fmt.Errorf("invalid location: %q", s.Location)
	}
	if s.CustomDomain != nil {
		if err := s.CustomDomain.validate(); err != nil {
			return fmt.Errorf("custom_domain: %w", err)
		}
	}
	return nil
}

func (s *CloudflareR2BucketSpecInput) applyDefaults() {
	if s.CustomDomain != nil {
		s.CustomDomain.applyDefaults()
	}
}

func (s *CloudflareR2BucketSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket_name"] = s.BucketName
	m["account_id"] = s.AccountId
	m["location"] = s.Location
	if s.PublicAccess {
		m["public_access"] = s.PublicAccess
	}
	if s.CustomDomain != nil {
		m["custom_domain"] = s.CustomDomain.toMap()
	}
	return m
}

// CloudflareR2BucketCustomDomainConfig configures a custom domain for accessing the R2 bucket.
//
//	When enabled, the bucket will be accessible via the specified domain.
type CloudflareR2BucketCustomDomainConfigInput struct {
	// Whether to enable custom domain access for the bucket.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether to enable custom domain access for the bucket."`
	// The Cloudflare Zone ID where the custom domain will be configured.
	//  Can be a literal value or referenced from a CloudflareDnsZone resource.
	//  Required when enabled is true.
	ZoneId string `json:"zone_id,omitempty" jsonschema:"The Cloudflare Zone ID where the custom domain will be configured. Can be a literal value or referenced from a CloudflareDnsZone resource. Required when enabled is true."`
	// The full domain name to use for accessing the bucket (e.g., "media.example.com").
	//  Must be within the zone specified by zone_id.
	//  Required when enabled is true.
	Domain string `json:"domain,omitempty" jsonschema:"The full domain name to use for accessing the bucket (e.g.; 'media.example.com'). Must be within the zone specified by zone_id. Required when enabled is true."`
}

func (s *CloudflareR2BucketCustomDomainConfigInput) validate() error {
	return nil
}

func (s *CloudflareR2BucketCustomDomainConfigInput) applyDefaults() {
}

func (s *CloudflareR2BucketCustomDomainConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.ZoneId != "" {
		m["zone_id"] = s.ZoneId
	}
	if s.Domain != "" {
		m["domain"] = s.Domain
	}
	return m
}

// ParseCloudflareR2Bucket validates and normalizes a CloudflareR2Bucket cloud_object.
func ParseCloudflareR2Bucket(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareR2Bucket"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareR2BucketSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
