// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cloudflare-d1-database
type CloudflareD1DatabaseSpecInput struct {
	// (Required) The Cloudflare account ID in which to create the database.
	AccountId string `json:"account_id" jsonschema:"required,(Required) The Cloudflare account ID in which to create the database."`
	// (Required) The unique name for the D1 database.
	//  Must be unique within the account.
	DatabaseName string `json:"database_name" jsonschema:"required,(Required) The unique name for the D1 database. Must be unique within the account."`
	// (Optional) The Cloudflare region where the D1 database will be hosted.
	//  This maps to the primary_location_hint property in the Cloudflare API.
	//  Valid values: weur, eeur, apac, oc, wnam, enam.
	//  If omitted, Cloudflare selects a default location based on your account settings.
	Region string `json:"region,omitempty" jsonschema:"enum=weur|eeur|apac|oc|wnam|enam,(Optional) The Cloudflare region where the D1 database will be hosted. This maps to the primary_location_hint property in the Cloudflare API. Valid values: weur; eeur; apac; oc; wnam; enam. If omitted..."`
	// (Optional) Configures D1 Read Replication (Beta).
	//  Enables automatic read replication across multiple regions for lower global read latency.
	//  WARNING: Enabling replication requires application-level code changes to use the D1 Sessions API.
	//  Failing to use the Sessions API will cause data consistency...
	ReadReplication *CloudflareD1ReadReplicationInput `json:"read_replication,omitempty" jsonschema:"(Optional) Configures D1 Read Replication (Beta). Enables automatic read replication across multiple regions for lower global read latency. WARNING: Enabling replication requires application-level cod..."`
}

func (s *CloudflareD1DatabaseSpecInput) validate() error {
	if s.AccountId == "" {
		return fmt.Errorf("account_id is required")
	}
	if s.DatabaseName == "" {
		return fmt.Errorf("database_name is required")
	}
	switch s.Region {
	case "", "weur", "eeur", "apac", "oc", "wnam", "enam":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.ReadReplication != nil {
		if err := s.ReadReplication.validate(); err != nil {
			return fmt.Errorf("read_replication: %w", err)
		}
	}
	return nil
}

func (s *CloudflareD1DatabaseSpecInput) applyDefaults() {
	if s.ReadReplication != nil {
		s.ReadReplication.applyDefaults()
	}
}

func (s *CloudflareD1DatabaseSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["account_id"] = s.AccountId
	m["database_name"] = s.DatabaseName
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.ReadReplication != nil {
		m["read_replication"] = s.ReadReplication.toMap()
	}
	return m
}

// CloudflareD1ReadReplication configures D1 Read Replication (Beta).
//
//	Read replication creates read-only replicas in multiple regions to reduce global read latency.
type CloudflareD1ReadReplicationInput struct {
	// (Required if read_replication is set) The replication mode.
	//  Valid values: "auto" (enable automatic read replication), "disabled" (disable replication).
	Mode string `json:"mode" jsonschema:"required,(Required if read_replication is set) The replication mode. Valid values: 'auto' (enable automatic read replication); 'disabled' (disable replication)."`
}

func (s *CloudflareD1ReadReplicationInput) validate() error {
	if s.Mode == "" {
		return fmt.Errorf("mode is required")
	}
	return nil
}

func (s *CloudflareD1ReadReplicationInput) applyDefaults() {
}

func (s *CloudflareD1ReadReplicationInput) toMap() map[string]any {
	m := make(map[string]any)
	m["mode"] = s.Mode
	return m
}

// ParseCloudflareD1Database validates and normalizes a CloudflareD1Database cloud_object.
func ParseCloudflareD1Database(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareD1Database"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareD1DatabaseSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
