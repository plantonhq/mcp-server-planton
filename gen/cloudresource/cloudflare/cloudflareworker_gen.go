// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package cloudflare

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// cloudflare-worker
type CloudflareWorkerSpecInput struct {
	// The Cloudflare account ID in which to create the worker.
	AccountId string `json:"account_id" jsonschema:"required,The Cloudflare account ID in which to create the worker."`
	// The name of the Cloudflare Worker.
	//  This is the worker name that will be visible in the Cloudflare dashboard.
	WorkerName string `json:"worker_name" jsonschema:"required,The name of the Cloudflare Worker. This is the worker name that will be visible in the Cloudflare dashboard."`
	// Worker script bundle configuration.
	//  Specifies the R2 bucket and path where the pre-built Worker script bundle is stored.
	ScriptBundle *CloudflareWorkerScriptBundleInput `json:"script_bundle" jsonschema:"required,Worker script bundle configuration. Specifies the R2 bucket and path where the pre-built Worker script bundle is stored."`
	// (Optional) One or more KV namespaces to bind to this Worker (referenced by CloudflareKVNamespace.namespace_id).
	KvBindings []string `json:"kv_bindings,omitempty" jsonschema:"(Optional) One or more KV namespaces to bind to this Worker (referenced by CloudflareKVNamespace.namespace_id)."`
	// (Optional) DNS configuration for attaching the Worker to a custom domain.
	Dns *CloudflareWorkerDnsInput `json:"dns,omitempty" jsonschema:"(Optional) DNS configuration for attaching the Worker to a custom domain."`
	// (Optional) Compatibility date for the Worker script (YYYY-MM-DD). If unset, defaults to today's date.
	CompatibilityDate string `json:"compatibility_date,omitempty" jsonschema:"(Optional) Compatibility date for the Worker script (YYYY-MM-DD). If unset; defaults to today's date."`
	// (Optional) Billing/usage model for the Worker. Defaults to BUNDLED if unspecified.
	UsageModel string `json:"usage_model,omitempty" jsonschema:"enum=UNBOUND,(Optional) Billing/usage model for the Worker. Defaults to BUNDLED if unspecified."`
	// Environment configuration supporting variables and secrets.
	//  Variables become plain-text bindings in the Worker.
	//  Secrets are uploaded via Cloudflare Workers Secrets API (encrypted at rest).
	Env *CloudflareWorkerEnvInput `json:"env,omitempty" jsonschema:"Environment configuration supporting variables and secrets. Variables become plain-text bindings in the Worker. Secrets are uploaded via Cloudflare Workers Secrets API (encrypted at rest)."`
}

func (s *CloudflareWorkerSpecInput) validate() error {
	if s.AccountId == "" {
		return fmt.Errorf("account_id is required")
	}
	if s.WorkerName == "" {
		return fmt.Errorf("worker_name is required")
	}
	if s.ScriptBundle == nil {
		return fmt.Errorf("script_bundle is required")
	}
	if s.ScriptBundle != nil {
		if err := s.ScriptBundle.validate(); err != nil {
			return fmt.Errorf("script_bundle: %w", err)
		}
	}
	if s.Dns != nil {
		if err := s.Dns.validate(); err != nil {
			return fmt.Errorf("dns: %w", err)
		}
	}
	switch s.UsageModel {
	case "", "UNBOUND":
	default:
		return fmt.Errorf("invalid usage_model: %q", s.UsageModel)
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	return nil
}

func (s *CloudflareWorkerSpecInput) applyDefaults() {
	if s.ScriptBundle != nil {
		s.ScriptBundle.applyDefaults()
	}
	if s.Dns != nil {
		s.Dns.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
}

func (s *CloudflareWorkerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["account_id"] = s.AccountId
	m["worker_name"] = s.WorkerName
	if s.ScriptBundle != nil {
		m["script_bundle"] = s.ScriptBundle.toMap()
	}
	if len(s.KvBindings) > 0 {
		m["kv_bindings"] = s.KvBindings
	}
	if s.Dns != nil {
		m["dns"] = s.Dns.toMap()
	}
	if s.CompatibilityDate != "" {
		m["compatibility_date"] = s.CompatibilityDate
	}
	if s.UsageModel != "" {
		m["usage_model"] = s.UsageModel
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	return m
}

// CloudflareWorkerDns defines DNS configuration for attaching a Worker to a custom domain.
type CloudflareWorkerDnsInput struct {
	// Enable or disable DNS/route configuration. Set to false to deploy worker without a route.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable or disable DNS/route configuration. Set to false to deploy worker without a route."`
	// The Cloudflare Zone ID where the Worker route will be created.
	ZoneId string `json:"zone_id,omitempty" jsonschema:"The Cloudflare Zone ID where the Worker route will be created."`
	// The fully qualified domain name where the Worker will be accessible (e.g., "git-webhooks.planton.live").
	//  A DNS record will be created automatically for this hostname with proxy (orange cloud) enabled.
	Hostname string `json:"hostname,omitempty" jsonschema:"The fully qualified domain name where the Worker will be accessible (e.g.; 'git-webhooks.planton.live'). A DNS record will be created automatically for this hostname with proxy (orange cloud) enabled."`
	// (Optional) URL pattern to match incoming requests. If not specified, defaults to "hostname/*".
	//  Examples: "git-webhooks.planton.live/*", "api.example.com/webhooks/*"
	RoutePattern string `json:"route_pattern,omitempty" jsonschema:"(Optional) URL pattern to match incoming requests. If not specified; defaults to 'hostname/*'. Examples: 'git-webhooks.planton.live/*'; 'api.example.com/webhooks/*'"`
}

func (s *CloudflareWorkerDnsInput) validate() error {
	return nil
}

func (s *CloudflareWorkerDnsInput) applyDefaults() {
}

func (s *CloudflareWorkerDnsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.ZoneId != "" {
		m["zone_id"] = s.ZoneId
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	if s.RoutePattern != "" {
		m["route_pattern"] = s.RoutePattern
	}
	return m
}

// CloudflareWorkerEnv defines environment variables and secrets for a CloudflareWorker.
type CloudflareWorkerEnvInput struct {
	// Non-sensitive configuration (becomes plain-text bindings in the Worker).
	//  Supports plain values or $variables-group/... references.
	//  Example: LOG_LEVEL: "info"
	//  Example: NAMESPACE: "$variables-group/temporal/namespace"
	Variables map[string]string `json:"variables,omitempty" jsonschema:"Non-sensitive configuration (becomes plain-text bindings in the Worker). Supports plain values or $variables-group/... references. Example: LOG_LEVEL: 'info' Example: NAMESPACE: '$variables-group/temp..."`
	// Sensitive configuration (uploaded via Cloudflare Secrets API, encrypted at rest).
	//  Supports plain values or $secrets-group/... references.
	//  Example: API_KEY: "$secrets-group/external-apis/stripe-key"
	//  Note: Secrets are uploaded separately from the worker version and are never logged.
	Secrets map[string]string `json:"secrets,omitempty" jsonschema:"Sensitive configuration (uploaded via Cloudflare Secrets API; encrypted at rest). Supports plain values or $secrets-group/... references. Example: API_KEY: '$secrets-group/external-apis/stripe-key' No..."`
}

func (s *CloudflareWorkerEnvInput) validate() error {
	return nil
}

func (s *CloudflareWorkerEnvInput) applyDefaults() {
}

func (s *CloudflareWorkerEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		m["secrets"] = s.Secrets
	}
	return m
}

// CloudflareWorkerScriptBundle defines the R2 object reference for the pre-built Worker script bundle.
type CloudflareWorkerScriptBundleInput struct {
	// The R2 bucket name where the script bundle is stored.
	Bucket string `json:"bucket" jsonschema:"required,The R2 bucket name where the script bundle is stored."`
	// The path to the script bundle within the R2 bucket.
	Path string `json:"path" jsonschema:"required,The path to the script bundle within the R2 bucket."`
}

func (s *CloudflareWorkerScriptBundleInput) validate() error {
	if s.Bucket == "" {
		return fmt.Errorf("bucket is required")
	}
	if s.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

func (s *CloudflareWorkerScriptBundleInput) applyDefaults() {
}

func (s *CloudflareWorkerScriptBundleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket"] = s.Bucket
	m["path"] = s.Path
	return m
}

// ParseCloudflareWorker validates and normalizes a CloudflareWorker cloud_object.
func ParseCloudflareWorker(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "cloudflare.openmcf.org/v1", "CloudflareWorker"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CloudflareWorkerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
