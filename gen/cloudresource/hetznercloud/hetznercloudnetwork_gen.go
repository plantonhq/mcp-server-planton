// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-network
type HetznerCloudNetworkSpecInput struct {
	// CIDR block for the network. Must be one of the private IPv4 ranges
	//  defined in RFC 1918 (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16).
	//  All subnet ip_ranges must fall within this range.
	//
	//  Changing this value forces replacement of the network resource.
	IpRange string `json:"ip_range,omitempty" jsonschema:"CIDR block for the network. Must be one of the private IPv4 ranges defined in RFC 1918 (10.0.0.0/8; 172.16.0.0/12; 192.168.0.0/16). All subnet ip_ranges must fall within this range. Changing this valu..."`
	// Subnets within the network. At least one subnet is required because
	//  a Hetzner Cloud network is unusable without subnets -- servers and
	//  other resources attach to subnets, not directly to the network.
	Subnets []*SubnetInput `json:"subnets,omitempty" jsonschema:"Subnets within the network. At least one subnet is required because a Hetzner Cloud network is unusable without subnets -- servers and other resources attach to subnets; not directly to the network."`
	// Static routes for the network. Optional -- default routing handles
	//  most use cases. Custom routes are needed for VPN gateways, NAT
	//  instances, or routing between networks.
	Routes []*RouteInput `json:"routes,omitempty" jsonschema:"Static routes for the network. Optional -- default routing handles most use cases. Custom routes are needed for VPN gateways; NAT instances; or routing between networks."`
	// Prevent accidental deletion of the network via the Hetzner Cloud API.
	//  When enabled, the network cannot be deleted until protection is removed.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"Prevent accidental deletion of the network via the Hetzner Cloud API. When enabled; the network cannot be deleted until protection is removed."`
	// Expose the network's routes to vSwitch connections. Only takes effect
	//  when a vSwitch connection is active (via a vswitch-type subnet).
	ExposeRoutesToVswitch bool `json:"expose_routes_to_vswitch,omitempty" jsonschema:"Expose the network's routes to vSwitch connections. Only takes effect when a vSwitch connection is active (via a vswitch-type subnet)."`
}

func (s *HetznerCloudNetworkSpecInput) validate() error {
	if len(s.Subnets) < 1 {
		return fmt.Errorf("subnets requires at least 1 items, got %d", len(s.Subnets))
	}
	for i, v := range s.Subnets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("subnets[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Routes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("routes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *HetznerCloudNetworkSpecInput) applyDefaults() {
}

func (s *HetznerCloudNetworkSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IpRange != "" {
		m["ip_range"] = s.IpRange
	}
	if len(s.Subnets) > 0 {
		items := make([]any, len(s.Subnets))
		for i, v := range s.Subnets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["subnets"] = items
	}
	if len(s.Routes) > 0 {
		items := make([]any, len(s.Routes))
		for i, v := range s.Routes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["routes"] = items
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	if s.ExposeRoutesToVswitch {
		m["expose_routes_to_vswitch"] = s.ExposeRoutesToVswitch
	}
	return m
}

// Route defines a static route within the network. The destination must
//
//	be a CIDR block that does not overlap with any subnet ip_range, and
//	the gateway must be an IP address within one of the network's subnets.
type RouteInput struct {
	// Destination CIDR for this route. Must not overlap with any subnet
	//  ip_range or other route destinations in the same network, and must
	//  not be the first IP of the network's ip_range.
	Destination string `json:"destination,omitempty" jsonschema:"Destination CIDR for this route. Must not overlap with any subnet ip_range or other route destinations in the same network; and must not be the first IP of the network's ip_range."`
	// Gateway IP address within one of the network's subnets. Cannot be
	//  the first IP of the network's ip_range or 172.31.1.1 (reserved for
	//  the public network interface gateway).
	Gateway string `json:"gateway,omitempty" jsonschema:"Gateway IP address within one of the network's subnets. Cannot be the first IP of the network's ip_range or 172.31.1.1 (reserved for the public network interface gateway)."`
}

func (s *RouteInput) validate() error {
	return nil
}

func (s *RouteInput) applyDefaults() {
}

func (s *RouteInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Destination != "" {
		m["destination"] = s.Destination
	}
	if s.Gateway != "" {
		m["gateway"] = s.Gateway
	}
	return m
}

// Subnet defines a subdivision of the network's ip_range assigned to a
//
//	specific network zone. Servers and other resources attach to subnets.
type SubnetInput struct {
	// Type of subnet. Determines how the subnet connects to infrastructure.
	//
	//    - cloud:   Standard subnet for cloud servers (most common).
	//    - server:  Subnet for connecting dedicated (Robot) servers.
	//    - vswitch: Subnet linked to a Hetzner Robot vSwitch.
	Type string `json:"type" jsonschema:"required,enum=cloud|server|vswitch,Type of subnet. Determines how the subnet connects to infrastructure. - cloud: Standard subnet for cloud servers (most common). - server: Subnet for connecting dedicated (Robot) servers. - vswitch: Su..."`
	// Hetzner Cloud network zone for this subnet.
	//
	//  Known zones: "eu-central", "us-east", "us-west", "ap-southeast".
	//  All subnets in a network can be in different zones, enabling
	//  multi-region private connectivity.
	NetworkZone string `json:"network_zone,omitempty" jsonschema:"Hetzner Cloud network zone for this subnet. Known zones: 'eu-central'; 'us-east'; 'us-west'; 'ap-southeast'. All subnets in a network can be in different zones; enabling multi-region private connectiv..."`
	// IP range for this subnet in CIDR notation. Must be a subset of the
	//  network's ip_range and must not overlap with other subnets or route
	//  destinations in the same network.
	//
	//  Changing this value forces replacement of the subnet.
	IpRange string `json:"ip_range,omitempty" jsonschema:"IP range for this subnet in CIDR notation. Must be a subset of the network's ip_range and must not overlap with other subnets or route destinations in the same network. Changing this value forces repl..."`
	// Hetzner Robot vSwitch ID. Required when type is vswitch, ignored
	//  otherwise. Links this subnet to a dedicated server vSwitch for
	//  hybrid cloud/dedicated connectivity.
	VswitchId int64 `json:"vswitch_id,omitempty" jsonschema:"Hetzner Robot vSwitch ID. Required when type is vswitch; ignored otherwise. Links this subnet to a dedicated server vSwitch for hybrid cloud/dedicated connectivity."`
}

func (s *SubnetInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "cloud", "server", "vswitch":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *SubnetInput) applyDefaults() {
}

func (s *SubnetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.NetworkZone != "" {
		m["network_zone"] = s.NetworkZone
	}
	if s.IpRange != "" {
		m["ip_range"] = s.IpRange
	}
	if s.VswitchId != 0 {
		m["vswitch_id"] = s.VswitchId
	}
	return m
}

// ParseHetznerCloudNetwork validates and normalizes a HetznerCloudNetwork cloud_object.
func ParseHetznerCloudNetwork(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudNetwork"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudNetworkSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
