// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-volume
type HetznerCloudVolumeSpecInput struct {
	// Volume size in GB. Minimum is 10 GB, maximum is 10240 GB (10 TB).
	//
	//  Size can be increased after creation (the provider resizes the underlying
	//  block device), but it can never be decreased -- the Hetzner Cloud API
	//  rejects size reductions.
	Size int32 `json:"size,omitempty" jsonschema:"Volume size in GB. Minimum is 10 GB; maximum is 10240 GB (10 TB). Size can be increased after creation (the provider resizes the underlying block device); but it can never be decreased -- the Hetzner ..."`
	// Hetzner Cloud location where the volume is stored (e.g., "fsn1", "nbg1",
	//  "hel1", "ash", "hil", "sin"). Determines the physical datacenter for
	//  the block storage device.
	//
	//  The volume can only be attached to servers in the same location.
	//
	//  Changing this value forces replacement of the volume (data lo...
	Location string `json:"location,omitempty" jsonschema:"Hetzner Cloud location where the volume is stored (e.g.; 'fsn1'; 'nbg1'; 'hel1'; 'ash'; 'hil'; 'sin'). Determines the physical datacenter for the block storage device. The volume can only be attached ..."`
	// Filesystem format applied when the volume is first created.
	//
	//  If unspecified (format_unspecified / 0), the volume is created raw without
	//  a filesystem. A raw volume must be formatted manually from the server
	//  before it can be mounted.
	//
	//  This is a create-time-only setting: the provider does not read ...
	Format string `json:"format,omitempty" jsonschema:"enum=ext4|xfs,Filesystem format applied when the volume is first created. If unspecified (format_unspecified / 0); the volume is created raw without a filesystem. A raw volume must be formatted manually from the se..."`
	// Server to attach this volume to. Optional.
	//
	//  Accepts a literal Hetzner Cloud server ID (as a string) or a reference
	//  to a HetznerCloudServer resource's output via valueFrom. The referenced
	//  server must be in the same location as the volume.
	//
	//  If omitted, the volume is created unattached (available)....
	ServerId string `json:"server_id,omitempty" jsonschema:"Server to attach this volume to. Optional. Accepts a literal Hetzner Cloud server ID (as a string) or a reference to a HetznerCloudServer resource's output via valueFrom. The referenced server must be..."`
	// Automatically mount the volume on the server after attaching.
	//
	//  Only meaningful when server_id is set. When true, Hetzner Cloud
	//  automatically mounts the volume at a system-assigned mount point
	//  after attachment.
	//
	//  This is a create-time-only setting: the provider does not read it back
	//  after creatio...
	Automount bool `json:"automount,omitempty" jsonschema:"Automatically mount the volume on the server after attaching. Only meaningful when server_id is set. When true; Hetzner Cloud automatically mounts the volume at a system-assigned mount point after att..."`
	// Prevent accidental deletion of the volume via the Hetzner Cloud API.
	//  When enabled, the volume cannot be deleted until protection is removed.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"Prevent accidental deletion of the volume via the Hetzner Cloud API. When enabled; the volume cannot be deleted until protection is removed."`
}

func (s *HetznerCloudVolumeSpecInput) validate() error {
	switch s.Format {
	case "", "ext4", "xfs":
	default:
		return fmt.Errorf("invalid format: %q", s.Format)
	}
	return nil
}

func (s *HetznerCloudVolumeSpecInput) applyDefaults() {
}

func (s *HetznerCloudVolumeSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Size != 0 {
		m["size"] = s.Size
	}
	if s.Location != "" {
		m["location"] = s.Location
	}
	if s.Format != "" {
		m["format"] = s.Format
	}
	if s.ServerId != "" {
		m["server_id"] = s.ServerId
	}
	if s.Automount {
		m["automount"] = s.Automount
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	return m
}

// ParseHetznerCloudVolume validates and normalizes a HetznerCloudVolume cloud_object.
func ParseHetznerCloudVolume(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudVolume"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudVolumeSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
