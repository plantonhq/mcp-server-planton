// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-dns-zone
type HetznerCloudDnsZoneSpecInput struct {
	// The DNS domain name for the zone (e.g., "example.com").
	//
	//  This is the actual domain, not the OpenMCF resource identifier
	//  (which is metadata.name). The zone's Hetzner Cloud "name" field
	//  is set to this value.
	//
	//  Changing this value forces replacement of the zone.
	DomainName string `json:"domain_name,omitempty" jsonschema:"The DNS domain name for the zone (e.g.; 'example.com'). This is the actual domain; not the OpenMCF resource identifier (which is metadata.name). The zone's Hetzner Cloud 'name' field is set to this va..."`
	// Zone mode. Determines whether Hetzner Cloud is the primary authority
	//  for this domain or synchronizes records from an external primary.
	//
	//  Changing this value forces replacement of the zone.
	Mode string `json:"mode" jsonschema:"required,enum=primary|secondary,Zone mode. Determines whether Hetzner Cloud is the primary authority for this domain or synchronizes records from an external primary. Changing this value forces replacement of the zone."`
	// Default Time To Live (TTL) for records in the zone, in seconds.
	//  Individual record sets can override this with their own TTL.
	//
	//  Default: 3600 (provider default when not specified).
	Ttl int32 `json:"ttl,omitempty" jsonschema:"Default Time To Live (TTL) for records in the zone; in seconds. Individual record sets can override this with their own TTL. Default: 3600 (provider default when not specified)."`
	// Primary nameservers for zone transfer. Required when mode is
	//  secondary; forbidden when mode is primary.
	//
	//  In secondary mode, Hetzner Cloud pulls DNS records from these
	//  nameservers via AXFR/IXFR. At least one primary nameserver must
	//  be specified.
	PrimaryNameservers []*PrimaryNameserverInput `json:"primary_nameservers,omitempty" jsonschema:"Primary nameservers for zone transfer. Required when mode is secondary; forbidden when mode is primary. In secondary mode; Hetzner Cloud pulls DNS records from these nameservers via AXFR/IXFR. At leas..."`
	// DNS record sets. Each entry manages all records for a unique
	//  (name, type) pair using hcloud_zone_rrset.
	//
	//  Only valid when mode is primary. In secondary mode, records are
	//  pulled from the primary nameserver and cannot be managed here.
	RecordSets []*RecordSetInput `json:"record_sets,omitempty" jsonschema:"DNS record sets. Each entry manages all records for a unique (name; type) pair using hcloud_zone_rrset. Only valid when mode is primary. In secondary mode; records are pulled from the primary nameserv..."`
	// Prevent accidental deletion of the zone via the Hetzner Cloud API.
	//  When enabled, the zone cannot be deleted until protection is removed.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"Prevent accidental deletion of the zone via the Hetzner Cloud API. When enabled; the zone cannot be deleted until protection is removed."`
}

func (s *HetznerCloudDnsZoneSpecInput) validate() error {
	if s.Mode == "" {
		return fmt.Errorf("mode is required")
	}
	switch s.Mode {
	case "primary", "secondary":
	default:
		return fmt.Errorf("invalid mode: %q", s.Mode)
	}
	for i, v := range s.PrimaryNameservers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("primary_nameservers[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RecordSets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("record_sets[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *HetznerCloudDnsZoneSpecInput) applyDefaults() {
	if s.Ttl == 0 {
		s.Ttl = 3600
	}
}

func (s *HetznerCloudDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DomainName != "" {
		m["domain_name"] = s.DomainName
	}
	m["mode"] = s.Mode
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	if len(s.PrimaryNameservers) > 0 {
		items := make([]any, len(s.PrimaryNameservers))
		for i, v := range s.PrimaryNameservers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["primary_nameservers"] = items
	}
	if len(s.RecordSets) > 0 {
		items := make([]any, len(s.RecordSets))
		for i, v := range s.RecordSets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["record_sets"] = items
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	return m
}

// PrimaryNameserver configures an external primary nameserver for
//
//	secondary zone mode. Hetzner Cloud connects to this server to
//	perform zone transfers.
type PrimaryNameserverInput struct {
	// Public IPv4 or IPv6 address of the primary nameserver.
	Address string `json:"address,omitempty" jsonschema:"Public IPv4 or IPv6 address of the primary nameserver."`
	// Port of the primary nameserver.
	//
	//  Default: 53
	Port int32 `json:"port,omitempty" jsonschema:"Port of the primary nameserver. Default: 53"`
	// Transaction Signature (TSIG) algorithm for authenticating zone
	//  transfers. Common values: "hmac-sha256", "hmac-sha512".
	//  Leave empty if the primary does not require TSIG authentication.
	TsigAlgorithm string `json:"tsig_algorithm,omitempty" jsonschema:"Transaction Signature (TSIG) algorithm for authenticating zone transfers. Common values: 'hmac-sha256'; 'hmac-sha512'. Leave empty if the primary does not require TSIG authentication."`
	// Transaction Signature (TSIG) key for authenticating zone transfers.
	//  SENSITIVE: This is a shared secret between the primary and
	//  secondary nameservers.
	//  Leave empty if the primary does not require TSIG authentication.
	TsigKey string `json:"tsig_key,omitempty" jsonschema:"Transaction Signature (TSIG) key for authenticating zone transfers. SENSITIVE: This is a shared secret between the primary and secondary nameservers. Leave empty if the primary does not require TSIG a..."`
}

func (s *PrimaryNameserverInput) validate() error {
	return nil
}

func (s *PrimaryNameserverInput) applyDefaults() {
	if s.Port == 0 {
		s.Port = 53
	}
}

func (s *PrimaryNameserverInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Address != "" {
		m["address"] = s.Address
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.TsigAlgorithm != "" {
		m["tsig_algorithm"] = s.TsigAlgorithm
	}
	if s.TsigKey != "" {
		m["tsig_key"] = s.TsigKey
	}
	return m
}

// RecordSet defines a group of DNS records sharing the same name and
//
//	type. Each RecordSet maps to one hcloud_zone_rrset resource.
//
//	The combination of (name, type) must be unique within the zone.
//	Changing name or type forces replacement of the record set;
//	updating record values or TTL is done in-place.
type RecordSetInput struct {
	// Record name relative to the zone.
	//
	//  Use "@" for the zone apex (e.g., A record for "example.com"
	//  itself), or a subdomain label (e.g., "www", "mail", "api").
	//  Use "*" for wildcard records.
	Name string `json:"name,omitempty" jsonschema:"Record name relative to the zone. Use '@' for the zone apex (e.g.; A record for 'example.com' itself); or a subdomain label (e.g.; 'www'; 'mail'; 'api'). Use '*' for wildcard records."`
	// DNS record type. Standard types: "A", "AAAA", "CNAME", "MX",
	//  "TXT", "NS", "SRV", "CAA", "PTR", "TLSA", "DS".
	Type string `json:"type,omitempty" jsonschema:"DNS record type. Standard types: 'A'; 'AAAA'; 'CNAME'; 'MX'; 'TXT'; 'NS'; 'SRV'; 'CAA'; 'PTR'; 'TLSA'; 'DS'."`
	// TTL override for this record set, in seconds. When unset,
	//  inherits the zone's default TTL.
	Ttl int32 `json:"ttl,omitempty" jsonschema:"TTL override for this record set; in seconds. When unset; inherits the zone's default TTL."`
	// Record values. At least one value is required per record set.
	//
	//  For most record types a single value suffices (CNAME, PTR).
	//  Multiple values are used for round-robin A/AAAA records, multiple
	//  MX servers, multiple TXT entries (e.g., SPF + DKIM), etc.
	Records []*RecordValueInput `json:"records,omitempty" jsonschema:"Record values. At least one value is required per record set. For most record types a single value suffices (CNAME; PTR). Multiple values are used for round-robin A/AAAA records; multiple MX servers; ..."`
}

func (s *RecordSetInput) validate() error {
	if len(s.Records) < 1 {
		return fmt.Errorf("records requires at least 1 items, got %d", len(s.Records))
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *RecordSetInput) applyDefaults() {
}

func (s *RecordSetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// RecordValue holds a single DNS record value within a record set.
type RecordValueInput struct {
	// The record value. Format depends on the record type:
	//    - A:     IPv4 address (e.g., "93.184.216.34")
	//    - AAAA:  IPv6 address (e.g., "2606:2800:220:1:248:1893:25c8:1946")
	//    - CNAME: Hostname with trailing dot (e.g., "example.com.")
	//    - MX:    Priority and hostname (e.g., "10 mail.example.com.")
	//  ...
	Value string `json:"value" jsonschema:"required,The record value. Format depends on the record type: - A: IPv4 address (e.g.; '93.184.216.34') - AAAA: IPv6 address (e.g.; '2606:2800:220:1:248:1893:25c8:1946') - CNAME: Hostname with trailing dot (e...."`
	// Optional comment for this record.
	Comment string `json:"comment,omitempty" jsonschema:"Optional comment for this record."`
}

func (s *RecordValueInput) validate() error {
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *RecordValueInput) applyDefaults() {
}

func (s *RecordValueInput) toMap() map[string]any {
	m := make(map[string]any)
	m["value"] = s.Value
	if s.Comment != "" {
		m["comment"] = s.Comment
	}
	return m
}

// ParseHetznerCloudDnsZone validates and normalizes a HetznerCloudDnsZone cloud_object.
func ParseHetznerCloudDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
