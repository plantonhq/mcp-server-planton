// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-load-balancer
type HetznerCloudLoadBalancerSpecInput struct {
	// Load balancer size that determines connection and bandwidth limits.
	//
	//  Available types: "lb11" (25 targets, 10k connections/s),
	//  "lb21" (75 targets, 20k connections/s), "lb31" (150 targets,
	//  40k connections/s).
	//
	//  Can be changed after creation (in-place resize).
	LoadBalancerType string `json:"load_balancer_type,omitempty" jsonschema:"Load balancer size that determines connection and bandwidth limits. Available types: 'lb11' (25 targets; 10k connections/s); 'lb21' (75 targets; 20k connections/s); 'lb31' (150 targets; 40k connection..."`
	// Hetzner Cloud location for the load balancer (e.g., "fsn1", "nbg1",
	//  "hel1", "ash", "hil", "sin"). Determines the physical datacenter.
	//
	//  Server targets must be reachable from this location. When using a
	//  private network, the network must have a subnet in the same network
	//  zone as this location.
	//
	//  Ch...
	Location string `json:"location,omitempty" jsonschema:"Hetzner Cloud location for the load balancer (e.g.; 'fsn1'; 'nbg1'; 'hel1'; 'ash'; 'hil'; 'sin'). Determines the physical datacenter. Server targets must be reachable from this location. When using a ..."`
	// Traffic distribution algorithm. Determines how the load balancer
	//  selects a target for each incoming connection.
	//
	//  Default: round_robin (if unspecified or algorithm_unspecified).
	Algorithm string `json:"algorithm,omitempty" jsonschema:"enum=round_robin|least_connections,Traffic distribution algorithm. Determines how the load balancer selects a target for each incoming connection. Default: round_robin (if unspecified or algorithm_unspecified)."`
	// Services (listeners) that the load balancer exposes. Each service
	//  binds to a listen_port and forwards traffic to targets on a
	//  destination_port using the specified protocol.
	//
	//  At least one service is required -- a load balancer without services
	//  cannot accept traffic.
	Services []*ServiceInput `json:"services,omitempty" jsonschema:"Services (listeners) that the load balancer exposes. Each service binds to a listen_port and forwards traffic to targets on a destination_port using the specified protocol. At least one service is req..."`
	// Server targets. Each entry adds a specific server as a backend.
	//  The server must be reachable from the load balancer's location.
	ServerTargets []*ServerTargetInput `json:"server_targets,omitempty" jsonschema:"Server targets. Each entry adds a specific server as a backend. The server must be reachable from the load balancer's location."`
	// Label selector targets. Each entry dynamically adds all servers
	//  matching a Hetzner Cloud label selector as backends. Servers are
	//  auto-discovered and may change as labels are added or removed.
	LabelSelectorTargets []*LabelSelectorTargetInput `json:"label_selector_targets,omitempty" jsonschema:"Label selector targets. Each entry dynamically adds all servers matching a Hetzner Cloud label selector as backends. Servers are auto-discovered and may change as labels are added or removed."`
	// IP targets. Each entry adds an external IP address as a backend.
	//  Use this for targets outside of Hetzner Cloud.
	IpTargets []*IpTargetInput `json:"ip_targets,omitempty" jsonschema:"IP targets. Each entry adds an external IP address as a backend. Use this for targets outside of Hetzner Cloud."`
	// Private network attachment. Optional. When set, the load balancer
	//  is attached to the specified Hetzner Cloud network and receives a
	//  private IP within the network's subnet range. Target traffic can
	//  then flow over the private network instead of the public internet.
	//
	//  A load balancer can be attached...
	Network *NetworkAttachmentInput `json:"network,omitempty" jsonschema:"Private network attachment. Optional. When set; the load balancer is attached to the specified Hetzner Cloud network and receives a private IP within the network's subnet range. Target traffic can the..."`
	// Prevent accidental deletion of the load balancer via the Hetzner
	//  Cloud API. When enabled, the load balancer cannot be deleted until
	//  protection is removed.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"Prevent accidental deletion of the load balancer via the Hetzner Cloud API. When enabled; the load balancer cannot be deleted until protection is removed."`
}

func (s *HetznerCloudLoadBalancerSpecInput) validate() error {
	switch s.Algorithm {
	case "", "round_robin", "least_connections":
	default:
		return fmt.Errorf("invalid algorithm: %q", s.Algorithm)
	}
	if len(s.Services) < 1 {
		return fmt.Errorf("services requires at least 1 items, got %d", len(s.Services))
	}
	for i, v := range s.Services {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("services[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ServerTargets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("server_targets[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.LabelSelectorTargets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("label_selector_targets[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.IpTargets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ip_targets[%d]: %w", i, err)
			}
		}
	}
	if s.Network != nil {
		if err := s.Network.validate(); err != nil {
			return fmt.Errorf("network: %w", err)
		}
	}
	return nil
}

func (s *HetznerCloudLoadBalancerSpecInput) applyDefaults() {
	if s.Network != nil {
		s.Network.applyDefaults()
	}
}

func (s *HetznerCloudLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.LoadBalancerType != "" {
		m["load_balancer_type"] = s.LoadBalancerType
	}
	if s.Location != "" {
		m["location"] = s.Location
	}
	if s.Algorithm != "" {
		m["algorithm"] = s.Algorithm
	}
	if len(s.Services) > 0 {
		items := make([]any, len(s.Services))
		for i, v := range s.Services {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["services"] = items
	}
	if len(s.ServerTargets) > 0 {
		items := make([]any, len(s.ServerTargets))
		for i, v := range s.ServerTargets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["server_targets"] = items
	}
	if len(s.LabelSelectorTargets) > 0 {
		items := make([]any, len(s.LabelSelectorTargets))
		for i, v := range s.LabelSelectorTargets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["label_selector_targets"] = items
	}
	if len(s.IpTargets) > 0 {
		items := make([]any, len(s.IpTargets))
		for i, v := range s.IpTargets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ip_targets"] = items
	}
	if s.Network != nil {
		m["network"] = s.Network.toMap()
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	return m
}

// HealthCheck configures how the load balancer verifies that targets
//
//	are healthy and able to receive traffic.
//
//	All fields except port are optional when the health check block is
//	present. Unset fields receive sensible defaults documented on each
//	field. This allows minimal overrides like:
//
//	  healthCheck:
//	    port: 8080
//	    http:
//	      path: /health
type HealthCheckInput struct {
	// Health check protocol. Determines whether the check performs a TCP
	//  connection test or an HTTP request.
	//
	//  Default: matches the parent service's protocol (http -> http,
	//  https -> http, tcp -> tcp). Handled in IaC modules.
	Protocol string `json:"protocol,omitempty" jsonschema:"enum=http|https|tcp,Health check protocol. Determines whether the check performs a TCP connection test or an HTTP request. Default: matches the parent service's protocol (http -> http; https -> http; tcp -> tcp). Handled..."`
	// Port to health-check on the target. Required when the health check
	//  block is present.
	//
	//  Default: matches the parent service's destination_port. Handled in
	//  IaC modules.
	Port int32 `json:"port,omitempty" jsonschema:"Port to health-check on the target. Required when the health check block is present. Default: matches the parent service's destination_port. Handled in IaC modules."`
	// Time between health checks in seconds.
	//
	//  Default: 15
	Interval int32 `json:"interval,omitempty" jsonschema:"Time between health checks in seconds. Default: 15"`
	// Maximum time to wait for a health check response in seconds. Must
	//  be less than interval.
	//
	//  Default: 10
	Timeout int32 `json:"timeout,omitempty" jsonschema:"Maximum time to wait for a health check response in seconds. Must be less than interval. Default: 10"`
	// Number of consecutive failed checks before a target is marked
	//  unhealthy.
	//
	//  Default: 3
	Retries int32 `json:"retries,omitempty" jsonschema:"Number of consecutive failed checks before a target is marked unhealthy. Default: 3"`
	// HTTP-specific health check settings. Only used when the health
	//  check protocol is http or https.
	Http *HealthCheckHttpInput `json:"http,omitempty" jsonschema:"HTTP-specific health check settings. Only used when the health check protocol is http or https."`
}

func (s *HealthCheckInput) validate() error {
	switch s.Protocol {
	case "", "http", "https", "tcp":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	if s.Http != nil {
		if err := s.Http.validate(); err != nil {
			return fmt.Errorf("http: %w", err)
		}
	}
	return nil
}

func (s *HealthCheckInput) applyDefaults() {
	if s.Interval == 0 {
		s.Interval = 15
	}
	if s.Timeout == 0 {
		s.Timeout = 10
	}
	if s.Retries == 0 {
		s.Retries = 3
	}
	if s.Http != nil {
		s.Http.applyDefaults()
	}
}

func (s *HealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Interval != 0 {
		m["interval"] = s.Interval
	}
	if s.Timeout != 0 {
		m["timeout"] = s.Timeout
	}
	if s.Retries != 0 {
		m["retries"] = s.Retries
	}
	if s.Http != nil {
		m["http"] = s.Http.toMap()
	}
	return m
}

// HealthCheckHttp holds HTTP-specific settings for health checks.
type HealthCheckHttpInput struct {
	// Domain name to send in the HTTP Host header for the health check
	//  request. If empty, the target's IP address is used.
	Domain string `json:"domain,omitempty" jsonschema:"Domain name to send in the HTTP Host header for the health check request. If empty; the target's IP address is used."`
	// URL path for the health check request.
	//
	//  Default: "/" (provider default when not specified).
	Path string `json:"path,omitempty" jsonschema:"URL path for the health check request. Default: '/' (provider default when not specified)."`
	// Expected response body substring. If set, the health check only
	//  passes when the response body contains this string.
	Response string `json:"response,omitempty" jsonschema:"Expected response body substring. If set; the health check only passes when the response body contains this string."`
	// Verify the target's TLS certificate when performing the health
	//  check. Only meaningful when the health check protocol is https.
	Tls bool `json:"tls,omitempty" jsonschema:"Verify the target's TLS certificate when performing the health check. Only meaningful when the health check protocol is https."`
	// Expected HTTP status codes. The health check passes when the
	//  response status matches any code in this list.
	//
	//  Default: ["2??", "3??"] (provider default when not specified).
	//  Uses wildcard notation: "2??" matches any 2xx status.
	StatusCodes []string `json:"status_codes,omitempty" jsonschema:"Expected HTTP status codes. The health check passes when the response status matches any code in this list. Default: ['2??'; '3??'] (provider default when not specified). Uses wildcard notation: '2??'..."`
}

func (s *HealthCheckHttpInput) validate() error {
	return nil
}

func (s *HealthCheckHttpInput) applyDefaults() {
}

func (s *HealthCheckHttpInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Domain != "" {
		m["domain"] = s.Domain
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Response != "" {
		m["response"] = s.Response
	}
	if s.Tls {
		m["tls"] = s.Tls
	}
	if len(s.StatusCodes) > 0 {
		m["status_codes"] = s.StatusCodes
	}
	return m
}

// HttpConfig holds HTTP-layer settings for http and https services.
type HttpConfigInput struct {
	// Enable cookie-based session affinity. When true, the load balancer
	//  sets a cookie on the first response and routes subsequent requests
	//  with that cookie to the same target.
	StickySessions bool `json:"sticky_sessions,omitempty" jsonschema:"Enable cookie-based session affinity. When true; the load balancer sets a cookie on the first response and routes subsequent requests with that cookie to the same target."`
	// Name of the sticky session cookie. Only used when sticky_sessions
	//  is true.
	//
	//  Default: "HCLBSTICKY" (provider default when not specified).
	CookieName string `json:"cookie_name,omitempty" jsonschema:"Name of the sticky session cookie. Only used when sticky_sessions is true. Default: 'HCLBSTICKY' (provider default when not specified)."`
	// Lifetime of the sticky session cookie in seconds. Only used when
	//  sticky_sessions is true.
	//
	//  Default: 300 (provider default when not specified or 0).
	CookieLifetime int32 `json:"cookie_lifetime,omitempty" jsonschema:"Lifetime of the sticky session cookie in seconds. Only used when sticky_sessions is true. Default: 300 (provider default when not specified or 0)."`
	// TLS certificates for HTTPS termination. Only used when the parent
	//  service protocol is https.
	//
	//  Each entry accepts a literal Hetzner Cloud certificate ID (as a
	//  string) or a reference to a HetznerCloudCertificate resource's
	//  output via valueFrom.
	//
	//  Example (reference):
	//    certificateIds:
	//      - valu...
	CertificateIds []string `json:"certificate_ids,omitempty" jsonschema:"TLS certificates for HTTPS termination. Only used when the parent service protocol is https. Each entry accepts a literal Hetzner Cloud certificate ID (as a string) or a reference to a HetznerCloudCer..."`
	// Redirect all HTTP traffic to HTTPS. Only valid for https services
	//  that use the default listen port (443). When enabled, the load
	//  balancer automatically creates an HTTP-to-HTTPS redirect on port
	//  80.
	RedirectHttp bool `json:"redirect_http,omitempty" jsonschema:"Redirect all HTTP traffic to HTTPS. Only valid for https services that use the default listen port (443). When enabled; the load balancer automatically creates an HTTP-to-HTTPS redirect on port 80."`
}

func (s *HttpConfigInput) validate() error {
	return nil
}

func (s *HttpConfigInput) applyDefaults() {
}

func (s *HttpConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.StickySessions {
		m["sticky_sessions"] = s.StickySessions
	}
	if s.CookieName != "" {
		m["cookie_name"] = s.CookieName
	}
	if s.CookieLifetime != 0 {
		m["cookie_lifetime"] = s.CookieLifetime
	}
	if len(s.CertificateIds) > 0 {
		m["certificate_ids"] = s.CertificateIds
	}
	if s.RedirectHttp {
		m["redirect_http"] = s.RedirectHttp
	}
	return m
}

// IpTarget adds an external IP address as a load balancer backend.
//
//	Use this for targets outside of Hetzner Cloud.
type IpTargetInput struct {
	// IP address of the external backend.
	//
	//  Changing this value forces replacement of the target.
	Ip string `json:"ip,omitempty" jsonschema:"IP address of the external backend. Changing this value forces replacement of the target."`
}

func (s *IpTargetInput) validate() error {
	return nil
}

func (s *IpTargetInput) applyDefaults() {
}

func (s *IpTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Ip != "" {
		m["ip"] = s.Ip
	}
	return m
}

// LabelSelectorTarget dynamically adds all Hetzner Cloud servers
//
//	matching a label selector as load balancer backends.
//
//	Servers are auto-discovered based on the selector expression. As
//	server labels change, the target set updates automatically. This is
//	useful for auto-scaling scenarios but means the exact target set is
//	not captured in the manifest.
type LabelSelectorTargetInput struct {
	// Hetzner Cloud label selector expression. All servers matching this
	//  selector are added as targets.
	//
	//  Example: "env=production,role=web"
	//
	//  Changing this value forces replacement of the target.
	Selector string `json:"selector,omitempty" jsonschema:"Hetzner Cloud label selector expression. All servers matching this selector are added as targets. Example: 'env=production;role=web' Changing this value forces replacement of the target."`
	// Route traffic to servers' private IPs instead of their public IPs.
	//  Requires the load balancer and all matching servers to be attached
	//  to the same private network.
	UsePrivateIp bool `json:"use_private_ip,omitempty" jsonschema:"Route traffic to servers' private IPs instead of their public IPs. Requires the load balancer and all matching servers to be attached to the same private network."`
}

func (s *LabelSelectorTargetInput) validate() error {
	return nil
}

func (s *LabelSelectorTargetInput) applyDefaults() {
}

func (s *LabelSelectorTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Selector != "" {
		m["selector"] = s.Selector
	}
	if s.UsePrivateIp {
		m["use_private_ip"] = s.UsePrivateIp
	}
	return m
}

// ServerTarget adds a specific Hetzner Cloud server as a load balancer
//
//	backend. The server must be reachable from the load balancer's
//	location.
type ServerTargetInput struct {
	// Server to add as a target.
	//
	//  Accepts a literal Hetzner Cloud server ID (as a string) or a
	//  reference to a HetznerCloudServer resource's output via valueFrom.
	//
	//  Changing this value forces replacement of the target.
	//
	//  Example (reference):
	//    serverId:
	//      valueFrom:
	//        kind: HetznerCloudServer
	//   ...
	ServerId string `json:"server_id" jsonschema:"required,Server to add as a target. Accepts a literal Hetzner Cloud server ID (as a string) or a reference to a HetznerCloudServer resource's output via valueFrom. Changing this value forces replacement of the..."`
	// Route traffic to the server's private IP instead of its public IP.
	//  Requires the load balancer and server to be attached to the same
	//  private network.
	UsePrivateIp bool `json:"use_private_ip,omitempty" jsonschema:"Route traffic to the server's private IP instead of its public IP. Requires the load balancer and server to be attached to the same private network."`
}

func (s *ServerTargetInput) validate() error {
	if s.ServerId == "" {
		return fmt.Errorf("server_id is required")
	}
	return nil
}

func (s *ServerTargetInput) applyDefaults() {
}

func (s *ServerTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["server_id"] = s.ServerId
	if s.UsePrivateIp {
		m["use_private_ip"] = s.UsePrivateIp
	}
	return m
}

// Service defines a listener on the load balancer that accepts traffic
//
//	on a protocol/port combination and forwards it to targets.
//
//	Each service binds to a unique listen_port on the load balancer. The
//	combination of protocol + listen_port identifies the service (both are
//	ForceNew in the provider -- changing either replaces the service).
type ServiceInput struct {
	// Listener protocol. Determines how the load balancer processes
	//  incoming connections for this service.
	Protocol string `json:"protocol" jsonschema:"required,enum=http|https|tcp,Listener protocol. Determines how the load balancer processes incoming connections for this service."`
	// Port the load balancer listens on for this service.
	//
	//  Must be unique across all services on the same load balancer.
	//  Defaults to 80 for HTTP, 443 for HTTPS. Required for TCP.
	//
	//  Changing this value forces replacement of the service.
	ListenPort int32 `json:"listen_port,omitempty" jsonschema:"Port the load balancer listens on for this service. Must be unique across all services on the same load balancer. Defaults to 80 for HTTP; 443 for HTTPS. Required for TCP. Changing this value forces r..."`
	// Port on the target servers that receives forwarded traffic.
	//
	//  Defaults to the listen_port value for HTTP and HTTPS. Required
	//  for TCP.
	DestinationPort int32 `json:"destination_port,omitempty" jsonschema:"Port on the target servers that receives forwarded traffic. Defaults to the listen_port value for HTTP and HTTPS. Required for TCP."`
	// Enable PROXY protocol (v1) when forwarding to targets. The target
	//  application must support PROXY protocol to parse the original
	//  client IP from the PROXY header.
	Proxyprotocol bool `json:"proxyprotocol,omitempty" jsonschema:"Enable PROXY protocol (v1) when forwarding to targets. The target application must support PROXY protocol to parse the original client IP from the PROXY header."`
	// HTTP-level configuration. Only applicable when protocol is http or
	//  https. Ignored for tcp services.
	Http *HttpConfigInput `json:"http,omitempty" jsonschema:"HTTP-level configuration. Only applicable when protocol is http or https. Ignored for tcp services."`
	// Health check configuration for this service. Optional -- when not
	//  set, the provider creates a default health check matching the
	//  service protocol and destination port.
	//
	//  Set this to customize the health check path, interval, thresholds,
	//  or to use a different protocol than the service (e.g., TCP he...
	HealthCheck *HealthCheckInput `json:"health_check,omitempty" jsonschema:"Health check configuration for this service. Optional -- when not set; the provider creates a default health check matching the service protocol and destination port. Set this to customize the health ..."`
}

func (s *ServiceInput) validate() error {
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	switch s.Protocol {
	case "http", "https", "tcp":
	default:
		return fmt.Errorf("invalid protocol: %q", s.Protocol)
	}
	if s.Http != nil {
		if err := s.Http.validate(); err != nil {
			return fmt.Errorf("http: %w", err)
		}
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	return nil
}

func (s *ServiceInput) applyDefaults() {
	if s.Http != nil {
		s.Http.applyDefaults()
	}
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *ServiceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["protocol"] = s.Protocol
	if s.ListenPort != 0 {
		m["listen_port"] = s.ListenPort
	}
	if s.DestinationPort != 0 {
		m["destination_port"] = s.DestinationPort
	}
	if s.Proxyprotocol {
		m["proxyprotocol"] = s.Proxyprotocol
	}
	if s.Http != nil {
		m["http"] = s.Http.toMap()
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	return m
}

// ParseHetznerCloudLoadBalancer validates and normalizes a HetznerCloudLoadBalancer cloud_object.
func ParseHetznerCloudLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
