// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package hetznercloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// hetznercloud-floating-ip
type HetznerCloudFloatingIpSpecInput struct {
	// IP address type. Determines whether an IPv4 address or an IPv6 /64
	//  network block is allocated.
	//
	//  Changing this value forces replacement of the Floating IP resource.
	Type string `json:"type" jsonschema:"required,enum=ipv4|ipv6,IP address type. Determines whether an IPv4 address or an IPv6 /64 network block is allocated. Changing this value forces replacement of the Floating IP resource."`
	// Hetzner Cloud location where the Floating IP is homed (e.g., "fsn1",
	//  "nbg1", "hel1", "ash", "hil", "sin"). The Floating IP can only be
	//  assigned to servers in the same location.
	//
	//  Changing this value forces replacement of the Floating IP resource.
	HomeLocation string `json:"home_location,omitempty" jsonschema:"Hetzner Cloud location where the Floating IP is homed (e.g.; 'fsn1'; 'nbg1'; 'hel1'; 'ash'; 'hil'; 'sin'). The Floating IP can only be assigned to servers in the same location. Changing this value for..."`
	// Human-readable description for the Floating IP. Visible in the
	//  Hetzner Cloud console and API. Useful for documenting the IP's
	//  purpose (e.g., "Production web frontend failover IP").
	Description string `json:"description,omitempty" jsonschema:"Human-readable description for the Floating IP. Visible in the Hetzner Cloud console and API. Useful for documenting the IP's purpose (e.g.; 'Production web frontend failover IP')."`
	// Server to assign this Floating IP to. Optional.
	//
	//  Accepts a literal Hetzner Cloud server ID (as a string) or a reference
	//  to a HetznerCloudServer resource's output via valueFrom. The referenced
	//  server must be in the same location as home_location.
	//
	//  If omitted, the Floating IP is created unassigned...
	ServerId string `json:"server_id,omitempty" jsonschema:"Server to assign this Floating IP to. Optional. Accepts a literal Hetzner Cloud server ID (as a string) or a reference to a HetznerCloudServer resource's output via valueFrom. The referenced server mu..."`
	// Reverse DNS pointer record for the allocated IP address. If set, an
	//  hcloud_rdns resource is created that maps the IP to this hostname.
	//
	//  Commonly used for mail servers (SPF/DKIM verification relies on matching
	//  forward and reverse DNS) and any service where clients verify the server's
	//  identity via...
	DnsPtr string `json:"dns_ptr,omitempty" jsonschema:"Reverse DNS pointer record for the allocated IP address. If set; an hcloud_rdns resource is created that maps the IP to this hostname. Commonly used for mail servers (SPF/DKIM verification relies on m..."`
	// Prevent accidental deletion of the Floating IP via the Hetzner Cloud API.
	//  When enabled, the IP cannot be deleted until protection is removed.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"Prevent accidental deletion of the Floating IP via the Hetzner Cloud API. When enabled; the IP cannot be deleted until protection is removed."`
}

func (s *HetznerCloudFloatingIpSpecInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "ipv4", "ipv6":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *HetznerCloudFloatingIpSpecInput) applyDefaults() {
}

func (s *HetznerCloudFloatingIpSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.HomeLocation != "" {
		m["home_location"] = s.HomeLocation
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.ServerId != "" {
		m["server_id"] = s.ServerId
	}
	if s.DnsPtr != "" {
		m["dns_ptr"] = s.DnsPtr
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	return m
}

// ParseHetznerCloudFloatingIp validates and normalizes a HetznerCloudFloatingIp cloud_object.
func ParseHetznerCloudFloatingIp(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "hetzner-cloud.openmcf.org/v1", "HetznerCloudFloatingIp"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec HetznerCloudFloatingIpSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
