// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackFloatingIp is a Kubernetes Resource Model (KRM) style resource
//
//	for managing OpenStack Neutron floating IP allocations.
//
//	A floating IP provides external (public) connectivity to instances or ports
//	on tenant networks. It is allocated from an external provider network and can
//	optionally be associated with a port for immediate connectivity.
//
//	For DAG-visible association in InfraCharts, allocate the floating IP without
//	port_id and use the separate OpenStackFloatingIpAssociate component.
//
//	Use this component for:
//	  - Allocating public IP addresses from an external network
//	  - Optionally binding the IP to a port in the same manifest (built-in association)
//	  - Reserving specific IP addresses for DNS or firewall pre-configuration
//
//	Use OpenStackFloatingIpAssociate for:
//	  - Associating an existing floating IP with a port as a separate DAG node
//	  - InfraCharts where the association must be visually explicit as a dependency
type OpenStackFloatingIpSpecInput struct {
	// floating_network_id is the ID of the external (provider) network from which
	//  the floating IP is allocated. This is the pool of public IP addresses.
	//  Maps to the Terraform "pool" attribute.
	//  Can reference an OpenStackNetwork resource's output or be a literal network UUID.
	FloatingNetworkId string `json:"floating_network_id" jsonschema:"required,floating_network_id is the ID of the external (provider) network from which the floating IP is allocated. This is the pool of public IP addresses. Maps to the Terraform 'pool' attribute. Can reference..."`
	// port_id is the ID of an existing port to associate with this floating IP.
	//  When set, the floating IP is immediately bound to the port, providing
	//  external connectivity to whatever is attached to that port (typically an instance).
	//  Optional: omit for allocation-only (use OpenStackFloatingIpAssociate ...
	PortId string `json:"port_id,omitempty" jsonschema:"port_id is the ID of an existing port to associate with this floating IP. When set; the floating IP is immediately bound to the port; providing external connectivity to whatever is attached to that po..."`
	// fixed_ip specifies which fixed IP address on the port to associate the
	//  floating IP with. Only relevant when port_id is set and the port has
	//  multiple IP addresses. If the port has a single IP, this can be omitted.
	FixedIp string `json:"fixed_ip,omitempty" jsonschema:"fixed_ip specifies which fixed IP address on the port to associate the floating IP with. Only relevant when port_id is set and the port has multiple IP addresses. If the port has a single IP; this can..."`
	// subnet_id is the UUID of a subnet within the external network from which
	//  to allocate the floating IP. This references an admin-managed subnet on the
	//  provider network. If omitted, OpenStack allocates from any available subnet.
	SubnetId string `json:"subnet_id,omitempty" jsonschema:"subnet_id is the UUID of a subnet within the external network from which to allocate the floating IP. This references an admin-managed subnet on the provider network. If omitted; OpenStack allocates f..."`
	// address requests a specific floating IP address from the pool.
	//  If omitted, OpenStack allocates any available address.
	//  This is a create-time setting (ForceNew in Terraform).
	//  Use case: DNS pre-configuration, firewall whitelisting, IP reservation.
	Address string `json:"address,omitempty" jsonschema:"address requests a specific floating IP address from the pool. If omitted; OpenStack allocates any available address. This is a create-time setting (ForceNew in Terraform). Use case: DNS pre-configura..."`
	// description is a human-readable description of the floating IP.
	//  Stored on the OpenStack resource and visible in Horizon and API responses.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the floating IP. Stored on the OpenStack resource and visible in Horizon and API responses."`
	// tags are string tags to associate with the floating IP in OpenStack.
	//  Tags are stored on the OpenStack resource and can be used for filtering
	//  and organization in the OpenStack API and Horizon dashboard.
	Tags []string `json:"tags,omitempty" jsonschema:"tags are string tags to associate with the floating IP in OpenStack. Tags are stored on the OpenStack resource and can be used for filtering and organization in the OpenStack API and Horizon dashboard..."`
	// region overrides the region from the provider config for this floating IP.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this floating IP. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackFloatingIpSpecInput) validate() error {
	if s.FloatingNetworkId == "" {
		return fmt.Errorf("floating_network_id is required")
	}
	return nil
}

func (s *OpenStackFloatingIpSpecInput) applyDefaults() {
}

func (s *OpenStackFloatingIpSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["floating_network_id"] = s.FloatingNetworkId
	if s.PortId != "" {
		m["port_id"] = s.PortId
	}
	if s.FixedIp != "" {
		m["fixed_ip"] = s.FixedIp
	}
	if s.SubnetId != "" {
		m["subnet_id"] = s.SubnetId
	}
	if s.Address != "" {
		m["address"] = s.Address
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackFloatingIp validates and normalizes a OpenStackFloatingIp cloud_object.
func ParseOpenStackFloatingIp(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackFloatingIp"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackFloatingIpSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
