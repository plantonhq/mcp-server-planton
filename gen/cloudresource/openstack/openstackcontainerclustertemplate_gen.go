// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackContainerClusterTemplate is a Kubernetes Resource Model (KRM) style resource
//
//	for managing Magnum cluster templates in OpenStack.
//
//	A cluster template is a reusable blueprint that defines the base image, network
//	topology, node flavors, and container orchestration engine for Kubernetes clusters.
//	Templates are referenced by OpenStackContainerCluster resources to create clusters.
type OpenStackContainerClusterTemplateSpecInput struct {
	// (Required) The Container Orchestration Engine for the cluster.
	//  Magnum supports "kubernetes" (actively maintained), "swarm" (deprecated),
	//  and "mesos" (abandoned). In practice, "kubernetes" is the only production choice.
	Coe string `json:"coe,omitempty" jsonschema:"(Required) The Container Orchestration Engine for the cluster. Magnum supports 'kubernetes' (actively maintained); 'swarm' (deprecated); and 'mesos' (abandoned). In practice; 'kubernetes' is the only ..."`
	// (Required) The base OS image for cluster nodes.
	//  Can be a literal image name/UUID or a reference to an OpenStackImage resource.
	//  Example literal: "fedora-coreos-39" (pre-existing image)
	//  Example value_from: reference to an OpenStackImage component
	//
	//  FK: OpenStackImage.status.outputs.image_id
	Image string `json:"image" jsonschema:"required,(Required) The base OS image for cluster nodes. Can be a literal image name/UUID or a reference to an OpenStackImage resource. Example literal: 'fedora-coreos-39' (pre-existing image) Example value_fr..."`
	// (Optional) The SSH keypair for node access.
	//  Can be a literal keypair name or a reference to an OpenStackKeypair resource.
	//
	//  FK: OpenStackKeypair.status.outputs.name
	Keypair string `json:"keypair,omitempty" jsonschema:"(Optional) The SSH keypair for node access. Can be a literal keypair name or a reference to an OpenStackKeypair resource. FK: OpenStackKeypair.status.outputs.name"`
	// (Optional) The external (provider) network for outbound connectivity.
	//  Typically the pre-existing public network in the OpenStack deployment.
	//  Can be a literal network ID/name or a reference to an OpenStackNetwork resource.
	//
	//  FK: OpenStackNetwork.status.outputs.network_id
	ExternalNetwork string `json:"external_network,omitempty" jsonschema:"(Optional) The external (provider) network for outbound connectivity. Typically the pre-existing public network in the OpenStack deployment. Can be a literal network ID/name or a reference to an OpenS..."`
	// (Optional) The fixed (tenant) network for cluster nodes.
	//  Can be a literal network ID/name or a reference to an OpenStackNetwork resource.
	//
	//  FK: OpenStackNetwork.status.outputs.network_id
	FixedNetwork string `json:"fixed_network,omitempty" jsonschema:"(Optional) The fixed (tenant) network for cluster nodes. Can be a literal network ID/name or a reference to an OpenStackNetwork resource. FK: OpenStackNetwork.status.outputs.network_id"`
	// (Optional) The fixed subnet for cluster nodes.
	//  Can be a literal subnet ID/name or a reference to an OpenStackSubnet resource.
	//
	//  FK: OpenStackSubnet.status.outputs.subnet_id
	FixedSubnet string `json:"fixed_subnet,omitempty" jsonschema:"(Optional) The fixed subnet for cluster nodes. Can be a literal subnet ID/name or a reference to an OpenStackSubnet resource. FK: OpenStackSubnet.status.outputs.subnet_id"`
	// (Optional) The network driver for the container network.
	//  Common values: "flannel", "calico".
	//  If omitted, Magnum uses its deployment default.
	NetworkDriver string `json:"network_driver,omitempty" jsonschema:"(Optional) The network driver for the container network. Common values: 'flannel'; 'calico'. If omitted; Magnum uses its deployment default."`
	// (Optional) The volume driver for container volumes.
	//  Common values: "cinder".
	//  If omitted, Magnum uses its deployment default.
	VolumeDriver string `json:"volume_driver,omitempty" jsonschema:"(Optional) The volume driver for container volumes. Common values: 'cinder'. If omitted; Magnum uses its deployment default."`
	// (Optional) The DNS nameserver address for cluster nodes.
	//  Example: "8.8.8.8"
	DnsNameserver string `json:"dns_nameserver,omitempty" jsonschema:"(Optional) The DNS nameserver address for cluster nodes. Example: '8.8.8.8'"`
	// (Optional) The size (in GB) of the Docker volume for each node.
	//  Only set if > 0. If omitted, Magnum uses its deployment default.
	DockerVolumeSize int32 `json:"docker_volume_size,omitempty" jsonschema:"(Optional) The size (in GB) of the Docker volume for each node. Only set if > 0. If omitted; Magnum uses its deployment default."`
	// (Optional) The Nova flavor for worker nodes.
	//  Example: "m1.medium", "m1.xlarge"
	Flavor string `json:"flavor,omitempty" jsonschema:"(Optional) The Nova flavor for worker nodes. Example: 'm1.medium'; 'm1.xlarge'"`
	// (Optional) The Nova flavor for master nodes.
	//  Example: "m1.large"
	MasterFlavor string `json:"master_flavor,omitempty" jsonschema:"(Optional) The Nova flavor for master nodes. Example: 'm1.large'"`
	// (Optional) Whether to create a floating IP for every cluster node.
	//  Required for external access to nodes when using a private network.
	FloatingIpEnabled bool `json:"floating_ip_enabled,omitempty" jsonschema:"(Optional) Whether to create a floating IP for every cluster node. Required for external access to nodes when using a private network."`
	// (Optional) Whether to create a load balancer for master nodes.
	//  Critical for HA Kubernetes clusters with multiple masters.
	MasterLbEnabled bool `json:"master_lb_enabled,omitempty" jsonschema:"(Optional) Whether to create a load balancer for master nodes. Critical for HA Kubernetes clusters with multiple masters."`
	// (Optional) Whether to disable TLS for the cluster API.
	//  Only set to true for testing environments. Production clusters should use TLS.
	TlsDisabled bool `json:"tls_disabled,omitempty" jsonschema:"(Optional) Whether to disable TLS for the cluster API. Only set to true for testing environments. Production clusters should use TLS."`
	// (Optional) Key-value labels for the cluster template.
	//  Magnum uses labels to configure Kubernetes-specific settings:
	//    - "kube_tag": Kubernetes version (e.g., "v1.28.4")
	//    - "cloud_provider_tag": Cloud controller manager version
	//    - "container_runtime": Container runtime (e.g., "containerd")
	//    -...
	Labels map[string]string `json:"labels,omitempty" jsonschema:"(Optional) Key-value labels for the cluster template. Magnum uses labels to configure Kubernetes-specific settings: - 'kube_tag': Kubernetes version (e.g.; 'v1.28.4') - 'cloud_provider_tag': Cloud con..."`
	// (Optional) Override the region from the provider config.
	//  ForceNew: changing this requires recreating the template.
	Region string `json:"region,omitempty" jsonschema:"(Optional) Override the region from the provider config. ForceNew: changing this requires recreating the template."`
}

func (s *OpenStackContainerClusterTemplateSpecInput) validate() error {
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	return nil
}

func (s *OpenStackContainerClusterTemplateSpecInput) applyDefaults() {
}

func (s *OpenStackContainerClusterTemplateSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Coe != "" {
		m["coe"] = s.Coe
	}
	m["image"] = s.Image
	if s.Keypair != "" {
		m["keypair"] = s.Keypair
	}
	if s.ExternalNetwork != "" {
		m["external_network"] = s.ExternalNetwork
	}
	if s.FixedNetwork != "" {
		m["fixed_network"] = s.FixedNetwork
	}
	if s.FixedSubnet != "" {
		m["fixed_subnet"] = s.FixedSubnet
	}
	if s.NetworkDriver != "" {
		m["network_driver"] = s.NetworkDriver
	}
	if s.VolumeDriver != "" {
		m["volume_driver"] = s.VolumeDriver
	}
	if s.DnsNameserver != "" {
		m["dns_nameserver"] = s.DnsNameserver
	}
	if s.DockerVolumeSize != 0 {
		m["docker_volume_size"] = s.DockerVolumeSize
	}
	if s.Flavor != "" {
		m["flavor"] = s.Flavor
	}
	if s.MasterFlavor != "" {
		m["master_flavor"] = s.MasterFlavor
	}
	if s.FloatingIpEnabled {
		m["floating_ip_enabled"] = s.FloatingIpEnabled
	}
	if s.MasterLbEnabled {
		m["master_lb_enabled"] = s.MasterLbEnabled
	}
	if s.TlsDisabled {
		m["tls_disabled"] = s.TlsDisabled
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackContainerClusterTemplate validates and normalizes a OpenStackContainerClusterTemplate cloud_object.
func ParseOpenStackContainerClusterTemplate(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackContainerClusterTemplate"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackContainerClusterTemplateSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
