// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackNetworkPort is a Kubernetes Resource Model (KRM) style resource
//
//	for managing OpenStack Neutron ports.
//
//	A port provides stable network identity (MAC address, fixed IPs, security
//	groups) on a Neutron network. Explicit ports are preferred over instance-inline
//	networking when you need:
//	  - Stable IP addresses that survive instance rebuilds
//	  - Pre-provisioned network identities for orchestration (InfraCharts)
//	  - Multiple security groups per network attachment
//	  - Specific MAC addresses for licensing or bonding
//
//	Use this component for:
//	  - Creating network interfaces before launching instances
//	  - Wiring floating IPs to specific network endpoints
//	  - Managing security group assignments independently of instances
//
//	Downstream consumers:
//	  - OpenStackFloatingIp.spec.port_id (built-in association)
//	  - OpenStackFloatingIpAssociate.spec.port_id (DAG-visible association)
//	  - OpenStackInstance.spec.networks[].port (future)
type OpenStackNetworkPortSpecInput struct {
	// network_id is the ID of the network to create this port on.
	//  This is the defining relationship -- every port belongs to exactly one network.
	//  ForceNew: changing the network recreates the port.
	//  Can reference an OpenStackNetwork resource's output or be a literal network UUID.
	NetworkId string `json:"network_id" jsonschema:"required,network_id is the ID of the network to create this port on. This is the defining relationship -- every port belongs to exactly one network. ForceNew: changing the network recreates the port. Can refer..."`
	// fixed_ips defines the IP address allocations for this port.
	//  Each entry assigns an IP from a subnet on the port's network.
	//  If omitted, OpenStack auto-assigns one IP from any subnet on the network.
	//  Multiple entries create a multi-homed port (one IP per subnet).
	FixedIps []*FixedIpInput `json:"fixed_ips,omitempty" jsonschema:"fixed_ips defines the IP address allocations for this port. Each entry assigns an IP from a subnet on the port's network. If omitted; OpenStack auto-assigns one IP from any subnet on the network. Mult..."`
	// security_group_ids is the list of security groups to apply to this port.
	//  Each entry can reference an OpenStackSecurityGroup resource's output
	//  (via value_from) or be a literal security group UUID.
	//  If omitted and no_security_groups is false, OpenStack applies the default
	//  security group for the pro...
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"security_group_ids is the list of security groups to apply to this port. Each entry can reference an OpenStackSecurityGroup resource's output (via value_from) or be a literal security group UUID. If o..."`
	// no_security_groups explicitly removes all security groups from this port,
	//  including the default security group that OpenStack normally applies.
	//  Set to true for ports that should have unrestricted traffic (e.g., load
	//  balancer VIPs, network appliance ports).
	//  Mutually exclusive with security_group_...
	NoSecurityGroups bool `json:"no_security_groups,omitempty" jsonschema:"no_security_groups explicitly removes all security groups from this port; including the default security group that OpenStack normally applies. Set to true for ports that should have unrestricted traf..."`
	// admin_state_up controls the administrative state of the port.
	//  When false, the port is administratively down and will not forward traffic.
	//  Default: true
	AdminStateUp bool `json:"admin_state_up,omitempty" jsonschema:"admin_state_up controls the administrative state of the port. When false; the port is administratively down and will not forward traffic. Default: true"`
	// mac_address specifies a specific MAC address for this port.
	//  If omitted, OpenStack auto-assigns a MAC from the network's allocation pool.
	//  ForceNew: changing the MAC recreates the port.
	//  Use case: network bonding, DPDK, or license-tied MAC addresses.
	MacAddress string `json:"mac_address,omitempty" jsonschema:"mac_address specifies a specific MAC address for this port. If omitted; OpenStack auto-assigns a MAC from the network's allocation pool. ForceNew: changing the MAC recreates the port. Use case: networ..."`
	// port_security_enabled controls whether port security is enforced on this port.
	//  When enabled, only traffic matching the port's security groups and allowed
	//  address pairs is permitted. When disabled, all traffic passes regardless of
	//  security groups.
	//  If omitted, inherits from the network's port_secu...
	PortSecurityEnabled bool `json:"port_security_enabled,omitempty" jsonschema:"port_security_enabled controls whether port security is enforced on this port. When enabled; only traffic matching the port's security groups and allowed address pairs is permitted. When disabled; all..."`
	// description is a human-readable description of the port.
	//  Stored on the OpenStack resource and visible in Horizon and API responses.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the port. Stored on the OpenStack resource and visible in Horizon and API responses."`
	// tags are string tags to associate with the port in OpenStack.
	//  Tags are stored on the OpenStack resource and can be used for filtering
	//  and organization in the OpenStack API and Horizon dashboard.
	Tags []string `json:"tags,omitempty" jsonschema:"tags are string tags to associate with the port in OpenStack. Tags are stored on the OpenStack resource and can be used for filtering and organization in the OpenStack API and Horizon dashboard."`
	// region overrides the region from the provider config for this port.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this port. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackNetworkPortSpecInput) validate() error {
	if s.NetworkId == "" {
		return fmt.Errorf("network_id is required")
	}
	for i, v := range s.FixedIps {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("fixed_ips[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenStackNetworkPortSpecInput) applyDefaults() {
	// default: AdminStateUp = true (applied at zero-value)
}

func (s *OpenStackNetworkPortSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["network_id"] = s.NetworkId
	if len(s.FixedIps) > 0 {
		items := make([]any, len(s.FixedIps))
		for i, v := range s.FixedIps {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["fixed_ips"] = items
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.NoSecurityGroups {
		m["no_security_groups"] = s.NoSecurityGroups
	}
	if s.AdminStateUp {
		m["admin_state_up"] = s.AdminStateUp
	}
	if s.MacAddress != "" {
		m["mac_address"] = s.MacAddress
	}
	if s.PortSecurityEnabled {
		m["port_security_enabled"] = s.PortSecurityEnabled
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// FixedIp defines an IP address allocation for a port.
//
//	Each fixed IP binds the port to a subnet and optionally requests a specific
//	IP address from that subnet's allocation pool.
type FixedIpInput struct {
	// subnet_id is the ID of the subnet to allocate an IP address from.
	//  Can reference an OpenStackSubnet resource's output (via value_from for
	//  InfraChart DAG wiring) or be a literal subnet UUID.
	//  If omitted, OpenStack auto-selects a subnet on the port's network.
	SubnetId string `json:"subnet_id,omitempty" jsonschema:"subnet_id is the ID of the subnet to allocate an IP address from. Can reference an OpenStackSubnet resource's output (via value_from for InfraChart DAG wiring) or be a literal subnet UUID. If omitted;..."`
	// ip_address requests a specific IP address from the subnet.
	//  If omitted, an available IP from the subnet's allocation pool is assigned.
	//  The IP must belong to the subnet's CIDR and be within an allocation pool.
	IpAddress string `json:"ip_address,omitempty" jsonschema:"ip_address requests a specific IP address from the subnet. If omitted; an available IP from the subnet's allocation pool is assigned. The IP must belong to the subnet's CIDR and be within an allocatio..."`
}

func (s *FixedIpInput) validate() error {
	return nil
}

func (s *FixedIpInput) applyDefaults() {
}

func (s *FixedIpInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SubnetId != "" {
		m["subnet_id"] = s.SubnetId
	}
	if s.IpAddress != "" {
		m["ip_address"] = s.IpAddress
	}
	return m
}

// ParseOpenStackNetworkPort validates and normalizes a OpenStackNetworkPort cloud_object.
func ParseOpenStackNetworkPort(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackNetworkPort"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackNetworkPortSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
