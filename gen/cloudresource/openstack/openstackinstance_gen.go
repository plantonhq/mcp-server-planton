// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackInstance is a Kubernetes Resource Model (KRM) style resource
//
//	for managing OpenStack Compute instances.
//
//	An instance is a virtual machine running on an OpenStack cloud. It is the
//	fundamental compute resource -- every developer workload, application server,
//	database, and CI runner is an instance.
//
//	Instances bind together networking (networks/ports), storage (images/volumes),
//	access control (keypairs/security groups), and placement (server groups/AZs)
//	into a running virtual machine.
type OpenStackInstanceSpecInput struct {
	// flavor_name is the human-readable name of the instance flavor (e.g., "m1.medium").
	//  This is the most common way to specify instance size.
	//  Mutually exclusive with flavor_id.
	FlavorName string `json:"flavor_name,omitempty" jsonschema:"flavor_name is the human-readable name of the instance flavor (e.g.; 'm1.medium'). This is the most common way to specify instance size. Mutually exclusive with flavor_id."`
	// flavor_id is the UUID of the instance flavor.
	//  Use when you need to reference a specific flavor by ID rather than name.
	//  Mutually exclusive with flavor_name.
	FlavorId string `json:"flavor_id,omitempty" jsonschema:"flavor_id is the UUID of the instance flavor. Use when you need to reference a specific flavor by ID rather than name. Mutually exclusive with flavor_name."`
	// image_name is the name of the Glance image to boot from (e.g., "ubuntu-22.04").
	//  This is the most common way to specify the boot image.
	//  Optional when using block_device with a boot volume.
	ImageName string `json:"image_name,omitempty" jsonschema:"image_name is the name of the Glance image to boot from (e.g.; 'ubuntu-22.04'). This is the most common way to specify the boot image. Optional when using block_device with a boot volume."`
	// image_id is the UUID of the Glance image to boot from.
	//  Alternative to image_name for UUID-based image references.
	//  Optional when using block_device with a boot volume.
	ImageId string `json:"image_id,omitempty" jsonschema:"image_id is the UUID of the Glance image to boot from. Alternative to image_name for UUID-based image references. Optional when using block_device with a boot volume."`
	// key_pair is the name of the SSH keypair to inject into the instance.
	//  Can reference an OpenStackKeypair resource's output name (via value_from
	//  for InfraChart DAG wiring) or be a literal keypair name.
	//  Optional: instances without SSH keys rely on other access methods
	//  (e.g., console, cloud-init pass...
	KeyPair string `json:"key_pair,omitempty" jsonschema:"key_pair is the name of the SSH keypair to inject into the instance. Can reference an OpenStackKeypair resource's output name (via value_from for InfraChart DAG wiring) or be a literal keypair name. O..."`
	// networks defines the network attachments for the instance.
	//  Each entry connects the instance to a network (via UUID) or attaches
	//  a pre-provisioned port (via port). At least one network is required.
	Networks []*InstanceNetworkInput `json:"networks,omitempty" jsonschema:"networks defines the network attachments for the instance. Each entry connects the instance to a network (via UUID) or attaches a pre-provisioned port (via port). At least one network is required."`
	// security_groups is the list of security group names to apply to the instance.
	//  Each entry can reference an OpenStackSecurityGroup resource's output name
	//  (via value_from) or be a literal security group name.
	//  If omitted, OpenStack applies the default security group.
	//
	//  Note: the Compute API uses secu...
	SecurityGroups []string `json:"security_groups,omitempty" jsonschema:"security_groups is the list of security group names to apply to the instance. Each entry can reference an OpenStackSecurityGroup resource's output name (via value_from) or be a literal security group ..."`
	// block_device defines block device mappings for the instance.
	//  Use this for boot-from-volume (persistent root disk) or attaching
	//  additional volumes at launch time.
	//  When using block_device with boot_index=0, image_name/image_id are optional.
	BlockDevice []*BlockDeviceInput `json:"block_device,omitempty" jsonschema:"block_device defines block device mappings for the instance. Use this for boot-from-volume (persistent root disk) or attaching additional volumes at launch time. When using block_device with boot_inde..."`
	// user_data is the cloud-init configuration or script to run at first boot.
	//  Accepts cloud-config YAML, shell scripts, or any cloud-init format.
	//  The value is base64-encoded before being passed to the instance.
	//  ForceNew: changing user_data recreates the instance.
	UserData string `json:"user_data,omitempty" jsonschema:"user_data is the cloud-init configuration or script to run at first boot. Accepts cloud-config YAML; shell scripts; or any cloud-init format. The value is base64-encoded before being passed to the ins..."`
	// metadata is a map of key-value pairs to attach to the instance.
	//  Metadata is visible in the OpenStack API and Horizon dashboard.
	//  Can be updated without recreating the instance.
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"metadata is a map of key-value pairs to attach to the instance. Metadata is visible in the OpenStack API and Horizon dashboard. Can be updated without recreating the instance."`
	// config_drive enables the config drive for metadata delivery.
	//  When true, a small read-only disk is attached containing instance
	//  metadata, user_data, and network config. Useful when DHCP is not
	//  available or for environments requiring metadata on a local disk.
	//  ForceNew: changing config_drive recrea...
	ConfigDrive bool `json:"config_drive,omitempty" jsonschema:"config_drive enables the config drive for metadata delivery. When true; a small read-only disk is attached containing instance metadata; user_data; and network config. Useful when DHCP is not availabl..."`
	// server_group_id is the UUID of the server group for placement control.
	//  Can reference an OpenStackServerGroup resource's output (via value_from
	//  for InfraChart DAG wiring) or be a literal server group UUID.
	//  Maps to scheduler_hints.group in the Terraform/Pulumi resources.
	//  ForceNew: changing the ser...
	ServerGroupId string `json:"server_group_id,omitempty" jsonschema:"server_group_id is the UUID of the server group for placement control. Can reference an OpenStackServerGroup resource's output (via value_from for InfraChart DAG wiring) or be a literal server group U..."`
	// availability_zone specifies the AZ where the instance should be launched.
	//  If omitted, Nova selects an AZ based on its scheduling algorithms.
	//  ForceNew: changing the AZ recreates the instance.
	//  Example: "nova", "az1", "az:host:node"
	AvailabilityZone string `json:"availability_zone,omitempty" jsonschema:"availability_zone specifies the AZ where the instance should be launched. If omitted; Nova selects an AZ based on its scheduling algorithms. ForceNew: changing the AZ recreates the instance. Example: ..."`
	// tags are string tags to associate with the instance in OpenStack.
	//  Tags are stored on the OpenStack resource and can be used for filtering
	//  and organization in the OpenStack API and Horizon dashboard.
	Tags []string `json:"tags,omitempty" jsonschema:"tags are string tags to associate with the instance in OpenStack. Tags are stored on the OpenStack resource and can be used for filtering and organization in the OpenStack API and Horizon dashboard."`
	// region overrides the region from the provider config for this instance.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this instance. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackInstanceSpecInput) validate() error {
	for i, v := range s.Networks {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("networks[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.BlockDevice {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("block_device[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenStackInstanceSpecInput) applyDefaults() {
}

func (s *OpenStackInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.FlavorName != "" {
		m["flavor_name"] = s.FlavorName
	}
	if s.FlavorId != "" {
		m["flavor_id"] = s.FlavorId
	}
	if s.ImageName != "" {
		m["image_name"] = s.ImageName
	}
	if s.ImageId != "" {
		m["image_id"] = s.ImageId
	}
	if s.KeyPair != "" {
		m["key_pair"] = s.KeyPair
	}
	if len(s.Networks) > 0 {
		items := make([]any, len(s.Networks))
		for i, v := range s.Networks {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["networks"] = items
	}
	if len(s.SecurityGroups) > 0 {
		m["security_groups"] = s.SecurityGroups
	}
	if len(s.BlockDevice) > 0 {
		items := make([]any, len(s.BlockDevice))
		for i, v := range s.BlockDevice {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["block_device"] = items
	}
	if s.UserData != "" {
		m["user_data"] = s.UserData
	}
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if s.ConfigDrive {
		m["config_drive"] = s.ConfigDrive
	}
	if s.ServerGroupId != "" {
		m["server_group_id"] = s.ServerGroupId
	}
	if s.AvailabilityZone != "" {
		m["availability_zone"] = s.AvailabilityZone
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// BlockDevice defines a block device mapping for a compute instance.
//
//	Block device mappings control the instance's storage: the boot device,
//	additional volumes, and ephemeral storage. The most common pattern is
//	boot-from-volume (source_type=image, destination_type=volume) for
//	persistent root disks.
type BlockDeviceInput struct {
	// source_type is the type of the source for this block device.
	//  Required.
	//    "image"    - boot from a Glance image (most common)
	//    "volume"   - attach an existing Cinder volume
	//    "snapshot" - create from a volume snapshot
	//    "blank"    - create an empty volume (for additional storage)
	SourceType string `json:"source_type,omitempty" jsonschema:"source_type is the type of the source for this block device. Required. 'image' - boot from a Glance image (most common) 'volume' - attach an existing Cinder volume 'snapshot' - create from a volume sn..."`
	// uuid is the UUID of the source (image, volume, or snapshot).
	//  Required when source_type is not "blank".
	Uuid string `json:"uuid,omitempty" jsonschema:"uuid is the UUID of the source (image; volume; or snapshot). Required when source_type is not 'blank'."`
	// destination_type controls where the block device is created.
	//    "local"  - ephemeral storage on the hypervisor (default for image)
	//    "volume" - persistent Cinder volume (recommended for production)
	DestinationType string `json:"destination_type,omitempty" jsonschema:"destination_type controls where the block device is created. 'local' - ephemeral storage on the hypervisor (default for image) 'volume' - persistent Cinder volume (recommended for production)"`
	// boot_index determines the boot order.
	//    0  - this is the boot device
	//   -1  - not bootable (data volume)
	//    N  - boot priority (lower = higher priority)
	BootIndex int32 `json:"boot_index,omitempty" jsonschema:"boot_index determines the boot order. 0 - this is the boot device -1 - not bootable (data volume) N - boot priority (lower = higher priority)"`
	// volume_size is the size of the block device in GB.
	//  Required for image-to-volume and blank-to-local mappings.
	VolumeSize int32 `json:"volume_size,omitempty" jsonschema:"volume_size is the size of the block device in GB. Required for image-to-volume and blank-to-local mappings."`
	// delete_on_termination controls whether the volume is deleted when
	//  the instance is terminated. Default: false (volume persists).
	DeleteOnTermination bool `json:"delete_on_termination,omitempty" jsonschema:"delete_on_termination controls whether the volume is deleted when the instance is terminated. Default: false (volume persists)."`
	// volume_type specifies the Cinder volume type (e.g., "SSD", "HDD").
	//  Only meaningful when destination_type is "volume".
	VolumeType string `json:"volume_type,omitempty" jsonschema:"volume_type specifies the Cinder volume type (e.g.; 'SSD'; 'HDD'). Only meaningful when destination_type is 'volume'."`
}

func (s *BlockDeviceInput) validate() error {
	return nil
}

func (s *BlockDeviceInput) applyDefaults() {
}

func (s *BlockDeviceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SourceType != "" {
		m["source_type"] = s.SourceType
	}
	if s.Uuid != "" {
		m["uuid"] = s.Uuid
	}
	if s.DestinationType != "" {
		m["destination_type"] = s.DestinationType
	}
	if s.BootIndex != 0 {
		m["boot_index"] = s.BootIndex
	}
	if s.VolumeSize != 0 {
		m["volume_size"] = s.VolumeSize
	}
	if s.DeleteOnTermination {
		m["delete_on_termination"] = s.DeleteOnTermination
	}
	if s.VolumeType != "" {
		m["volume_type"] = s.VolumeType
	}
	return m
}

// InstanceNetwork defines a network attachment for a compute instance.
//
//	Each entry connects the instance to a network either by specifying the
//	network UUID (auto-creates a port) or by attaching a pre-provisioned port
//	(for stable network identity, pre-assigned IPs, or multiple security groups).
type InstanceNetworkInput struct {
	// uuid is the network UUID to attach the instance to.
	//  OpenStack auto-creates a port on this network for the instance.
	//  Can reference an OpenStackNetwork resource's output (via value_from).
	//  Mutually exclusive with port.
	Uuid string `json:"uuid,omitempty" jsonschema:"uuid is the network UUID to attach the instance to. OpenStack auto-creates a port on this network for the instance. Can reference an OpenStackNetwork resource's output (via value_from). Mutually exclu..."`
	// port is the UUID of a pre-provisioned port to attach to the instance.
	//  Use when you need stable MAC/IP addresses, specific security groups,
	//  or other port-level configuration.
	//  Can reference an OpenStackNetworkPort resource's output (via value_from).
	//  Mutually exclusive with uuid.
	Port string `json:"port,omitempty" jsonschema:"port is the UUID of a pre-provisioned port to attach to the instance. Use when you need stable MAC/IP addresses; specific security groups; or other port-level configuration. Can reference an OpenStack..."`
	// fixed_ip_v4 requests a specific IPv4 address on the network.
	//  Only meaningful when uuid is used (not port -- port has its own fixed_ips).
	//  If omitted, an available IP from the subnet's allocation pool is assigned.
	FixedIpV4 string `json:"fixed_ip_v4,omitempty" jsonschema:"fixed_ip_v4 requests a specific IPv4 address on the network. Only meaningful when uuid is used (not port -- port has its own fixed_ips). If omitted; an available IP from the subnet's allocation pool i..."`
	// access_network marks this network as the instance's access network.
	//  The access network determines which IP appears in access_ip_v4 output.
	//  Only one network should be marked as access_network.
	AccessNetwork bool `json:"access_network,omitempty" jsonschema:"access_network marks this network as the instance's access network. The access network determines which IP appears in access_ip_v4 output. Only one network should be marked as access_network."`
}

func (s *InstanceNetworkInput) validate() error {
	return nil
}

func (s *InstanceNetworkInput) applyDefaults() {
}

func (s *InstanceNetworkInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Uuid != "" {
		m["uuid"] = s.Uuid
	}
	if s.Port != "" {
		m["port"] = s.Port
	}
	if s.FixedIpV4 != "" {
		m["fixed_ip_v4"] = s.FixedIpV4
	}
	if s.AccessNetwork {
		m["access_network"] = s.AccessNetwork
	}
	return m
}

// ParseOpenStackInstance validates and normalizes a OpenStackInstance cloud_object.
func ParseOpenStackInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
