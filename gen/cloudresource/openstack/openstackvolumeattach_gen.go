// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackVolumeAttach is a Kubernetes Resource Model (KRM) style resource
//
//	for attaching an OpenStack Cinder volume to a compute instance.
//
//	This is a "join" resource that connects two independently managed resources:
//	  - A volume (created via OpenStackVolume)
//	  - An instance (created via OpenStackInstance)
//
//	In InfraCharts, this component appears as a visible DAG node with dependency
//	edges to both the volume and the instance, making the attachment relationship
//	explicit and transparent. The volume must be in "available" state and the
//	instance must be running before attachment can succeed.
//
//	Volume attachments are the standard way to add persistent storage to instances.
//	Unlike ephemeral storage, attached volumes persist after instance termination
//	and can be detached and reattached to different instances.
type OpenStackVolumeAttachSpecInput struct {
	// instance_id is the ID of the compute instance to attach the volume to.
	//  This is a required foreign key -- every volume attachment must reference
	//  exactly one instance.
	//  Can reference an OpenStackInstance resource's output or be a literal instance UUID.
	InstanceId string `json:"instance_id" jsonschema:"required,instance_id is the ID of the compute instance to attach the volume to. This is a required foreign key -- every volume attachment must reference exactly one instance. Can reference an OpenStackInstance..."`
	// volume_id is the ID of the Cinder volume to attach.
	//  This is a required foreign key -- every volume attachment must reference
	//  exactly one volume.
	//  Can reference an OpenStackVolume resource's output or be a literal volume UUID.
	VolumeId string `json:"volume_id" jsonschema:"required,volume_id is the ID of the Cinder volume to attach. This is a required foreign key -- every volume attachment must reference exactly one volume. Can reference an OpenStackVolume resource's output or b..."`
	// device is the device path where the volume appears inside the instance.
	//  Example: "/dev/vdb", "/dev/vdc".
	//  If omitted, OpenStack (Nova) automatically selects the next available device.
	//  Computed by OpenStack if not specified.
	Device string `json:"device,omitempty" jsonschema:"device is the device path where the volume appears inside the instance. Example: '/dev/vdb'; '/dev/vdc'. If omitted; OpenStack (Nova) automatically selects the next available device. Computed by OpenS..."`
	// region overrides the region from the provider config for this attachment.
	//  If omitted, the region from the OpenStack provider config is used.
	//  ForceNew: changing the region recreates the attachment.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this attachment. If omitted; the region from the OpenStack provider config is used. ForceNew: changing the region recreates the attachment. Exa..."`
}

func (s *OpenStackVolumeAttachSpecInput) validate() error {
	if s.InstanceId == "" {
		return fmt.Errorf("instance_id is required")
	}
	if s.VolumeId == "" {
		return fmt.Errorf("volume_id is required")
	}
	return nil
}

func (s *OpenStackVolumeAttachSpecInput) applyDefaults() {
}

func (s *OpenStackVolumeAttachSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["instance_id"] = s.InstanceId
	m["volume_id"] = s.VolumeId
	if s.Device != "" {
		m["device"] = s.Device
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackVolumeAttach validates and normalizes a OpenStackVolumeAttach cloud_object.
func ParseOpenStackVolumeAttach(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackVolumeAttach"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackVolumeAttachSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
