// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackLoadBalancerPool is a Kubernetes Resource Model (KRM) style resource
//
//	for managing Octavia backend pools in OpenStack.
//
//	A pool groups backend members and defines how traffic from a listener is distributed
//	across those members. The pool specifies the protocol, load-balancing algorithm,
//	and optional session persistence. Members and health monitors attach to the pool.
type OpenStackLoadBalancerPoolSpecInput struct {
	// (Required) The listener this pool is the default pool for.
	//  ForceNew: changing this requires recreating the pool.
	//
	//  FK: OpenStackLoadBalancerListener.status.outputs.listener_id
	ListenerId string `json:"listener_id" jsonschema:"required,(Required) The listener this pool is the default pool for. ForceNew: changing this requires recreating the pool. FK: OpenStackLoadBalancerListener.status.outputs.listener_id"`
	// (Required) The protocol used by pool members to receive traffic.
	//  ForceNew: changing this requires recreating the pool.
	Protocol string `json:"protocol" jsonschema:"required,(Required) The protocol used by pool members to receive traffic. ForceNew: changing this requires recreating the pool."`
	// (Required) The load-balancing algorithm to distribute traffic across members.
	//
	//  - ROUND_ROBIN: Equal distribution across all members
	//  - LEAST_CONNECTIONS: Send to member with fewest active connections
	//  - SOURCE_IP: Hash client IP for sticky routing
	//  - SOURCE_IP_PORT: Hash client IP and port for fine...
	LbMethod string `json:"lb_method" jsonschema:"required,(Required) The load-balancing algorithm to distribute traffic across members. - ROUND_ROBIN: Equal distribution across all members - LEAST_CONNECTIONS: Send to member with fewest active connections - ..."`
	// (Optional) Session persistence configuration.
	//  Ensures requests from the same client are routed to the same backend member.
	//  Only one persistence config is allowed (Octavia enforces this).
	Persistence *SessionPersistenceInput `json:"persistence,omitempty" jsonschema:"(Optional) Session persistence configuration. Ensures requests from the same client are routed to the same backend member. Only one persistence config is allowed (Octavia enforces this)."`
	// (Optional) Human-readable description of the pool.
	Description string `json:"description,omitempty" jsonschema:"(Optional) Human-readable description of the pool."`
	// (Optional) Administrative state of the pool.
	//  When false, the pool stops receiving traffic. Default: true.
	AdminStateUp bool `json:"admin_state_up,omitempty" jsonschema:"(Optional) Administrative state of the pool. When false; the pool stops receiving traffic. Default: true."`
	// (Optional) Tags applied to the pool in OpenStack.
	//  Must be unique within this resource.
	Tags []string `json:"tags,omitempty" jsonschema:"(Optional) Tags applied to the pool in OpenStack. Must be unique within this resource."`
	// (Optional) Override the region from the provider configuration.
	Region string `json:"region,omitempty" jsonschema:"(Optional) Override the region from the provider configuration."`
}

func (s *OpenStackLoadBalancerPoolSpecInput) validate() error {
	if s.ListenerId == "" {
		return fmt.Errorf("listener_id is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if s.LbMethod == "" {
		return fmt.Errorf("lb_method is required")
	}
	if s.Persistence != nil {
		if err := s.Persistence.validate(); err != nil {
			return fmt.Errorf("persistence: %w", err)
		}
	}
	return nil
}

func (s *OpenStackLoadBalancerPoolSpecInput) applyDefaults() {
	if s.Persistence != nil {
		s.Persistence.applyDefaults()
	}
	// default: AdminStateUp = true (applied at zero-value)
}

func (s *OpenStackLoadBalancerPoolSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["listener_id"] = s.ListenerId
	m["protocol"] = s.Protocol
	m["lb_method"] = s.LbMethod
	if s.Persistence != nil {
		m["persistence"] = s.Persistence.toMap()
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.AdminStateUp {
		m["admin_state_up"] = s.AdminStateUp
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// SessionPersistence defines how client sessions are pinned to backend members.
//
//	Validations:
//	- cookie_name is only valid when type is APP_COOKIE.
type SessionPersistenceInput struct {
	// (Required) The type of session persistence.
	//
	//  - SOURCE_IP: Hash the client's IP address
	//  - HTTP_COOKIE: Octavia inserts and tracks a cookie
	//  - APP_COOKIE: Application manages the cookie (requires cookie_name)
	Type string `json:"type" jsonschema:"required,(Required) The type of session persistence. - SOURCE_IP: Hash the client's IP address - HTTP_COOKIE: Octavia inserts and tracks a cookie - APP_COOKIE: Application manages the cookie (requires cookie_n..."`
	// (Optional) The name of the application cookie to use for session affinity.
	//  Only valid when type is APP_COOKIE.
	CookieName string `json:"cookie_name,omitempty" jsonschema:"(Optional) The name of the application cookie to use for session affinity. Only valid when type is APP_COOKIE."`
}

func (s *SessionPersistenceInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *SessionPersistenceInput) applyDefaults() {
}

func (s *SessionPersistenceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.CookieName != "" {
		m["cookie_name"] = s.CookieName
	}
	return m
}

// ParseOpenStackLoadBalancerPool validates and normalizes a OpenStackLoadBalancerPool cloud_object.
func ParseOpenStackLoadBalancerPool(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackLoadBalancerPool"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackLoadBalancerPoolSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
