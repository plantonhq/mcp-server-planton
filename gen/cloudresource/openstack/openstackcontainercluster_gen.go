// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackContainerCluster is a Kubernetes Resource Model (KRM) style resource
//
//	for managing Magnum container clusters in OpenStack.
//
//	A Magnum cluster provisions a fully functional Kubernetes cluster using a
//	cluster template as a blueprint. The cluster manages master and worker nodes,
//	networking, and outputs the kubeconfig needed to access the Kubernetes API.
//
//	Important: Almost all fields are ForceNew. Only node_count (scale) and
//	cluster_template (upgrade) can be updated after creation.
type OpenStackContainerClusterSpecInput struct {
	// (Required) The cluster template to use as a blueprint.
	//  Can be a literal template UUID or a reference to an OpenStackContainerClusterTemplate.
	//  UPDATABLE: changing the template triggers a cluster upgrade.
	//
	//  FK: OpenStackContainerClusterTemplate.status.outputs.template_id
	ClusterTemplate string `json:"cluster_template" jsonschema:"required,(Required) The cluster template to use as a blueprint. Can be a literal template UUID or a reference to an OpenStackContainerClusterTemplate. UPDATABLE: changing the template triggers a cluster upgrad..."`
	// (Optional) The number of master nodes.
	//  Use 1 for development, 3+ for production HA.
	//  ForceNew: changing this requires recreating the cluster.
	MasterCount int32 `json:"master_count,omitempty" jsonschema:"(Optional) The number of master nodes. Use 1 for development; 3+ for production HA. ForceNew: changing this requires recreating the cluster."`
	// (Optional) The number of worker nodes.
	//  UPDATABLE: changing this triggers a scale operation.
	//  Default: 1 (set by Magnum if not specified).
	NodeCount int32 `json:"node_count,omitempty" jsonschema:"(Optional) The number of worker nodes. UPDATABLE: changing this triggers a scale operation. Default: 1 (set by Magnum if not specified)."`
	// (Optional) The SSH keypair for cluster node access.
	//  Overrides the keypair from the cluster template.
	//  Can be a literal keypair name or a reference to an OpenStackKeypair resource.
	//  ForceNew: changing this requires recreating the cluster.
	//
	//  FK: OpenStackKeypair.status.outputs.name
	Keypair string `json:"keypair,omitempty" jsonschema:"(Optional) The SSH keypair for cluster node access. Overrides the keypair from the cluster template. Can be a literal keypair name or a reference to an OpenStackKeypair resource. ForceNew: changing th..."`
	// (Optional) The Nova flavor for worker nodes.
	//  Overrides the flavor from the cluster template.
	//  ForceNew: changing this requires recreating the cluster.
	Flavor string `json:"flavor,omitempty" jsonschema:"(Optional) The Nova flavor for worker nodes. Overrides the flavor from the cluster template. ForceNew: changing this requires recreating the cluster."`
	// (Optional) The Nova flavor for master nodes.
	//  Overrides the master_flavor from the cluster template.
	//  ForceNew: changing this requires recreating the cluster.
	MasterFlavor string `json:"master_flavor,omitempty" jsonschema:"(Optional) The Nova flavor for master nodes. Overrides the master_flavor from the cluster template. ForceNew: changing this requires recreating the cluster."`
	// (Optional) The size (in GB) of the Docker volume for each node.
	//  Overrides the docker_volume_size from the cluster template.
	//  ForceNew: changing this requires recreating the cluster.
	DockerVolumeSize int32 `json:"docker_volume_size,omitempty" jsonschema:"(Optional) The size (in GB) of the Docker volume for each node. Overrides the docker_volume_size from the cluster template. ForceNew: changing this requires recreating the cluster."`
	// (Optional) Key-value labels for the cluster.
	//  Can extend or override the cluster template's labels.
	//  Used for Kubernetes-specific settings (kube_tag, container_runtime, etc.).
	//  ForceNew: changing this requires recreating the cluster.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"(Optional) Key-value labels for the cluster. Can extend or override the cluster template's labels. Used for Kubernetes-specific settings (kube_tag; container_runtime; etc.). ForceNew: changing this re..."`
	// (Optional) The timeout (in minutes) for cluster creation.
	//  If the cluster is not ready within this time, creation fails.
	//  ForceNew: changing this requires recreating the cluster.
	CreateTimeout int32 `json:"create_timeout,omitempty" jsonschema:"(Optional) The timeout (in minutes) for cluster creation. If the cluster is not ready within this time; creation fails. ForceNew: changing this requires recreating the cluster."`
	// (Optional) Whether to create a floating IP for every cluster node.
	//  Overrides the floating_ip_enabled from the cluster template.
	//  ForceNew: changing this requires recreating the cluster.
	FloatingIpEnabled bool `json:"floating_ip_enabled,omitempty" jsonschema:"(Optional) Whether to create a floating IP for every cluster node. Overrides the floating_ip_enabled from the cluster template. ForceNew: changing this requires recreating the cluster."`
	// (Optional) Override the region from the provider config.
	//  ForceNew: changing this requires recreating the cluster.
	Region string `json:"region,omitempty" jsonschema:"(Optional) Override the region from the provider config. ForceNew: changing this requires recreating the cluster."`
}

func (s *OpenStackContainerClusterSpecInput) validate() error {
	if s.ClusterTemplate == "" {
		return fmt.Errorf("cluster_template is required")
	}
	return nil
}

func (s *OpenStackContainerClusterSpecInput) applyDefaults() {
}

func (s *OpenStackContainerClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cluster_template"] = s.ClusterTemplate
	if s.MasterCount != 0 {
		m["master_count"] = s.MasterCount
	}
	if s.NodeCount != 0 {
		m["node_count"] = s.NodeCount
	}
	if s.Keypair != "" {
		m["keypair"] = s.Keypair
	}
	if s.Flavor != "" {
		m["flavor"] = s.Flavor
	}
	if s.MasterFlavor != "" {
		m["master_flavor"] = s.MasterFlavor
	}
	if s.DockerVolumeSize != 0 {
		m["docker_volume_size"] = s.DockerVolumeSize
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if s.CreateTimeout != 0 {
		m["create_timeout"] = s.CreateTimeout
	}
	if s.FloatingIpEnabled {
		m["floating_ip_enabled"] = s.FloatingIpEnabled
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackContainerCluster validates and normalizes a OpenStackContainerCluster cloud_object.
func ParseOpenStackContainerCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackContainerCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackContainerClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
