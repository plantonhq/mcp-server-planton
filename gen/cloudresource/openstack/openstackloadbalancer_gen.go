// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackLoadBalancer is a Kubernetes Resource Model (KRM) style resource for managing
//
//	Octavia load balancers in OpenStack.
//
//	An Octavia load balancer provides a Virtual IP (VIP) endpoint on a subnet.
//	Listeners, pools, members, and health monitors are attached to it to distribute
//	traffic across backend servers. The VIP can be associated with a floating IP
//	for external access.
type OpenStackLoadBalancerSpecInput struct {
	// (Required) The subnet on which to allocate the VIP address.
	//  This determines the network segment where the load balancer's virtual IP lives.
	//  The subnet must already exist and have available IP addresses.
	//
	//  FK: OpenStackSubnet.status.outputs.subnet_id
	VipSubnetId string `json:"vip_subnet_id" jsonschema:"required,(Required) The subnet on which to allocate the VIP address. This determines the network segment where the load balancer's virtual IP lives. The subnet must already exist and have available IP addresse..."`
	// (Optional) A specific IP address to request for the VIP.
	//  Must be within the CIDR range of the specified subnet.
	//  If omitted, Octavia auto-allocates an available IP from the subnet.
	//  ForceNew: changing this requires recreating the load balancer.
	VipAddress string `json:"vip_address,omitempty" jsonschema:"(Optional) A specific IP address to request for the VIP. Must be within the CIDR range of the specified subnet. If omitted; Octavia auto-allocates an available IP from the subnet. ForceNew: changing t..."`
	// (Optional) Human-readable description of the load balancer.
	Description string `json:"description,omitempty" jsonschema:"(Optional) Human-readable description of the load balancer."`
	// (Optional) Administrative state of the load balancer.
	//  When false, the LB stops accepting traffic. Default: true.
	AdminStateUp bool `json:"admin_state_up,omitempty" jsonschema:"(Optional) Administrative state of the load balancer. When false; the LB stops accepting traffic. Default: true."`
	// (Optional) The ID of an Octavia flavor to use for the load balancer.
	//  Flavors define resource limits (bandwidth, connections, etc.).
	//  ForceNew: changing this requires recreating the load balancer.
	FlavorId string `json:"flavor_id,omitempty" jsonschema:"(Optional) The ID of an Octavia flavor to use for the load balancer. Flavors define resource limits (bandwidth; connections; etc.). ForceNew: changing this requires recreating the load balancer."`
	// (Optional) Tags applied to the load balancer in OpenStack.
	//  Must be unique within this resource.
	Tags []string `json:"tags,omitempty" jsonschema:"(Optional) Tags applied to the load balancer in OpenStack. Must be unique within this resource."`
	// (Optional) Override the region from the provider configuration.
	//  Use this when the load balancer must be created in a specific region
	//  that differs from the provider's default.
	Region string `json:"region,omitempty" jsonschema:"(Optional) Override the region from the provider configuration. Use this when the load balancer must be created in a specific region that differs from the provider's default."`
}

func (s *OpenStackLoadBalancerSpecInput) validate() error {
	if s.VipSubnetId == "" {
		return fmt.Errorf("vip_subnet_id is required")
	}
	return nil
}

func (s *OpenStackLoadBalancerSpecInput) applyDefaults() {
	// default: AdminStateUp = true (applied at zero-value)
}

func (s *OpenStackLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["vip_subnet_id"] = s.VipSubnetId
	if s.VipAddress != "" {
		m["vip_address"] = s.VipAddress
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.AdminStateUp {
		m["admin_state_up"] = s.AdminStateUp
	}
	if s.FlavorId != "" {
		m["flavor_id"] = s.FlavorId
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackLoadBalancer validates and normalizes a OpenStackLoadBalancer cloud_object.
func ParseOpenStackLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
