// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackRouter is a Kubernetes Resource Model (KRM) style resource for managing
//
//	Neutron routers in OpenStack.
//
//	A router provides L3 routing between subnets and, optionally, external network
//	connectivity. Routers connect tenant subnets to each other and to external networks
//	via SNAT/DNAT. They are referenced by router interfaces that attach subnets.
type OpenStackRouterSpecInput struct {
	// external_network_id is the ID of the external (provider) network used as
	//  the router's gateway. When set, the router gains external connectivity and
	//  can perform SNAT for tenant traffic.
	//  Optional: routers without an external gateway provide internal routing only.
	//  Can reference an OpenStackNetwork ...
	ExternalNetworkId string `json:"external_network_id,omitempty" jsonschema:"external_network_id is the ID of the external (provider) network used as the router's gateway. When set; the router gains external connectivity and can perform SNAT for tenant traffic. Optional: route..."`
	// admin_state_up controls the administrative state of the router.
	//  When false, the router is administratively disabled and does not forward traffic.
	//  Default: true
	AdminStateUp bool `json:"admin_state_up,omitempty" jsonschema:"admin_state_up controls the administrative state of the router. When false; the router is administratively disabled and does not forward traffic. Default: true"`
	// enable_snat controls whether Source NAT is enabled on the router's external gateway.
	//  When enabled, traffic from tenant subnets is NATed to the router's external IP.
	//  Only valid when external_network_id is configured.
	//  If omitted, OpenStack uses its deployment default (typically true).
	EnableSnat bool `json:"enable_snat,omitempty" jsonschema:"enable_snat controls whether Source NAT is enabled on the router's external gateway. When enabled; traffic from tenant subnets is NATed to the router's external IP. Only valid when external_network_id..."`
	// distributed controls whether the router uses Distributed Virtual Router (DVR) mode.
	//  DVR eliminates the centralized L3 agent bottleneck by distributing routing to
	//  each compute node. This is a create-time setting and cannot be changed after creation.
	//  If omitted, OpenStack uses its deployment defaul...
	Distributed bool `json:"distributed,omitempty" jsonschema:"distributed controls whether the router uses Distributed Virtual Router (DVR) mode. DVR eliminates the centralized L3 agent bottleneck by distributing routing to each compute node. This is a create-ti..."`
	// external_fixed_ips specifies fixed IP addresses to allocate on the external network
	//  for the router's gateway. Each entry can request a specific subnet and/or IP address.
	//  Only valid when external_network_id is configured.
	//  If omitted, OpenStack automatically allocates an IP from the external networ...
	ExternalFixedIps []*ExternalFixedIpInput `json:"external_fixed_ips,omitempty" jsonschema:"external_fixed_ips specifies fixed IP addresses to allocate on the external network for the router's gateway. Each entry can request a specific subnet and/or IP address. Only valid when external_netwo..."`
	// description is a human-readable description of the router.
	//  This is stored on the OpenStack resource and visible in Horizon and API responses.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the router. This is stored on the OpenStack resource and visible in Horizon and API responses."`
	// tags are string tags to associate with the router in OpenStack.
	//  Tags are stored on the OpenStack resource and can be used for filtering
	//  and organization in the OpenStack API and Horizon dashboard.
	Tags []string `json:"tags,omitempty" jsonschema:"tags are string tags to associate with the router in OpenStack. Tags are stored on the OpenStack resource and can be used for filtering and organization in the OpenStack API and Horizon dashboard."`
	// region overrides the region from the provider config for this router.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this router. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackRouterSpecInput) validate() error {
	for i, v := range s.ExternalFixedIps {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("external_fixed_ips[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenStackRouterSpecInput) applyDefaults() {
	// default: AdminStateUp = true (applied at zero-value)
}

func (s *OpenStackRouterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ExternalNetworkId != "" {
		m["external_network_id"] = s.ExternalNetworkId
	}
	if s.AdminStateUp {
		m["admin_state_up"] = s.AdminStateUp
	}
	if s.EnableSnat {
		m["enable_snat"] = s.EnableSnat
	}
	if s.Distributed {
		m["distributed"] = s.Distributed
	}
	if len(s.ExternalFixedIps) > 0 {
		items := make([]any, len(s.ExternalFixedIps))
		for i, v := range s.ExternalFixedIps {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["external_fixed_ips"] = items
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ExternalFixedIp specifies a fixed IP allocation on the router's external network.
//
//	Both fields are optional: you can request a specific subnet, a specific IP, both, or neither.
//	When neither is specified, OpenStack allocates from any available subnet on the external network.
type ExternalFixedIpInput struct {
	// subnet_id is the UUID of a subnet on the external network from which to allocate the IP.
	//  This references a subnet managed by the cloud administrator on the provider network.
	SubnetId string `json:"subnet_id,omitempty" jsonschema:"subnet_id is the UUID of a subnet on the external network from which to allocate the IP. This references a subnet managed by the cloud administrator on the provider network."`
	// ip_address is the specific IP address to allocate on the external network.
	//  Must be within the range of the specified subnet (or any external subnet if subnet_id is omitted).
	IpAddress string `json:"ip_address,omitempty" jsonschema:"ip_address is the specific IP address to allocate on the external network. Must be within the range of the specified subnet (or any external subnet if subnet_id is omitted)."`
}

func (s *ExternalFixedIpInput) validate() error {
	return nil
}

func (s *ExternalFixedIpInput) applyDefaults() {
}

func (s *ExternalFixedIpInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SubnetId != "" {
		m["subnet_id"] = s.SubnetId
	}
	if s.IpAddress != "" {
		m["ip_address"] = s.IpAddress
	}
	return m
}

// ParseOpenStackRouter validates and normalizes a OpenStackRouter cloud_object.
func ParseOpenStackRouter(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackRouter"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackRouterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
