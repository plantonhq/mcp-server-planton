// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackSecurityGroup is a Kubernetes Resource Model (KRM) style resource for
//
//	managing Neutron security groups in OpenStack.
//
//	A security group acts as a virtual firewall for instances and ports, controlling
//	ingress and egress traffic through a set of rules. This component supports
//	inline rules for convenience (rules defined in the spec) and is also referenced
//	by the standalone OpenStackSecurityGroupRule component for DAG-visible rule
//	management in InfraCharts.
//
//	Security groups are referenced by network ports, instances, and other networking
//	resources as the primary mechanism for network-level access control.
type OpenStackSecurityGroupSpecInput struct {
	// description is a human-readable description of the security group.
	//  This is stored on the OpenStack resource and visible in Horizon and API responses.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the security group. This is stored on the OpenStack resource and visible in Horizon and API responses."`
	// delete_default_rules controls whether OpenStack's automatically created default
	//  egress rules are deleted after the security group is created.
	//  OpenStack creates two default rules on every new security group:
	//    - Allow all egress IPv4 traffic
	//    - Allow all egress IPv6 traffic
	//  Set to true to start...
	DeleteDefaultRules bool `json:"delete_default_rules,omitempty" jsonschema:"delete_default_rules controls whether OpenStack's automatically created default egress rules are deleted after the security group is created. OpenStack creates two default rules on every new security ..."`
	// stateful controls whether the security group operates in stateful or stateless mode.
	//  Stateful (default in OpenStack): Return traffic is automatically allowed regardless
	//  of rules. Stateless: Return traffic must be explicitly permitted by rules.
	//  Stateless security groups offer better performance fo...
	Stateful bool `json:"stateful,omitempty" jsonschema:"stateful controls whether the security group operates in stateful or stateless mode. Stateful (default in OpenStack): Return traffic is automatically allowed regardless of rules. Stateless: Return tra..."`
	// rules defines inline security group rules to create alongside the security group.
	//  Each rule is provisioned as a separate openstack_networking_secgroup_rule_v2 resource,
	//  keyed by the rule's `key` field for stable IaC state management.
	//  For DAG-visible, independently managed rules, use the OpenStack...
	Rules []*SecurityGroupRuleInput `json:"rules,omitempty" jsonschema:"rules defines inline security group rules to create alongside the security group. Each rule is provisioned as a separate openstack_networking_secgroup_rule_v2 resource; keyed by the rule's 'key' field..."`
	// tags are string tags to associate with the security group in OpenStack.
	//  Tags are stored on the OpenStack resource and can be used for filtering
	//  and organization in the OpenStack API and Horizon dashboard.
	Tags []string `json:"tags,omitempty" jsonschema:"tags are string tags to associate with the security group in OpenStack. Tags are stored on the OpenStack resource and can be used for filtering and organization in the OpenStack API and Horizon dashbo..."`
	// region overrides the region from the provider config for this security group.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this security group. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackSecurityGroupSpecInput) validate() error {
	for i, v := range s.Rules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenStackSecurityGroupSpecInput) applyDefaults() {
}

func (s *OpenStackSecurityGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.DeleteDefaultRules {
		m["delete_default_rules"] = s.DeleteDefaultRules
	}
	if s.Stateful {
		m["stateful"] = s.Stateful
	}
	if len(s.Rules) > 0 {
		items := make([]any, len(s.Rules))
		for i, v := range s.Rules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rules"] = items
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// SecurityGroupRule defines an inline security group rule.
//
//	Each rule controls traffic in one direction (ingress or egress) for a specific
//	protocol and port range, optionally restricted to a source/destination CIDR
//	or another security group.
type SecurityGroupRuleInput struct {
	// key is a unique identifier for this rule within the security group.
	//  Used as the resource key in IaC state management (Terraform for_each key,
	//  Pulumi resource name suffix). Must be unique across all rules in the spec.
	//  Use descriptive, kebab-case names like "allow-ssh", "egress-all-ipv4",
	//  "allow-h...
	Key string `json:"key,omitempty" jsonschema:"key is a unique identifier for this rule within the security group. Used as the resource key in IaC state management (Terraform for_each key; Pulumi resource name suffix). Must be unique across all ru..."`
	// direction specifies whether the rule applies to incoming or outgoing traffic.
	//  Must be "ingress" or "egress".
	Direction string `json:"direction,omitempty" jsonschema:"direction specifies whether the rule applies to incoming or outgoing traffic. Must be 'ingress' or 'egress'."`
	// ethertype specifies the layer-3 protocol type for the rule.
	//  Must be "IPv4" or "IPv6".
	Ethertype string `json:"ethertype,omitempty" jsonschema:"ethertype specifies the layer-3 protocol type for the rule. Must be 'IPv4' or 'IPv6'."`
	// protocol is the IP protocol for the rule.
	//  Common values: "tcp", "udp", "icmp", "icmpv6".
	//  Also accepts any IANA protocol name or number (0-255).
	//  If omitted, the rule applies to all protocols.
	Protocol string `json:"protocol,omitempty" jsonschema:"protocol is the IP protocol for the rule. Common values: 'tcp'; 'udp'; 'icmp'; 'icmpv6'. Also accepts any IANA protocol name or number (0-255). If omitted; the rule applies to all protocols."`
	// port_range_min is the minimum port number for the rule.
	//  For TCP/UDP: the start of the port range (0-65535).
	//  For ICMP: the ICMP type (0-255). Type 0 = Echo Reply, Type 8 = Echo Request.
	//  Must be set together with port_range_max. Requires protocol to be set.
	PortRangeMin int32 `json:"port_range_min,omitempty" jsonschema:"port_range_min is the minimum port number for the rule. For TCP/UDP: the start of the port range (0-65535). For ICMP: the ICMP type (0-255). Type 0 = Echo Reply; Type 8 = Echo Request. Must be set tog..."`
	// port_range_max is the maximum port number for the rule.
	//  For TCP/UDP: the end of the port range (0-65535).
	//  For ICMP: the ICMP code (0-255). Code 0 is valid and commonly used.
	//  Must be set together with port_range_min. Requires protocol to be set.
	PortRangeMax int32 `json:"port_range_max,omitempty" jsonschema:"port_range_max is the maximum port number for the rule. For TCP/UDP: the end of the port range (0-65535). For ICMP: the ICMP code (0-255). Code 0 is valid and commonly used. Must be set together with ..."`
	// remote_ip_prefix restricts the rule to traffic from/to a specific CIDR.
	//  For ingress: the source IP range. For egress: the destination IP range.
	//  Example: "0.0.0.0/0" (all IPv4), "10.0.0.0/8" (private range), "203.0.113.0/24".
	//  Mutually exclusive with remote_group_id.
	RemoteIpPrefix string `json:"remote_ip_prefix,omitempty" jsonschema:"remote_ip_prefix restricts the rule to traffic from/to a specific CIDR. For ingress: the source IP range. For egress: the destination IP range. Example: '0.0.0.0/0' (all IPv4); '10.0.0.0/8' (private r..."`
	// remote_group_id restricts the rule to traffic from/to instances in another
	//  security group (or the same security group for self-referencing rules).
	//  This is a literal UUID of an existing security group.
	//  For self-referencing rules in InfraCharts, use the standalone
	//  OpenStackSecurityGroupRule compon...
	RemoteGroupId string `json:"remote_group_id,omitempty" jsonschema:"remote_group_id restricts the rule to traffic from/to instances in another security group (or the same security group for self-referencing rules). This is a literal UUID of an existing security group...."`
	// description is a human-readable description of the rule.
	//  Stored on the OpenStack rule resource.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the rule. Stored on the OpenStack rule resource."`
}

func (s *SecurityGroupRuleInput) validate() error {
	return nil
}

func (s *SecurityGroupRuleInput) applyDefaults() {
}

func (s *SecurityGroupRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Key != "" {
		m["key"] = s.Key
	}
	if s.Direction != "" {
		m["direction"] = s.Direction
	}
	if s.Ethertype != "" {
		m["ethertype"] = s.Ethertype
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRangeMin != 0 {
		m["port_range_min"] = s.PortRangeMin
	}
	if s.PortRangeMax != 0 {
		m["port_range_max"] = s.PortRangeMax
	}
	if s.RemoteIpPrefix != "" {
		m["remote_ip_prefix"] = s.RemoteIpPrefix
	}
	if s.RemoteGroupId != "" {
		m["remote_group_id"] = s.RemoteGroupId
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ParseOpenStackSecurityGroup validates and normalizes a OpenStackSecurityGroup cloud_object.
func ParseOpenStackSecurityGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackSecurityGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackSecurityGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
