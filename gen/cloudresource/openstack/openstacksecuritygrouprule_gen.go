// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackSecurityGroupRule is a Kubernetes Resource Model (KRM) style resource
//
//	for managing standalone OpenStack Neutron security group rules.
//
//	A standalone security group rule is independently managed and visible as its
//	own node in InfraChart DAG visualizations. Both security_group_id and
//	remote_group_id support StringValueOrRef for cross-resource FK resolution,
//	unlike inline rules in OpenStackSecurityGroup.rules[] which use plain strings.
//
//	Use this component for:
//	  - Cross-security-group rules where remote_group_id needs DAG resolution
//	  - Rules that need independent lifecycle management
//	  - InfraCharts where rule dependencies must be visually explicit
//
//	Use inline rules (OpenStackSecurityGroup.rules[]) for:
//	  - Self-contained security groups where all rules are co-managed
//	  - Simpler configurations without cross-SG references
type OpenStackSecurityGroupRuleSpecInput struct {
	// security_group_id is the ID of the security group this rule belongs to.
	//  This is a required foreign key -- every standalone rule must reference
	//  exactly one security group.
	//  Can reference an OpenStackSecurityGroup resource's output or be a literal UUID.
	SecurityGroupId string `json:"security_group_id" jsonschema:"required,security_group_id is the ID of the security group this rule belongs to. This is a required foreign key -- every standalone rule must reference exactly one security group. Can reference an OpenStackSec..."`
	// direction specifies whether the rule applies to incoming or outgoing traffic.
	//  Must be "ingress" or "egress".
	Direction string `json:"direction,omitempty" jsonschema:"direction specifies whether the rule applies to incoming or outgoing traffic. Must be 'ingress' or 'egress'."`
	// ethertype specifies the layer-3 protocol type for the rule.
	//  Must be "IPv4" or "IPv6".
	Ethertype string `json:"ethertype,omitempty" jsonschema:"ethertype specifies the layer-3 protocol type for the rule. Must be 'IPv4' or 'IPv6'."`
	// protocol is the IP protocol for the rule.
	//  Common values: "tcp", "udp", "icmp", "icmpv6".
	//  Also accepts any IANA protocol name or number (0-255).
	//  If omitted, the rule applies to all protocols.
	Protocol string `json:"protocol,omitempty" jsonschema:"protocol is the IP protocol for the rule. Common values: 'tcp'; 'udp'; 'icmp'; 'icmpv6'. Also accepts any IANA protocol name or number (0-255). If omitted; the rule applies to all protocols."`
	// port_range_min is the minimum port number for the rule.
	//  For TCP/UDP: the start of the port range (0-65535).
	//  For ICMP: the ICMP type (0-255). Type 0 = Echo Reply, Type 8 = Echo Request.
	//  Must be set together with port_range_max. Requires protocol to be set.
	PortRangeMin int32 `json:"port_range_min,omitempty" jsonschema:"port_range_min is the minimum port number for the rule. For TCP/UDP: the start of the port range (0-65535). For ICMP: the ICMP type (0-255). Type 0 = Echo Reply; Type 8 = Echo Request. Must be set tog..."`
	// port_range_max is the maximum port number for the rule.
	//  For TCP/UDP: the end of the port range (0-65535).
	//  For ICMP: the ICMP code (0-255). Code 0 is valid and commonly used.
	//  Must be set together with port_range_min. Requires protocol to be set.
	PortRangeMax int32 `json:"port_range_max,omitempty" jsonschema:"port_range_max is the maximum port number for the rule. For TCP/UDP: the end of the port range (0-65535). For ICMP: the ICMP code (0-255). Code 0 is valid and commonly used. Must be set together with ..."`
	// remote_ip_prefix restricts the rule to traffic from/to a specific CIDR.
	//  For ingress: the source IP range. For egress: the destination IP range.
	//  Example: "0.0.0.0/0" (all IPv4), "10.0.0.0/8" (private range), "203.0.113.0/24".
	//  Mutually exclusive with remote_group_id.
	RemoteIpPrefix string `json:"remote_ip_prefix,omitempty" jsonschema:"remote_ip_prefix restricts the rule to traffic from/to a specific CIDR. For ingress: the source IP range. For egress: the destination IP range. Example: '0.0.0.0/0' (all IPv4); '10.0.0.0/8' (private r..."`
	// remote_group_id restricts the rule to traffic from/to instances in another
	//  security group (or the same security group for self-referencing rules).
	//  This is an optional foreign key to OpenStackSecurityGroup -- the key advantage
	//  of standalone rules over inline rules, enabling InfraChart DAG wiring f...
	RemoteGroupId string `json:"remote_group_id,omitempty" jsonschema:"remote_group_id restricts the rule to traffic from/to instances in another security group (or the same security group for self-referencing rules). This is an optional foreign key to OpenStackSecurityG..."`
	// description is a human-readable description of the rule.
	//  Stored on the OpenStack rule resource and visible in Horizon and API responses.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the rule. Stored on the OpenStack rule resource and visible in Horizon and API responses."`
	// region overrides the region from the provider config for this rule.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this rule. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackSecurityGroupRuleSpecInput) validate() error {
	if s.SecurityGroupId == "" {
		return fmt.Errorf("security_group_id is required")
	}
	return nil
}

func (s *OpenStackSecurityGroupRuleSpecInput) applyDefaults() {
}

func (s *OpenStackSecurityGroupRuleSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["security_group_id"] = s.SecurityGroupId
	if s.Direction != "" {
		m["direction"] = s.Direction
	}
	if s.Ethertype != "" {
		m["ethertype"] = s.Ethertype
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRangeMin != 0 {
		m["port_range_min"] = s.PortRangeMin
	}
	if s.PortRangeMax != 0 {
		m["port_range_max"] = s.PortRangeMax
	}
	if s.RemoteIpPrefix != "" {
		m["remote_ip_prefix"] = s.RemoteIpPrefix
	}
	if s.RemoteGroupId != "" {
		m["remote_group_id"] = s.RemoteGroupId
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackSecurityGroupRule validates and normalizes a OpenStackSecurityGroupRule cloud_object.
func ParseOpenStackSecurityGroupRule(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackSecurityGroupRule"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackSecurityGroupRuleSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
