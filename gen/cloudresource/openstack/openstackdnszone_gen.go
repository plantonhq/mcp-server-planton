// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackDnsZone is a Kubernetes Resource Model (KRM) style resource for managing
//
//	Designate DNS zones in OpenStack.
//
//	A DNS zone represents an authoritative domain managed by the OpenStack Designate
//	service. It can optionally include inline DNS records that are provisioned alongside
//	the zone. For independently managed records (DAG-visible in InfraCharts), use the
//	standalone OpenStackDnsRecord component.
type OpenStackDnsZoneSpecInput struct {
	// (Required) The DNS domain name for the zone (e.g., "example.com").
	//  This is the authoritative domain managed by Designate.
	//  Must be a valid domain name (lowercase labels separated by dots, ending with a TLD).
	//  Note: Designate may auto-append a trailing dot internally.
	//  ForceNew: changing this requir...
	DomainName string `json:"domain_name" jsonschema:"required,(Required) The DNS domain name for the zone (e.g.; 'example.com'). This is the authoritative domain managed by Designate. Must be a valid domain name (lowercase labels separated by dots; ending with a..."`
	// (Optional) Email address of the zone administrator.
	//  Used in the SOA record for the zone.
	//  Example: "admin@example.com"
	Email string `json:"email,omitempty" jsonschema:"(Optional) Email address of the zone administrator. Used in the SOA record for the zone. Example: 'admin@example.com'"`
	// (Optional) Human-readable description of the DNS zone.
	Description string `json:"description,omitempty" jsonschema:"(Optional) Human-readable description of the DNS zone."`
	// (Optional) Default Time To Live (in seconds) for records in this zone.
	//  Determines how long resolvers cache records from this zone.
	//  If omitted, Designate uses its deployment default.
	Ttl int32 `json:"ttl,omitempty" jsonschema:"(Optional) Default Time To Live (in seconds) for records in this zone. Determines how long resolvers cache records from this zone. If omitted; Designate uses its deployment default."`
	// (Optional) The zone type.
	//  "PRIMARY" for zones where Designate is the authoritative source.
	//  "SECONDARY" for zones replicated from upstream master nameservers.
	//  If omitted, Designate defaults to PRIMARY.
	//  ForceNew: changing this requires recreating the zone.
	Type string `json:"type,omitempty" jsonschema:"(Optional) The zone type. 'PRIMARY' for zones where Designate is the authoritative source. 'SECONDARY' for zones replicated from upstream master nameservers. If omitted; Designate defaults to PRIMARY...."`
	// (Optional) List of master nameserver addresses for SECONDARY zones.
	//  Required when type is "SECONDARY". Ignored for PRIMARY zones.
	//  Example: ["ns1.upstream.com", "ns2.upstream.com"]
	Masters []string `json:"masters,omitempty" jsonschema:"(Optional) List of master nameserver addresses for SECONDARY zones. Required when type is 'SECONDARY'. Ignored for PRIMARY zones. Example: ['ns1.upstream.com'; 'ns2.upstream.com']"`
	// (Optional) Inline DNS records to create alongside the zone.
	//  Each record is provisioned as a separate openstack_dns_recordset_v2 resource,
	//  keyed by record_type + record_name for stable IaC state management.
	//  For DAG-visible, independently managed records in InfraCharts, use the
	//  standalone OpenStac...
	Records []*OpenStackDnsRecordInput `json:"records,omitempty" jsonschema:"(Optional) Inline DNS records to create alongside the zone. Each record is provisioned as a separate openstack_dns_recordset_v2 resource; keyed by record_type + record_name for stable IaC state manage..."`
	// (Optional) Override the region from the provider config for this zone.
	//  If omitted, the region from the OpenStack provider config is used.
	//  ForceNew: changing this requires recreating the zone.
	Region string `json:"region,omitempty" jsonschema:"(Optional) Override the region from the provider config for this zone. If omitted; the region from the OpenStack provider config is used. ForceNew: changing this requires recreating the zone."`
}

func (s *OpenStackDnsZoneSpecInput) validate() error {
	if s.DomainName == "" {
		return fmt.Errorf("domain_name is required")
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenStackDnsZoneSpecInput) applyDefaults() {
}

func (s *OpenStackDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domain_name"] = s.DomainName
	if s.Email != "" {
		m["email"] = s.Email
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if len(s.Masters) > 0 {
		m["masters"] = s.Masters
	}
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// OpenStackDnsRecord defines an inline DNS record within a zone.
//
//	Each record creates a Designate recordset (one name + one type + one or more values).
type OpenStackDnsRecordInput struct {
	// (Required) The DNS record type.
	//  Supported types: A, AAAA, CNAME, MX, TXT, SRV, NS, PTR, CAA, SOA, SPF, SSHFP, NAPTR.
	RecordType string `json:"record_type" jsonschema:"required,enum=A|AAAA|CNAME|MX|TXT|SRV|NS|PTR|CAA|SOA|SPF|SSHFP|NAPTR,(Required) The DNS record type. Supported types: A; AAAA; CNAME; MX; TXT; SRV; NS; PTR; CAA; SOA; SPF; SSHFP; NAPTR."`
	// (Required) The fully qualified domain name for this record.
	//  Must end with a trailing dot to indicate FQDN.
	//  Example: "www.example.com." or "api.example.com."
	RecordName string `json:"record_name" jsonschema:"required,(Required) The fully qualified domain name for this record. Must end with a trailing dot to indicate FQDN. Example: 'www.example.com.' or 'api.example.com.'"`
	// (Required) The DNS record values.
	//  For A records: IPv4 addresses (e.g., "192.0.2.1")
	//  For AAAA records: IPv6 addresses (e.g., "2001:db8::1")
	//  For CNAME records: target hostname with trailing dot (e.g., "target.example.com.")
	//  For MX records: priority and mail server (e.g., "10 mail.example.com.")
	//  F...
	Values []string `json:"values,omitempty" jsonschema:"(Required) The DNS record values. For A records: IPv4 addresses (e.g.; '192.0.2.1') For AAAA records: IPv6 addresses (e.g.; '2001:db8::1') For CNAME records: target hostname with trailing dot (e.g.; '..."`
	// (Optional) Time To Live (in seconds) for this specific record.
	//  Overrides the zone-level TTL for this record.
	//  Default: 60 seconds.
	Ttl int32 `json:"ttl,omitempty" jsonschema:"(Optional) Time To Live (in seconds) for this specific record. Overrides the zone-level TTL for this record. Default: 60 seconds."`
}

func (s *OpenStackDnsRecordInput) validate() error {
	if s.RecordType == "" {
		return fmt.Errorf("record_type is required")
	}
	switch s.RecordType {
	case "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "NS", "PTR", "CAA", "SOA", "SPF", "SSHFP", "NAPTR":
	default:
		return fmt.Errorf("invalid record_type: %q", s.RecordType)
	}
	if s.RecordName == "" {
		return fmt.Errorf("record_name is required")
	}
	if len(s.Values) < 1 {
		return fmt.Errorf("values requires at least 1 items, got %d", len(s.Values))
	}
	return nil
}

func (s *OpenStackDnsRecordInput) applyDefaults() {
	if s.Ttl == 0 {
		s.Ttl = 60
	}
}

func (s *OpenStackDnsRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["record_type"] = s.RecordType
	m["record_name"] = s.RecordName
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	return m
}

// ParseOpenStackDnsZone validates and normalizes a OpenStackDnsZone cloud_object.
func ParseOpenStackDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
