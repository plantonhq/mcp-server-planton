// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackFloatingIpAssociate is a Kubernetes Resource Model (KRM) style
//
//	resource for associating an OpenStack Neutron floating IP with a port.
//
//	This is a "join" resource that connects two independently managed resources:
//	  - A floating IP (allocated via OpenStackFloatingIp)
//	  - A port (created via OpenStackNetworkPort)
//
//	In InfraCharts, this component appears as a visible DAG node with dependency
//	edges to both the floating IP and the port, making the association relationship
//	explicit and transparent.
//
//	Use this component when:
//	  - The floating IP and port are managed as separate InfraChart components
//	  - You need DAG visibility of the association relationship
//	  - The floating IP allocation is decoupled from its use
//
//	Use OpenStackFloatingIp.spec.port_id instead when:
//	  - Allocation and association happen together in a single manifest
//	  - DAG visibility of the association is not needed
type OpenStackFloatingIpAssociateSpecInput struct {
	// floating_ip is the floating IP address (or ID) to associate.
	//  This targets the *address* output of an OpenStackFloatingIp resource
	//  (e.g., "203.0.113.42"), not its UUID. The Terraform provider accepts
	//  either an IP address or a floating IP UUID for this field.
	//  Can reference an OpenStackFloatingIp r...
	FloatingIp string `json:"floating_ip" jsonschema:"required,floating_ip is the floating IP address (or ID) to associate. This targets the *address* output of an OpenStackFloatingIp resource (e.g.; '203.0.113.42'); not its UUID. The Terraform provider accepts e..."`
	// port_id is the ID of the port to associate the floating IP with.
	//  The port must have at least one fixed IP address.
	//  Can reference an OpenStackNetworkPort resource's output or be a literal port UUID.
	PortId string `json:"port_id" jsonschema:"required,port_id is the ID of the port to associate the floating IP with. The port must have at least one fixed IP address. Can reference an OpenStackNetworkPort resource's output or be a literal port UUID."`
	// fixed_ip specifies which fixed IP address on the port to map the floating
	//  IP to. Only relevant when the port has multiple fixed IP addresses.
	//  If omitted and the port has a single IP, that IP is used automatically.
	//  If omitted and the port has multiple IPs, OpenStack picks the first one.
	FixedIp string `json:"fixed_ip,omitempty" jsonschema:"fixed_ip specifies which fixed IP address on the port to map the floating IP to. Only relevant when the port has multiple fixed IP addresses. If omitted and the port has a single IP; that IP is used a..."`
	// region overrides the region from the provider config for this association.
	//  If omitted, the region from the OpenStack provider config is used.
	//  ForceNew: changing the region recreates the association.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this association. If omitted; the region from the OpenStack provider config is used. ForceNew: changing the region recreates the association. E..."`
}

func (s *OpenStackFloatingIpAssociateSpecInput) validate() error {
	if s.FloatingIp == "" {
		return fmt.Errorf("floating_ip is required")
	}
	if s.PortId == "" {
		return fmt.Errorf("port_id is required")
	}
	return nil
}

func (s *OpenStackFloatingIpAssociateSpecInput) applyDefaults() {
}

func (s *OpenStackFloatingIpAssociateSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["floating_ip"] = s.FloatingIp
	m["port_id"] = s.PortId
	if s.FixedIp != "" {
		m["fixed_ip"] = s.FixedIp
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// ParseOpenStackFloatingIpAssociate validates and normalizes a OpenStackFloatingIpAssociate cloud_object.
func ParseOpenStackFloatingIpAssociate(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackFloatingIpAssociate"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackFloatingIpAssociateSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
