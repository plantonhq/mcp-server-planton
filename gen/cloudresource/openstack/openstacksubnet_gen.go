// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package openstack

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenStackSubnet is a Kubernetes Resource Model (KRM) style resource for managing
//
//	Neutron subnets in OpenStack.
//
//	A subnet provides IP address allocation within a network. It defines the CIDR block,
//	gateway, DHCP settings, and DNS configuration for network connectivity.
//	Subnets are referenced by router interfaces, load balancers, and container cluster templates.
type OpenStackSubnetSpecInput struct {
	// network_id is the ID of the network to which this subnet belongs.
	//  This is the defining relationship -- every subnet must belong to exactly one network.
	//  Can reference an OpenStackNetwork resource's output or be a literal network UUID.
	NetworkId string `json:"network_id" jsonschema:"required,network_id is the ID of the network to which this subnet belongs. This is the defining relationship -- every subnet must belong to exactly one network. Can reference an OpenStackNetwork resource's out..."`
	// cidr is the IP address range for this subnet in CIDR notation.
	//  Example IPv4: "192.168.1.0/24". Example IPv6: "2001:db8::/64".
	//  The CIDR must be valid for the selected ip_version.
	Cidr string `json:"cidr" jsonschema:"required,cidr is the IP address range for this subnet in CIDR notation. Example IPv4: '192.168.1.0/24'. Example IPv6: '2001:db8::/64'. The CIDR must be valid for the selected ip_version."`
	// ip_version is the IP protocol version for this subnet.
	//  Must be 4 (IPv4) or 6 (IPv6).
	//  Default: 4
	IpVersion int32 `json:"ip_version,omitempty" jsonschema:"ip_version is the IP protocol version for this subnet. Must be 4 (IPv4) or 6 (IPv6). Default: 4"`
	// gateway_ip is the IP address of the subnet gateway.
	//  If omitted (and no_gateway is false), OpenStack automatically assigns the first
	//  usable IP in the CIDR as the gateway.
	//  Mutually exclusive with no_gateway.
	GatewayIp string `json:"gateway_ip,omitempty" jsonschema:"gateway_ip is the IP address of the subnet gateway. If omitted (and no_gateway is false); OpenStack automatically assigns the first usable IP in the CIDR as the gateway. Mutually exclusive with no_gat..."`
	// no_gateway disables the gateway on this subnet when set to true.
	//  Use this for isolated subnets that do not need routing (e.g., storage networks).
	//  Mutually exclusive with gateway_ip.
	NoGateway bool `json:"no_gateway,omitempty" jsonschema:"no_gateway disables the gateway on this subnet when set to true. Use this for isolated subnets that do not need routing (e.g.; storage networks). Mutually exclusive with gateway_ip."`
	// enable_dhcp controls whether DHCP is enabled on this subnet.
	//  When enabled, OpenStack's DHCP agent assigns IP addresses to ports on this subnet.
	//  Default: true
	EnableDhcp bool `json:"enable_dhcp,omitempty" jsonschema:"enable_dhcp controls whether DHCP is enabled on this subnet. When enabled; OpenStack's DHCP agent assigns IP addresses to ports on this subnet. Default: true"`
	// dns_nameservers is a list of DNS server IP addresses for this subnet.
	//  These are pushed to instances via DHCP.
	//  Example: ["8.8.8.8", "8.8.4.4"]
	DnsNameservers []string `json:"dns_nameservers,omitempty" jsonschema:"dns_nameservers is a list of DNS server IP addresses for this subnet. These are pushed to instances via DHCP. Example: ['8.8.8.8'; '8.8.4.4']"`
	// allocation_pools defines the sub-ranges of the CIDR from which IPs are allocated.
	//  If omitted, the entire CIDR (minus gateway and network/broadcast addresses) is used.
	//  Each pool specifies a start and end IP address.
	AllocationPools []*AllocationPoolInput `json:"allocation_pools,omitempty" jsonschema:"allocation_pools defines the sub-ranges of the CIDR from which IPs are allocated. If omitted; the entire CIDR (minus gateway and network/broadcast addresses) is used. Each pool specifies a start and e..."`
	// description is a human-readable description of the subnet.
	//  This is stored on the OpenStack resource and visible in Horizon and API responses.
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the subnet. This is stored on the OpenStack resource and visible in Horizon and API responses."`
	// tags are string tags to associate with the subnet in OpenStack.
	//  Tags are stored on the OpenStack resource and can be used for filtering
	//  and organization in the OpenStack API and Horizon dashboard.
	Tags []string `json:"tags,omitempty" jsonschema:"tags are string tags to associate with the subnet in OpenStack. Tags are stored on the OpenStack resource and can be used for filtering and organization in the OpenStack API and Horizon dashboard."`
	// region overrides the region from the provider config for this subnet.
	//  If omitted, the region from the OpenStack provider config is used.
	//  Example: "RegionOne"
	Region string `json:"region,omitempty" jsonschema:"region overrides the region from the provider config for this subnet. If omitted; the region from the OpenStack provider config is used. Example: 'RegionOne'"`
}

func (s *OpenStackSubnetSpecInput) validate() error {
	if s.NetworkId == "" {
		return fmt.Errorf("network_id is required")
	}
	if s.Cidr == "" {
		return fmt.Errorf("cidr is required")
	}
	for i, v := range s.AllocationPools {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("allocation_pools[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *OpenStackSubnetSpecInput) applyDefaults() {
	if s.IpVersion == 0 {
		s.IpVersion = 4
	}
	// default: EnableDhcp = true (applied at zero-value)
}

func (s *OpenStackSubnetSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["network_id"] = s.NetworkId
	m["cidr"] = s.Cidr
	if s.IpVersion != 0 {
		m["ip_version"] = s.IpVersion
	}
	if s.GatewayIp != "" {
		m["gateway_ip"] = s.GatewayIp
	}
	if s.NoGateway {
		m["no_gateway"] = s.NoGateway
	}
	if s.EnableDhcp {
		m["enable_dhcp"] = s.EnableDhcp
	}
	if len(s.DnsNameservers) > 0 {
		m["dns_nameservers"] = s.DnsNameservers
	}
	if len(s.AllocationPools) > 0 {
		items := make([]any, len(s.AllocationPools))
		for i, v := range s.AllocationPools {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["allocation_pools"] = items
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Region != "" {
		m["region"] = s.Region
	}
	return m
}

// AllocationPool defines an IP allocation range within a subnet.
//
//	The range is inclusive: both start and end addresses are allocatable.
type AllocationPoolInput struct {
	// start is the first IP address in the allocation range.
	//  Example: "192.168.1.100"
	Start string `json:"start" jsonschema:"required,start is the first IP address in the allocation range. Example: '192.168.1.100'"`
	// end is the last IP address in the allocation range.
	//  Example: "192.168.1.200"
	End string `json:"end" jsonschema:"required,end is the last IP address in the allocation range. Example: '192.168.1.200'"`
}

func (s *AllocationPoolInput) validate() error {
	if s.Start == "" {
		return fmt.Errorf("start is required")
	}
	if s.End == "" {
		return fmt.Errorf("end is required")
	}
	return nil
}

func (s *AllocationPoolInput) applyDefaults() {
}

func (s *AllocationPoolInput) toMap() map[string]any {
	m := make(map[string]any)
	m["start"] = s.Start
	m["end"] = s.End
	return m
}

// ParseOpenStackSubnet validates and normalizes a OpenStackSubnet cloud_object.
func ParseOpenStackSubnet(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openstack.openmcf.org/v1", "OpenStackSubnet"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenStackSubnetSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
