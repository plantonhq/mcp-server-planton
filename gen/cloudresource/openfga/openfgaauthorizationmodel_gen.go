// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package openfga

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenFgaAuthorizationModel is a deployment component that creates an authorization model in OpenFGA.
//
//	An authorization model defines the types, relations, and access rules for fine-grained
//	authorization. It is the schema that determines what relationship tuples mean and how
//	access decisions are computed.
//
//	Key concepts:
//	- Types: Define object types (user, document, folder, etc.)
//	- Relations: Define relationships between types (viewer, editor, owner, parent, etc.)
//	- Rewrites: Define how relations are computed (direct, computed, union, intersection, etc.)
//	- Conditions: Define dynamic rules for access decisions
//
//	IMPORTANT: Authorization models are immutable. Each model_json change creates a new model ID.
//
//	IMPORTANT: OpenFGA only has a Terraform provider - there is no Pulumi provider available.
//	This component must be deployed using Terraform/Tofu as the provisioner.
//	The Pulumi module is a pass-through placeholder that does not create resources.
//
//	Use cases:
//	- Define access control rules for applications
//	- Version authorization schemas over time
//	- Test new authorization models before production deployment
//	- Manage authorization infrastructure as code
//
//	Example manifest:
//	```yaml
//	apiVersion: openfga.openmcf.org/v1
//	kind: OpenFgaAuthorizationModel
//	metadata:
//	  name: production-model-v1
//	  org: my-organization
//	  env: production
//	spec:
//	  storeId: "01HXYZ..."
//	  modelJson: |
//	    {
//	      "schema_version": "1.1",
//	      "type_definitions": [
//	        {"type": "user", "relations": {}},
//	        {"type": "document", "relations": {"viewer": {"this": {}}}}
//	      ]
//	    }
//	```
type OpenFgaAuthorizationModelSpecInput struct {
	// store_id is the unique identifier of the OpenFGA store where this model will be created.
	//
	//  This can be either:
	//  - A direct value: {value: "01HXYZ..."}
	//  - A reference to an OpenFgaStore: {value_from: {name: "my-store"}}
	//
	//  When using references, the store ID is automatically resolved from the
	//  OpenFga...
	StoreId string `json:"store_id" jsonschema:"required,store_id is the unique identifier of the OpenFGA store where this model will be created. This can be either: - A direct value: {value: '01HXYZ...'} - A reference to an OpenFgaStore: {value_from: {name..."`
	// model_dsl is the authorization model definition in DSL format (recommended).
	//
	//  The DSL format is more human-readable than JSON and is the preferred format
	//  in OpenFGA documentation. The Terraform module automatically converts DSL to JSON
	//  using the openfga_authorization_model_document data source.
	//
	// ...
	ModelDsl string `json:"model_dsl,omitempty" jsonschema:"model_dsl is the authorization model definition in DSL format (recommended). The DSL format is more human-readable than JSON and is the preferred format in OpenFGA documentation. The Terraform module ..."`
	// model_json is the authorization model definition in JSON format.
	//
	//  Use this if you prefer JSON over DSL, or if you're migrating from existing JSON models.
	//  The JSON must conform to the OpenFGA authorization model schema and include:
	//  - schema_version: The schema version (e.g., "1.1")
	//  - type_definit...
	ModelJson string `json:"model_json,omitempty" jsonschema:"model_json is the authorization model definition in JSON format. Use this if you prefer JSON over DSL; or if you're migrating from existing JSON models. The JSON must conform to the OpenFGA authorizat..."`
}

func (s *OpenFgaAuthorizationModelSpecInput) validate() error {
	if s.StoreId == "" {
		return fmt.Errorf("store_id is required")
	}
	return nil
}

func (s *OpenFgaAuthorizationModelSpecInput) applyDefaults() {
}

func (s *OpenFgaAuthorizationModelSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["store_id"] = s.StoreId
	if s.ModelDsl != "" {
		m["model_dsl"] = s.ModelDsl
	}
	if s.ModelJson != "" {
		m["model_json"] = s.ModelJson
	}
	return m
}

// ParseOpenFgaAuthorizationModel validates and normalizes a OpenFgaAuthorizationModel cloud_object.
func ParseOpenFgaAuthorizationModel(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openfga.openmcf.org/v1", "OpenFgaAuthorizationModel"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenFgaAuthorizationModelSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
