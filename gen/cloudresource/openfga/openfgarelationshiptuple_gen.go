// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package openfga

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// OpenFgaRelationshipTuple is a deployment component that creates a relationship tuple in OpenFGA.
//
//	A relationship tuple is the fundamental unit of authorization data in OpenFGA. It represents
//	a relationship between a user (or userset) and an object through a specific relation. When
//	combined with an authorization model, tuples determine access decisions.
//
//	Key concepts:
//	- User: The subject being granted access (user:anne, group:engineering#member, user:*)
//	- Relation: The type of relationship (viewer, editor, owner, member, admin)
//	- Object: The resource being accessed (document:budget, folder:reports)
//	- Condition: Optional dynamic rules evaluated at check time
//
//	IMPORTANT: Relationship tuples are immutable. Changing any field creates a new tuple and
//	deletes the old one (Terraform handles this automatically).
//
//	IMPORTANT: OpenFGA only has a Terraform provider - there is no Pulumi provider available.
//	This component must be deployed using Terraform/Tofu as the provisioner.
//	The Pulumi module is a pass-through placeholder that does not create resources.
//
//	Use cases:
//	- Grant a user access to a specific document
//	- Add a user to a group or organization
//	- Create hierarchical relationships (folder contains document)
//	- Implement role-based access with conditions
//
//	Example manifest:
//	```yaml
//	apiVersion: openfga.openmcf.org/v1
//	kind: OpenFgaRelationshipTuple
//	metadata:
//	  name: anne-views-budget
//	  org: my-organization
//	  env: production
//	spec:
//	  storeId: "01HXYZ..."
//	  user: "user:anne"
//	  relation: "viewer"
//	  object: "document:budget-2024"
//	```
type OpenFgaRelationshipTupleSpecInput struct {
	// store_id is the unique identifier of the OpenFGA store this tuple belongs to.
	//
	//  This can be either:
	//  - A direct value: {value: "01HXYZ..."}
	//  - A reference to an OpenFgaStore: {value_from: {name: "my-store"}}
	//
	//  When using references, the store ID is automatically resolved from the
	//  OpenFgaStore's sta...
	StoreId string `json:"store_id" jsonschema:"required,store_id is the unique identifier of the OpenFGA store this tuple belongs to. This can be either: - A direct value: {value: '01HXYZ...'} - A reference to an OpenFgaStore: {value_from: {name: 'my-store..."`
	// authorization_model_id is the unique identifier of the authorization model this tuple
	//  is associated with.
	//
	//  This can be either:
	//  - A direct value: {value: "01HXYZ..."}
	//  - A reference to an OpenFgaAuthorizationModel: {value_from: {name: "my-model"}}
	//
	//  When using references, the model ID is automatic...
	AuthorizationModelId string `json:"authorization_model_id,omitempty" jsonschema:"authorization_model_id is the unique identifier of the authorization model this tuple is associated with. This can be either: - A direct value: {value: '01HXYZ...'} - A reference to an OpenFgaAuthoriz..."`
	// user is the subject of the relationship tuple - who is being granted access.
	//
	//  The user is specified as a structured object with:
	//  - type: The user type defined in the authorization model (e.g., "user", "group")
	//  - id: The user identifier (e.g., "anne", "engineering", "*" for wildcard)
	//  - relation: ...
	User *OpenFgaRelationshipTupleUserInput `json:"user" jsonschema:"required,user is the subject of the relationship tuple - who is being granted access. The user is specified as a structured object with: - type: The user type defined in the authorization model (e.g.; 'user'; ..."`
	// relation is the relationship type between the user and object.
	//
	//  The relation must be defined in the authorization model for the object type.
	//  Common relations include: viewer, editor, owner, member, admin, parent.
	//
	//  Note: The relation is immutable - changing it requires replacing the tuple.
	//
	//  Examp...
	Relation string `json:"relation" jsonschema:"required,relation is the relationship type between the user and object. The relation must be defined in the authorization model for the object type. Common relations include: viewer; editor; owner; member; adm..."`
	// object is the resource the user is being granted access to.
	//
	//  The object is specified as a structured object with:
	//  - type: The object type defined in the authorization model (e.g., "document", "folder")
	//  - id: The object identifier (e.g., "budget-2024", "reports")
	//
	//  The IaC module combines these in...
	Object *OpenFgaRelationshipTupleObjectInput `json:"object" jsonschema:"required,object is the resource the user is being granted access to. The object is specified as a structured object with: - type: The object type defined in the authorization model (e.g.; 'document'; 'folder')..."`
	// condition optionally specifies a condition that must be satisfied for this tuple
	//  to be considered during access checks.
	//
	//  Conditions enable dynamic access control based on runtime context. The condition
	//  must be defined in the authorization model, and the context must provide values
	//  for the condit...
	Condition *OpenFgaRelationshipTupleConditionInput `json:"condition,omitempty" jsonschema:"condition optionally specifies a condition that must be satisfied for this tuple to be considered during access checks. Conditions enable dynamic access control based on runtime context. The condition..."`
}

func (s *OpenFgaRelationshipTupleSpecInput) validate() error {
	if s.StoreId == "" {
		return fmt.Errorf("store_id is required")
	}
	if s.User == nil {
		return fmt.Errorf("user is required")
	}
	if s.User != nil {
		if err := s.User.validate(); err != nil {
			return fmt.Errorf("user: %w", err)
		}
	}
	if s.Relation == "" {
		return fmt.Errorf("relation is required")
	}
	if s.Object == nil {
		return fmt.Errorf("object is required")
	}
	if s.Object != nil {
		if err := s.Object.validate(); err != nil {
			return fmt.Errorf("object: %w", err)
		}
	}
	if s.Condition != nil {
		if err := s.Condition.validate(); err != nil {
			return fmt.Errorf("condition: %w", err)
		}
	}
	return nil
}

func (s *OpenFgaRelationshipTupleSpecInput) applyDefaults() {
	if s.User != nil {
		s.User.applyDefaults()
	}
	if s.Object != nil {
		s.Object.applyDefaults()
	}
	if s.Condition != nil {
		s.Condition.applyDefaults()
	}
}

func (s *OpenFgaRelationshipTupleSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["store_id"] = s.StoreId
	if s.AuthorizationModelId != "" {
		m["authorization_model_id"] = s.AuthorizationModelId
	}
	if s.User != nil {
		m["user"] = s.User.toMap()
	}
	m["relation"] = s.Relation
	if s.Object != nil {
		m["object"] = s.Object.toMap()
	}
	if s.Condition != nil {
		m["condition"] = s.Condition.toMap()
	}
	return m
}

// OpenFgaRelationshipTupleCondition defines an optional condition for a relationship tuple.
//
//	Conditions allow dynamic access decisions based on context provided at check time.
//	For example, you might have a condition that only allows access during business hours
//	or from specific IP ranges.
//
//	Reference:
//	- OpenFGA Conditions: https://openfga.dev/docs/modeling/conditions
type OpenFgaRelationshipTupleConditionInput struct {
	// name is the name of the condition as defined in the authorization model.
	//
	//  The condition must be declared in the authorization model's conditions section
	//  before it can be used in tuples.
	//
	//  Example: "in_allowed_ip_range", "during_business_hours"
	Name string `json:"name" jsonschema:"required,name is the name of the condition as defined in the authorization model. The condition must be declared in the authorization model's conditions section before it can be used in tuples. Example: 'in_al..."`
	// context_json is the partial context provided with the tuple, in JSON format.
	//
	//  This context is merged with the context provided at check time. The combined
	//  context is then evaluated against the condition defined in the authorization model.
	//
	//  The JSON must be a valid object with keys matching the co...
	ContextJson string `json:"context_json,omitempty" jsonschema:"context_json is the partial context provided with the tuple; in JSON format. This context is merged with the context provided at check time. The combined context is then evaluated against the conditio..."`
}

func (s *OpenFgaRelationshipTupleConditionInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *OpenFgaRelationshipTupleConditionInput) applyDefaults() {
}

func (s *OpenFgaRelationshipTupleConditionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.ContextJson != "" {
		m["context_json"] = s.ContextJson
	}
	return m
}

// OpenFgaRelationshipTupleObject defines the object (resource) of a relationship tuple.
//
//	In OpenFGA, objects are represented as "type:id". This structured message
//	makes it easier to specify objects without manually constructing the
//	colon-separated format.
//
//	Examples:
//	- {type: "document", id: {value: "budget-2024"}} → "document:budget-2024"
//	- {type: "folder", id: {value: "reports"}} → "folder:reports"
//	- {type: "project", id: {value_from: {name: "my-project"}}} → "project:<resolved-id>"
type OpenFgaRelationshipTupleObjectInput struct {
	// type is the object type as defined in the authorization model.
	//
	//  This must match a type defined in the authorization model.
	//
	//  Examples: "document", "folder", "project", "organization", "team"
	Type string `json:"type" jsonschema:"required,type is the object type as defined in the authorization model. This must match a type defined in the authorization model. Examples: 'document'; 'folder'; 'project'; 'organization'; 'team'"`
	// id is the unique identifier of the object.
	//
	//  This can be either:
	//  - A direct value: {value: "budget-2024"}
	//  - A reference to another resource: {value_from: {name: "my-resource"}}
	//
	//  When using references, the ID is automatically resolved from the referenced
	//  resource's field (default: metadata.id).
	//
	// ...
	Id string `json:"id" jsonschema:"required,id is the unique identifier of the object. This can be either: - A direct value: {value: 'budget-2024'} - A reference to another resource: {value_from: {name: 'my-resource'}} When using references; th..."`
}

func (s *OpenFgaRelationshipTupleObjectInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.Id == "" {
		return fmt.Errorf("id is required")
	}
	return nil
}

func (s *OpenFgaRelationshipTupleObjectInput) applyDefaults() {
}

func (s *OpenFgaRelationshipTupleObjectInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	m["id"] = s.Id
	return m
}

// OpenFgaRelationshipTupleUser defines the user (subject) of a relationship tuple.
//
//	In OpenFGA, users are represented as "type:id" or "type:id#relation" for usersets.
//	This structured message makes it easier to specify users without manually
//	constructing the colon-separated format.
//
//	Examples:
//	- Simple user: {type: "user", id: {value: "anne"}} → "user:anne"
//	- Wildcard: {type: "user", id: {value: "*"}} → "user:*"
//	- Reference: {type: "user", id: {value_from: {name: "my-user"}}} → "user:<resolved-id>"
//	- Userset: {type: "group", id: {value: "engineering"}, relation: "member"} → "group:engineering#member"
type OpenFgaRelationshipTupleUserInput struct {
	// type is the user type as defined in the authorization model.
	//
	//  This must match a type defined in the authorization model that is allowed
	//  as a subject for the target relation.
	//
	//  Examples: "user", "group", "team", "service", "application"
	Type string `json:"type" jsonschema:"required,type is the user type as defined in the authorization model. This must match a type defined in the authorization model that is allowed as a subject for the target relation. Examples: 'user'; 'group'; ..."`
	// id is the unique identifier of the user.
	//
	//  This can be either:
	//  - A direct value: {value: "anne"}
	//  - A reference to another resource: {value_from: {name: "my-resource"}}
	//
	//  When using references, the ID is automatically resolved from the referenced
	//  resource's field (default: metadata.id).
	//
	//  Use {val...
	Id string `json:"id" jsonschema:"required,id is the unique identifier of the user. This can be either: - A direct value: {value: 'anne'} - A reference to another resource: {value_from: {name: 'my-resource'}} When using references; the ID is a..."`
	// relation is optional, used to create usersets (type:id#relation format).
	//
	//  When specified, the user represents "all entities that have this relation
	//  to the specified object". For example, "all members of the engineering group".
	//
	//  When omitted, the user is a direct reference to "type:id".
	//  When spec...
	Relation string `json:"relation,omitempty" jsonschema:"relation is optional; used to create usersets (type:id#relation format). When specified; the user represents 'all entities that have this relation to the specified object'. For example; 'all members o..."`
}

func (s *OpenFgaRelationshipTupleUserInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.Id == "" {
		return fmt.Errorf("id is required")
	}
	return nil
}

func (s *OpenFgaRelationshipTupleUserInput) applyDefaults() {
}

func (s *OpenFgaRelationshipTupleUserInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	m["id"] = s.Id
	if s.Relation != "" {
		m["relation"] = s.Relation
	}
	return m
}

// ParseOpenFgaRelationshipTuple validates and normalizes a OpenFgaRelationshipTuple cloud_object.
func ParseOpenFgaRelationshipTuple(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "openfga.openmcf.org/v1", "OpenFgaRelationshipTuple"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec OpenFgaRelationshipTupleSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
