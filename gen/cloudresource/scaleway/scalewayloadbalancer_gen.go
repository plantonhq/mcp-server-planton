// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package scaleway

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// ScalewayLoadBalancer represents a managed Scaleway Load Balancer that bundles
//
//	a Flexible IP, the LB appliance, backend server pools, frontend listeners,
//	and optional TLS certificates into a single declarative resource.
//
//	This is a composite resource. Applying a single ScalewayLoadBalancer manifest
//	creates up to 5 different Scaleway resource types under the hood:
//	  - scaleway_lb_ip       -- Dedicated Flexible IP
//	  - scaleway_lb          -- Load Balancer appliance
//	  - scaleway_lb_backend  -- Backend server pool(s)
//	  - scaleway_lb_frontend -- Frontend listener(s)
//	  - scaleway_lb_certificate -- TLS certificate(s)
type ScalewayLoadBalancerSpecInput struct {
	// The Scaleway zone where the Load Balancer will be created.
	//  Examples: "fr-par-1", "nl-ams-1", "pl-waw-1"
	//
	//  Load Balancers are zonal resources. The zone must be within the same
	//  region as any Private Network the LB is attached to. For example, if
	//  the Private Network is in region "fr-par", the LB zon...
	Zone string `json:"zone" jsonschema:"required,The Scaleway zone where the Load Balancer will be created. Examples: 'fr-par-1'; 'nl-ams-1'; 'pl-waw-1' Load Balancers are zonal resources. The zone must be within the same region as any Private Netwo..."`
	// Load Balancer type determines bandwidth, throughput, and pricing tier.
	//
	//  Available types (subject to Scaleway's current offering):
	//    - "LB-S"     -- Small. Up to 400 Mbps. Good for development and small apps.
	//    - "LB-GP-M"  -- Medium. Up to 4 Gbps. General-purpose production workloads.
	//    - "LB-GP...
	Type string `json:"type" jsonschema:"required,Load Balancer type determines bandwidth; throughput; and pricing tier. Available types (subject to Scaleway's current offering): - 'LB-S' -- Small. Up to 400 Mbps. Good for development and small apps...."`
	// The Private Network to attach the Load Balancer to.
	//
	//  When set, the LB receives a private IP on this network and can reach
	//  backend servers via their private IPs. This is the recommended topology
	//  for production: keep backend servers off the public internet and let
	//  the LB handle ingress.
	//
	//  In infra...
	PrivateNetworkId string `json:"private_network_id,omitempty" jsonschema:"The Private Network to attach the Load Balancer to. When set; the LB receives a private IP on this network and can reach backend servers via their private IPs. This is the recommended topology for pro..."`
	// Human-readable description for the Load Balancer.
	//
	//  Optional. Useful for organizational purposes in the Scaleway console.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description for the Load Balancer. Optional. Useful for organizational purposes in the Scaleway console."`
	// Minimum SSL/TLS compatibility level for HTTPS frontends.
	//
	//  Controls the minimum TLS version clients must support to connect.
	//  Options:
	//    - "ssl_compatibility_level_intermediate" (default) -- TLS 1.2+. Broad compatibility.
	//    - "ssl_compatibility_level_modern" -- TLS 1.3 only. Maximum security.
	//
	//  On...
	SslCompatibilityLevel string `json:"ssl_compatibility_level,omitempty" jsonschema:"Minimum SSL/TLS compatibility level for HTTPS frontends. Controls the minimum TLS version clients must support to connect. Options: - 'ssl_compatibility_level_intermediate' (default) -- TLS 1.2+. Broa..."`
	// Backend pools. Each backend defines a named set of servers that receive
	//  traffic, along with health check rules and load-balancing configuration.
	//
	//  At least one backend is required. Frontends reference backends by name
	//  to route traffic.
	//
	//  Example: A backend named "web" with two server IPs on port 8...
	Backends []*ScalewayLoadBalancerBackendInput `json:"backends" jsonschema:"required,Backend pools. Each backend defines a named set of servers that receive traffic; along with health check rules and load-balancing configuration. At least one backend is required. Frontends reference b..."`
	// Frontends. Each frontend defines a named listener on a specific port
	//  that routes incoming traffic to a backend.
	//
	//  At least one frontend is required. Each frontend must reference a
	//  backend by name (the `backend_name` field must match a backend's `name`).
	//
	//  Example: A frontend named "http" listening...
	Frontends []*ScalewayLoadBalancerFrontendInput `json:"frontends" jsonschema:"required,Frontends. Each frontend defines a named listener on a specific port that routes incoming traffic to a backend. At least one frontend is required. Each frontend must reference a backend by name (the '..."`
	// TLS certificates for HTTPS frontends.
	//
	//  Each certificate has a name and is either auto-provisioned via Let's Encrypt
	//  or provided as a custom PEM chain. Frontends reference certificates by
	//  name in their `certificate_names` field.
	//
	//  Optional. Only needed when frontends serve HTTPS traffic.
	Certificates []*ScalewayLoadBalancerCertificateInput `json:"certificates,omitempty" jsonschema:"TLS certificates for HTTPS frontends. Each certificate has a name and is either auto-provisioned via Let's Encrypt or provided as a custom PEM chain. Frontends reference certificates by name in their ..."`
}

func (s *ScalewayLoadBalancerSpecInput) validate() error {
	if s.Zone == "" {
		return fmt.Errorf("zone is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if len(s.Backends) == 0 {
		return fmt.Errorf("backends is required")
	}
	if len(s.Backends) < 1 {
		return fmt.Errorf("backends requires at least 1 items, got %d", len(s.Backends))
	}
	for i, v := range s.Backends {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backends[%d]: %w", i, err)
			}
		}
	}
	if len(s.Frontends) == 0 {
		return fmt.Errorf("frontends is required")
	}
	if len(s.Frontends) < 1 {
		return fmt.Errorf("frontends requires at least 1 items, got %d", len(s.Frontends))
	}
	for i, v := range s.Frontends {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("frontends[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Certificates {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("certificates[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ScalewayLoadBalancerSpecInput) applyDefaults() {
}

func (s *ScalewayLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone"] = s.Zone
	m["type"] = s.Type
	if s.PrivateNetworkId != "" {
		m["private_network_id"] = s.PrivateNetworkId
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.SslCompatibilityLevel != "" {
		m["ssl_compatibility_level"] = s.SslCompatibilityLevel
	}
	if len(s.Backends) > 0 {
		items := make([]any, len(s.Backends))
		for i, v := range s.Backends {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backends"] = items
	}
	if len(s.Frontends) > 0 {
		items := make([]any, len(s.Frontends))
		for i, v := range s.Frontends {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["frontends"] = items
	}
	if len(s.Certificates) > 0 {
		items := make([]any, len(s.Certificates))
		for i, v := range s.Certificates {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["certificates"] = items
	}
	return m
}

// ScalewayLoadBalancerBackend defines a named backend server pool.
//
//	Each backend is a group of servers (identified by IP) that receive traffic
//	forwarded by one or more frontends. Backends include health check
//	configuration to detect and remove unhealthy servers from rotation.
//
//	Backend names must be unique within the Load Balancer spec. Frontends
//	reference backends by their `name` field.
type ScalewayLoadBalancerBackendInput struct {
	// Name identifying this backend. Used by frontends to reference this pool.
	//
	//  Must be unique within the Load Balancer spec. Use descriptive names
	//  like "web", "api", "grpc" to make the configuration self-documenting.
	Name string `json:"name" jsonschema:"required,Name identifying this backend. Used by frontends to reference this pool. Must be unique within the Load Balancer spec. Use descriptive names like 'web'; 'api'; 'grpc' to make the configuration self-do..."`
	// IP addresses of backend servers.
	//
	//  These are the servers that will receive forwarded traffic. When the LB
	//  is attached to a Private Network, use private IPs (e.g., "10.0.1.5").
	//  Without a Private Network, use public IPs.
	//
	//  At least one server IP is required.
	ServerIps []string `json:"server_ips" jsonschema:"required,IP addresses of backend servers. These are the servers that will receive forwarded traffic. When the LB is attached to a Private Network; use private IPs (e.g.; '10.0.1.5'). Without a Private Network;..."`
	// Port on backend servers that receives forwarded traffic.
	//
	//  This is the port your application listens on (e.g., 80 for HTTP,
	//  443 for HTTPS, 8080 for a custom app server).
	ForwardPort int32 `json:"forward_port" jsonschema:"required,Port on backend servers that receives forwarded traffic. This is the port your application listens on (e.g.; 80 for HTTP; 443 for HTTPS; 8080 for a custom app server)."`
	// Protocol for communication between the LB and backend servers.
	//
	//  Options: "http", "https", "tcp"
	//    - "http"  -- Layer 7. The LB inspects HTTP headers. Use for web apps.
	//    - "https" -- Layer 7 with TLS to backends (ssl_bridging). Use when
	//                 backends require encrypted connections.
	//    -...
	ForwardProtocol string `json:"forward_protocol" jsonschema:"required,Protocol for communication between the LB and backend servers. Options: 'http'; 'https'; 'tcp' - 'http' -- Layer 7. The LB inspects HTTP headers. Use for web apps. - 'https' -- Layer 7 with TLS to bac..."`
	// Load-balancing algorithm for distributing connections across servers.
	//
	//  Options:
	//    - "roundrobin" (default) -- Distribute evenly in rotation.
	//    - "leastconn"  -- Send to the server with fewest active connections.
	//    - "first"      -- Send to the first healthy server (active-passive).
	ForwardPortAlgorithm string `json:"forward_port_algorithm,omitempty" jsonschema:"Load-balancing algorithm for distributing connections across servers. Options: - 'roundrobin' (default) -- Distribute evenly in rotation. - 'leastconn' -- Send to the server with fewest active connect..."`
	// Sticky session type for maintaining client affinity.
	//
	//  Options:
	//    - "none" (default)  -- No session affinity.
	//    - "cookie" -- Insert an HTTP cookie to track client sessions.
	//    - "table"  -- Use a connection table (Layer 4, for TCP backends).
	//
	//  Use "cookie" for web applications that store session ...
	StickySessions string `json:"sticky_sessions,omitempty" jsonschema:"Sticky session type for maintaining client affinity. Options: - 'none' (default) -- No session affinity. - 'cookie' -- Insert an HTTP cookie to track client sessions. - 'table' -- Use a connection tab..."`
	// Cookie name for sticky sessions. Required when sticky_sessions = "cookie".
	//
	//  The LB injects this cookie into HTTP responses to track which backend
	//  server a client was previously routed to.
	//  Example: "SERVERID"
	StickySessionsCookieName string `json:"sticky_sessions_cookie_name,omitempty" jsonschema:"Cookie name for sticky sessions. Required when sticky_sessions = 'cookie'. The LB injects this cookie into HTTP responses to track which backend server a client was previously routed to. Example: 'SER..."`
	// Health check configuration for this backend.
	//
	//  Defines how the LB probes backend servers to detect failures. Unhealthy
	//  servers are automatically removed from rotation and re-added when they
	//  recover.
	//
	//  If omitted, a default TCP health check on the forward_port is used
	//  with a 5-second interval, 3-s...
	HealthCheck *ScalewayLoadBalancerHealthCheckInput `json:"health_check,omitempty" jsonschema:"Health check configuration for this backend. Defines how the LB probes backend servers to detect failures. Unhealthy servers are automatically removed from rotation and re-added when they recover. If ..."`
	// Maximum time to wait for a connection to a backend server.
	//
	//  Duration string (e.g., "5s", "10s"). If omitted, Scaleway's default applies.
	//  Increase for backends with slow connection establishment (e.g., cold starts).
	TimeoutConnect string `json:"timeout_connect,omitempty" jsonschema:"Maximum time to wait for a connection to a backend server. Duration string (e.g.; '5s'; '10s'). If omitted; Scaleway's default applies. Increase for backends with slow connection establishment (e.g.; ..."`
	// Maximum time a backend server connection can be idle before being closed.
	//
	//  Duration string (e.g., "30s", "5m"). If omitted, Scaleway's default applies.
	//  Increase for long-polling, WebSocket, or streaming backends.
	TimeoutServer string `json:"timeout_server,omitempty" jsonschema:"Maximum time a backend server connection can be idle before being closed. Duration string (e.g.; '30s'; '5m'). If omitted; Scaleway's default applies. Increase for long-polling; WebSocket; or streamin..."`
	// Action when a backend server is marked as down.
	//
	//  Options:
	//    - "none" (default) -- Keep existing connections open.
	//    - "shutdown_sessions" -- Immediately close all connections to the
	//      downed server. Use when fast failover is more important than
	//      graceful connection draining.
	OnMarkedDownAction string `json:"on_marked_down_action,omitempty" jsonschema:"Action when a backend server is marked as down. Options: - 'none' (default) -- Keep existing connections open. - 'shutdown_sessions' -- Immediately close all connections to the downed server. Use when..."`
	// Enable SSL bridging (re-encrypt traffic between the LB and backends).
	//
	//  When true, the LB establishes a new TLS connection to backend servers.
	//  Use when backends require encrypted connections (e.g., for compliance).
	//
	//  Default: false (traffic between LB and backends is unencrypted).
	SslBridging bool `json:"ssl_bridging,omitempty" jsonschema:"Enable SSL bridging (re-encrypt traffic between the LB and backends). When true; the LB establishes a new TLS connection to backend servers. Use when backends require encrypted connections (e.g.; for ..."`
	// PROXY protocol version for passing client connection metadata to backends.
	//
	//  Options:
	//    - "none" (default) -- No PROXY protocol.
	//    - "v1"      -- PROXY protocol v1 (human-readable header).
	//    - "v2"      -- PROXY protocol v2 (binary header).
	//    - "v2_ssl"  -- v2 with SSL information.
	//    - "v2_ssl_...
	ProxyProtocol string `json:"proxy_protocol,omitempty" jsonschema:"PROXY protocol version for passing client connection metadata to backends. Options: - 'none' (default) -- No PROXY protocol. - 'v1' -- PROXY protocol v1 (human-readable header). - 'v2' -- PROXY protoc..."`
}

func (s *ScalewayLoadBalancerBackendInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.ServerIps) == 0 {
		return fmt.Errorf("server_ips is required")
	}
	if len(s.ServerIps) < 1 {
		return fmt.Errorf("server_ips requires at least 1 items, got %d", len(s.ServerIps))
	}
	if s.ForwardProtocol == "" {
		return fmt.Errorf("forward_protocol is required")
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	return nil
}

func (s *ScalewayLoadBalancerBackendInput) applyDefaults() {
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *ScalewayLoadBalancerBackendInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["server_ips"] = s.ServerIps
	m["forward_port"] = s.ForwardPort
	m["forward_protocol"] = s.ForwardProtocol
	if s.ForwardPortAlgorithm != "" {
		m["forward_port_algorithm"] = s.ForwardPortAlgorithm
	}
	if s.StickySessions != "" {
		m["sticky_sessions"] = s.StickySessions
	}
	if s.StickySessionsCookieName != "" {
		m["sticky_sessions_cookie_name"] = s.StickySessionsCookieName
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	if s.TimeoutConnect != "" {
		m["timeout_connect"] = s.TimeoutConnect
	}
	if s.TimeoutServer != "" {
		m["timeout_server"] = s.TimeoutServer
	}
	if s.OnMarkedDownAction != "" {
		m["on_marked_down_action"] = s.OnMarkedDownAction
	}
	if s.SslBridging {
		m["ssl_bridging"] = s.SslBridging
	}
	if s.ProxyProtocol != "" {
		m["proxy_protocol"] = s.ProxyProtocol
	}
	return m
}

// ScalewayLoadBalancerCertificate defines a TLS certificate for HTTPS frontends.
//
//	Each certificate has a unique name and is either auto-provisioned via
//	Let's Encrypt or provided as a custom PEM chain. Frontends reference
//	certificates by name in their `certificate_names` field.
//
//	Exactly one of `letsencrypt` or `custom_certificate` must be set.
type ScalewayLoadBalancerCertificateInput struct {
	// Name identifying this certificate.
	//
	//  Must be unique within the Load Balancer spec. Frontends reference
	//  this name in their `certificate_names` field.
	//  Example: "example-com-cert", "wildcard-cert"
	Name string `json:"name" jsonschema:"required,Name identifying this certificate. Must be unique within the Load Balancer spec. Frontends reference this name in their 'certificate_names' field. Example: 'example-com-cert'; 'wildcard-cert'"`
	// Let's Encrypt auto-provisioned certificate configuration.
	//
	//  When set, Scaleway automatically provisions and renews a TLS certificate
	//  for the specified domain(s) using the ACME protocol. The domain must
	//  resolve to the LB's public IP for validation to succeed.
	//
	//  Exactly one of `letsencrypt` or `cust...
	Letsencrypt *ScalewayLoadBalancerLetsencryptInput `json:"letsencrypt,omitempty" jsonschema:"Let's Encrypt auto-provisioned certificate configuration. When set; Scaleway automatically provisions and renews a TLS certificate for the specified domain(s) using the ACME protocol. The domain must ..."`
	// Custom certificate configuration (user-provided PEM).
	//
	//  When set, the user provides a full certificate chain in PEM format.
	//  Use this for certificates from commercial CAs, internal PKI, or
	//  wildcard certificates that Let's Encrypt doesn't support.
	//
	//  Exactly one of `letsencrypt` or `custom_certificat...
	CustomCertificate *ScalewayLoadBalancerCustomCertificateInput `json:"custom_certificate,omitempty" jsonschema:"Custom certificate configuration (user-provided PEM). When set; the user provides a full certificate chain in PEM format. Use this for certificates from commercial CAs; internal PKI; or wildcard certi..."`
}

func (s *ScalewayLoadBalancerCertificateInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Letsencrypt != nil {
		if err := s.Letsencrypt.validate(); err != nil {
			return fmt.Errorf("letsencrypt: %w", err)
		}
	}
	if s.CustomCertificate != nil {
		if err := s.CustomCertificate.validate(); err != nil {
			return fmt.Errorf("custom_certificate: %w", err)
		}
	}
	return nil
}

func (s *ScalewayLoadBalancerCertificateInput) applyDefaults() {
	if s.Letsencrypt != nil {
		s.Letsencrypt.applyDefaults()
	}
	if s.CustomCertificate != nil {
		s.CustomCertificate.applyDefaults()
	}
}

func (s *ScalewayLoadBalancerCertificateInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Letsencrypt != nil {
		m["letsencrypt"] = s.Letsencrypt.toMap()
	}
	if s.CustomCertificate != nil {
		m["custom_certificate"] = s.CustomCertificate.toMap()
	}
	return m
}

// ScalewayLoadBalancerCustomCertificate provides a user-managed TLS certificate.
//
//	Use this for certificates from commercial CAs, internal PKI, or when
//	Let's Encrypt is not suitable (e.g., EV certificates, wildcard certs
//	for domains that can't point to the LB during validation).
type ScalewayLoadBalancerCustomCertificateInput struct {
	// Full certificate chain in PEM format.
	//
	//  Must include the server certificate followed by any intermediate
	//  certificates, in order. The private key must NOT be included (it is
	//  managed separately by Scaleway).
	//
	//  Example: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----\n"
	CertificateChain string `json:"certificate_chain" jsonschema:"required,Full certificate chain in PEM format. Must include the server certificate followed by any intermediate certificates; in order. The private key must NOT be included (it is managed separately by Scalewa..."`
}

func (s *ScalewayLoadBalancerCustomCertificateInput) validate() error {
	if s.CertificateChain == "" {
		return fmt.Errorf("certificate_chain is required")
	}
	return nil
}

func (s *ScalewayLoadBalancerCustomCertificateInput) applyDefaults() {
}

func (s *ScalewayLoadBalancerCustomCertificateInput) toMap() map[string]any {
	m := make(map[string]any)
	m["certificate_chain"] = s.CertificateChain
	return m
}

// ScalewayLoadBalancerFrontend defines a named listener on the Load Balancer.
//
//	Each frontend listens on a specific TCP port and routes incoming traffic
//	to a backend server pool. For HTTPS, frontends can reference TLS
//	certificates defined in the `certificates` section.
//
//	Frontend names must be unique within the Load Balancer spec.
type ScalewayLoadBalancerFrontendInput struct {
	// Name identifying this frontend.
	//
	//  Must be unique within the Load Balancer spec. Use descriptive names
	//  like "http", "https", "grpc", "api-8080".
	Name string `json:"name" jsonschema:"required,Name identifying this frontend. Must be unique within the Load Balancer spec. Use descriptive names like 'http'; 'https'; 'grpc'; 'api-8080'."`
	// TCP port to listen on for incoming connections.
	//
	//  Common ports: 80 (HTTP), 443 (HTTPS), 8080 (alt-HTTP), 8443 (alt-HTTPS).
	//  Each frontend must use a unique port within the Load Balancer.
	InboundPort int32 `json:"inbound_port" jsonschema:"required,TCP port to listen on for incoming connections. Common ports: 80 (HTTP); 443 (HTTPS); 8080 (alt-HTTP); 8443 (alt-HTTPS). Each frontend must use a unique port within the Load Balancer."`
	// Name of the backend to route traffic to.
	//
	//  Must match a backend's `name` field defined in `spec.backends`.
	//  All traffic arriving on this frontend's port is forwarded to the
	//  referenced backend's server pool.
	BackendName string `json:"backend_name" jsonschema:"required,Name of the backend to route traffic to. Must match a backend's 'name' field defined in 'spec.backends'. All traffic arriving on this frontend's port is forwarded to the referenced backend's server po..."`
	// Names of TLS certificates to attach to this frontend.
	//
	//  Must match certificate names defined in `spec.certificates`.
	//  Required for HTTPS frontends. Not allowed on plaintext HTTP frontends
	//  (Scaleway rejects certificates on port 80).
	//
	//  Multiple certificates can be attached for SNI-based selection (th...
	CertificateNames []string `json:"certificate_names,omitempty" jsonschema:"Names of TLS certificates to attach to this frontend. Must match certificate names defined in 'spec.certificates'. Required for HTTPS frontends. Not allowed on plaintext HTTP frontends (Scaleway rejec..."`
	// Maximum time a client connection can be idle before being closed.
	//
	//  Duration string (e.g., "30s", "5m"). If omitted, Scaleway's default applies.
	//  Increase for long-polling, WebSocket, or Server-Sent Events clients.
	TimeoutClient string `json:"timeout_client,omitempty" jsonschema:"Maximum time a client connection can be idle before being closed. Duration string (e.g.; '30s'; '5m'). If omitted; Scaleway's default applies. Increase for long-polling; WebSocket; or Server-Sent Even..."`
	// Enable HTTP/3 (QUIC) support on this frontend.
	//
	//  When true, the frontend accepts HTTP/3 connections over UDP in addition
	//  to HTTP/1.1 and HTTP/2 over TCP. Requires an HTTPS frontend with a
	//  TLS certificate.
	//
	//  Default: false.
	EnableHttp3 bool `json:"enable_http3,omitempty" jsonschema:"Enable HTTP/3 (QUIC) support on this frontend. When true; the frontend accepts HTTP/3 connections over UDP in addition to HTTP/1.1 and HTTP/2 over TCP. Requires an HTTPS frontend with a TLS certificat..."`
}

func (s *ScalewayLoadBalancerFrontendInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.BackendName == "" {
		return fmt.Errorf("backend_name is required")
	}
	return nil
}

func (s *ScalewayLoadBalancerFrontendInput) applyDefaults() {
}

func (s *ScalewayLoadBalancerFrontendInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["inbound_port"] = s.InboundPort
	m["backend_name"] = s.BackendName
	if len(s.CertificateNames) > 0 {
		m["certificate_names"] = s.CertificateNames
	}
	if s.TimeoutClient != "" {
		m["timeout_client"] = s.TimeoutClient
	}
	if s.EnableHttp3 {
		m["enable_http3"] = s.EnableHttp3
	}
	return m
}

// ScalewayLoadBalancerHealthCheck defines how the LB probes backend servers.
//
//	Health checks run periodically against each server in the backend pool.
//	Servers that fail `check_max_retries` consecutive checks are removed from
//	rotation. They are automatically re-added when they start passing again.
//
//	The `type` field selects the check protocol:
//	  - "tcp"   -- Attempts a TCP connection. Simplest, works for any service.
//	  - "http"  -- Sends an HTTP request and checks the response code.
//	  - "https" -- Like "http" but over TLS.
//
//	For "http" and "https" types, `uri` and `expected_code` are meaningful.
//	For "tcp", they are ignored.
type ScalewayLoadBalancerHealthCheckInput struct {
	// Health check protocol.
	//
	//  Options: "tcp" (default), "http", "https"
	//
	//  Use "tcp" for non-HTTP services (databases, gRPC, custom protocols).
	//  Use "http" for web applications. Use "https" when backends require TLS.
	Type string `json:"type,omitempty" jsonschema:"Health check protocol. Options: 'tcp' (default); 'http'; 'https' Use 'tcp' for non-HTTP services (databases; gRPC; custom protocols). Use 'http' for web applications. Use 'https' when backends require..."`
	// URI path for HTTP/HTTPS health checks.
	//
	//  The LB sends a GET request to this path on each backend server.
	//  Example: "/health", "/ready", "/ping"
	//
	//  Default: "/" -- Only meaningful when type is "http" or "https".
	Uri string `json:"uri,omitempty" jsonschema:"URI path for HTTP/HTTPS health checks. The LB sends a GET request to this path on each backend server. Example: '/health'; '/ready'; '/ping' Default: '/' -- Only meaningful when type is 'http' or 'htt..."`
	// Expected HTTP status code for a healthy response.
	//
	//  The health check passes if the server returns this status code.
	//  Default: 200 -- Only meaningful when type is "http" or "https".
	ExpectedCode int32 `json:"expected_code,omitempty" jsonschema:"Expected HTTP status code for a healthy response. The health check passes if the server returns this status code. Default: 200 -- Only meaningful when type is 'http' or 'https'."`
	// Interval between health check probes.
	//
	//  Duration string (e.g., "5s", "10s", "30s").
	//  Lower values detect failures faster but generate more probe traffic.
	//  Default: "5s"
	CheckDelay string `json:"check_delay,omitempty" jsonschema:"Interval between health check probes. Duration string (e.g.; '5s'; '10s'; '30s'). Lower values detect failures faster but generate more probe traffic. Default: '5s'"`
	// Maximum time to wait for a health check response.
	//
	//  Duration string (e.g., "3s", "5s").
	//  Must be less than check_delay. Default: "3s"
	CheckTimeout string `json:"check_timeout,omitempty" jsonschema:"Maximum time to wait for a health check response. Duration string (e.g.; '3s'; '5s'). Must be less than check_delay. Default: '3s'"`
	// Number of consecutive failed checks before marking a server as unhealthy.
	//
	//  Higher values tolerate transient failures but take longer to detect
	//  real outages. Default: 3
	CheckMaxRetries int32 `json:"check_max_retries,omitempty" jsonschema:"Number of consecutive failed checks before marking a server as unhealthy. Higher values tolerate transient failures but take longer to detect real outages. Default: 3"`
	// Port to send health check probes to.
	//
	//  If omitted or set to 0, defaults to the backend's `forward_port`.
	//  Set a different port when health checks run on a dedicated monitoring
	//  port (e.g., an application that serves traffic on 8080 but exposes
	//  health at 8081).
	Port int32 `json:"port,omitempty" jsonschema:"Port to send health check probes to. If omitted or set to 0; defaults to the backend's 'forward_port'. Set a different port when health checks run on a dedicated monitoring port (e.g.; an application ..."`
}

func (s *ScalewayLoadBalancerHealthCheckInput) validate() error {
	return nil
}

func (s *ScalewayLoadBalancerHealthCheckInput) applyDefaults() {
}

func (s *ScalewayLoadBalancerHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Uri != "" {
		m["uri"] = s.Uri
	}
	if s.ExpectedCode != 0 {
		m["expected_code"] = s.ExpectedCode
	}
	if s.CheckDelay != "" {
		m["check_delay"] = s.CheckDelay
	}
	if s.CheckTimeout != "" {
		m["check_timeout"] = s.CheckTimeout
	}
	if s.CheckMaxRetries != 0 {
		m["check_max_retries"] = s.CheckMaxRetries
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	return m
}

// ScalewayLoadBalancerLetsencrypt configures automatic TLS certificate provisioning
//
//	via Let's Encrypt.
//
//	Scaleway handles the ACME challenge, provisioning, and renewal. The domain
//	must resolve to the LB's public IP for HTTP-01 validation to succeed.
//	Create DNS records pointing to the LB's IP BEFORE enabling Let's Encrypt.
type ScalewayLoadBalancerLetsencryptInput struct {
	// Primary domain name for the certificate.
	//
	//  Example: "example.com", "app.example.com"
	//
	//  The domain must resolve to the LB's public IP. If using a new domain,
	//  create a DNS A record first, then add the certificate.
	CommonName string `json:"common_name" jsonschema:"required,Primary domain name for the certificate. Example: 'example.com'; 'app.example.com' The domain must resolve to the LB's public IP. If using a new domain; create a DNS A record first; then add the certi..."`
	// Subject Alternative Names (additional domains covered by this certificate).
	//
	//  Examples: ["www.example.com", "api.example.com"]
	//
	//  All SANs must also resolve to the LB's public IP. Let's Encrypt
	//  validates each domain independently.
	SubjectAlternativeNames []string `json:"subject_alternative_names,omitempty" jsonschema:"Subject Alternative Names (additional domains covered by this certificate). Examples: ['www.example.com'; 'api.example.com'] All SANs must also resolve to the LB's public IP. Let's Encrypt validates e..."`
}

func (s *ScalewayLoadBalancerLetsencryptInput) validate() error {
	if s.CommonName == "" {
		return fmt.Errorf("common_name is required")
	}
	return nil
}

func (s *ScalewayLoadBalancerLetsencryptInput) applyDefaults() {
}

func (s *ScalewayLoadBalancerLetsencryptInput) toMap() map[string]any {
	m := make(map[string]any)
	m["common_name"] = s.CommonName
	if len(s.SubjectAlternativeNames) > 0 {
		m["subject_alternative_names"] = s.SubjectAlternativeNames
	}
	return m
}

// ParseScalewayLoadBalancer validates and normalizes a ScalewayLoadBalancer cloud_object.
func ParseScalewayLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "scaleway.openmcf.org/v1", "ScalewayLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec ScalewayLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
