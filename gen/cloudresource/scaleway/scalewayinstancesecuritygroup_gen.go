// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package scaleway

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// scaleway-instance-security-group
type ScalewayInstanceSecurityGroupSpecInput struct {
	// The Scaleway zone where the security group will be created.
	//  Examples: "fr-par-1", "nl-ams-1", "pl-waw-1"
	//
	//  Security groups are zonal resources. The zone must match the zone of
	//  the Instances that will use this security group.
	//
	//  This field is required and cannot be changed after creation.
	Zone string `json:"zone" jsonschema:"required,The Scaleway zone where the security group will be created. Examples: 'fr-par-1'; 'nl-ams-1'; 'pl-waw-1' Security groups are zonal resources. The zone must match the zone of the Instances that will us..."`
	// Optional human-readable description of the security group's purpose.
	//  Example: "Web tier firewall -- allows HTTP/HTTPS inbound, all outbound"
	Description string `json:"description,omitempty" jsonschema:"Optional human-readable description of the security group's purpose. Example: 'Web tier firewall -- allows HTTP/HTTPS inbound; all outbound'"`
	// Whether the security group is stateful.
	//
	//  When true (default), return traffic for accepted connections is
	//  automatically permitted. For example, if an inbound rule accepts TCP
	//  port 80, the outbound response packets are automatically allowed
	//  without needing an explicit outbound rule.
	//
	//  Set to false...
	Stateful bool `json:"stateful,omitempty" jsonschema:"Whether the security group is stateful. When true (default); return traffic for accepted connections is automatically permitted. For example; if an inbound rule accepts TCP port 80; the outbound respo..."`
	// Default policy for inbound traffic that matches no rule.
	//
	//  Possible values:
	//    - "accept" -- Allow all inbound traffic unless a rule drops it.
	//                  Use this when you want a denylist model (block specific traffic).
	//    - "drop"   -- Drop all inbound traffic unless a rule accepts it.
	//       ...
	InboundDefaultPolicy string `json:"inbound_default_policy,omitempty" jsonschema:"Default policy for inbound traffic that matches no rule. Possible values: - 'accept' -- Allow all inbound traffic unless a rule drops it. Use this when you want a denylist model (block specific traffi..."`
	// Default policy for outbound traffic that matches no rule.
	//
	//  Possible values:
	//    - "accept" -- Allow all outbound traffic unless a rule drops it.
	//    - "drop"   -- Drop all outbound traffic unless a rule accepts it.
	//
	//  Default: "accept"
	//
	//  Recommendation: Keep as "accept" unless you need strict egress c...
	OutboundDefaultPolicy string `json:"outbound_default_policy,omitempty" jsonschema:"Default policy for outbound traffic that matches no rule. Possible values: - 'accept' -- Allow all outbound traffic unless a rule drops it. - 'drop' -- Drop all outbound traffic unless a rule accepts ..."`
	// Whether to enable Scaleway's default SMTP security.
	//
	//  When true (default), outbound SMTP traffic on ports 25, 465, and 587
	//  is blocked to prevent spam abuse. This is a Scaleway account-level
	//  protection that applies on top of your rules.
	//
	//  Set to false ONLY if your Scaleway account is authorized for...
	EnableDefaultSecurity bool `json:"enable_default_security,omitempty" jsonschema:"Whether to enable Scaleway's default SMTP security. When true (default); outbound SMTP traffic on ports 25; 465; and 587 is blocked to prevent spam abuse. This is a Scaleway account-level protection t..."`
	// Inbound (ingress) rules: traffic allowed or dropped TO instances.
	//
	//  Rules are evaluated in order -- the first matching rule wins.
	//  Traffic that matches no rule is handled by inbound_default_policy.
	//
	//  When inbound_default_policy is "drop", define accept rules for
	//  traffic you want to permit (allowlis...
	InboundRules []*ScalewaySecurityGroupInboundRuleInput `json:"inbound_rules,omitempty" jsonschema:"Inbound (ingress) rules: traffic allowed or dropped TO instances. Rules are evaluated in order -- the first matching rule wins. Traffic that matches no rule is handled by inbound_default_policy. When ..."`
	// Outbound (egress) rules: traffic allowed or dropped FROM instances.
	//
	//  Rules are evaluated in order -- the first matching rule wins.
	//  Traffic that matches no rule is handled by outbound_default_policy.
	OutboundRules []*ScalewaySecurityGroupOutboundRuleInput `json:"outbound_rules,omitempty" jsonschema:"Outbound (egress) rules: traffic allowed or dropped FROM instances. Rules are evaluated in order -- the first matching rule wins. Traffic that matches no rule is handled by outbound_default_policy."`
}

func (s *ScalewayInstanceSecurityGroupSpecInput) validate() error {
	if s.Zone == "" {
		return fmt.Errorf("zone is required")
	}
	for i, v := range s.InboundRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("inbound_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.OutboundRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("outbound_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *ScalewayInstanceSecurityGroupSpecInput) applyDefaults() {
}

func (s *ScalewayInstanceSecurityGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["zone"] = s.Zone
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Stateful {
		m["stateful"] = s.Stateful
	}
	if s.InboundDefaultPolicy != "" {
		m["inbound_default_policy"] = s.InboundDefaultPolicy
	}
	if s.OutboundDefaultPolicy != "" {
		m["outbound_default_policy"] = s.OutboundDefaultPolicy
	}
	if s.EnableDefaultSecurity {
		m["enable_default_security"] = s.EnableDefaultSecurity
	}
	if len(s.InboundRules) > 0 {
		items := make([]any, len(s.InboundRules))
		for i, v := range s.InboundRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["inbound_rules"] = items
	}
	if len(s.OutboundRules) > 0 {
		items := make([]any, len(s.OutboundRules))
		for i, v := range s.OutboundRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["outbound_rules"] = items
	}
	return m
}

// ScalewaySecurityGroupInboundRule defines a single inbound firewall rule.
//
//	Each rule specifies a combination of action, protocol, port(s), and
//	source IP range. The action determines whether matching traffic is
//	accepted or dropped.
type ScalewaySecurityGroupInboundRuleInput struct {
	// Action to take when traffic matches this rule.
	//
	//  Possible values: "accept" or "drop".
	//  This field is required.
	Action string `json:"action" jsonschema:"required,Action to take when traffic matches this rule. Possible values: 'accept' or 'drop'. This field is required."`
	// IP protocol for this rule.
	//
	//  Possible values: "TCP", "UDP", "ICMP", "ANY".
	//  Note: Scaleway uses uppercase protocol names.
	//
	//  Default: "TCP" (if omitted).
	Protocol string `json:"protocol,omitempty" jsonschema:"IP protocol for this rule. Possible values: 'TCP'; 'UDP'; 'ICMP'; 'ANY'. Note: Scaleway uses uppercase protocol names. Default: 'TCP' (if omitted)."`
	// Port or port range for this rule.
	//
	//  Formats:
	//    - Single port: "80", "443", "22"
	//    - Port range:  "8000-9000", "30000-32767"
	//
	//  If omitted, the rule applies to ALL ports.
	//  Ignored when protocol is "ICMP".
	PortRange string `json:"port_range,omitempty" jsonschema:"Port or port range for this rule. Formats: - Single port: '80'; '443'; '22' - Port range: '8000-9000'; '30000-32767' If omitted; the rule applies to ALL ports. Ignored when protocol is 'ICMP'."`
	// Source IP range in CIDR notation.
	//
	//  Examples: "0.0.0.0/0" (all IPv4), "203.0.113.10/32" (single host),
	//            "10.0.0.0/8" (private range)
	//
	//  If omitted, the rule applies to ALL source IPs.
	IpRange string `json:"ip_range,omitempty" jsonschema:"Source IP range in CIDR notation. Examples: '0.0.0.0/0' (all IPv4); '203.0.113.10/32' (single host); '10.0.0.0/8' (private range) If omitted; the rule applies to ALL source IPs."`
}

func (s *ScalewaySecurityGroupInboundRuleInput) validate() error {
	if s.Action == "" {
		return fmt.Errorf("action is required")
	}
	return nil
}

func (s *ScalewaySecurityGroupInboundRuleInput) applyDefaults() {
}

func (s *ScalewaySecurityGroupInboundRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["action"] = s.Action
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRange != "" {
		m["port_range"] = s.PortRange
	}
	if s.IpRange != "" {
		m["ip_range"] = s.IpRange
	}
	return m
}

// ScalewaySecurityGroupOutboundRule defines a single outbound firewall rule.
//
//	Each rule specifies a combination of action, protocol, port(s), and
//	destination IP range.
type ScalewaySecurityGroupOutboundRuleInput struct {
	// Action to take when traffic matches this rule.
	//
	//  Possible values: "accept" or "drop".
	//  This field is required.
	Action string `json:"action" jsonschema:"required,Action to take when traffic matches this rule. Possible values: 'accept' or 'drop'. This field is required."`
	// IP protocol for this rule.
	//
	//  Possible values: "TCP", "UDP", "ICMP", "ANY".
	//  Note: Scaleway uses uppercase protocol names.
	//
	//  Default: "TCP" (if omitted).
	Protocol string `json:"protocol,omitempty" jsonschema:"IP protocol for this rule. Possible values: 'TCP'; 'UDP'; 'ICMP'; 'ANY'. Note: Scaleway uses uppercase protocol names. Default: 'TCP' (if omitted)."`
	// Port or port range for this rule.
	//
	//  Formats:
	//    - Single port: "443", "53"
	//    - Port range:  "1024-65535"
	//
	//  If omitted, the rule applies to ALL ports.
	//  Ignored when protocol is "ICMP".
	PortRange string `json:"port_range,omitempty" jsonschema:"Port or port range for this rule. Formats: - Single port: '443'; '53' - Port range: '1024-65535' If omitted; the rule applies to ALL ports. Ignored when protocol is 'ICMP'."`
	// Destination IP range in CIDR notation.
	//
	//  Examples: "0.0.0.0/0" (all IPv4), "10.0.0.0/8" (private range)
	//
	//  If omitted, the rule applies to ALL destination IPs.
	IpRange string `json:"ip_range,omitempty" jsonschema:"Destination IP range in CIDR notation. Examples: '0.0.0.0/0' (all IPv4); '10.0.0.0/8' (private range) If omitted; the rule applies to ALL destination IPs."`
}

func (s *ScalewaySecurityGroupOutboundRuleInput) validate() error {
	if s.Action == "" {
		return fmt.Errorf("action is required")
	}
	return nil
}

func (s *ScalewaySecurityGroupOutboundRuleInput) applyDefaults() {
}

func (s *ScalewaySecurityGroupOutboundRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["action"] = s.Action
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRange != "" {
		m["port_range"] = s.PortRange
	}
	if s.IpRange != "" {
		m["ip_range"] = s.IpRange
	}
	return m
}

// ParseScalewayInstanceSecurityGroup validates and normalizes a ScalewayInstanceSecurityGroup cloud_object.
func ParseScalewayInstanceSecurityGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "scaleway.openmcf.org/v1", "ScalewayInstanceSecurityGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec ScalewayInstanceSecurityGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
