// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-nat-gateway
type AliCloudNatGatewaySpecInput struct {
	// Alibaba Cloud region where the NAT Gateway will be created.
	//  Must match the region of the VPC and VSwitch.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the NAT Gateway will be created. Must match the region of the VPC and VSwitch. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// VPC ID that the NAT Gateway belongs to.
	VpcId string `json:"vpc_id" jsonschema:"required,VPC ID that the NAT Gateway belongs to."`
	// VSwitch ID where the Enhanced NAT Gateway is placed.
	//  The NAT Gateway consumes an IP from this VSwitch. Must be in the same VPC
	//  as vpc_id. Required for Enhanced NAT Gateways (the default and recommended
	//  type).
	VswitchId string `json:"vswitch_id" jsonschema:"required,VSwitch ID where the Enhanced NAT Gateway is placed. The NAT Gateway consumes an IP from this VSwitch. Must be in the same VPC as vpc_id. Required for Enhanced NAT Gateways (the default and recommende..."`
	// NAT Gateway name. 2-128 characters; must start with a letter or Chinese
	//  character; can contain digits, underscores, periods, and hyphens.
	NatGatewayName string `json:"nat_gateway_name" jsonschema:"required,NAT Gateway name. 2-128 characters; must start with a letter or Chinese character; can contain digits; underscores; periods; and hyphens."`
	// Human-readable description of the NAT Gateway's purpose.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the NAT Gateway's purpose."`
	// NAT Gateway type. "Enhanced" is the modern standard with higher
	//  performance and VSwitch placement support. "Normal" is legacy.
	//  Default: "Enhanced"
	NatType string `json:"nat_type,omitempty" jsonschema:"NAT Gateway type. 'Enhanced' is the modern standard with higher performance and VSwitch placement support. 'Normal' is legacy. Default: 'Enhanced'"`
	// Billing method for the NAT Gateway.
	//  "PayAsYouGo" for on-demand billing, "Subscription" for reserved pricing.
	//  Default: "PayAsYouGo"
	PaymentType string `json:"payment_type,omitempty" jsonschema:"Billing method for the NAT Gateway. 'PayAsYouGo' for on-demand billing; 'Subscription' for reserved pricing. Default: 'PayAsYouGo'"`
	// Metering method for the NAT Gateway.
	//  "PayByLcu" bills based on actual capacity units (recommended for most
	//  workloads). "PayBySpec" bills based on a fixed specification tier.
	//  Default: "PayByLcu"
	InternetChargeType string `json:"internet_charge_type,omitempty" jsonschema:"Metering method for the NAT Gateway. 'PayByLcu' bills based on actual capacity units (recommended for most workloads). 'PayBySpec' bills based on a fixed specification tier. Default: 'PayByLcu'"`
	// Fixed specification tier for the NAT Gateway. Only applicable when
	//  internet_charge_type is "PayBySpec". Ignored when "PayByLcu".
	//  Valid values: "Small" (1Gbps), "Middle" (5Gbps), "Large" (10Gbps),
	//  "XLarge.1" (20Gbps).
	Specification string `json:"specification,omitempty" jsonschema:"Fixed specification tier for the NAT Gateway. Only applicable when internet_charge_type is 'PayBySpec'. Ignored when 'PayByLcu'. Valid values: 'Small' (1Gbps); 'Middle' (5Gbps); 'Large' (10Gbps); 'XLa..."`
	// Enable deletion protection to prevent accidental deletion via the console
	//  or API. Must be explicitly disabled before the NAT Gateway can be deleted.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"Enable deletion protection to prevent accidental deletion via the console or API. Must be explicitly disabled before the NAT Gateway can be deleted."`
	// Tags to apply to the NAT Gateway resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the NAT Gateway resource."`
	// EIP allocation ID to associate with this NAT Gateway.
	//  The IaC module resolves the EIP's public IP address internally via a data
	//  source lookup and uses it for all SNAT entries. The EIP must already exist
	//  (create one with AliCloudEipAddress).
	EipId string `json:"eip_id" jsonschema:"required,EIP allocation ID to associate with this NAT Gateway. The IaC module resolves the EIP's public IP address internally via a data source lookup and uses it for all SNAT entries. The EIP must already exi..."`
	// SNAT entries that map private network sources to the NAT Gateway's EIP.
	//  Each entry enables outbound internet access for traffic originating from
	//  the specified VSwitch or CIDR block.
	SnatEntries []*AliCloudSnatEntryInput `json:"snat_entries,omitempty" jsonschema:"SNAT entries that map private network sources to the NAT Gateway's EIP. Each entry enables outbound internet access for traffic originating from the specified VSwitch or CIDR block."`
}

func (s *AliCloudNatGatewaySpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if s.VswitchId == "" {
		return fmt.Errorf("vswitch_id is required")
	}
	if s.NatGatewayName == "" {
		return fmt.Errorf("nat_gateway_name is required")
	}
	if s.EipId == "" {
		return fmt.Errorf("eip_id is required")
	}
	for i, v := range s.SnatEntries {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("snat_entries[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudNatGatewaySpecInput) applyDefaults() {
	if s.NatType == "" {
		s.NatType = "Enhanced"
	}
	if s.PaymentType == "" {
		s.PaymentType = "PayAsYouGo"
	}
	if s.InternetChargeType == "" {
		s.InternetChargeType = "PayByLcu"
	}
}

func (s *AliCloudNatGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["vpc_id"] = s.VpcId
	m["vswitch_id"] = s.VswitchId
	m["nat_gateway_name"] = s.NatGatewayName
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.NatType != "" {
		m["nat_type"] = s.NatType
	}
	if s.PaymentType != "" {
		m["payment_type"] = s.PaymentType
	}
	if s.InternetChargeType != "" {
		m["internet_charge_type"] = s.InternetChargeType
	}
	if s.Specification != "" {
		m["specification"] = s.Specification
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	m["eip_id"] = s.EipId
	if len(s.SnatEntries) > 0 {
		items := make([]any, len(s.SnatEntries))
		for i, v := range s.SnatEntries {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["snat_entries"] = items
	}
	return m
}

// AliCloudSnatEntry defines a single SNAT rule mapping a private traffic
//
//	source to the NAT Gateway's associated EIP for outbound internet access.
//
//	Specify exactly one of source_vswitch_id or source_cidr:
//	  - source_vswitch_id: NATs all traffic from a VSwitch (the common 80% case).
//	  - source_cidr: NATs traffic from a specific CIDR (for fine-grained control).
//
//	These are mutually exclusive in the provider. If neither is set, the
//	provider will reject the SNAT entry.
type AliCloudSnatEntryInput struct {
	// VSwitch whose traffic should be NATed through the EIP.
	//  Use this for the common case of enabling internet access for an entire
	//  VSwitch. Mutually exclusive with source_cidr.
	SourceVswitchId string `json:"source_vswitch_id,omitempty" jsonschema:"VSwitch whose traffic should be NATed through the EIP. Use this for the common case of enabling internet access for an entire VSwitch. Mutually exclusive with source_cidr."`
	// Source CIDR block whose traffic should be NATed. Use this for fine-grained
	//  control when you want to NAT only a subset of a VSwitch's address space.
	//  Mutually exclusive with source_vswitch_id.
	//  Example: "10.0.1.0/24"
	SourceCidr string `json:"source_cidr,omitempty" jsonschema:"Source CIDR block whose traffic should be NATed. Use this for fine-grained control when you want to NAT only a subset of a VSwitch's address space. Mutually exclusive with source_vswitch_id. Example: ..."`
	// Human-readable name for this SNAT entry. 2-128 characters.
	//  If omitted, a name is generated from the NAT Gateway name and entry index.
	SnatEntryName string `json:"snat_entry_name,omitempty" jsonschema:"Human-readable name for this SNAT entry. 2-128 characters. If omitted; a name is generated from the NAT Gateway name and entry index."`
}

func (s *AliCloudSnatEntryInput) validate() error {
	return nil
}

func (s *AliCloudSnatEntryInput) applyDefaults() {
}

func (s *AliCloudSnatEntryInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SourceVswitchId != "" {
		m["source_vswitch_id"] = s.SourceVswitchId
	}
	if s.SourceCidr != "" {
		m["source_cidr"] = s.SourceCidr
	}
	if s.SnatEntryName != "" {
		m["snat_entry_name"] = s.SnatEntryName
	}
	return m
}

// ParseAliCloudNatGateway validates and normalizes a AliCloudNatGateway cloud_object.
func ParseAliCloudNatGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudNatGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudNatGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
