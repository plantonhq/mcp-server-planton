// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-polardb-cluster
type AliCloudPolardbClusterSpecInput struct {
	// Alibaba Cloud region where the PolarDB cluster will be created.
	//  Must match the region of the VSwitch.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the PolarDB cluster will be created. Must match the region of the VSwitch. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// Database engine type. PolarDB supports three compatibility modes, each
	//  with its own set of valid versions and node classes.
	DbType string `json:"db_type" jsonschema:"required,Database engine type. PolarDB supports three compatibility modes; each with its own set of valid versions and node classes."`
	// Database engine version. Must be a version supported by the selected
	//  db_type. Examples: "8.0", "5.7", "5.6" (MySQL), "14", "11" (PostgreSQL),
	//  "11" (Oracle).
	DbVersion string `json:"db_version" jsonschema:"required,Database engine version. Must be a version supported by the selected db_type. Examples: '8.0'; '5.7'; '5.6' (MySQL); '14'; '11' (PostgreSQL); '11' (Oracle)."`
	// PolarDB node instance class that determines CPU and memory per node.
	//  Examples: "polar.mysql.x4.large", "polar.mysql.x4.xlarge",
	//  "polar.pg.x4.large", "polar.o.x4.large".
	DbNodeClass string `json:"db_node_class" jsonschema:"required,PolarDB node instance class that determines CPU and memory per node. Examples: 'polar.mysql.x4.large'; 'polar.mysql.x4.xlarge'; 'polar.pg.x4.large'; 'polar.o.x4.large'."`
	// VSwitch ID where the PolarDB cluster is placed. The cluster inherits
	//  the VPC and availability zone from the VSwitch.
	VswitchId string `json:"vswitch_id" jsonschema:"required,VSwitch ID where the PolarDB cluster is placed. The cluster inherits the VPC and availability zone from the VSwitch."`
	// Number of nodes in the cluster. Includes 1 primary node and (N-1) read
	//  replicas. Minimum 1, maximum 16. Default: 2 (1 primary + 1 read replica).
	DbNodeCount int32 `json:"db_node_count,omitempty" jsonschema:"Number of nodes in the cluster. Includes 1 primary node and (N-1) read replicas. Minimum 1; maximum 16. Default: 2 (1 primary + 1 read replica)."`
	// Cluster description. 2-256 characters.
	Description string `json:"description,omitempty" jsonschema:"Cluster description. 2-256 characters."`
	// Billing method. "PostPaid" for pay-as-you-go, "PrePaid" for subscription.
	//  Default: "PostPaid"
	PayType string `json:"pay_type,omitempty" jsonschema:"Billing method. 'PostPaid' for pay-as-you-go; 'PrePaid' for subscription. Default: 'PostPaid'"`
	// Subscription period in months. Only applicable when pay_type is "PrePaid".
	//  Valid values: 1-9, 12, 24, 36.
	Period int32 `json:"period,omitempty" jsonschema:"Subscription period in months. Only applicable when pay_type is 'PrePaid'. Valid values: 1-9; 12; 24; 36."`
	// Auto-renewal behavior for PrePaid clusters. Ignored for PostPaid clusters.
	//  "AutoRenewal" -- automatically renew before expiration.
	//  "Normal" -- send expiration notification but do not auto-renew.
	//  "NotRenewal" -- no notification, no auto-renew (default).
	RenewalStatus string `json:"renewal_status,omitempty" jsonschema:"Auto-renewal behavior for PrePaid clusters. Ignored for PostPaid clusters. 'AutoRenewal' -- automatically renew before expiration. 'Normal' -- send expiration notification but do not auto-renew. 'NotR..."`
	// Auto-renewal period in months. Only applicable when renewal_status is
	//  "AutoRenewal". Valid values: 1, 2, 3, 6, 12, 24, 36. Default: 1.
	AutoRenewPeriod int32 `json:"auto_renew_period,omitempty" jsonschema:"Auto-renewal period in months. Only applicable when renewal_status is 'AutoRenewal'. Valid values: 1; 2; 3; 6; 12; 24; 36. Default: 1."`
	// Availability zone ID for the primary node.
	//  If omitted, Alibaba Cloud selects a zone from the VSwitch's region.
	//  Examples: "cn-hangzhou-a", "cn-shanghai-b".
	ZoneId string `json:"zone_id,omitempty" jsonschema:"Availability zone ID for the primary node. If omitted; Alibaba Cloud selects a zone from the VSwitch's region. Examples: 'cn-hangzhou-a'; 'cn-shanghai-b'."`
	// IP addresses or CIDR blocks allowed to access the PolarDB cluster.
	//  Default: ["127.0.0.1"] (no access). Set to ["0.0.0.0/0"] to allow all
	//  (not recommended for production).
	SecurityIps []string `json:"security_ips,omitempty" jsonschema:"IP addresses or CIDR blocks allowed to access the PolarDB cluster. Default: ['127.0.0.1'] (no access). Set to ['0.0.0.0/0'] to allow all (not recommended for production)."`
	// VPC security group IDs to associate with the PolarDB cluster.
	//  You can add a maximum of three security groups.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"VPC security group IDs to associate with the PolarDB cluster. You can add a maximum of three security groups."`
	// Maintenance window in UTC. PolarDB may perform minor version upgrades
	//  or patches during this window.
	//  Format: "HH:00Z-HH:00Z" (must be a 1-hour interval on the hour,
	//  e.g., "02:00Z-03:00Z").
	MaintainTime string `json:"maintain_time,omitempty" jsonschema:"Maintenance window in UTC. PolarDB may perform minor version upgrades or patches during this window. Format: 'HH:00Z-HH:00Z' (must be a 1-hour interval on the hour; e.g.; '02:00Z-03:00Z')."`
	// Alibaba Cloud resource group ID for organizational grouping (per DD05).
	//  If omitted, the cluster is placed in the account's default resource group.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Alibaba Cloud resource group ID for organizational grouping (per DD05). If omitted; the cluster is placed in the account's default resource group."`
	// Tags to apply to the PolarDB cluster resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the PolarDB cluster resource."`
	// PolarDB edition that determines the storage architecture.
	//  "Normal" -- Enterprise Edition with shared distributed storage.
	//  "Basic" -- single-node edition for dev/test.
	//  "ArchiveNormal" -- archival storage edition.
	//  "NormalMultimaster" -- multi-master edition (MySQL only).
	//  "SENormal" -- Standard Ed...
	CreationCategory string `json:"creation_category,omitempty" jsonschema:"PolarDB edition that determines the storage architecture. 'Normal' -- Enterprise Edition with shared distributed storage. 'Basic' -- single-node edition for dev/test. 'ArchiveNormal' -- archival stora..."`
	// Sub-category for the cluster. Determines the resource allocation model.
	//  "Exclusive" -- dedicated resources (higher performance).
	//  "General" -- shared resources (lower cost).
	//  Only applicable to MySQL clusters.
	SubCategory string `json:"sub_category,omitempty" jsonschema:"Sub-category for the cluster. Determines the resource allocation model. 'Exclusive' -- dedicated resources (higher performance). 'General' -- shared resources (lower cost). Only applicable to MySQL cl..."`
	// Storage type. Determines the underlying storage medium.
	//  Enterprise Edition: "PSL5" (performance level 5), "PSL4" (performance level 4).
	//  Standard Edition: "ESSDPL0", "ESSDPL1", "ESSDPL2", "ESSDPL3" (ESSD performance levels),
	//  "ESSDAUTOPL" (auto performance level).
	StorageType string `json:"storage_type,omitempty" jsonschema:"Storage type. Determines the underlying storage medium. Enterprise Edition: 'PSL5' (performance level 5); 'PSL4' (performance level 4). Standard Edition: 'ESSDPL0'; 'ESSDPL1'; 'ESSDPL2'; 'ESSDPL3' (ES..."`
	// Storage space in GB. Only applicable for Standard Edition clusters
	//  (creation_category = "SENormal") where storage is pre-allocated.
	//  Enterprise Edition clusters use auto-scaling shared storage and do not
	//  need this field. Valid range: 20-100000 GB.
	StorageSpace int32 `json:"storage_space,omitempty" jsonschema:"Storage space in GB. Only applicable for Standard Edition clusters (creation_category = 'SENormal') where storage is pre-allocated. Enterprise Edition clusters use auto-scaling shared storage and do n..."`
	// Transparent Data Encryption (TDE) status. TDE encrypts data at rest
	//  at the storage level. Once enabled, TDE cannot be disabled.
	//  "Enabled" turns on TDE. "Disabled" is the default.
	TdeStatus string `json:"tde_status,omitempty" jsonschema:"Transparent Data Encryption (TDE) status. TDE encrypts data at rest at the storage level. Once enabled; TDE cannot be disabled. 'Enabled' turns on TDE. 'Disabled' is the default."`
	// KMS encryption key ID for TDE. Required when tde_status is "Enabled".
	//  Cannot be changed after TDE is enabled.
	EncryptionKey string `json:"encryption_key,omitempty" jsonschema:"KMS encryption key ID for TDE. Required when tde_status is 'Enabled'. Cannot be changed after TDE is enabled."`
	// Deletion protection lock. Prevents accidental cluster deletion via
	//  console or API. Set to 1 to enable, 0 to disable.
	DeletionLock int32 `json:"deletion_lock,omitempty" jsonschema:"Deletion protection lock. Prevents accidental cluster deletion via console or API. Set to 1 to enable; 0 to disable."`
	// SQL audit log collector status.
	//  "Enable" turns on audit logging for compliance and troubleshooting.
	//  "Disabled" turns it off.
	CollectorStatus string `json:"collector_status,omitempty" jsonschema:"SQL audit log collector status. 'Enable' turns on audit logging for compliance and troubleshooting. 'Disabled' turns it off."`
	// Backup retention policy when the cluster is deleted.
	//  "ALL" -- retain all backups.
	//  "LATEST" -- retain only the most recent backup.
	//  "NONE" -- delete all backups immediately.
	BackupRetentionPolicyOnClusterDeletion string `json:"backup_retention_policy_on_cluster_deletion,omitempty" jsonschema:"Backup retention policy when the cluster is deleted. 'ALL' -- retain all backups. 'LATEST' -- retain only the most recent backup. 'NONE' -- delete all backups immediately."`
	// Cluster parameter overrides. Each parameter sets a specific database
	//  engine configuration value. Refer to Alibaba Cloud documentation for
	//  valid parameter names and value ranges per engine.
	Parameters []*AliCloudPolardbParameterInput `json:"parameters,omitempty" jsonschema:"Cluster parameter overrides. Each parameter sets a specific database engine configuration value. Refer to Alibaba Cloud documentation for valid parameter names and value ranges per engine."`
	// Databases to create within the PolarDB cluster.
	Databases []*AliCloudPolardbDatabaseInput `json:"databases,omitempty" jsonschema:"Databases to create within the PolarDB cluster."`
	// Database accounts to create within the PolarDB cluster.
	Accounts []*AliCloudPolardbAccountInput `json:"accounts,omitempty" jsonschema:"Database accounts to create within the PolarDB cluster."`
}

func (s *AliCloudPolardbClusterSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.DbType == "" {
		return fmt.Errorf("db_type is required")
	}
	if s.DbVersion == "" {
		return fmt.Errorf("db_version is required")
	}
	if s.DbNodeClass == "" {
		return fmt.Errorf("db_node_class is required")
	}
	if s.VswitchId == "" {
		return fmt.Errorf("vswitch_id is required")
	}
	for i, v := range s.Parameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("parameters[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Databases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("databases[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Accounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("accounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudPolardbClusterSpecInput) applyDefaults() {
	if s.DbNodeCount == 0 {
		s.DbNodeCount = 2
	}
	if s.PayType == "" {
		s.PayType = "PostPaid"
	}
}

func (s *AliCloudPolardbClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["db_type"] = s.DbType
	m["db_version"] = s.DbVersion
	m["db_node_class"] = s.DbNodeClass
	m["vswitch_id"] = s.VswitchId
	if s.DbNodeCount != 0 {
		m["db_node_count"] = s.DbNodeCount
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.PayType != "" {
		m["pay_type"] = s.PayType
	}
	if s.Period != 0 {
		m["period"] = s.Period
	}
	if s.RenewalStatus != "" {
		m["renewal_status"] = s.RenewalStatus
	}
	if s.AutoRenewPeriod != 0 {
		m["auto_renew_period"] = s.AutoRenewPeriod
	}
	if s.ZoneId != "" {
		m["zone_id"] = s.ZoneId
	}
	if len(s.SecurityIps) > 0 {
		m["security_ips"] = s.SecurityIps
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.MaintainTime != "" {
		m["maintain_time"] = s.MaintainTime
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.CreationCategory != "" {
		m["creation_category"] = s.CreationCategory
	}
	if s.SubCategory != "" {
		m["sub_category"] = s.SubCategory
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.StorageSpace != 0 {
		m["storage_space"] = s.StorageSpace
	}
	if s.TdeStatus != "" {
		m["tde_status"] = s.TdeStatus
	}
	if s.EncryptionKey != "" {
		m["encryption_key"] = s.EncryptionKey
	}
	if s.DeletionLock != 0 {
		m["deletion_lock"] = s.DeletionLock
	}
	if s.CollectorStatus != "" {
		m["collector_status"] = s.CollectorStatus
	}
	if s.BackupRetentionPolicyOnClusterDeletion != "" {
		m["backup_retention_policy_on_cluster_deletion"] = s.BackupRetentionPolicyOnClusterDeletion
	}
	if len(s.Parameters) > 0 {
		items := make([]any, len(s.Parameters))
		for i, v := range s.Parameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["parameters"] = items
	}
	if len(s.Databases) > 0 {
		items := make([]any, len(s.Databases))
		for i, v := range s.Databases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["databases"] = items
	}
	if len(s.Accounts) > 0 {
		items := make([]any, len(s.Accounts))
		for i, v := range s.Accounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["accounts"] = items
	}
	return m
}

// AliCloudPolardbAccount defines a database account to create within the
//
//	PolarDB cluster.
type AliCloudPolardbAccountInput struct {
	// Account login name. Must start with a lowercase letter, end with a
	//  letter or number, consist of lowercase letters, numbers, or underscores,
	//  and be 2-16 characters long.
	AccountName string `json:"account_name" jsonschema:"required,Account login name. Must start with a lowercase letter; end with a letter or number; consist of lowercase letters; numbers; or underscores; and be 2-16 characters long."`
	// Account password. Must be 8-32 characters and contain at least three of:
	//  uppercase letters, lowercase letters, digits, and special characters
	//  (!@#$%^&*()_+-=).
	AccountPassword string `json:"account_password" jsonschema:"required,Account password. Must be 8-32 characters and contain at least three of: uppercase letters; lowercase letters; digits; and special characters (!@#$%^&*()_+-=)."`
	// Account type.
	//  "Normal" -- standard account with explicit database privileges.
	//  "Super" -- superuser with full privileges on all databases.
	//  Default: "Normal"
	AccountType string `json:"account_type,omitempty" jsonschema:"Account type. 'Normal' -- standard account with explicit database privileges. 'Super' -- superuser with full privileges on all databases. Default: 'Normal'"`
	// Human-readable description of the account's purpose.
	AccountDescription string `json:"account_description,omitempty" jsonschema:"Human-readable description of the account's purpose."`
	// Database privileges to grant to this account. Each entry grants a
	//  privilege level on a set of databases. Only applicable when account_type
	//  is "Normal"; Super accounts have implicit full access.
	Privileges []*AliCloudPolardbAccountPrivilegeInput `json:"privileges,omitempty" jsonschema:"Database privileges to grant to this account. Each entry grants a privilege level on a set of databases. Only applicable when account_type is 'Normal'; Super accounts have implicit full access."`
}

func (s *AliCloudPolardbAccountInput) validate() error {
	if s.AccountName == "" {
		return fmt.Errorf("account_name is required")
	}
	if s.AccountPassword == "" {
		return fmt.Errorf("account_password is required")
	}
	for i, v := range s.Privileges {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("privileges[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudPolardbAccountInput) applyDefaults() {
	if s.AccountType == "" {
		s.AccountType = "Normal"
	}
}

func (s *AliCloudPolardbAccountInput) toMap() map[string]any {
	m := make(map[string]any)
	m["account_name"] = s.AccountName
	m["account_password"] = s.AccountPassword
	if s.AccountType != "" {
		m["account_type"] = s.AccountType
	}
	if s.AccountDescription != "" {
		m["account_description"] = s.AccountDescription
	}
	if len(s.Privileges) > 0 {
		items := make([]any, len(s.Privileges))
		for i, v := range s.Privileges {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["privileges"] = items
	}
	return m
}

// AliCloudPolardbAccountPrivilege grants a single privilege level on a set of
//
//	databases to the owning account.
type AliCloudPolardbAccountPrivilegeInput struct {
	// Database names to grant access to. Each name must match a database
	//  defined in the spec's databases list.
	DbNames []string `json:"db_names" jsonschema:"required,Database names to grant access to. Each name must match a database defined in the spec's databases list."`
	// Privilege level to grant on the specified databases.
	//  "ReadOnly" -- SELECT access.
	//  "ReadWrite" -- SELECT, INSERT, UPDATE, DELETE access.
	//  "DDLOnly" -- DDL operations only (CREATE, ALTER, DROP).
	//  "DMLOnly" -- DML operations only (INSERT, UPDATE, DELETE).
	//  Default: "ReadOnly"
	AccountPrivilege string `json:"account_privilege,omitempty" jsonschema:"Privilege level to grant on the specified databases. 'ReadOnly' -- SELECT access. 'ReadWrite' -- SELECT; INSERT; UPDATE; DELETE access. 'DDLOnly' -- DDL operations only (CREATE; ALTER; DROP). 'DMLOnly..."`
}

func (s *AliCloudPolardbAccountPrivilegeInput) validate() error {
	if len(s.DbNames) == 0 {
		return fmt.Errorf("db_names is required")
	}
	if len(s.DbNames) < 1 {
		return fmt.Errorf("db_names requires at least 1 items, got %d", len(s.DbNames))
	}
	return nil
}

func (s *AliCloudPolardbAccountPrivilegeInput) applyDefaults() {
	if s.AccountPrivilege == "" {
		s.AccountPrivilege = "ReadOnly"
	}
}

func (s *AliCloudPolardbAccountPrivilegeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["db_names"] = s.DbNames
	if s.AccountPrivilege != "" {
		m["account_privilege"] = s.AccountPrivilege
	}
	return m
}

// AliCloudPolardbDatabase defines a database to create within the PolarDB
//
//	cluster.
type AliCloudPolardbDatabaseInput struct {
	// Database name. Must start with a letter, consist of lowercase letters,
	//  numbers, and underscores, and be no more than 64 characters.
	DbName string `json:"db_name" jsonschema:"required,Database name. Must start with a letter; consist of lowercase letters; numbers; and underscores; and be no more than 64 characters."`
	// Character set for the database. Default: "utf8" for MySQL, varies for
	//  PostgreSQL and Oracle. Common values: "utf8", "utf8mb4", "gbk" (MySQL),
	//  "UTF8", "SQL_ASCII" (PostgreSQL/Oracle).
	CharacterSetName string `json:"character_set_name,omitempty" jsonschema:"Character set for the database. Default: 'utf8' for MySQL; varies for PostgreSQL and Oracle. Common values: 'utf8'; 'utf8mb4'; 'gbk' (MySQL); 'UTF8'; 'SQL_ASCII' (PostgreSQL/Oracle)."`
	// Human-readable description of the database. 2-256 characters.
	DbDescription string `json:"db_description,omitempty" jsonschema:"Human-readable description of the database. 2-256 characters."`
	// Collation rules for the database. Only applicable to PolarDB for
	//  PostgreSQL and Oracle compatibility modes. Must be compatible with
	//  the character_set_name. Default: "C".
	Collate string `json:"collate,omitempty" jsonschema:"Collation rules for the database. Only applicable to PolarDB for PostgreSQL and Oracle compatibility modes. Must be compatible with the character_set_name. Default: 'C'."`
	// Character type setting. Only applicable to PolarDB for PostgreSQL and
	//  Oracle compatibility modes. Must be compatible with the
	//  character_set_name. Default: "C".
	Ctype string `json:"ctype,omitempty" jsonschema:"Character type setting. Only applicable to PolarDB for PostgreSQL and Oracle compatibility modes. Must be compatible with the character_set_name. Default: 'C'."`
}

func (s *AliCloudPolardbDatabaseInput) validate() error {
	if s.DbName == "" {
		return fmt.Errorf("db_name is required")
	}
	return nil
}

func (s *AliCloudPolardbDatabaseInput) applyDefaults() {
}

func (s *AliCloudPolardbDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["db_name"] = s.DbName
	if s.CharacterSetName != "" {
		m["character_set_name"] = s.CharacterSetName
	}
	if s.DbDescription != "" {
		m["db_description"] = s.DbDescription
	}
	if s.Collate != "" {
		m["collate"] = s.Collate
	}
	if s.Ctype != "" {
		m["ctype"] = s.Ctype
	}
	return m
}

// AliCloudPolardbParameter represents a single cluster parameter override.
type AliCloudPolardbParameterInput struct {
	// Parameter name (e.g., "loose_innodb_buffer_pool_size", "max_connections").
	Name string `json:"name" jsonschema:"required,Parameter name (e.g.; 'loose_innodb_buffer_pool_size'; 'max_connections')."`
	// Parameter value as a string. The database engine interprets the value
	//  according to the parameter's type.
	Value string `json:"value" jsonschema:"required,Parameter value as a string. The database engine interprets the value according to the parameter's type."`
}

func (s *AliCloudPolardbParameterInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AliCloudPolardbParameterInput) applyDefaults() {
}

func (s *AliCloudPolardbParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	return m
}

// ParseAliCloudPolardbCluster validates and normalizes a AliCloudPolardbCluster cloud_object.
func ParseAliCloudPolardbCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudPolardbCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudPolardbClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
