// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-nas-file-system
type AliCloudNasFileSystemSpecInput struct {
	// Alibaba Cloud region where the file system will be created.
	//  Must match the region of the VPC and VSwitch used for the mount target.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the file system will be created. Must match the region of the VPC and VSwitch used for the mount target. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1..."`
	// File system type. Determines the performance model and available
	//  storage types. This is immutable after creation (ForceNew).
	//
	//    "standard" -- auto-scaling capacity, general-purpose workloads.
	//    "extreme"  -- dedicated throughput, fixed capacity, requires zone_id.
	//  Default: "standard"
	FileSystemType string `json:"file_system_type,omitempty" jsonschema:"File system type. Determines the performance model and available storage types. This is immutable after creation (ForceNew). 'standard' -- auto-scaling capacity; general-purpose workloads. 'extreme' -..."`
	// NAS protocol type. Determines how clients mount and access the file
	//  system. This is immutable after creation (ForceNew).
	//
	//    "NFS" -- Network File System, the standard Linux/Unix protocol.
	//    "SMB" -- Server Message Block, for Windows compatibility.
	ProtocolType string `json:"protocol_type" jsonschema:"required,NAS protocol type. Determines how clients mount and access the file system. This is immutable after creation (ForceNew). 'NFS' -- Network File System; the standard Linux/Unix protocol. 'SMB' -- Server..."`
	// Storage type. Determines the IOPS, throughput, and latency
	//  characteristics. This is immutable after creation (ForceNew).
	//
	//  For standard file systems:
	//    "Performance" -- SSD-backed, low latency, up to 10 GiB/s throughput
	//    "Capacity"    -- HDD-backed, cost-effective for warm/cold data
	//    "Premium"...
	StorageType string `json:"storage_type" jsonschema:"required,Storage type. Determines the IOPS; throughput; and latency characteristics. This is immutable after creation (ForceNew). For standard file systems: 'Performance' -- SSD-backed; low latency; up to 10 G..."`
	// Human-readable description of the file system's purpose.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the file system's purpose."`
	// Encryption configuration. When omitted, the file system is not encrypted.
	//  Encryption type is immutable after creation (ForceNew).
	Encryption *AliCloudNasEncryptionInput `json:"encryption,omitempty" jsonschema:"Encryption configuration. When omitted; the file system is not encrypted. Encryption type is immutable after creation (ForceNew)."`
	// File system capacity in GiB.
	//  Required for extreme NAS (minimum 100 GiB). Ignored for standard NAS,
	//  which auto-scales capacity based on stored data.
	Capacity int32 `json:"capacity,omitempty" jsonschema:"File system capacity in GiB. Required for extreme NAS (minimum 100 GiB). Ignored for standard NAS; which auto-scales capacity based on stored data."`
	// Availability zone for the file system.
	//  Required for extreme NAS. Optional for standard NAS (the service
	//  auto-assigns a zone when omitted).
	//  Format: "{region}-{letter}", e.g. "cn-hangzhou-a", "cn-hangzhou-b".
	ZoneId string `json:"zone_id,omitempty" jsonschema:"Availability zone for the file system. Required for extreme NAS. Optional for standard NAS (the service auto-assigns a zone when omitted). Format: '{region}-{letter}'; e.g. 'cn-hangzhou-a'; 'cn-hangzh..."`
	// VPC ID for the mount target.
	//  The mount target is created in this VPC, making the file system
	//  accessible to resources within it.
	VpcId string `json:"vpc_id" jsonschema:"required,VPC ID for the mount target. The mount target is created in this VPC; making the file system accessible to resources within it."`
	// VSwitch ID for the mount target.
	//  Must be in the VPC specified by vpc_id. Determines which availability
	//  zone the mount target is placed in.
	VswitchId string `json:"vswitch_id" jsonschema:"required,VSwitch ID for the mount target. Must be in the VPC specified by vpc_id. Determines which availability zone the mount target is placed in."`
	// Access rules that control which IP ranges can mount the file system and
	//  with what permissions.
	//
	//  When one or more access_rules are specified, a custom access group is
	//  auto-created and associated with the mount target. This gives fine-grained
	//  control over which subnets or hosts can access the file...
	AccessRules []*AliCloudNasAccessRuleInput `json:"access_rules,omitempty" jsonschema:"Access rules that control which IP ranges can mount the file system and with what permissions. When one or more access_rules are specified; a custom access group is auto-created and associated with th..."`
	// Alibaba Cloud resource group ID for organizational grouping (per DD05).
	//  If omitted, the file system is placed in the account's default resource
	//  group.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Alibaba Cloud resource group ID for organizational grouping (per DD05). If omitted; the file system is placed in the account's default resource group."`
	// Tags to apply to the file system resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the file system resource."`
}

func (s *AliCloudNasFileSystemSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ProtocolType == "" {
		return fmt.Errorf("protocol_type is required")
	}
	if s.StorageType == "" {
		return fmt.Errorf("storage_type is required")
	}
	if s.Encryption != nil {
		if err := s.Encryption.validate(); err != nil {
			return fmt.Errorf("encryption: %w", err)
		}
	}
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if s.VswitchId == "" {
		return fmt.Errorf("vswitch_id is required")
	}
	for i, v := range s.AccessRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("access_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudNasFileSystemSpecInput) applyDefaults() {
	if s.FileSystemType == "" {
		s.FileSystemType = "standard"
	}
	if s.Encryption != nil {
		s.Encryption.applyDefaults()
	}
}

func (s *AliCloudNasFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	if s.FileSystemType != "" {
		m["file_system_type"] = s.FileSystemType
	}
	m["protocol_type"] = s.ProtocolType
	m["storage_type"] = s.StorageType
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Encryption != nil {
		m["encryption"] = s.Encryption.toMap()
	}
	if s.Capacity != 0 {
		m["capacity"] = s.Capacity
	}
	if s.ZoneId != "" {
		m["zone_id"] = s.ZoneId
	}
	m["vpc_id"] = s.VpcId
	m["vswitch_id"] = s.VswitchId
	if len(s.AccessRules) > 0 {
		items := make([]any, len(s.AccessRules))
		for i, v := range s.AccessRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["access_rules"] = items
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// An access rule within a NAS access group that controls which IP ranges
//
//	can mount the file system and with what permissions.
type AliCloudNasAccessRuleInput struct {
	// Source CIDR IP address or block.
	//  Allows traffic from this network range to access the file system.
	//  Examples: "0.0.0.0/0" for all IPs, "10.0.0.0/8" for a private range,
	//  "10.0.1.5" for a single host.
	SourceCidrIp string `json:"source_cidr_ip" jsonschema:"required,Source CIDR IP address or block. Allows traffic from this network range to access the file system. Examples: '0.0.0.0/0' for all IPs; '10.0.0.0/8' for a private range; '10.0.1.5' for a single host."`
	// Read-write access type.
	//    "RDWR"   -- full read-write access (default)
	//    "RDONLY" -- read-only access
	//  Default: "RDWR"
	RwAccessType string `json:"rw_access_type,omitempty" jsonschema:"Read-write access type. 'RDWR' -- full read-write access (default) 'RDONLY' -- read-only access Default: 'RDWR'"`
	// User identity mapping for NFS root access.
	//    "no_squash"    -- preserve original user identity (default)
	//    "root_squash"  -- map root (uid 0) to anonymous user
	//    "all_squash"   -- map all users to anonymous user
	//  Default: "no_squash"
	UserAccessType string `json:"user_access_type,omitempty" jsonschema:"User identity mapping for NFS root access. 'no_squash' -- preserve original user identity (default) 'root_squash' -- map root (uid 0) to anonymous user 'all_squash' -- map all users to anonymous user ..."`
	// Priority of this access rule. Lower values have higher precedence.
	//  Range: 1-100.
	//  Default: 1
	Priority int32 `json:"priority,omitempty" jsonschema:"Priority of this access rule. Lower values have higher precedence. Range: 1-100. Default: 1"`
}

func (s *AliCloudNasAccessRuleInput) validate() error {
	if s.SourceCidrIp == "" {
		return fmt.Errorf("source_cidr_ip is required")
	}
	return nil
}

func (s *AliCloudNasAccessRuleInput) applyDefaults() {
	if s.RwAccessType == "" {
		s.RwAccessType = "RDWR"
	}
	if s.UserAccessType == "" {
		s.UserAccessType = "no_squash"
	}
	if s.Priority == 0 {
		s.Priority = 1
	}
}

func (s *AliCloudNasAccessRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["source_cidr_ip"] = s.SourceCidrIp
	if s.RwAccessType != "" {
		m["rw_access_type"] = s.RwAccessType
	}
	if s.UserAccessType != "" {
		m["user_access_type"] = s.UserAccessType
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	return m
}

// Encryption configuration for a NAS file system.
type AliCloudNasEncryptionInput struct {
	// Encryption type.
	//    1 = NAS-managed key: Alibaba Cloud manages the encryption key.
	//        No additional configuration needed.
	//    2 = Customer-managed KMS key: You manage the key via KMS.
	//        Requires kms_key_id to be set.
	EncryptType int32 `json:"encrypt_type" jsonschema:"required,Encryption type. 1 = NAS-managed key: Alibaba Cloud manages the encryption key. No additional configuration needed. 2 = Customer-managed KMS key: You manage the key via KMS. Requires kms_key_id to be ..."`
	// KMS key ID for customer-managed encryption.
	//  Required when encrypt_type is 2. Ignored when encrypt_type is 1.
	//  Create one with AliCloudKmsKey and reference its key_id output.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"KMS key ID for customer-managed encryption. Required when encrypt_type is 2. Ignored when encrypt_type is 1. Create one with AliCloudKmsKey and reference its key_id output."`
}

func (s *AliCloudNasEncryptionInput) validate() error {
	return nil
}

func (s *AliCloudNasEncryptionInput) applyDefaults() {
}

func (s *AliCloudNasEncryptionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["encrypt_type"] = s.EncryptType
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	return m
}

// ParseAliCloudNasFileSystem validates and normalizes a AliCloudNasFileSystem cloud_object.
func ParseAliCloudNasFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudNasFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudNasFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
