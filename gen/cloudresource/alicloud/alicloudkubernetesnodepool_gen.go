// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-kubernetes-node-pool
type AliCloudKubernetesNodePoolSpecInput struct {
	// Alibaba Cloud region. Must match the parent cluster's region.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region. Must match the parent cluster's region. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// ACK cluster ID that this node pool belongs to.
	ClusterId string `json:"cluster_id" jsonschema:"required,ACK cluster ID that this node pool belongs to."`
	// Node pool name. 1-63 characters.
	//  Maps to provider field `node_pool_name`.
	Name string `json:"name" jsonschema:"required,Node pool name. 1-63 characters. Maps to provider field 'node_pool_name'."`
	// VSwitch IDs for worker node placement. 1-5 VSwitches, preferably in
	//  distinct availability zones for high availability.
	VswitchIds []string `json:"vswitch_ids" jsonschema:"required,VSwitch IDs for worker node placement. 1-5 VSwitches; preferably in distinct availability zones for high availability."`
	// ECS instance types for worker nodes. At least one type is required.
	//  Specifying multiple types improves availability, especially for spot
	//  instances where a single type may be unavailable.
	//  Examples: "ecs.g7.xlarge", "ecs.g7.2xlarge", "ecs.c7.xlarge"
	InstanceTypes []string `json:"instance_types" jsonschema:"required,ECS instance types for worker nodes. At least one type is required. Specifying multiple types improves availability; especially for spot instances where a single type may be unavailable. Examples: 'ec..."`
	// Desired number of nodes in the node pool.
	//  For auto-scaling pools (scaling_config.enable = true), this sets the
	//  initial count; the auto-scaler may adjust between min_size and max_size.
	//  For fixed-size pools, this is the exact count.
	//  Range: 0-1000.
	DesiredSize int32 `json:"desired_size,omitempty" jsonschema:"Desired number of nodes in the node pool. For auto-scaling pools (scaling_config.enable = true); this sets the initial count; the auto-scaler may adjust between min_size and max_size. For fixed-size p..."`
	// OS image type for the worker nodes.
	//  Default: "AliyunLinux3"
	ImageType string `json:"image_type,omitempty" jsonschema:"OS image type for the worker nodes. Default: 'AliyunLinux3'"`
	// System disk configuration for the worker nodes.
	SystemDisk *AliCloudKubernetesNodePoolSystemDiskInput `json:"system_disk,omitempty" jsonschema:"System disk configuration for the worker nodes."`
	// Additional data disks attached to each worker node.
	DataDisks []*AliCloudKubernetesNodePoolDataDiskInput `json:"data_disks,omitempty" jsonschema:"Additional data disks attached to each worker node."`
	// Security group IDs for the worker nodes.
	//  Immutable after creation.
	//  If omitted, the cluster's default security group is used.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security group IDs for the worker nodes. Immutable after creation. If omitted; the cluster's default security group is used."`
	// Maximum outbound internet bandwidth in Mbps.
	//  0 means no public IP is allocated (default). 1-100 allocates a public IP.
	InternetMaxBandwidthOut int32 `json:"internet_max_bandwidth_out,omitempty" jsonschema:"Maximum outbound internet bandwidth in Mbps. 0 means no public IP is allocated (default). 1-100 allocates a public IP."`
	// Billing method for public internet access.
	//  Only relevant when internet_max_bandwidth_out > 0.
	//  Default: "PayByTraffic"
	InternetChargeType string `json:"internet_charge_type,omitempty" jsonschema:"Billing method for public internet access. Only relevant when internet_max_bandwidth_out > 0. Default: 'PayByTraffic'"`
	// SSH key pair name for node access.
	//  Mutually exclusive with password.
	//  Recommended over password for managed node pools.
	KeyName string `json:"key_name,omitempty" jsonschema:"SSH key pair name for node access. Mutually exclusive with password. Recommended over password for managed node pools."`
	// SSH password for node access. 8-30 characters.
	//  Mutually exclusive with key_name. Sensitive value.
	Password string `json:"password,omitempty" jsonschema:"SSH password for node access. 8-30 characters. Mutually exclusive with key_name. Sensitive value."`
	// Kubernetes labels applied to all nodes in the pool.
	//  Used for pod scheduling affinity and node selectors.
	//  Example: {"workload-type": "compute", "team": "platform"}
	Labels map[string]string `json:"labels,omitempty" jsonschema:"Kubernetes labels applied to all nodes in the pool. Used for pod scheduling affinity and node selectors. Example: {'workload-type': 'compute'; 'team': 'platform'}"`
	// Kubernetes taints applied to all nodes in the pool.
	//  Taints repel pods unless the pod has a matching toleration.
	Taints []*AliCloudKubernetesNodePoolTaintInput `json:"taints,omitempty" jsonschema:"Kubernetes taints applied to all nodes in the pool. Taints repel pods unless the pod has a matching toleration."`
	// CPU management policy for nodes.
	//  "none" (default) -- standard CFS scheduling.
	//  "static" -- pin exclusive containers to specific CPUs; improves
	//    determinism for latency-sensitive workloads.
	CpuPolicy string `json:"cpu_policy,omitempty" jsonschema:"CPU management policy for nodes. 'none' (default) -- standard CFS scheduling. 'static' -- pin exclusive containers to specific CPUs; improves determinism for latency-sensitive workloads."`
	// Container runtime name (e.g., "containerd", "Sandboxed-Container.runv").
	//  If omitted, the provider default for the selected image_type is used.
	RuntimeName string `json:"runtime_name,omitempty" jsonschema:"Container runtime name (e.g.; 'containerd'; 'Sandboxed-Container.runv'). If omitted; the provider default for the selected image_type is used."`
	// Container runtime version.
	//  If omitted, the latest version supported by the cluster is used.
	RuntimeVersion string `json:"runtime_version,omitempty" jsonschema:"Container runtime version. If omitted; the latest version supported by the cluster is used."`
	// Whether newly added nodes are marked unschedulable.
	//  When true, pods cannot be scheduled on new nodes until the taint is
	//  manually removed. Useful for pre-configuration before accepting workloads.
	Unschedulable bool `json:"unschedulable,omitempty" jsonschema:"Whether newly added nodes are marked unschedulable. When true; pods cannot be scheduled on new nodes until the taint is manually removed. Useful for pre-configuration before accepting workloads."`
	// Custom user data script to execute on each node at boot time.
	//  Must be base64-encoded. Maximum 16 KB before encoding.
	UserData string `json:"user_data,omitempty" jsonschema:"Custom user data script to execute on each node at boot time. Must be base64-encoded. Maximum 16 KB before encoding."`
	// Whether to install Alibaba Cloud CloudMonitor agent on nodes.
	//  Default: true
	InstallCloudMonitor bool `json:"install_cloud_monitor,omitempty" jsonschema:"Whether to install Alibaba Cloud CloudMonitor agent on nodes. Default: true"`
	// Auto-scaling configuration. When enabled, the cluster auto-scaler
	//  adjusts the number of nodes between min_size and max_size based on
	//  pending pod resource requests.
	ScalingConfig *AliCloudKubernetesNodePoolScalingConfigInput `json:"scaling_config,omitempty" jsonschema:"Auto-scaling configuration. When enabled; the cluster auto-scaler adjusts the number of nodes between min_size and max_size based on pending pod resource requests."`
	// Multi-AZ scheduling policy when vswitch_ids spans multiple zones.
	//  "PRIORITY" -- allocate in the first AZ with available capacity.
	//  "COST_OPTIMIZED" -- allocate in the cheapest AZ.
	//  "BALANCE" -- evenly distribute across AZs.
	MultiAzPolicy string `json:"multi_az_policy,omitempty" jsonschema:"Multi-AZ scheduling policy when vswitch_ids spans multiple zones. 'PRIORITY' -- allocate in the first AZ with available capacity. 'COST_OPTIMIZED' -- allocate in the cheapest AZ. 'BALANCE' -- evenly d..."`
	// Managed node pool lifecycle management settings.
	//  When enabled, ACK automatically repairs unhealthy nodes, upgrades
	//  kubelet versions, and patches vulnerabilities.
	Management *AliCloudKubernetesNodePoolManagementInput `json:"management,omitempty" jsonschema:"Managed node pool lifecycle management settings. When enabled; ACK automatically repairs unhealthy nodes; upgrades kubelet versions; and patches vulnerabilities."`
	// Spot instance strategy for cost optimization.
	//  "NoSpot" (default) -- only on-demand instances.
	//  "SpotWithPriceLimit" -- spot instances with a price cap.
	//  "SpotAsPriceGo" -- spot instances at market price (cheapest).
	SpotStrategy string `json:"spot_strategy,omitempty" jsonschema:"Spot instance strategy for cost optimization. 'NoSpot' (default) -- only on-demand instances. 'SpotWithPriceLimit' -- spot instances with a price cap. 'SpotAsPriceGo' -- spot instances at market price..."`
	// Per-instance-type price caps for spot instances.
	//  Only relevant when spot_strategy is "SpotWithPriceLimit".
	SpotPriceLimits []*AliCloudKubernetesNodePoolSpotPriceLimitInput `json:"spot_price_limits,omitempty" jsonschema:"Per-instance-type price caps for spot instances. Only relevant when spot_strategy is 'SpotWithPriceLimit'."`
	// Billing method for worker node instances.
	//  "PostPaid" (default) -- pay-as-you-go.
	//  "PrePaid" -- subscription; requires period and optionally auto_renew.
	InstanceChargeType string `json:"instance_charge_type,omitempty" jsonschema:"Billing method for worker node instances. 'PostPaid' (default) -- pay-as-you-go. 'PrePaid' -- subscription; requires period and optionally auto_renew."`
	// Subscription period in months. Required when instance_charge_type is PrePaid.
	//  Valid values: 1, 2, 3, 6, 12.
	Period int32 `json:"period,omitempty" jsonschema:"Subscription period in months. Required when instance_charge_type is PrePaid. Valid values: 1; 2; 3; 6; 12."`
	// Whether to automatically renew the subscription.
	//  Only relevant when instance_charge_type is PrePaid.
	AutoRenew bool `json:"auto_renew,omitempty" jsonschema:"Whether to automatically renew the subscription. Only relevant when instance_charge_type is PrePaid."`
	// Auto-renewal period in months.
	//  Valid values: 1, 2, 3, 6, 12.
	AutoRenewPeriod int32 `json:"auto_renew_period,omitempty" jsonschema:"Auto-renewal period in months. Valid values: 1; 2; 3; 6; 12."`
	// Tags applied to the ECS instances in the node pool.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags applied to the ECS instances in the node pool."`
	// Alibaba Cloud resource group ID for organizational grouping.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Alibaba Cloud resource group ID for organizational grouping."`
	// RAM role name for worker nodes.
	//  Determines what Alibaba Cloud APIs the node can call (e.g., pulling
	//  images from ACR, writing to SLS). If omitted, the cluster's default
	//  worker RAM role is used.
	//  Immutable after creation.
	RamRoleName string `json:"ram_role_name,omitempty" jsonschema:"RAM role name for worker nodes. Determines what Alibaba Cloud APIs the node can call (e.g.; pulling images from ACR; writing to SLS). If omitted; the cluster's default worker RAM role is used. Immutab..."`
}

func (s *AliCloudKubernetesNodePoolSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ClusterId == "" {
		return fmt.Errorf("cluster_id is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.VswitchIds) == 0 {
		return fmt.Errorf("vswitch_ids is required")
	}
	if len(s.VswitchIds) < 1 {
		return fmt.Errorf("vswitch_ids requires at least 1 items, got %d", len(s.VswitchIds))
	}
	if len(s.InstanceTypes) == 0 {
		return fmt.Errorf("instance_types is required")
	}
	if len(s.InstanceTypes) < 1 {
		return fmt.Errorf("instance_types requires at least 1 items, got %d", len(s.InstanceTypes))
	}
	if s.SystemDisk != nil {
		if err := s.SystemDisk.validate(); err != nil {
			return fmt.Errorf("system_disk: %w", err)
		}
	}
	for i, v := range s.DataDisks {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("data_disks[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Taints {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("taints[%d]: %w", i, err)
			}
		}
	}
	if s.ScalingConfig != nil {
		if err := s.ScalingConfig.validate(); err != nil {
			return fmt.Errorf("scaling_config: %w", err)
		}
	}
	if s.Management != nil {
		if err := s.Management.validate(); err != nil {
			return fmt.Errorf("management: %w", err)
		}
	}
	for i, v := range s.SpotPriceLimits {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("spot_price_limits[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudKubernetesNodePoolSpecInput) applyDefaults() {
	if s.ImageType == "" {
		s.ImageType = "AliyunLinux3"
	}
	if s.SystemDisk != nil {
		s.SystemDisk.applyDefaults()
	}
	// default: InstallCloudMonitor = true (applied at zero-value)
	if s.ScalingConfig != nil {
		s.ScalingConfig.applyDefaults()
	}
	if s.Management != nil {
		s.Management.applyDefaults()
	}
	if s.InstanceChargeType == "" {
		s.InstanceChargeType = "PostPaid"
	}
}

func (s *AliCloudKubernetesNodePoolSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["cluster_id"] = s.ClusterId
	m["name"] = s.Name
	m["vswitch_ids"] = s.VswitchIds
	m["instance_types"] = s.InstanceTypes
	if s.DesiredSize != 0 {
		m["desired_size"] = s.DesiredSize
	}
	if s.ImageType != "" {
		m["image_type"] = s.ImageType
	}
	if s.SystemDisk != nil {
		m["system_disk"] = s.SystemDisk.toMap()
	}
	if len(s.DataDisks) > 0 {
		items := make([]any, len(s.DataDisks))
		for i, v := range s.DataDisks {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["data_disks"] = items
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.InternetMaxBandwidthOut != 0 {
		m["internet_max_bandwidth_out"] = s.InternetMaxBandwidthOut
	}
	if s.InternetChargeType != "" {
		m["internet_charge_type"] = s.InternetChargeType
	}
	if s.KeyName != "" {
		m["key_name"] = s.KeyName
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Taints) > 0 {
		items := make([]any, len(s.Taints))
		for i, v := range s.Taints {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["taints"] = items
	}
	if s.CpuPolicy != "" {
		m["cpu_policy"] = s.CpuPolicy
	}
	if s.RuntimeName != "" {
		m["runtime_name"] = s.RuntimeName
	}
	if s.RuntimeVersion != "" {
		m["runtime_version"] = s.RuntimeVersion
	}
	if s.Unschedulable {
		m["unschedulable"] = s.Unschedulable
	}
	if s.UserData != "" {
		m["user_data"] = s.UserData
	}
	if s.InstallCloudMonitor {
		m["install_cloud_monitor"] = s.InstallCloudMonitor
	}
	if s.ScalingConfig != nil {
		m["scaling_config"] = s.ScalingConfig.toMap()
	}
	if s.MultiAzPolicy != "" {
		m["multi_az_policy"] = s.MultiAzPolicy
	}
	if s.Management != nil {
		m["management"] = s.Management.toMap()
	}
	if s.SpotStrategy != "" {
		m["spot_strategy"] = s.SpotStrategy
	}
	if len(s.SpotPriceLimits) > 0 {
		items := make([]any, len(s.SpotPriceLimits))
		for i, v := range s.SpotPriceLimits {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["spot_price_limits"] = items
	}
	if s.InstanceChargeType != "" {
		m["instance_charge_type"] = s.InstanceChargeType
	}
	if s.Period != 0 {
		m["period"] = s.Period
	}
	if s.AutoRenew {
		m["auto_renew"] = s.AutoRenew
	}
	if s.AutoRenewPeriod != 0 {
		m["auto_renew_period"] = s.AutoRenewPeriod
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if s.RamRoleName != "" {
		m["ram_role_name"] = s.RamRoleName
	}
	return m
}

// AliCloudKubernetesNodePoolDataDisk configures an additional data disk
//
//	attached to each worker node.
type AliCloudKubernetesNodePoolDataDiskInput struct {
	// Disk category.
	//  Default: "cloud_essd"
	Category string `json:"category,omitempty" jsonschema:"Disk category. Default: 'cloud_essd'"`
	// Disk size in GiB. Range: 40-32767.
	Size int32 `json:"size" jsonschema:"required,Disk size in GiB. Range: 40-32767."`
	// Disk name.
	Name string `json:"name,omitempty" jsonschema:"Disk name."`
	// ESSD performance level. Only applies when category is "cloud_essd".
	//  Valid values: "PL0", "PL1", "PL2", "PL3".
	PerformanceLevel string `json:"performance_level,omitempty" jsonschema:"ESSD performance level. Only applies when category is 'cloud_essd'. Valid values: 'PL0'; 'PL1'; 'PL2'; 'PL3'."`
	// Whether to encrypt the data disk. "true" or "false".
	Encrypted string `json:"encrypted,omitempty" jsonschema:"Whether to encrypt the data disk. 'true' or 'false'."`
	// KMS key ID for disk encryption.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"KMS key ID for disk encryption."`
}

func (s *AliCloudKubernetesNodePoolDataDiskInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesNodePoolDataDiskInput) applyDefaults() {
	if s.Category == "" {
		s.Category = "cloud_essd"
	}
}

func (s *AliCloudKubernetesNodePoolDataDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Category != "" {
		m["category"] = s.Category
	}
	m["size"] = s.Size
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.PerformanceLevel != "" {
		m["performance_level"] = s.PerformanceLevel
	}
	if s.Encrypted != "" {
		m["encrypted"] = s.Encrypted
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	return m
}

// AliCloudKubernetesNodePoolManagement configures automatic lifecycle
//
//	management for a managed node pool.
type AliCloudKubernetesNodePoolManagementInput struct {
	// Whether managed node pool features are enabled.
	//  Default: true
	Enable bool `json:"enable,omitempty" jsonschema:"Whether managed node pool features are enabled. Default: true"`
	// Whether ACK automatically repairs unhealthy nodes.
	//  Unhealthy nodes are detected via node conditions (Ready, DiskPressure, etc.).
	AutoRepair bool `json:"auto_repair,omitempty" jsonschema:"Whether ACK automatically repairs unhealthy nodes. Unhealthy nodes are detected via node conditions (Ready; DiskPressure; etc.)."`
	// Whether ACK automatically upgrades kubelet on nodes when the cluster
	//  version is upgraded.
	AutoUpgrade bool `json:"auto_upgrade,omitempty" jsonschema:"Whether ACK automatically upgrades kubelet on nodes when the cluster version is upgraded."`
	// Maximum number of nodes that can be unavailable during managed
	//  operations (repair, upgrade, patching).
	//  Range: 0-1000. Default: 1.
	MaxUnavailable int32 `json:"max_unavailable,omitempty" jsonschema:"Maximum number of nodes that can be unavailable during managed operations (repair; upgrade; patching). Range: 0-1000. Default: 1."`
}

func (s *AliCloudKubernetesNodePoolManagementInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesNodePoolManagementInput) applyDefaults() {
	// default: Enable = true (applied at zero-value)
}

func (s *AliCloudKubernetesNodePoolManagementInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enable {
		m["enable"] = s.Enable
	}
	if s.AutoRepair {
		m["auto_repair"] = s.AutoRepair
	}
	if s.AutoUpgrade {
		m["auto_upgrade"] = s.AutoUpgrade
	}
	if s.MaxUnavailable != 0 {
		m["max_unavailable"] = s.MaxUnavailable
	}
	return m
}

// AliCloudKubernetesNodePoolScalingConfig configures the cluster auto-scaler
//
//	for this node pool.
type AliCloudKubernetesNodePoolScalingConfigInput struct {
	// Whether auto-scaling is enabled.
	//  Default: true (when scaling_config is present).
	Enable bool `json:"enable,omitempty" jsonschema:"Whether auto-scaling is enabled. Default: true (when scaling_config is present)."`
	// Minimum number of nodes the auto-scaler will maintain.
	//  Range: 0-1000.
	MinSize int32 `json:"min_size,omitempty" jsonschema:"Minimum number of nodes the auto-scaler will maintain. Range: 0-1000."`
	// Maximum number of nodes the auto-scaler can scale to.
	//  Range: 0-2000. Must be >= min_size.
	MaxSize int32 `json:"max_size,omitempty" jsonschema:"Maximum number of nodes the auto-scaler can scale to. Range: 0-2000. Must be >= min_size."`
	// Instance classification for the auto-scaler.
	//  "cpu" (default) -- general-purpose CPU instances.
	//  "gpu" -- GPU instances.
	//  "gpushare" -- shared GPU instances.
	//  "spot" -- spot/preemptible instances.
	Type string `json:"type,omitempty" jsonschema:"Instance classification for the auto-scaler. 'cpu' (default) -- general-purpose CPU instances. 'gpu' -- GPU instances. 'gpushare' -- shared GPU instances. 'spot' -- spot/preemptible instances."`
}

func (s *AliCloudKubernetesNodePoolScalingConfigInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesNodePoolScalingConfigInput) applyDefaults() {
	// default: Enable = true (applied at zero-value)
}

func (s *AliCloudKubernetesNodePoolScalingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enable {
		m["enable"] = s.Enable
	}
	if s.MinSize != 0 {
		m["min_size"] = s.MinSize
	}
	if s.MaxSize != 0 {
		m["max_size"] = s.MaxSize
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	return m
}

// AliCloudKubernetesNodePoolSpotPriceLimit defines a price cap for a
//
//	specific spot instance type.
type AliCloudKubernetesNodePoolSpotPriceLimitInput struct {
	// ECS instance type (e.g., "ecs.g7.xlarge").
	//  Must be one of the types listed in instance_types.
	InstanceType string `json:"instance_type,omitempty" jsonschema:"ECS instance type (e.g.; 'ecs.g7.xlarge'). Must be one of the types listed in instance_types."`
	// Maximum hourly price in CNY (e.g., "0.98").
	//  When the spot market price exceeds this, the instance is not created.
	PriceLimit string `json:"price_limit,omitempty" jsonschema:"Maximum hourly price in CNY (e.g.; '0.98'). When the spot market price exceeds this; the instance is not created."`
}

func (s *AliCloudKubernetesNodePoolSpotPriceLimitInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesNodePoolSpotPriceLimitInput) applyDefaults() {
}

func (s *AliCloudKubernetesNodePoolSpotPriceLimitInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.InstanceType != "" {
		m["instance_type"] = s.InstanceType
	}
	if s.PriceLimit != "" {
		m["price_limit"] = s.PriceLimit
	}
	return m
}

// AliCloudKubernetesNodePoolSystemDisk configures the system (OS) disk
//
//	for each worker node.
type AliCloudKubernetesNodePoolSystemDiskInput struct {
	// Disk category.
	//  Default: "cloud_essd"
	Category string `json:"category,omitempty" jsonschema:"Disk category. Default: 'cloud_essd'"`
	// Disk size in GiB.
	//  Minimum: 40 GiB. Default: 120 GiB.
	Size int32 `json:"size,omitempty" jsonschema:"Disk size in GiB. Minimum: 40 GiB. Default: 120 GiB."`
	// ESSD performance level. Only applies when category is "cloud_essd".
	//  Valid values: "PL0", "PL1", "PL2", "PL3".
	//  Higher levels provide more IOPS and throughput.
	PerformanceLevel string `json:"performance_level,omitempty" jsonschema:"ESSD performance level. Only applies when category is 'cloud_essd'. Valid values: 'PL0'; 'PL1'; 'PL2'; 'PL3'. Higher levels provide more IOPS and throughput."`
	// Whether to encrypt the system disk.
	Encrypted bool `json:"encrypted,omitempty" jsonschema:"Whether to encrypt the system disk."`
	// KMS key ID for disk encryption.
	//  Only relevant when encrypted is true.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"KMS key ID for disk encryption. Only relevant when encrypted is true."`
}

func (s *AliCloudKubernetesNodePoolSystemDiskInput) validate() error {
	return nil
}

func (s *AliCloudKubernetesNodePoolSystemDiskInput) applyDefaults() {
	if s.Category == "" {
		s.Category = "cloud_essd"
	}
	if s.Size == 0 {
		s.Size = 120
	}
}

func (s *AliCloudKubernetesNodePoolSystemDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Category != "" {
		m["category"] = s.Category
	}
	if s.Size != 0 {
		m["size"] = s.Size
	}
	if s.PerformanceLevel != "" {
		m["performance_level"] = s.PerformanceLevel
	}
	if s.Encrypted {
		m["encrypted"] = s.Encrypted
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	return m
}

// AliCloudKubernetesNodePoolTaint defines a Kubernetes taint applied to
//
//	all nodes in the pool.
type AliCloudKubernetesNodePoolTaintInput struct {
	// Taint key. Must be a valid Kubernetes label key.
	Key string `json:"key" jsonschema:"required,Taint key. Must be a valid Kubernetes label key."`
	// Taint value.
	Value string `json:"value,omitempty" jsonschema:"Taint value."`
	// Taint effect that determines the scheduling behavior.
	//  "NoSchedule" -- pods without a toleration are not scheduled.
	//  "PreferNoSchedule" -- soft version; scheduler tries to avoid.
	//  "NoExecute" -- existing pods without a toleration are evicted.
	Effect string `json:"effect,omitempty" jsonschema:"Taint effect that determines the scheduling behavior. 'NoSchedule' -- pods without a toleration are not scheduled. 'PreferNoSchedule' -- soft version; scheduler tries to avoid. 'NoExecute' -- existing..."`
}

func (s *AliCloudKubernetesNodePoolTaintInput) validate() error {
	if s.Key == "" {
		return fmt.Errorf("key is required")
	}
	return nil
}

func (s *AliCloudKubernetesNodePoolTaintInput) applyDefaults() {
}

func (s *AliCloudKubernetesNodePoolTaintInput) toMap() map[string]any {
	m := make(map[string]any)
	m["key"] = s.Key
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.Effect != "" {
		m["effect"] = s.Effect
	}
	return m
}

// ParseAliCloudKubernetesNodePool validates and normalizes a AliCloudKubernetesNodePool cloud_object.
func ParseAliCloudKubernetesNodePool(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudKubernetesNodePool"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudKubernetesNodePoolSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
