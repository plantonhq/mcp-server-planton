// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-sae-application
type AliCloudSaeApplicationSpecInput struct {
	// Alibaba Cloud region where the SAE application will be created.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the SAE application will be created. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// Application name. Must start with a letter, and can contain letters,
	//  digits, and dashes. Maximum 36 characters.
	//  This field is immutable after creation (ForceNew in the provider).
	AppName string `json:"app_name" jsonschema:"required,Application name. Must start with a letter; and can contain letters; digits; and dashes. Maximum 36 characters. This field is immutable after creation (ForceNew in the provider)."`
	// Human-readable description of the application. Maximum 1024 characters.
	AppDescription string `json:"app_description,omitempty" jsonschema:"Human-readable description of the application. Maximum 1024 characters."`
	// Application package type. Determines how the application code is
	//  delivered and which runtime fields apply.
	//  This field is immutable after creation (ForceNew in the provider).
	PackageType string `json:"package_type" jsonschema:"required,Application package type. Determines how the application code is delivered and which runtime fields apply. This field is immutable after creation (ForceNew in the provider)."`
	// Number of application instances to run. Minimum 1.
	Replicas int32 `json:"replicas" jsonschema:"required,Number of application instances to run. Minimum 1."`
	// CPU allocation per instance in millicores.
	Cpu int32 `json:"cpu" jsonschema:"required,CPU allocation per instance in millicores."`
	// Memory allocation per instance in MB.
	Memory int32 `json:"memory" jsonschema:"required,Memory allocation per instance in MB."`
	// VPC ID for VPC-based deployment. When set, the application runs inside
	//  the specified VPC. Optional — SAE provides managed networking by default.
	//  This field is immutable after creation (ForceNew in the provider).
	VpcId string `json:"vpc_id,omitempty" jsonschema:"VPC ID for VPC-based deployment. When set; the application runs inside the specified VPC. Optional — SAE provides managed networking by default. This field is immutable after creation (ForceNew in t..."`
	// VSwitch ID for VPC-based deployment. Determines the subnet and
	//  availability zone.
	VswitchId string `json:"vswitch_id,omitempty" jsonschema:"VSwitch ID for VPC-based deployment. Determines the subnet and availability zone."`
	// Security group ID for VPC-based deployment. Controls inbound/outbound
	//  traffic rules for the application instances.
	SecurityGroupId string `json:"security_group_id,omitempty" jsonschema:"Security group ID for VPC-based deployment. Controls inbound/outbound traffic rules for the application instances."`
	// SAE namespace ID. Format: "{region}:{short_id}". Applications in the
	//  same namespace share configuration items (ConfigMaps) and can discover
	//  each other via built-in service registration.
	//  If omitted, the application is placed in the default namespace.
	//  This field is immutable after creation (ForceN...
	NamespaceId string `json:"namespace_id,omitempty" jsonschema:"SAE namespace ID. Format: '{region}:{short_id}'. Applications in the same namespace share configuration items (ConfigMaps) and can discover each other via built-in service registration. If omitted; th..."`
	// Container image URL. Required when package_type is "Image".
	//  Example: "registry.cn-hangzhou.aliyuncs.com/my-ns/my-app:v1"
	ImageUrl string `json:"image_url,omitempty" jsonschema:"Container image URL. Required when package_type is 'Image'. Example: 'registry.cn-hangzhou.aliyuncs.com/my-ns/my-app:v1'"`
	// Deployment package URL (OSS or HTTP). Required when package_type is
	//  "FatJar", "War", "PythonZip", or "PhpZip".
	PackageUrl string `json:"package_url,omitempty" jsonschema:"Deployment package URL (OSS or HTTP). Required when package_type is 'FatJar'; 'War'; 'PythonZip'; or 'PhpZip'."`
	// Deployment package version identifier. Recommended for non-Image
	//  deployments to track which version is deployed.
	PackageVersion string `json:"package_version,omitempty" jsonschema:"Deployment package version identifier. Recommended for non-Image deployments to track which version is deployed."`
	// Container start command override (ENTRYPOINT equivalent).
	Command string `json:"command,omitempty" jsonschema:"Container start command override (ENTRYPOINT equivalent)."`
	// Container start command arguments (CMD equivalent).
	//  Maps to the provider's command_args_v2 field.
	CommandArgs []string `json:"command_args,omitempty" jsonschema:"Container start command arguments (CMD equivalent). Maps to the provider's command_args_v2 field."`
	// Environment variables passed to the application at runtime.
	//  The IaC modules convert this map to the JSON array format that
	//  the SAE API expects: [{"name":"K","value":"V"},...].
	Envs map[string]string `json:"envs,omitempty" jsonschema:"Environment variables passed to the application at runtime. The IaC modules convert this map to the JSON array format that the SAE API expects: [{'name':'K';'value':'V'};...]."`
	// JDK version for Java applications (package_type FatJar or War).
	//  Examples: "Open JDK 8", "Open JDK 11", "Open JDK 17", "Dragonwell 8",
	//  "Dragonwell 11", "Dragonwell 17".
	Jdk string `json:"jdk,omitempty" jsonschema:"JDK version for Java applications (package_type FatJar or War). Examples: 'Open JDK 8'; 'Open JDK 11'; 'Open JDK 17'; 'Dragonwell 8'; 'Dragonwell 11'; 'Dragonwell 17'."`
	// JVM startup options for FatJar applications.
	//  Example: "-Xms512m -Xmx1024m -Dserver.port=8080"
	JarStartOptions string `json:"jar_start_options,omitempty" jsonschema:"JVM startup options for FatJar applications. Example: '-Xms512m -Xmx1024m -Dserver.port=8080'"`
	// Application startup arguments for FatJar applications.
	JarStartArgs string `json:"jar_start_args,omitempty" jsonschema:"Application startup arguments for FatJar applications."`
	// Programming language. Affects which runtime features are available.
	//  This field is immutable after creation (ForceNew in the provider).
	ProgrammingLanguage string `json:"programming_language,omitempty" jsonschema:"Programming language. Affects which runtime features are available. This field is immutable after creation (ForceNew in the provider)."`
	// Application timezone. Affects log timestamps and scheduled tasks.
	Timezone string `json:"timezone,omitempty" jsonschema:"Application timezone. Affects log timestamps and scheduled tasks."`
	// Graceful shutdown timeout in seconds. The application receives SIGTERM
	//  and has this many seconds to clean up before SIGKILL.
	//  Range: 1-60. Provider default: 30.
	TerminationGracePeriodSeconds int32 `json:"termination_grace_period_seconds,omitempty" jsonschema:"Graceful shutdown timeout in seconds. The application receives SIGTERM and has this many seconds to clean up before SIGKILL. Range: 1-60. Provider default: 30."`
	// Minimum number of available instances during a rolling deployment.
	//  Ensures service availability while new instances are starting.
	MinReadyInstances int32 `json:"min_ready_instances,omitempty" jsonschema:"Minimum number of available instances during a rolling deployment. Ensures service availability while new instances are starting."`
	// ACR Enterprise Edition instance ID for pulling images from a private
	//  container registry. Only needed when image_url points to an ACR EE
	//  instance (not the default ACR Personal Edition).
	AcrInstanceId string `json:"acr_instance_id,omitempty" jsonschema:"ACR Enterprise Edition instance ID for pulling images from a private container registry. Only needed when image_url points to an ACR EE instance (not the default ACR Personal Edition)."`
	// Liveness probe configuration. If the liveness check fails repeatedly,
	//  SAE restarts the application instance.
	Liveness *AliCloudSaeApplicationHealthCheckInput `json:"liveness,omitempty" jsonschema:"Liveness probe configuration. If the liveness check fails repeatedly; SAE restarts the application instance."`
	// Readiness probe configuration. Until the readiness check passes, SAE
	//  does not route traffic to the instance.
	Readiness *AliCloudSaeApplicationHealthCheckInput `json:"readiness,omitempty" jsonschema:"Readiness probe configuration. Until the readiness check passes; SAE does not route traffic to the instance."`
	// Custom hostname-to-IP mappings injected into the container's /etc/hosts.
	//  Useful for resolving internal service names without DNS.
	CustomHostAliases []*AliCloudSaeApplicationCustomHostAliasInput `json:"custom_host_aliases,omitempty" jsonschema:"Custom hostname-to-IP mappings injected into the container's /etc/hosts. Useful for resolving internal service names without DNS."`
	// Deployment update strategy controlling how new versions are rolled out.
	UpdateStrategy *AliCloudSaeApplicationUpdateStrategyInput `json:"update_strategy,omitempty" jsonschema:"Deployment update strategy controlling how new versions are rolled out."`
	// SLS log collection configuration as a JSON string.
	//  Format: [{"logDir":"/path","logType":"stdout"},...]
	//  When set, SAE collects application logs and ships them to SLS.
	SlsConfigs string `json:"sls_configs,omitempty" jsonschema:"SLS log collection configuration as a JSON string. Format: [{'logDir':'/path';'logType':'stdout'};...] When set; SAE collects application logs and ships them to SLS."`
	// Tags to apply to the SAE application resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the SAE application resource."`
}

func (s *AliCloudSaeApplicationSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.AppName == "" {
		return fmt.Errorf("app_name is required")
	}
	if s.PackageType == "" {
		return fmt.Errorf("package_type is required")
	}
	if s.Liveness != nil {
		if err := s.Liveness.validate(); err != nil {
			return fmt.Errorf("liveness: %w", err)
		}
	}
	if s.Readiness != nil {
		if err := s.Readiness.validate(); err != nil {
			return fmt.Errorf("readiness: %w", err)
		}
	}
	for i, v := range s.CustomHostAliases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("custom_host_aliases[%d]: %w", i, err)
			}
		}
	}
	if s.UpdateStrategy != nil {
		if err := s.UpdateStrategy.validate(); err != nil {
			return fmt.Errorf("update_strategy: %w", err)
		}
	}
	return nil
}

func (s *AliCloudSaeApplicationSpecInput) applyDefaults() {
	if s.Liveness != nil {
		s.Liveness.applyDefaults()
	}
	if s.Readiness != nil {
		s.Readiness.applyDefaults()
	}
	if s.UpdateStrategy != nil {
		s.UpdateStrategy.applyDefaults()
	}
}

func (s *AliCloudSaeApplicationSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["app_name"] = s.AppName
	if s.AppDescription != "" {
		m["app_description"] = s.AppDescription
	}
	m["package_type"] = s.PackageType
	m["replicas"] = s.Replicas
	m["cpu"] = s.Cpu
	m["memory"] = s.Memory
	if s.VpcId != "" {
		m["vpc_id"] = s.VpcId
	}
	if s.VswitchId != "" {
		m["vswitch_id"] = s.VswitchId
	}
	if s.SecurityGroupId != "" {
		m["security_group_id"] = s.SecurityGroupId
	}
	if s.NamespaceId != "" {
		m["namespace_id"] = s.NamespaceId
	}
	if s.ImageUrl != "" {
		m["image_url"] = s.ImageUrl
	}
	if s.PackageUrl != "" {
		m["package_url"] = s.PackageUrl
	}
	if s.PackageVersion != "" {
		m["package_version"] = s.PackageVersion
	}
	if s.Command != "" {
		m["command"] = s.Command
	}
	if len(s.CommandArgs) > 0 {
		m["command_args"] = s.CommandArgs
	}
	if len(s.Envs) > 0 {
		m["envs"] = s.Envs
	}
	if s.Jdk != "" {
		m["jdk"] = s.Jdk
	}
	if s.JarStartOptions != "" {
		m["jar_start_options"] = s.JarStartOptions
	}
	if s.JarStartArgs != "" {
		m["jar_start_args"] = s.JarStartArgs
	}
	if s.ProgrammingLanguage != "" {
		m["programming_language"] = s.ProgrammingLanguage
	}
	if s.Timezone != "" {
		m["timezone"] = s.Timezone
	}
	if s.TerminationGracePeriodSeconds != 0 {
		m["termination_grace_period_seconds"] = s.TerminationGracePeriodSeconds
	}
	if s.MinReadyInstances != 0 {
		m["min_ready_instances"] = s.MinReadyInstances
	}
	if s.AcrInstanceId != "" {
		m["acr_instance_id"] = s.AcrInstanceId
	}
	if s.Liveness != nil {
		m["liveness"] = s.Liveness.toMap()
	}
	if s.Readiness != nil {
		m["readiness"] = s.Readiness.toMap()
	}
	if len(s.CustomHostAliases) > 0 {
		items := make([]any, len(s.CustomHostAliases))
		for i, v := range s.CustomHostAliases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["custom_host_aliases"] = items
	}
	if s.UpdateStrategy != nil {
		m["update_strategy"] = s.UpdateStrategy.toMap()
	}
	if s.SlsConfigs != "" {
		m["sls_configs"] = s.SlsConfigs
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// AliCloudSaeApplicationBatchUpdate defines the batch release configuration.
type AliCloudSaeApplicationBatchUpdateInput struct {
	// Number of batches to split the release into.
	Batch int32 `json:"batch,omitempty" jsonschema:"Number of batches to split the release into."`
	// Seconds to wait between batches.
	BatchWaitTime int32 `json:"batch_wait_time,omitempty" jsonschema:"Seconds to wait between batches."`
	// Release processing method.
	//  "auto": automatically proceed to the next batch.
	//  "manual": pause between batches for manual approval.
	ReleaseType string `json:"release_type,omitempty" jsonschema:"Release processing method. 'auto': automatically proceed to the next batch. 'manual': pause between batches for manual approval."`
}

func (s *AliCloudSaeApplicationBatchUpdateInput) validate() error {
	return nil
}

func (s *AliCloudSaeApplicationBatchUpdateInput) applyDefaults() {
}

func (s *AliCloudSaeApplicationBatchUpdateInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Batch != 0 {
		m["batch"] = s.Batch
	}
	if s.BatchWaitTime != 0 {
		m["batch_wait_time"] = s.BatchWaitTime
	}
	if s.ReleaseType != "" {
		m["release_type"] = s.ReleaseType
	}
	return m
}

// AliCloudSaeApplicationCustomHostAlias defines a hostname-to-IP mapping
//
//	injected into the container's /etc/hosts file.
type AliCloudSaeApplicationCustomHostAliasInput struct {
	// Hostname to map.
	HostName string `json:"host_name,omitempty" jsonschema:"Hostname to map."`
	// IP address the hostname resolves to.
	Ip string `json:"ip,omitempty" jsonschema:"IP address the hostname resolves to."`
}

func (s *AliCloudSaeApplicationCustomHostAliasInput) validate() error {
	return nil
}

func (s *AliCloudSaeApplicationCustomHostAliasInput) applyDefaults() {
}

func (s *AliCloudSaeApplicationCustomHostAliasInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HostName != "" {
		m["host_name"] = s.HostName
	}
	if s.Ip != "" {
		m["ip"] = s.Ip
	}
	return m
}

// AliCloudSaeApplicationExecAction defines a command-based health check.
type AliCloudSaeApplicationExecActionInput struct {
	// Command to execute inside the container. The check succeeds if the
	//  command exits with code 0.
	Command string `json:"command,omitempty" jsonschema:"Command to execute inside the container. The check succeeds if the command exits with code 0."`
}

func (s *AliCloudSaeApplicationExecActionInput) validate() error {
	return nil
}

func (s *AliCloudSaeApplicationExecActionInput) applyDefaults() {
}

func (s *AliCloudSaeApplicationExecActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Command != "" {
		m["command"] = s.Command
	}
	return m
}

// AliCloudSaeApplicationHealthCheck defines a health check probe for the
//
//	SAE application. Exactly one of http_get, tcp_socket, or exec should be
//	configured to specify the check mechanism.
type AliCloudSaeApplicationHealthCheckInput struct {
	// HTTP GET probe. SAE sends an HTTP GET request to the specified path
	//  and port, and considers the check successful if the response status
	//  is 200-399.
	HttpGet *AliCloudSaeApplicationHttpGetActionInput `json:"http_get,omitempty" jsonschema:"HTTP GET probe. SAE sends an HTTP GET request to the specified path and port; and considers the check successful if the response status is 200-399."`
	// TCP socket probe. SAE attempts a TCP connection to the specified port
	//  and considers the check successful if the connection is established.
	TcpSocket *AliCloudSaeApplicationTcpSocketActionInput `json:"tcp_socket,omitempty" jsonschema:"TCP socket probe. SAE attempts a TCP connection to the specified port and considers the check successful if the connection is established."`
	// Exec probe. SAE executes the specified command inside the container
	//  and considers the check successful if the command exits with code 0.
	Exec *AliCloudSaeApplicationExecActionInput `json:"exec,omitempty" jsonschema:"Exec probe. SAE executes the specified command inside the container and considers the check successful if the command exits with code 0."`
	// Seconds to wait after the container starts before initiating the
	//  first health check.
	InitialDelaySeconds int32 `json:"initial_delay_seconds,omitempty" jsonschema:"Seconds to wait after the container starts before initiating the first health check."`
	// Seconds between consecutive health checks.
	PeriodSeconds int32 `json:"period_seconds,omitempty" jsonschema:"Seconds between consecutive health checks."`
	// Seconds to wait for a health check response before marking it failed.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Seconds to wait for a health check response before marking it failed."`
	// Number of consecutive failures before considering the container
	//  unhealthy (liveness) or not ready (readiness).
	FailureThreshold int32 `json:"failure_threshold,omitempty" jsonschema:"Number of consecutive failures before considering the container unhealthy (liveness) or not ready (readiness)."`
	// Number of consecutive successes before considering the container
	//  healthy or ready again after a failure.
	SuccessThreshold int32 `json:"success_threshold,omitempty" jsonschema:"Number of consecutive successes before considering the container healthy or ready again after a failure."`
}

func (s *AliCloudSaeApplicationHealthCheckInput) validate() error {
	if s.HttpGet != nil {
		if err := s.HttpGet.validate(); err != nil {
			return fmt.Errorf("http_get: %w", err)
		}
	}
	if s.TcpSocket != nil {
		if err := s.TcpSocket.validate(); err != nil {
			return fmt.Errorf("tcp_socket: %w", err)
		}
	}
	if s.Exec != nil {
		if err := s.Exec.validate(); err != nil {
			return fmt.Errorf("exec: %w", err)
		}
	}
	return nil
}

func (s *AliCloudSaeApplicationHealthCheckInput) applyDefaults() {
	if s.HttpGet != nil {
		s.HttpGet.applyDefaults()
	}
	if s.TcpSocket != nil {
		s.TcpSocket.applyDefaults()
	}
	if s.Exec != nil {
		s.Exec.applyDefaults()
	}
}

func (s *AliCloudSaeApplicationHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HttpGet != nil {
		m["http_get"] = s.HttpGet.toMap()
	}
	if s.TcpSocket != nil {
		m["tcp_socket"] = s.TcpSocket.toMap()
	}
	if s.Exec != nil {
		m["exec"] = s.Exec.toMap()
	}
	if s.InitialDelaySeconds != 0 {
		m["initial_delay_seconds"] = s.InitialDelaySeconds
	}
	if s.PeriodSeconds != 0 {
		m["period_seconds"] = s.PeriodSeconds
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.FailureThreshold != 0 {
		m["failure_threshold"] = s.FailureThreshold
	}
	if s.SuccessThreshold != 0 {
		m["success_threshold"] = s.SuccessThreshold
	}
	return m
}

// AliCloudSaeApplicationHttpGetAction defines an HTTP GET health check.
type AliCloudSaeApplicationHttpGetActionInput struct {
	// URL path for the HTTP GET request (e.g., "/healthz").
	Path string `json:"path,omitempty" jsonschema:"URL path for the HTTP GET request (e.g.; '/healthz')."`
	// Port to send the HTTP GET request to.
	Port int32 `json:"port,omitempty" jsonschema:"Port to send the HTTP GET request to."`
}

func (s *AliCloudSaeApplicationHttpGetActionInput) validate() error {
	return nil
}

func (s *AliCloudSaeApplicationHttpGetActionInput) applyDefaults() {
}

func (s *AliCloudSaeApplicationHttpGetActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	return m
}

// AliCloudSaeApplicationTcpSocketAction defines a TCP socket health check.
type AliCloudSaeApplicationTcpSocketActionInput struct {
	// Port to attempt a TCP connection to.
	Port int32 `json:"port,omitempty" jsonschema:"Port to attempt a TCP connection to."`
}

func (s *AliCloudSaeApplicationTcpSocketActionInput) validate() error {
	return nil
}

func (s *AliCloudSaeApplicationTcpSocketActionInput) applyDefaults() {
}

func (s *AliCloudSaeApplicationTcpSocketActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Port != 0 {
		m["port"] = s.Port
	}
	return m
}

// AliCloudSaeApplicationUpdateStrategy controls how new application
//
//	versions are rolled out to instances.
type AliCloudSaeApplicationUpdateStrategyInput struct {
	// Release policy type.
	//  "BatchUpdate": release in sequential batches.
	//  "GrayBatchUpdate": canary-style phased release.
	Type string `json:"type,omitempty" jsonschema:"Release policy type. 'BatchUpdate': release in sequential batches. 'GrayBatchUpdate': canary-style phased release."`
	// Batch update configuration.
	BatchUpdate *AliCloudSaeApplicationBatchUpdateInput `json:"batch_update,omitempty" jsonschema:"Batch update configuration."`
}

func (s *AliCloudSaeApplicationUpdateStrategyInput) validate() error {
	if s.BatchUpdate != nil {
		if err := s.BatchUpdate.validate(); err != nil {
			return fmt.Errorf("batch_update: %w", err)
		}
	}
	return nil
}

func (s *AliCloudSaeApplicationUpdateStrategyInput) applyDefaults() {
	if s.BatchUpdate != nil {
		s.BatchUpdate.applyDefaults()
	}
}

func (s *AliCloudSaeApplicationUpdateStrategyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.BatchUpdate != nil {
		m["batch_update"] = s.BatchUpdate.toMap()
	}
	return m
}

// ParseAliCloudSaeApplication validates and normalizes a AliCloudSaeApplication cloud_object.
func ParseAliCloudSaeApplication(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudSaeApplication"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudSaeApplicationSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
