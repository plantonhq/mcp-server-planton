// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package alicloud

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// alicloud-vpn-gateway
type AliCloudVpnGatewaySpecInput struct {
	// Alibaba Cloud region where the VPN Gateway will be created.
	//  Must match the region of the VPC and VSwitch.
	//  Examples: "cn-hangzhou", "cn-shanghai", "us-west-1", "ap-southeast-1".
	Region string `json:"region" jsonschema:"required,Alibaba Cloud region where the VPN Gateway will be created. Must match the region of the VPC and VSwitch. Examples: 'cn-hangzhou'; 'cn-shanghai'; 'us-west-1'; 'ap-southeast-1'."`
	// VPC ID that the VPN Gateway belongs to.
	VpcId string `json:"vpc_id" jsonschema:"required,VPC ID that the VPN Gateway belongs to."`
	// VSwitch ID where the VPN Gateway is placed. Must be in the same VPC as
	//  vpc_id. The VPN Gateway consumes a private IP from this VSwitch.
	VswitchId string `json:"vswitch_id" jsonschema:"required,VSwitch ID where the VPN Gateway is placed. Must be in the same VPC as vpc_id. The VPN Gateway consumes a private IP from this VSwitch."`
	// VPN Gateway name. 2-128 characters; must start with a letter or Chinese
	//  character; can contain digits, underscores, periods, and hyphens.
	VpnGatewayName string `json:"vpn_gateway_name" jsonschema:"required,VPN Gateway name. 2-128 characters; must start with a letter or Chinese character; can contain digits; underscores; periods; and hyphens."`
	// Human-readable description of the VPN Gateway's purpose.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the VPN Gateway's purpose."`
	// Maximum public network bandwidth for the VPN Gateway in Mbps.
	//  This is immutable after creation (ForceNew in the provider).
	Bandwidth int32 `json:"bandwidth" jsonschema:"required,Maximum public network bandwidth for the VPN Gateway in Mbps. This is immutable after creation (ForceNew in the provider)."`
	// Billing method for the VPN Gateway.
	//  "PayAsYouGo" for on-demand billing, "Subscription" for reserved pricing.
	//  Default: "PayAsYouGo"
	PaymentType string `json:"payment_type,omitempty" jsonschema:"Billing method for the VPN Gateway. 'PayAsYouGo' for on-demand billing; 'Subscription' for reserved pricing. Default: 'PayAsYouGo'"`
	// Enable SSL VPN on the gateway for remote client access.
	//  When true, the gateway allocates a dedicated SSL VPN IP and supports
	//  SSL VPN server/client configuration. Default: false
	EnableSsl bool `json:"enable_ssl,omitempty" jsonschema:"Enable SSL VPN on the gateway for remote client access. When true; the gateway allocates a dedicated SSL VPN IP and supports SSL VPN server/client configuration. Default: false"`
	// Maximum number of concurrent SSL VPN client connections.
	//  Only relevant when enable_ssl is true. The value determines
	//  the SSL VPN license tier on the gateway.
	SslConnections int32 `json:"ssl_connections,omitempty" jsonschema:"Maximum number of concurrent SSL VPN client connections. Only relevant when enable_ssl is true. The value determines the SSL VPN license tier on the gateway."`
	// Tags to apply to the VPN Gateway resource.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the VPN Gateway resource."`
	// Resource group ID for access control. Leave empty to use the default
	//  resource group.
	ResourceGroupId string `json:"resource_group_id,omitempty" jsonschema:"Resource group ID for access control. Leave empty to use the default resource group."`
	// IPsec VPN connections bundled with this gateway. Each entry creates a
	//  Customer Gateway (from the remote device's public IP) and a VPN
	//  Connection with the specified IKE/IPsec negotiation parameters.
	Connections []*AliCloudVpnConnectionInput `json:"connections,omitempty" jsonschema:"IPsec VPN connections bundled with this gateway. Each entry creates a Customer Gateway (from the remote device's public IP) and a VPN Connection with the specified IKE/IPsec negotiation parameters."`
}

func (s *AliCloudVpnGatewaySpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if s.VswitchId == "" {
		return fmt.Errorf("vswitch_id is required")
	}
	if s.VpnGatewayName == "" {
		return fmt.Errorf("vpn_gateway_name is required")
	}
	for i, v := range s.Connections {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("connections[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AliCloudVpnGatewaySpecInput) applyDefaults() {
	if s.PaymentType == "" {
		s.PaymentType = "PayAsYouGo"
	}
}

func (s *AliCloudVpnGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["vpc_id"] = s.VpcId
	m["vswitch_id"] = s.VswitchId
	m["vpn_gateway_name"] = s.VpnGatewayName
	if s.Description != "" {
		m["description"] = s.Description
	}
	m["bandwidth"] = s.Bandwidth
	if s.PaymentType != "" {
		m["payment_type"] = s.PaymentType
	}
	if s.EnableSsl {
		m["enable_ssl"] = s.EnableSsl
	}
	if s.SslConnections != 0 {
		m["ssl_connections"] = s.SslConnections
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.ResourceGroupId != "" {
		m["resource_group_id"] = s.ResourceGroupId
	}
	if len(s.Connections) > 0 {
		items := make([]any, len(s.Connections))
		for i, v := range s.Connections {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["connections"] = items
	}
	return m
}

// AliCloudIkeConfig defines the IKE (Internet Key Exchange) Phase 1
//
//	negotiation parameters for establishing the IPsec security association.
type AliCloudIkeConfigInput struct {
	// Pre-shared key (PSK) for IKE authentication. 1-100 characters.
	//  If omitted, the provider auto-generates a random PSK.
	Psk string `json:"psk,omitempty" jsonschema:"Pre-shared key (PSK) for IKE authentication. 1-100 characters. If omitted; the provider auto-generates a random PSK."`
	// IKE protocol version. IKEv2 is recommended for better performance and
	//  security. Default: "ikev2"
	IkeVersion string `json:"ike_version,omitempty" jsonschema:"IKE protocol version. IKEv2 is recommended for better performance and security. Default: 'ikev2'"`
	// IKE negotiation mode. "main" provides identity protection (6 messages);
	//  "aggressive" is faster (3 messages) but exposes identities.
	//  Default: "main"
	IkeMode string `json:"ike_mode,omitempty" jsonschema:"IKE negotiation mode. 'main' provides identity protection (6 messages); 'aggressive' is faster (3 messages) but exposes identities. Default: 'main'"`
	// IKE encryption algorithm for Phase 1.
	//  Default: "aes"
	IkeEncAlg string `json:"ike_enc_alg,omitempty" jsonschema:"IKE encryption algorithm for Phase 1. Default: 'aes'"`
	// IKE authentication algorithm for Phase 1.
	//  Default: "sha1"
	IkeAuthAlg string `json:"ike_auth_alg,omitempty" jsonschema:"IKE authentication algorithm for Phase 1. Default: 'sha1'"`
	// Diffie-Hellman key exchange group for Perfect Forward Secrecy in Phase 1.
	//  Higher groups provide stronger security at the cost of performance.
	//  Default: "group2" (1024-bit MODP)
	IkePfs string `json:"ike_pfs,omitempty" jsonschema:"Diffie-Hellman key exchange group for Perfect Forward Secrecy in Phase 1. Higher groups provide stronger security at the cost of performance. Default: 'group2' (1024-bit MODP)"`
	// IKE SA (Security Association) lifetime in seconds. When this expires, the
	//  SA is re-negotiated. Range: 0-86400. Default: 86400 (24 hours)
	IkeLifetime int32 `json:"ike_lifetime,omitempty" jsonschema:"IKE SA (Security Association) lifetime in seconds. When this expires; the SA is re-negotiated. Range: 0-86400. Default: 86400 (24 hours)"`
}

func (s *AliCloudIkeConfigInput) validate() error {
	return nil
}

func (s *AliCloudIkeConfigInput) applyDefaults() {
	if s.IkeVersion == "" {
		s.IkeVersion = "ikev2"
	}
	if s.IkeMode == "" {
		s.IkeMode = "main"
	}
	if s.IkeEncAlg == "" {
		s.IkeEncAlg = "aes"
	}
	if s.IkeAuthAlg == "" {
		s.IkeAuthAlg = "sha1"
	}
	if s.IkePfs == "" {
		s.IkePfs = "group2"
	}
	if s.IkeLifetime == 0 {
		s.IkeLifetime = 86400
	}
}

func (s *AliCloudIkeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Psk != "" {
		m["psk"] = s.Psk
	}
	if s.IkeVersion != "" {
		m["ike_version"] = s.IkeVersion
	}
	if s.IkeMode != "" {
		m["ike_mode"] = s.IkeMode
	}
	if s.IkeEncAlg != "" {
		m["ike_enc_alg"] = s.IkeEncAlg
	}
	if s.IkeAuthAlg != "" {
		m["ike_auth_alg"] = s.IkeAuthAlg
	}
	if s.IkePfs != "" {
		m["ike_pfs"] = s.IkePfs
	}
	if s.IkeLifetime != 0 {
		m["ike_lifetime"] = s.IkeLifetime
	}
	return m
}

// AliCloudIpsecConfig defines the IPsec (Phase 2) negotiation parameters
//
//	that control how data traffic is encrypted through the tunnel.
type AliCloudIpsecConfigInput struct {
	// IPsec encryption algorithm for Phase 2 data traffic.
	//  Default: "aes"
	IpsecEncAlg string `json:"ipsec_enc_alg,omitempty" jsonschema:"IPsec encryption algorithm for Phase 2 data traffic. Default: 'aes'"`
	// IPsec authentication algorithm for Phase 2 data traffic.
	//  Default: "md5"
	IpsecAuthAlg string `json:"ipsec_auth_alg,omitempty" jsonschema:"IPsec authentication algorithm for Phase 2 data traffic. Default: 'md5'"`
	// Diffie-Hellman key exchange group for Perfect Forward Secrecy in Phase 2.
	//  "disabled" turns off PFS (the Phase 1 key is reused).
	//  Default: "group2"
	IpsecPfs string `json:"ipsec_pfs,omitempty" jsonschema:"Diffie-Hellman key exchange group for Perfect Forward Secrecy in Phase 2. 'disabled' turns off PFS (the Phase 1 key is reused). Default: 'group2'"`
	// IPsec SA lifetime in seconds. Range: 0-86400. Default: 86400 (24 hours)
	IpsecLifetime int32 `json:"ipsec_lifetime,omitempty" jsonschema:"IPsec SA lifetime in seconds. Range: 0-86400. Default: 86400 (24 hours)"`
}

func (s *AliCloudIpsecConfigInput) validate() error {
	return nil
}

func (s *AliCloudIpsecConfigInput) applyDefaults() {
	if s.IpsecEncAlg == "" {
		s.IpsecEncAlg = "aes"
	}
	if s.IpsecAuthAlg == "" {
		s.IpsecAuthAlg = "md5"
	}
	if s.IpsecPfs == "" {
		s.IpsecPfs = "group2"
	}
	if s.IpsecLifetime == 0 {
		s.IpsecLifetime = 86400
	}
}

func (s *AliCloudIpsecConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IpsecEncAlg != "" {
		m["ipsec_enc_alg"] = s.IpsecEncAlg
	}
	if s.IpsecAuthAlg != "" {
		m["ipsec_auth_alg"] = s.IpsecAuthAlg
	}
	if s.IpsecPfs != "" {
		m["ipsec_pfs"] = s.IpsecPfs
	}
	if s.IpsecLifetime != 0 {
		m["ipsec_lifetime"] = s.IpsecLifetime
	}
	return m
}

// AliCloudVpnConnection defines a single IPsec VPN connection between the
//
//	Alibaba Cloud VPN Gateway and a remote network device (on-premises router,
//	firewall, or another cloud VPN endpoint).
//
//	Each connection creates two provider resources:
//	  - A Customer Gateway representing the remote device's identity (IP + ASN)
//	  - A VPN Connection with IPsec tunnel configuration
type AliCloudVpnConnectionInput struct {
	// Connection name. Used as both the customer_gateway_name and
	//  vpn_connection_name in the provider. 2-128 characters.
	Name string `json:"name" jsonschema:"required,Connection name. Used as both the customer_gateway_name and vpn_connection_name in the provider. 2-128 characters."`
	// Public IP address of the remote VPN device (on-premises router, firewall,
	//  or other cloud gateway). This is immutable after the customer gateway is
	//  created.
	CustomerGatewayIp string `json:"customer_gateway_ip" jsonschema:"required,Public IP address of the remote VPN device (on-premises router; firewall; or other cloud gateway). This is immutable after the customer gateway is created."`
	// BGP Autonomous System Number of the remote device. Used when the remote
	//  gateway participates in BGP routing. Format: plain 32-bit ASN (e.g.
	//  "65001") or dot notation (e.g. "4200000001").
	CustomerGatewayAsn string `json:"customer_gateway_asn,omitempty" jsonschema:"BGP Autonomous System Number of the remote device. Used when the remote gateway participates in BGP routing. Format: plain 32-bit ASN (e.g. '65001') or dot notation (e.g. '4200000001')."`
	// VPC-side CIDR blocks that should be reachable through this tunnel.
	//  The VPN connection routes traffic for these CIDRs through the tunnel.
	//  At least 1, at most 10 CIDR blocks.
	//  Example: ["10.0.0.0/8", "172.16.0.0/12"]
	LocalSubnets []string `json:"local_subnets,omitempty" jsonschema:"VPC-side CIDR blocks that should be reachable through this tunnel. The VPN connection routes traffic for these CIDRs through the tunnel. At least 1; at most 10 CIDR blocks. Example: ['10.0.0.0/8'; '17..."`
	// Remote-site CIDR blocks reachable on the other end of the tunnel.
	//  At least 1, at most 10 CIDR blocks.
	//  Example: ["192.168.0.0/16"]
	RemoteSubnets []string `json:"remote_subnets,omitempty" jsonschema:"Remote-site CIDR blocks reachable on the other end of the tunnel. At least 1; at most 10 CIDR blocks. Example: ['192.168.0.0/16']"`
	// Enable Dead Peer Detection (DPD). When enabled, the VPN gateway sends
	//  DPD packets to verify the remote peer is alive and re-negotiates if the
	//  peer becomes unreachable. Default: true
	EnableDpd bool `json:"enable_dpd,omitempty" jsonschema:"Enable Dead Peer Detection (DPD). When enabled; the VPN gateway sends DPD packets to verify the remote peer is alive and re-negotiates if the peer becomes unreachable. Default: true"`
	// Enable NAT traversal (NAT-T). Required when the remote VPN device is
	//  behind a NAT device. Encapsulates IPsec ESP packets in UDP to traverse
	//  NAT. Default: true
	EnableNatTraversal bool `json:"enable_nat_traversal,omitempty" jsonschema:"Enable NAT traversal (NAT-T). Required when the remote VPN device is behind a NAT device. Encapsulates IPsec ESP packets in UDP to traverse NAT. Default: true"`
	// Initiate IPsec negotiation immediately after creation rather than waiting
	//  for traffic to trigger the tunnel. Default: true
	EffectImmediately bool `json:"effect_immediately,omitempty" jsonschema:"Initiate IPsec negotiation immediately after creation rather than waiting for traffic to trigger the tunnel. Default: true"`
	// IKE (Phase 1) negotiation parameters. When omitted, the provider uses
	//  sensible defaults (IKEv2, main mode, AES encryption, SHA1 auth, DH group2,
	//  auto-generated pre-shared key, 86400s lifetime).
	IkeConfig *AliCloudIkeConfigInput `json:"ike_config,omitempty" jsonschema:"IKE (Phase 1) negotiation parameters. When omitted; the provider uses sensible defaults (IKEv2; main mode; AES encryption; SHA1 auth; DH group2; auto-generated pre-shared key; 86400s lifetime)."`
	// IPsec (Phase 2) negotiation parameters. When omitted, the provider uses
	//  sensible defaults (AES encryption, MD5 auth, DH group2, 86400s lifetime).
	IpsecConfig *AliCloudIpsecConfigInput `json:"ipsec_config,omitempty" jsonschema:"IPsec (Phase 2) negotiation parameters. When omitted; the provider uses sensible defaults (AES encryption; MD5 auth; DH group2; 86400s lifetime)."`
	// Health check configuration for monitoring tunnel connectivity. When
	//  enabled, the VPN gateway periodically probes the remote endpoint and
	//  can trigger failover if the tunnel becomes unhealthy.
	HealthCheckConfig *AliCloudVpnHealthCheckConfigInput `json:"health_check_config,omitempty" jsonschema:"Health check configuration for monitoring tunnel connectivity. When enabled; the VPN gateway periodically probes the remote endpoint and can trigger failover if the tunnel becomes unhealthy."`
}

func (s *AliCloudVpnConnectionInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.CustomerGatewayIp == "" {
		return fmt.Errorf("customer_gateway_ip is required")
	}
	if len(s.LocalSubnets) < 1 {
		return fmt.Errorf("local_subnets requires at least 1 items, got %d", len(s.LocalSubnets))
	}
	if len(s.RemoteSubnets) < 1 {
		return fmt.Errorf("remote_subnets requires at least 1 items, got %d", len(s.RemoteSubnets))
	}
	if s.IkeConfig != nil {
		if err := s.IkeConfig.validate(); err != nil {
			return fmt.Errorf("ike_config: %w", err)
		}
	}
	if s.IpsecConfig != nil {
		if err := s.IpsecConfig.validate(); err != nil {
			return fmt.Errorf("ipsec_config: %w", err)
		}
	}
	if s.HealthCheckConfig != nil {
		if err := s.HealthCheckConfig.validate(); err != nil {
			return fmt.Errorf("health_check_config: %w", err)
		}
	}
	return nil
}

func (s *AliCloudVpnConnectionInput) applyDefaults() {
	// default: EnableDpd = true (applied at zero-value)
	// default: EnableNatTraversal = true (applied at zero-value)
	// default: EffectImmediately = true (applied at zero-value)
	if s.IkeConfig != nil {
		s.IkeConfig.applyDefaults()
	}
	if s.IpsecConfig != nil {
		s.IpsecConfig.applyDefaults()
	}
	if s.HealthCheckConfig != nil {
		s.HealthCheckConfig.applyDefaults()
	}
}

func (s *AliCloudVpnConnectionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["customer_gateway_ip"] = s.CustomerGatewayIp
	if s.CustomerGatewayAsn != "" {
		m["customer_gateway_asn"] = s.CustomerGatewayAsn
	}
	if len(s.LocalSubnets) > 0 {
		m["local_subnets"] = s.LocalSubnets
	}
	if len(s.RemoteSubnets) > 0 {
		m["remote_subnets"] = s.RemoteSubnets
	}
	if s.EnableDpd {
		m["enable_dpd"] = s.EnableDpd
	}
	if s.EnableNatTraversal {
		m["enable_nat_traversal"] = s.EnableNatTraversal
	}
	if s.EffectImmediately {
		m["effect_immediately"] = s.EffectImmediately
	}
	if s.IkeConfig != nil {
		m["ike_config"] = s.IkeConfig.toMap()
	}
	if s.IpsecConfig != nil {
		m["ipsec_config"] = s.IpsecConfig.toMap()
	}
	if s.HealthCheckConfig != nil {
		m["health_check_config"] = s.HealthCheckConfig.toMap()
	}
	return m
}

// AliCloudVpnHealthCheckConfig defines health monitoring for a VPN connection.
//
//	When enabled, the VPN gateway periodically sends probes to detect tunnel
//	failures and can trigger route failover in active-standby setups.
type AliCloudVpnHealthCheckConfigInput struct {
	// Enable health checks for this connection. Default: false
	Enable bool `json:"enable,omitempty" jsonschema:"Enable health checks for this connection. Default: false"`
	// Source IP address for health check probes. Should be a private IP
	//  within the local VPC that is routable through the tunnel.
	Sip string `json:"sip,omitempty" jsonschema:"Source IP address for health check probes. Should be a private IP within the local VPC that is routable through the tunnel."`
	// Destination IP address for health check probes. Should be an IP on the
	//  remote network reachable through the tunnel.
	Dip string `json:"dip,omitempty" jsonschema:"Destination IP address for health check probes. Should be an IP on the remote network reachable through the tunnel."`
	// Interval between health check probes in seconds. Default: 3
	Interval int32 `json:"interval,omitempty" jsonschema:"Interval between health check probes in seconds. Default: 3"`
	// Maximum number of consecutive probe failures before the tunnel is
	//  declared unhealthy. Default: 3
	Retry int32 `json:"retry,omitempty" jsonschema:"Maximum number of consecutive probe failures before the tunnel is declared unhealthy. Default: 3"`
}

func (s *AliCloudVpnHealthCheckConfigInput) validate() error {
	return nil
}

func (s *AliCloudVpnHealthCheckConfigInput) applyDefaults() {
	if s.Interval == 0 {
		s.Interval = 3
	}
	if s.Retry == 0 {
		s.Retry = 3
	}
}

func (s *AliCloudVpnHealthCheckConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enable {
		m["enable"] = s.Enable
	}
	if s.Sip != "" {
		m["sip"] = s.Sip
	}
	if s.Dip != "" {
		m["dip"] = s.Dip
	}
	if s.Interval != 0 {
		m["interval"] = s.Interval
	}
	if s.Retry != 0 {
		m["retry"] = s.Retry
	}
	return m
}

// ParseAliCloudVpnGateway validates and normalizes a AliCloudVpnGateway cloud_object.
func ParseAliCloudVpnGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "ali-cloud.openmcf.org/v1", "AliCloudVpnGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AliCloudVpnGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
