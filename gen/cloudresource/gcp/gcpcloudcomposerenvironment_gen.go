// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-composer-environment
type GcpCloudComposerEnvironmentSpecInput struct {
	// GCP project in which to create the Cloud Composer environment.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project in which to create the Cloud Composer environment."`
	// GCP region for the Composer environment (e.g., "us-central1").
	Region string `json:"region" jsonschema:"required,GCP region for the Composer environment (e.g.; 'us-central1')."`
	// Name of the Composer environment resource in GCP.
	//  Must be lowercase letters, numbers, and hyphens; start with a letter;
	//  end with a letter or number; 1-64 characters.
	//  Optional: when empty, defaults to metadata.name.
	EnvironmentName string `json:"environment_name,omitempty" jsonschema:"Name of the Composer environment resource in GCP. Must be lowercase letters; numbers; and hyphens; start with a letter; end with a letter or number; 1-64 characters. Optional: when empty; defaults to ..."`
	// Networking and node configuration for the Composer environment.
	NodeConfig *GcpCloudComposerNodeConfigInput `json:"node_config,omitempty" jsonschema:"Networking and node configuration for the Composer environment."`
	// Airflow software configuration including image version, packages,
	//  and configuration overrides.
	SoftwareConfig *GcpCloudComposerSoftwareConfigInput `json:"software_config,omitempty" jsonschema:"Airflow software configuration including image version; packages; and configuration overrides."`
	// Private networking configuration for Composer 2.x environments using
	//  VPC peering or Private Service Connect. Not applicable to Composer 3
	//  which uses enable_private_environment and composer_network_attachment instead.
	PrivateEnvironmentConfig *GcpCloudComposerPrivateEnvironmentConfigInput `json:"private_environment_config,omitempty" jsonschema:"Private networking configuration for Composer 2.x environments using VPC peering or Private Service Connect. Not applicable to Composer 3 which uses enable_private_environment and composer_network_att..."`
	// Workload resource allocation for Airflow components (scheduler, worker,
	//  web server, triggerer, DAG processor). Applies to Composer 2.x and 3.
	WorkloadsConfig *GcpCloudComposerWorkloadsConfigInput `json:"workloads_config,omitempty" jsonschema:"Workload resource allocation for Airflow components (scheduler; worker; web server; triggerer; DAG processor). Applies to Composer 2.x and 3."`
	// Size of the Composer environment. Controls the managed infrastructure
	//  capacity. Only applicable to Composer 2.x and 3.
	EnvironmentSize string `json:"environment_size,omitempty" jsonschema:"Size of the Composer environment. Controls the managed infrastructure capacity. Only applicable to Composer 2.x and 3."`
	// Resilience mode for the Composer environment. HIGH_RESILIENCE provides
	//  multi-zone redundancy for increased availability. Applies to Composer 2.1.15+.
	ResilienceMode string `json:"resilience_mode,omitempty" jsonschema:"Resilience mode for the Composer environment. HIGH_RESILIENCE provides multi-zone redundancy for increased availability. Applies to Composer 2.1.15+."`
	// Customer-managed encryption key for the Composer environment.
	//  All Composer-managed resources (GKE nodes, Cloud SQL, Cloud Storage) are
	//  encrypted with this key.
	KmsKeyName string `json:"kms_key_name,omitempty" jsonschema:"Customer-managed encryption key for the Composer environment. All Composer-managed resources (GKE nodes; Cloud SQL; Cloud Storage) are encrypted with this key."`
	// Maintenance window configuration for the Composer environment.
	//  Defines when GCP may perform maintenance operations on the environment.
	MaintenanceWindow *GcpCloudComposerMaintenanceWindowInput `json:"maintenance_window,omitempty" jsonschema:"Maintenance window configuration for the Composer environment. Defines when GCP may perform maintenance operations on the environment."`
	// Recovery configuration with scheduled snapshots for disaster recovery.
	RecoveryConfig *GcpCloudComposerRecoveryConfigInput `json:"recovery_config,omitempty" jsonschema:"Recovery configuration with scheduled snapshots for disaster recovery."`
	// Network-level access restrictions for the Airflow web server UI.
	//  When configured, only requests from the specified IP ranges are allowed.
	WebServerNetworkAccessControl *GcpCloudComposerWebServerAccessControlInput `json:"web_server_network_access_control,omitempty" jsonschema:"Network-level access restrictions for the Airflow web server UI. When configured; only requests from the specified IP ranges are allowed."`
	// Enable private environment for Composer 3 environments. When true, the
	//  environment does not have a public IP endpoint for the web server.
	//  Only applicable to Composer 3.
	EnablePrivateEnvironment bool `json:"enable_private_environment,omitempty" jsonschema:"Enable private environment for Composer 3 environments. When true; the environment does not have a public IP endpoint for the web server. Only applicable to Composer 3."`
	// Enable private builds only for Composer 3 environments. When true,
	//  only builds using private connectivity are allowed for Python packages.
	//  Only applicable to Composer 3.
	EnablePrivateBuildsOnly bool `json:"enable_private_builds_only,omitempty" jsonschema:"Enable private builds only for Composer 3 environments. When true; only builds using private connectivity are allowed for Python packages. Only applicable to Composer 3."`
}

func (s *GcpCloudComposerEnvironmentSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.NodeConfig != nil {
		if err := s.NodeConfig.validate(); err != nil {
			return fmt.Errorf("node_config: %w", err)
		}
	}
	if s.SoftwareConfig != nil {
		if err := s.SoftwareConfig.validate(); err != nil {
			return fmt.Errorf("software_config: %w", err)
		}
	}
	if s.PrivateEnvironmentConfig != nil {
		if err := s.PrivateEnvironmentConfig.validate(); err != nil {
			return fmt.Errorf("private_environment_config: %w", err)
		}
	}
	if s.WorkloadsConfig != nil {
		if err := s.WorkloadsConfig.validate(); err != nil {
			return fmt.Errorf("workloads_config: %w", err)
		}
	}
	if s.MaintenanceWindow != nil {
		if err := s.MaintenanceWindow.validate(); err != nil {
			return fmt.Errorf("maintenance_window: %w", err)
		}
	}
	if s.RecoveryConfig != nil {
		if err := s.RecoveryConfig.validate(); err != nil {
			return fmt.Errorf("recovery_config: %w", err)
		}
	}
	if s.WebServerNetworkAccessControl != nil {
		if err := s.WebServerNetworkAccessControl.validate(); err != nil {
			return fmt.Errorf("web_server_network_access_control: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudComposerEnvironmentSpecInput) applyDefaults() {
	if s.NodeConfig != nil {
		s.NodeConfig.applyDefaults()
	}
	if s.SoftwareConfig != nil {
		s.SoftwareConfig.applyDefaults()
	}
	if s.PrivateEnvironmentConfig != nil {
		s.PrivateEnvironmentConfig.applyDefaults()
	}
	if s.WorkloadsConfig != nil {
		s.WorkloadsConfig.applyDefaults()
	}
	if s.MaintenanceWindow != nil {
		s.MaintenanceWindow.applyDefaults()
	}
	if s.RecoveryConfig != nil {
		s.RecoveryConfig.applyDefaults()
	}
	if s.WebServerNetworkAccessControl != nil {
		s.WebServerNetworkAccessControl.applyDefaults()
	}
}

func (s *GcpCloudComposerEnvironmentSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["region"] = s.Region
	if s.EnvironmentName != "" {
		m["environment_name"] = s.EnvironmentName
	}
	if s.NodeConfig != nil {
		m["node_config"] = s.NodeConfig.toMap()
	}
	if s.SoftwareConfig != nil {
		m["software_config"] = s.SoftwareConfig.toMap()
	}
	if s.PrivateEnvironmentConfig != nil {
		m["private_environment_config"] = s.PrivateEnvironmentConfig.toMap()
	}
	if s.WorkloadsConfig != nil {
		m["workloads_config"] = s.WorkloadsConfig.toMap()
	}
	if s.EnvironmentSize != "" {
		m["environment_size"] = s.EnvironmentSize
	}
	if s.ResilienceMode != "" {
		m["resilience_mode"] = s.ResilienceMode
	}
	if s.KmsKeyName != "" {
		m["kms_key_name"] = s.KmsKeyName
	}
	if s.MaintenanceWindow != nil {
		m["maintenance_window"] = s.MaintenanceWindow.toMap()
	}
	if s.RecoveryConfig != nil {
		m["recovery_config"] = s.RecoveryConfig.toMap()
	}
	if s.WebServerNetworkAccessControl != nil {
		m["web_server_network_access_control"] = s.WebServerNetworkAccessControl.toMap()
	}
	if s.EnablePrivateEnvironment {
		m["enable_private_environment"] = s.EnablePrivateEnvironment
	}
	if s.EnablePrivateBuildsOnly {
		m["enable_private_builds_only"] = s.EnablePrivateBuildsOnly
	}
	return m
}

// GcpCloudComposerAllowedIpRange defines a single IP range allowed to access
//
//	the Airflow web server.
type GcpCloudComposerAllowedIpRangeInput struct {
	// IP address or CIDR range (e.g., "10.0.0.0/8", "203.0.113.0/24").
	Value string `json:"value" jsonschema:"required,IP address or CIDR range (e.g.; '10.0.0.0/8'; '203.0.113.0/24')."`
	// Optional human-readable description of this IP range.
	Description string `json:"description,omitempty" jsonschema:"Optional human-readable description of this IP range."`
}

func (s *GcpCloudComposerAllowedIpRangeInput) validate() error {
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *GcpCloudComposerAllowedIpRangeInput) applyDefaults() {
}

func (s *GcpCloudComposerAllowedIpRangeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["value"] = s.Value
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// GcpCloudComposerMaintenanceWindow defines when GCP may perform scheduled
//
//	maintenance on the Cloud Composer environment.
type GcpCloudComposerMaintenanceWindowInput struct {
	// Start time of the maintenance window in RFC3339 format.
	//  Example: "2026-01-01T00:00:00Z"
	StartTime string `json:"start_time" jsonschema:"required,Start time of the maintenance window in RFC3339 format. Example: '2026-01-01T00:00:00Z'"`
	// End time of the maintenance window in RFC3339 format.
	//  Must be after start_time. The window duration must be at least 12 hours.
	EndTime string `json:"end_time" jsonschema:"required,End time of the maintenance window in RFC3339 format. Must be after start_time. The window duration must be at least 12 hours."`
	// Recurrence specification in RFC5545 RRULE format.
	//  Examples: "FREQ=WEEKLY;BYDAY=TU,WE,TH" or "FREQ=DAILY".
	Recurrence string `json:"recurrence" jsonschema:"required,Recurrence specification in RFC5545 RRULE format. Examples: 'FREQ=WEEKLY;BYDAY=TU;WE;TH' or 'FREQ=DAILY'."`
}

func (s *GcpCloudComposerMaintenanceWindowInput) validate() error {
	if s.StartTime == "" {
		return fmt.Errorf("start_time is required")
	}
	if s.EndTime == "" {
		return fmt.Errorf("end_time is required")
	}
	if s.Recurrence == "" {
		return fmt.Errorf("recurrence is required")
	}
	return nil
}

func (s *GcpCloudComposerMaintenanceWindowInput) applyDefaults() {
}

func (s *GcpCloudComposerMaintenanceWindowInput) toMap() map[string]any {
	m := make(map[string]any)
	m["start_time"] = s.StartTime
	m["end_time"] = s.EndTime
	m["recurrence"] = s.Recurrence
	return m
}

// GcpCloudComposerNodeConfig defines networking and compute settings for the
//
//	underlying Kubernetes nodes that run Airflow components.
type GcpCloudComposerNodeConfigInput struct {
	// VPC network for the Composer environment.
	//  Used for Composer 2.x with VPC peering networking.
	//  Not applicable when composer_network_attachment is set (Composer 3 PSC).
	Network string `json:"network,omitempty" jsonschema:"VPC network for the Composer environment. Used for Composer 2.x with VPC peering networking. Not applicable when composer_network_attachment is set (Composer 3 PSC)."`
	// VPC subnetwork for the Composer environment.
	//  Used for Composer 2.x with VPC peering networking.
	Subnetwork string `json:"subnetwork,omitempty" jsonschema:"VPC subnetwork for the Composer environment. Used for Composer 2.x with VPC peering networking."`
	// Service account used by the Composer environment's GKE nodes.
	//  If empty, the default Compute Engine service account is used.
	ServiceAccount string `json:"service_account,omitempty" jsonschema:"Service account used by the Composer environment's GKE nodes. If empty; the default Compute Engine service account is used."`
	// Network tags applied to Composer environment GKE nodes.
	//  Used for firewall rule targeting.
	Tags []string `json:"tags,omitempty" jsonschema:"Network tags applied to Composer environment GKE nodes. Used for firewall rule targeting."`
	// PSC Network Attachment for Composer 3 networking.
	//  Format: projects/{project}/regions/{region}/networkAttachments/{name}
	//  Mutually exclusive with network/subnetwork (VPC peering).
	ComposerNetworkAttachment string `json:"composer_network_attachment,omitempty" jsonschema:"PSC Network Attachment for Composer 3 networking. Format: projects/{project}/regions/{region}/networkAttachments/{name} Mutually exclusive with network/subnetwork (VPC peering)."`
	// IPv4 CIDR block for Composer 3 internal components.
	//  Must be a /20 range. Only applicable when using Composer 3.
	ComposerInternalIpv4CidrBlock string `json:"composer_internal_ipv4_cidr_block,omitempty" jsonschema:"IPv4 CIDR block for Composer 3 internal components. Must be a /20 range. Only applicable when using Composer 3."`
}

func (s *GcpCloudComposerNodeConfigInput) validate() error {
	return nil
}

func (s *GcpCloudComposerNodeConfigInput) applyDefaults() {
}

func (s *GcpCloudComposerNodeConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Network != "" {
		m["network"] = s.Network
	}
	if s.Subnetwork != "" {
		m["subnetwork"] = s.Subnetwork
	}
	if s.ServiceAccount != "" {
		m["service_account"] = s.ServiceAccount
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.ComposerNetworkAttachment != "" {
		m["composer_network_attachment"] = s.ComposerNetworkAttachment
	}
	if s.ComposerInternalIpv4CidrBlock != "" {
		m["composer_internal_ipv4_cidr_block"] = s.ComposerInternalIpv4CidrBlock
	}
	return m
}

// GcpCloudComposerPrivateEnvironmentConfig configures private networking
//
//	for Composer 2.x environments. Composer 3 uses enable_private_environment
//	and composer_network_attachment on the top-level spec instead.
type GcpCloudComposerPrivateEnvironmentConfigInput struct {
	// Whether to deny access to the public Airflow web server endpoint.
	//  When true, the web server is only accessible via private IP.
	EnablePrivateEndpoint bool `json:"enable_private_endpoint,omitempty" jsonschema:"Whether to deny access to the public Airflow web server endpoint. When true; the web server is only accessible via private IP."`
	// Connection type for the Composer 2.x private environment.
	ConnectionType string `json:"connection_type,omitempty" jsonschema:"Connection type for the Composer 2.x private environment."`
	// IP range for the GKE master network in CIDR notation.
	//  Default: 172.16.0.0/28.
	MasterIpv4CidrBlock string `json:"master_ipv4_cidr_block,omitempty" jsonschema:"IP range for the GKE master network in CIDR notation. Default: 172.16.0.0/28."`
	// IP range for the Cloud SQL instance in CIDR notation.
	CloudSqlIpv4CidrBlock string `json:"cloud_sql_ipv4_cidr_block,omitempty" jsonschema:"IP range for the Cloud SQL instance in CIDR notation."`
	// IP range for Cloud Composer internal components in CIDR notation.
	//  Applies to Composer 2.x and newer.
	CloudComposerNetworkIpv4CidrBlock string `json:"cloud_composer_network_ipv4_cidr_block,omitempty" jsonschema:"IP range for Cloud Composer internal components in CIDR notation. Applies to Composer 2.x and newer."`
	// PSC connection subnetwork for Composer 2.x with Private Service Connect.
	CloudComposerConnectionSubnetwork string `json:"cloud_composer_connection_subnetwork,omitempty" jsonschema:"PSC connection subnetwork for Composer 2.x with Private Service Connect."`
	// Whether to allow public IPs from non-RFC1918 ranges for IP allocation
	//  in the environment.
	EnablePrivatelyUsedPublicIps bool `json:"enable_privately_used_public_ips,omitempty" jsonschema:"Whether to allow public IPs from non-RFC1918 ranges for IP allocation in the environment."`
}

func (s *GcpCloudComposerPrivateEnvironmentConfigInput) validate() error {
	return nil
}

func (s *GcpCloudComposerPrivateEnvironmentConfigInput) applyDefaults() {
}

func (s *GcpCloudComposerPrivateEnvironmentConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EnablePrivateEndpoint {
		m["enable_private_endpoint"] = s.EnablePrivateEndpoint
	}
	if s.ConnectionType != "" {
		m["connection_type"] = s.ConnectionType
	}
	if s.MasterIpv4CidrBlock != "" {
		m["master_ipv4_cidr_block"] = s.MasterIpv4CidrBlock
	}
	if s.CloudSqlIpv4CidrBlock != "" {
		m["cloud_sql_ipv4_cidr_block"] = s.CloudSqlIpv4CidrBlock
	}
	if s.CloudComposerNetworkIpv4CidrBlock != "" {
		m["cloud_composer_network_ipv4_cidr_block"] = s.CloudComposerNetworkIpv4CidrBlock
	}
	if s.CloudComposerConnectionSubnetwork != "" {
		m["cloud_composer_connection_subnetwork"] = s.CloudComposerConnectionSubnetwork
	}
	if s.EnablePrivatelyUsedPublicIps {
		m["enable_privately_used_public_ips"] = s.EnablePrivatelyUsedPublicIps
	}
	return m
}

// GcpCloudComposerRecoveryConfig defines disaster recovery settings for the
//
//	Cloud Composer environment using scheduled snapshots.
type GcpCloudComposerRecoveryConfigInput struct {
	// Whether scheduled snapshots are enabled.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether scheduled snapshots are enabled."`
	// Cloud Storage location for snapshots (GCS bucket folder URI).
	//  Example: "gs://my-bucket/composer-snapshots"
	SnapshotLocation string `json:"snapshot_location,omitempty" jsonschema:"Cloud Storage location for snapshots (GCS bucket folder URI). Example: 'gs://my-bucket/composer-snapshots'"`
	// Cron schedule for snapshot creation in Unix-cron format.
	//  Example: "0 4 * * *" (daily at 4 AM).
	SnapshotCreationSchedule string `json:"snapshot_creation_schedule,omitempty" jsonschema:"Cron schedule for snapshot creation in Unix-cron format. Example: '0 4 * * *' (daily at 4 AM)."`
	// Time zone for the cron schedule (e.g., "America/Los_Angeles", "UTC").
	TimeZone string `json:"time_zone,omitempty" jsonschema:"Time zone for the cron schedule (e.g.; 'America/Los_Angeles'; 'UTC')."`
}

func (s *GcpCloudComposerRecoveryConfigInput) validate() error {
	return nil
}

func (s *GcpCloudComposerRecoveryConfigInput) applyDefaults() {
}

func (s *GcpCloudComposerRecoveryConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.SnapshotLocation != "" {
		m["snapshot_location"] = s.SnapshotLocation
	}
	if s.SnapshotCreationSchedule != "" {
		m["snapshot_creation_schedule"] = s.SnapshotCreationSchedule
	}
	if s.TimeZone != "" {
		m["time_zone"] = s.TimeZone
	}
	return m
}

// GcpCloudComposerSoftwareConfig defines the Airflow software configuration
//
//	including the Composer/Airflow version, Python packages, and configuration
//	overrides.
type GcpCloudComposerSoftwareConfigInput struct {
	// Composer and Airflow image version.
	//  Format: "composer-A.B.C-airflow-X.Y.Z" (e.g., "composer-2.9.7-airflow-2.9.3").
	//  If empty, the latest stable version is used.
	ImageVersion string `json:"image_version,omitempty" jsonschema:"Composer and Airflow image version. Format: 'composer-A.B.C-airflow-X.Y.Z' (e.g.; 'composer-2.9.7-airflow-2.9.3'). If empty; the latest stable version is used."`
	// Airflow configuration property overrides.
	//  Keys are section-key pairs (e.g., "core-dags_are_paused_at_creation": "True").
	//  Values that conflict with managed Composer settings are rejected.
	AirflowConfigOverrides map[string]string `json:"airflow_config_overrides,omitempty" jsonschema:"Airflow configuration property overrides. Keys are section-key pairs (e.g.; 'core-dags_are_paused_at_creation': 'True'). Values that conflict with managed Composer settings are rejected."`
	// Custom PyPI packages to install in the environment.
	//  Keys are package names, values are version specifiers or empty strings.
	//  Example: {"numpy": ">=1.21", "requests": ""}
	PypiPackages map[string]string `json:"pypi_packages,omitempty" jsonschema:"Custom PyPI packages to install in the environment. Keys are package names; values are version specifiers or empty strings. Example: {'numpy': '>=1.21'; 'requests': ''}"`
	// Additional environment variables available to all Airflow components.
	//  Variable names starting with "AIRFLOW__" are reserved by Airflow and
	//  should not be set here.
	EnvVariables map[string]string `json:"env_variables,omitempty" jsonschema:"Additional environment variables available to all Airflow components. Variable names starting with 'AIRFLOW__' are reserved by Airflow and should not be set here."`
	// Web server plugins mode for Composer 3 environments.
	//  When DISABLED, custom Airflow UI plugins are not loaded.
	//  Only applicable to Composer 3.
	WebServerPluginsMode string `json:"web_server_plugins_mode,omitempty" jsonschema:"Web server plugins mode for Composer 3 environments. When DISABLED; custom Airflow UI plugins are not loaded. Only applicable to Composer 3."`
}

func (s *GcpCloudComposerSoftwareConfigInput) validate() error {
	return nil
}

func (s *GcpCloudComposerSoftwareConfigInput) applyDefaults() {
}

func (s *GcpCloudComposerSoftwareConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ImageVersion != "" {
		m["image_version"] = s.ImageVersion
	}
	if len(s.AirflowConfigOverrides) > 0 {
		m["airflow_config_overrides"] = s.AirflowConfigOverrides
	}
	if len(s.PypiPackages) > 0 {
		m["pypi_packages"] = s.PypiPackages
	}
	if len(s.EnvVariables) > 0 {
		m["env_variables"] = s.EnvVariables
	}
	if s.WebServerPluginsMode != "" {
		m["web_server_plugins_mode"] = s.WebServerPluginsMode
	}
	return m
}

// GcpCloudComposerTriggererResource defines resource allocation for the
//
//	Airflow triggerer. The triggerer monitors deferred tasks and only has
//	CPU, memory, and replica count (no persistent storage).
type GcpCloudComposerTriggererResourceInput struct {
	// CPU allocation per triggerer in vCPUs.
	Cpu float64 `json:"cpu,omitempty" jsonschema:"CPU allocation per triggerer in vCPUs."`
	// Memory allocation per triggerer in GB.
	MemoryGb float64 `json:"memory_gb,omitempty" jsonschema:"Memory allocation per triggerer in GB."`
	// Number of triggerer replicas. Set to 0 to disable the triggerer.
	Count int32 `json:"count,omitempty" jsonschema:"Number of triggerer replicas. Set to 0 to disable the triggerer."`
}

func (s *GcpCloudComposerTriggererResourceInput) validate() error {
	return nil
}

func (s *GcpCloudComposerTriggererResourceInput) applyDefaults() {
}

func (s *GcpCloudComposerTriggererResourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Cpu != 0 {
		m["cpu"] = s.Cpu
	}
	if s.MemoryGb != 0 {
		m["memory_gb"] = s.MemoryGb
	}
	if s.Count != 0 {
		m["count"] = s.Count
	}
	return m
}

// GcpCloudComposerWebServerAccessControl defines IP-based access restrictions
//
//	for the Airflow web server UI.
type GcpCloudComposerWebServerAccessControlInput struct {
	// Allowed IP ranges that can access the Airflow web server.
	AllowedIpRanges []*GcpCloudComposerAllowedIpRangeInput `json:"allowed_ip_ranges,omitempty" jsonschema:"Allowed IP ranges that can access the Airflow web server."`
}

func (s *GcpCloudComposerWebServerAccessControlInput) validate() error {
	for i, v := range s.AllowedIpRanges {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("allowed_ip_ranges[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpCloudComposerWebServerAccessControlInput) applyDefaults() {
}

func (s *GcpCloudComposerWebServerAccessControlInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AllowedIpRanges) > 0 {
		items := make([]any, len(s.AllowedIpRanges))
		for i, v := range s.AllowedIpRanges {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["allowed_ip_ranges"] = items
	}
	return m
}

// GcpCloudComposerWebServerResource defines CPU, memory, and storage
//
//	allocation for the Airflow web server. The web server does not have a
//	configurable replica count (always 1).
type GcpCloudComposerWebServerResourceInput struct {
	// CPU allocation in vCPUs.
	Cpu float64 `json:"cpu,omitempty" jsonschema:"CPU allocation in vCPUs."`
	// Memory allocation in GB.
	MemoryGb float64 `json:"memory_gb,omitempty" jsonschema:"Memory allocation in GB."`
	// Storage allocation in GB.
	StorageGb float64 `json:"storage_gb,omitempty" jsonschema:"Storage allocation in GB."`
}

func (s *GcpCloudComposerWebServerResourceInput) validate() error {
	return nil
}

func (s *GcpCloudComposerWebServerResourceInput) applyDefaults() {
}

func (s *GcpCloudComposerWebServerResourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Cpu != 0 {
		m["cpu"] = s.Cpu
	}
	if s.MemoryGb != 0 {
		m["memory_gb"] = s.MemoryGb
	}
	if s.StorageGb != 0 {
		m["storage_gb"] = s.StorageGb
	}
	return m
}

// GcpCloudComposerWorkerResource defines resource allocation for Airflow workers
//
//	with autoscaling bounds.
type GcpCloudComposerWorkerResourceInput struct {
	// CPU allocation per worker in vCPUs.
	Cpu float64 `json:"cpu,omitempty" jsonschema:"CPU allocation per worker in vCPUs."`
	// Memory allocation per worker in GB.
	MemoryGb float64 `json:"memory_gb,omitempty" jsonschema:"Memory allocation per worker in GB."`
	// Storage allocation per worker in GB.
	StorageGb float64 `json:"storage_gb,omitempty" jsonschema:"Storage allocation per worker in GB."`
	// Minimum number of workers. Must be >= 0.
	MinCount int32 `json:"min_count,omitempty" jsonschema:"Minimum number of workers. Must be >= 0."`
	// Maximum number of workers. Must be >= min_count.
	MaxCount int32 `json:"max_count,omitempty" jsonschema:"Maximum number of workers. Must be >= min_count."`
}

func (s *GcpCloudComposerWorkerResourceInput) validate() error {
	return nil
}

func (s *GcpCloudComposerWorkerResourceInput) applyDefaults() {
}

func (s *GcpCloudComposerWorkerResourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Cpu != 0 {
		m["cpu"] = s.Cpu
	}
	if s.MemoryGb != 0 {
		m["memory_gb"] = s.MemoryGb
	}
	if s.StorageGb != 0 {
		m["storage_gb"] = s.StorageGb
	}
	if s.MinCount != 0 {
		m["min_count"] = s.MinCount
	}
	if s.MaxCount != 0 {
		m["max_count"] = s.MaxCount
	}
	return m
}

// GcpCloudComposerWorkloadResource defines CPU, memory, and storage allocation
//
//	for a standard Airflow workload component with an optional replica count.
type GcpCloudComposerWorkloadResourceInput struct {
	// CPU allocation in vCPUs (e.g., 0.5, 1.0, 2.0).
	Cpu float64 `json:"cpu,omitempty" jsonschema:"CPU allocation in vCPUs (e.g.; 0.5; 1.0; 2.0)."`
	// Memory allocation in GB (e.g., 1.0, 2.0, 4.0).
	MemoryGb float64 `json:"memory_gb,omitempty" jsonschema:"Memory allocation in GB (e.g.; 1.0; 2.0; 4.0)."`
	// Storage allocation in GB (e.g., 1.0, 5.0, 10.0).
	StorageGb float64 `json:"storage_gb,omitempty" jsonschema:"Storage allocation in GB (e.g.; 1.0; 5.0; 10.0)."`
	// Number of replicas for this component.
	Count int32 `json:"count,omitempty" jsonschema:"Number of replicas for this component."`
}

func (s *GcpCloudComposerWorkloadResourceInput) validate() error {
	return nil
}

func (s *GcpCloudComposerWorkloadResourceInput) applyDefaults() {
}

func (s *GcpCloudComposerWorkloadResourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Cpu != 0 {
		m["cpu"] = s.Cpu
	}
	if s.MemoryGb != 0 {
		m["memory_gb"] = s.MemoryGb
	}
	if s.StorageGb != 0 {
		m["storage_gb"] = s.StorageGb
	}
	if s.Count != 0 {
		m["count"] = s.Count
	}
	return m
}

// GcpCloudComposerWorkloadsConfig defines resource allocation for individual
//
//	Airflow components. Each component runs as a separate workload in the
//	underlying GKE cluster.
type GcpCloudComposerWorkloadsConfigInput struct {
	// Resource allocation for the Airflow scheduler.
	//  The scheduler parses DAGs, manages task scheduling, and triggers task instances.
	Scheduler *GcpCloudComposerWorkloadResourceInput `json:"scheduler,omitempty" jsonschema:"Resource allocation for the Airflow scheduler. The scheduler parses DAGs; manages task scheduling; and triggers task instances."`
	// Resource allocation for the Airflow web server (UI).
	WebServer *GcpCloudComposerWebServerResourceInput `json:"web_server,omitempty" jsonschema:"Resource allocation for the Airflow web server (UI)."`
	// Resource allocation for Airflow workers.
	//  Workers execute the actual tasks defined in DAGs.
	Worker *GcpCloudComposerWorkerResourceInput `json:"worker,omitempty" jsonschema:"Resource allocation for Airflow workers. Workers execute the actual tasks defined in DAGs."`
	// Resource allocation for the Airflow triggerer.
	//  The triggerer monitors deferred tasks and resumes them when conditions are met.
	//  Critical for deferrable operators in Airflow 2.x+.
	Triggerer *GcpCloudComposerTriggererResourceInput `json:"triggerer,omitempty" jsonschema:"Resource allocation for the Airflow triggerer. The triggerer monitors deferred tasks and resumes them when conditions are met. Critical for deferrable operators in Airflow 2.x+."`
	// Resource allocation for the DAG processor.
	//  The DAG processor parses DAG files independently of the scheduler.
	//  Only applicable to Composer 3.
	DagProcessor *GcpCloudComposerWorkloadResourceInput `json:"dag_processor,omitempty" jsonschema:"Resource allocation for the DAG processor. The DAG processor parses DAG files independently of the scheduler. Only applicable to Composer 3."`
}

func (s *GcpCloudComposerWorkloadsConfigInput) validate() error {
	if s.Scheduler != nil {
		if err := s.Scheduler.validate(); err != nil {
			return fmt.Errorf("scheduler: %w", err)
		}
	}
	if s.WebServer != nil {
		if err := s.WebServer.validate(); err != nil {
			return fmt.Errorf("web_server: %w", err)
		}
	}
	if s.Worker != nil {
		if err := s.Worker.validate(); err != nil {
			return fmt.Errorf("worker: %w", err)
		}
	}
	if s.Triggerer != nil {
		if err := s.Triggerer.validate(); err != nil {
			return fmt.Errorf("triggerer: %w", err)
		}
	}
	if s.DagProcessor != nil {
		if err := s.DagProcessor.validate(); err != nil {
			return fmt.Errorf("dag_processor: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudComposerWorkloadsConfigInput) applyDefaults() {
	if s.Scheduler != nil {
		s.Scheduler.applyDefaults()
	}
	if s.WebServer != nil {
		s.WebServer.applyDefaults()
	}
	if s.Worker != nil {
		s.Worker.applyDefaults()
	}
	if s.Triggerer != nil {
		s.Triggerer.applyDefaults()
	}
	if s.DagProcessor != nil {
		s.DagProcessor.applyDefaults()
	}
}

func (s *GcpCloudComposerWorkloadsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Scheduler != nil {
		m["scheduler"] = s.Scheduler.toMap()
	}
	if s.WebServer != nil {
		m["web_server"] = s.WebServer.toMap()
	}
	if s.Worker != nil {
		m["worker"] = s.Worker.toMap()
	}
	if s.Triggerer != nil {
		m["triggerer"] = s.Triggerer.toMap()
	}
	if s.DagProcessor != nil {
		m["dag_processor"] = s.DagProcessor.toMap()
	}
	return m
}

// ParseGcpCloudComposerEnvironment validates and normalizes a GcpCloudComposerEnvironment cloud_object.
func ParseGcpCloudComposerEnvironment(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudComposerEnvironment"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudComposerEnvironmentSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
