// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-redis-instance
type GcpRedisInstanceSpecInput struct {
	// GCP project where the Redis instance will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the Redis instance will be created."`
	// Name of the Redis instance. This becomes the GCP resource name.
	//  Must start with a lowercase letter, contain only lowercase letters, numbers,
	//  and hyphens, and end with a lowercase letter or number. Maximum 40 characters.
	//  Immutable after creation.
	InstanceName string `json:"instance_name" jsonschema:"required,Name of the Redis instance. This becomes the GCP resource name. Must start with a lowercase letter; contain only lowercase letters; numbers; and hyphens; and end with a lowercase letter or number. Max..."`
	// GCP region where the instance will be deployed (e.g., "us-central1").
	Region string `json:"region" jsonschema:"required,GCP region where the instance will be deployed (e.g.; 'us-central1')."`
	// Service tier controlling availability and replication.
	//  BASIC: standalone instance, no replication, no SLA.
	//  STANDARD_HA: primary + replica with automatic failover, 99.9% SLA.
	Tier string `json:"tier" jsonschema:"required,Service tier controlling availability and replication. BASIC: standalone instance; no replication; no SLA. STANDARD_HA: primary + replica with automatic failover; 99.9% SLA."`
	// Memory size in GiB for the Redis instance. This is the total memory
	//  available for storing data. Minimum 1 GiB.
	MemorySizeGb int32 `json:"memory_size_gb" jsonschema:"required,Memory size in GiB for the Redis instance. This is the total memory available for storing data. Minimum 1 GiB."`
	// Redis engine version (e.g., "REDIS_7_0", "REDIS_7_2", "REDIS_6_X").
	//  If not specified, the latest supported version is used.
	RedisVersion string `json:"redis_version,omitempty" jsonschema:"Redis engine version (e.g.; 'REDIS_7_0'; 'REDIS_7_2'; 'REDIS_6_X'). If not specified; the latest supported version is used."`
	// Human-readable display name for the instance.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable display name for the instance."`
	// Zone within the region where the instance will be placed.
	//  For STANDARD_HA, this is the primary zone. GCP automatically selects
	//  a different zone for the replica. If not specified, GCP picks a zone.
	LocationId string `json:"location_id,omitempty" jsonschema:"Zone within the region where the instance will be placed. For STANDARD_HA; this is the primary zone. GCP automatically selects a different zone for the replica. If not specified; GCP picks a zone."`
	// VPC network to which the instance is connected.
	//  If not specified, the default network is used.
	//  Immutable after creation.
	AuthorizedNetwork string `json:"authorized_network,omitempty" jsonschema:"VPC network to which the instance is connected. If not specified; the default network is used. Immutable after creation."`
	// How the instance connects to the VPC network.
	//  DIRECT_PEERING: VPC peering (default). Simpler setup.
	//  PRIVATE_SERVICE_ACCESS: uses a private services connection. Required for
	//  Shared VPC and some network configurations.
	//  Immutable after creation.
	ConnectMode string `json:"connect_mode,omitempty" jsonschema:"How the instance connects to the VPC network. DIRECT_PEERING: VPC peering (default). Simpler setup. PRIVATE_SERVICE_ACCESS: uses a private services connection. Required for Shared VPC and some network..."`
	// CIDR range of internal addresses reserved for this instance (e.g., "10.0.0.0/29").
	//  Must be a /29 block, unique and non-overlapping with existing subnets.
	//  If not specified, GCP automatically selects an unused /29 block.
	//  Immutable after creation.
	ReservedIpRange string `json:"reserved_ip_range,omitempty" jsonschema:"CIDR range of internal addresses reserved for this instance (e.g.; '10.0.0.0/29'). Must be a /29 block; unique and non-overlapping with existing subnets. If not specified; GCP automatically selects an..."`
	// Whether Redis AUTH is enabled. When true, clients must provide
	//  the AUTH string (exported in stack outputs) to connect.
	//  AUTH provides an additional layer of security beyond network controls.
	AuthEnabled bool `json:"auth_enabled,omitempty" jsonschema:"Whether Redis AUTH is enabled. When true; clients must provide the AUTH string (exported in stack outputs) to connect. AUTH provides an additional layer of security beyond network controls."`
	// TLS encryption mode for client-to-server traffic.
	//  DISABLED: no encryption (default).
	//  SERVER_AUTHENTICATION: clients verify the server's identity via TLS.
	//  Immutable after creation.
	TransitEncryptionMode string `json:"transit_encryption_mode,omitempty" jsonschema:"TLS encryption mode for client-to-server traffic. DISABLED: no encryption (default). SERVER_AUTHENTICATION: clients verify the server's identity via TLS. Immutable after creation."`
	// Redis configuration parameters as key-value pairs.
	//  See https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs
	//  for the list of supported parameters (e.g., "maxmemory-policy", "notify-keyspace-events").
	RedisConfigs map[string]string `json:"redis_configs,omitempty" jsonschema:"Redis configuration parameters as key-value pairs. See https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs for the list of supp..."`
	// Weekly maintenance window. If not specified, GCP schedules maintenance
	//  at its discretion.
	MaintenanceWindow *GcpRedisInstanceMaintenanceWindowInput `json:"maintenance_window,omitempty" jsonschema:"Weekly maintenance window. If not specified; GCP schedules maintenance at its discretion."`
	// Read replica mode. Can only be set at creation time.
	//  READ_REPLICAS_DISABLED (default): no read endpoint, no scaling.
	//  READ_REPLICAS_ENABLED: read endpoint provided, instance can scale replicas.
	//  Only available with STANDARD_HA tier.
	ReadReplicasMode string `json:"read_replicas_mode,omitempty" jsonschema:"Read replica mode. Can only be set at creation time. READ_REPLICAS_DISABLED (default): no read endpoint; no scaling. READ_REPLICAS_ENABLED: read endpoint provided; instance can scale replicas. Only av..."`
	// Number of read replicas. Valid range is 1-5 when read_replicas_mode is
	//  READ_REPLICAS_ENABLED and tier is STANDARD_HA.
	ReplicaCount int32 `json:"replica_count,omitempty" jsonschema:"Number of read replicas. Valid range is 1-5 when read_replicas_mode is READ_REPLICAS_ENABLED and tier is STANDARD_HA."`
	// Persistence configuration for RDB snapshots.
	PersistenceConfig *GcpRedisInstancePersistenceConfigInput `json:"persistence_config,omitempty" jsonschema:"Persistence configuration for RDB snapshots."`
	// Cloud KMS key for customer-managed encryption at rest (CMEK).
	//  Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
	//  If not specified, data is encrypted with Google-managed keys.
	//  Immutable after creation.
	CustomerManagedKey string `json:"customer_managed_key,omitempty" jsonschema:"Cloud KMS key for customer-managed encryption at rest (CMEK). Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key} If not specified; data is encrypted with Google-manage..."`
	// Whether Terraform/Pulumi deletion protection is enabled.
	//  When true, the instance cannot be destroyed without first disabling
	//  this flag. Recommended for production instances.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"Whether Terraform/Pulumi deletion protection is enabled. When true; the instance cannot be destroyed without first disabling this flag. Recommended for production instances."`
}

func (s *GcpRedisInstanceSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.InstanceName == "" {
		return fmt.Errorf("instance_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.Tier == "" {
		return fmt.Errorf("tier is required")
	}
	if s.MaintenanceWindow != nil {
		if err := s.MaintenanceWindow.validate(); err != nil {
			return fmt.Errorf("maintenance_window: %w", err)
		}
	}
	if s.PersistenceConfig != nil {
		if err := s.PersistenceConfig.validate(); err != nil {
			return fmt.Errorf("persistence_config: %w", err)
		}
	}
	return nil
}

func (s *GcpRedisInstanceSpecInput) applyDefaults() {
	if s.MaintenanceWindow != nil {
		s.MaintenanceWindow.applyDefaults()
	}
	if s.PersistenceConfig != nil {
		s.PersistenceConfig.applyDefaults()
	}
}

func (s *GcpRedisInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["instance_name"] = s.InstanceName
	m["region"] = s.Region
	m["tier"] = s.Tier
	m["memory_size_gb"] = s.MemorySizeGb
	if s.RedisVersion != "" {
		m["redis_version"] = s.RedisVersion
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.LocationId != "" {
		m["location_id"] = s.LocationId
	}
	if s.AuthorizedNetwork != "" {
		m["authorized_network"] = s.AuthorizedNetwork
	}
	if s.ConnectMode != "" {
		m["connect_mode"] = s.ConnectMode
	}
	if s.ReservedIpRange != "" {
		m["reserved_ip_range"] = s.ReservedIpRange
	}
	if s.AuthEnabled {
		m["auth_enabled"] = s.AuthEnabled
	}
	if s.TransitEncryptionMode != "" {
		m["transit_encryption_mode"] = s.TransitEncryptionMode
	}
	if len(s.RedisConfigs) > 0 {
		m["redis_configs"] = s.RedisConfigs
	}
	if s.MaintenanceWindow != nil {
		m["maintenance_window"] = s.MaintenanceWindow.toMap()
	}
	if s.ReadReplicasMode != "" {
		m["read_replicas_mode"] = s.ReadReplicasMode
	}
	if s.ReplicaCount != 0 {
		m["replica_count"] = s.ReplicaCount
	}
	if s.PersistenceConfig != nil {
		m["persistence_config"] = s.PersistenceConfig.toMap()
	}
	if s.CustomerManagedKey != "" {
		m["customer_managed_key"] = s.CustomerManagedKey
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	return m
}

// GcpRedisInstanceMaintenanceWindow defines a weekly maintenance window for
//
//	the Redis instance. GCP uses this to schedule updates and patches.
//	The maintenance window is fixed at 1 hour duration.
type GcpRedisInstanceMaintenanceWindowInput struct {
	// Day of the week for the maintenance window.
	Day string `json:"day" jsonschema:"required,Day of the week for the maintenance window."`
	// Hour of day (0-23, UTC) when the maintenance window starts.
	Hour int32 `json:"hour,omitempty" jsonschema:"Hour of day (0-23; UTC) when the maintenance window starts."`
}

func (s *GcpRedisInstanceMaintenanceWindowInput) validate() error {
	if s.Day == "" {
		return fmt.Errorf("day is required")
	}
	return nil
}

func (s *GcpRedisInstanceMaintenanceWindowInput) applyDefaults() {
}

func (s *GcpRedisInstanceMaintenanceWindowInput) toMap() map[string]any {
	m := make(map[string]any)
	m["day"] = s.Day
	if s.Hour != 0 {
		m["hour"] = s.Hour
	}
	return m
}

// GcpRedisInstancePersistenceConfig controls RDB snapshot persistence for
//
//	the Redis instance. When enabled, data is periodically written to disk,
//	providing durability across restarts and failovers.
//
//	Persistence is only meaningful for STANDARD_HA tier instances.
type GcpRedisInstancePersistenceConfigInput struct {
	// Persistence mode. DISABLED turns off persistence entirely.
	//  RDB enables periodic RDB snapshots.
	PersistenceMode string `json:"persistence_mode" jsonschema:"required,Persistence mode. DISABLED turns off persistence entirely. RDB enables periodic RDB snapshots."`
	// How often RDB snapshots are taken. Required when persistence_mode is RDB.
	RdbSnapshotPeriod string `json:"rdb_snapshot_period,omitempty" jsonschema:"How often RDB snapshots are taken. Required when persistence_mode is RDB."`
}

func (s *GcpRedisInstancePersistenceConfigInput) validate() error {
	if s.PersistenceMode == "" {
		return fmt.Errorf("persistence_mode is required")
	}
	return nil
}

func (s *GcpRedisInstancePersistenceConfigInput) applyDefaults() {
}

func (s *GcpRedisInstancePersistenceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["persistence_mode"] = s.PersistenceMode
	if s.RdbSnapshotPeriod != "" {
		m["rdb_snapshot_period"] = s.RdbSnapshotPeriod
	}
	return m
}

// ParseGcpRedisInstance validates and normalizes a GcpRedisInstance cloud_object.
func ParseGcpRedisInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpRedisInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpRedisInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
