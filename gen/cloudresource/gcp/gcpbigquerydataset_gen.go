// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-bigquery-dataset
type GcpBigQueryDatasetSpecInput struct {
	// GCP project where the dataset will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the dataset will be created."`
	// Unique identifier for the dataset within the project.
	//  Must contain only letters (upper/lower), numbers, and underscores.
	//  Maximum 1024 characters. Immutable after creation.
	//  Example: "analytics_prod", "raw_events_2024"
	DatasetId string `json:"dataset_id" jsonschema:"required,Unique identifier for the dataset within the project. Must contain only letters (upper/lower); numbers; and underscores. Maximum 1024 characters. Immutable after creation. Example: 'analytics_prod'; '..."`
	// Geographic location where the dataset and its tables reside.
	//  Use multi-regional locations (e.g., "US", "EU") for maximum availability,
	//  or regional locations (e.g., "us-central1", "europe-west1") for data
	//  residency requirements. Immutable after creation.
	Location string `json:"location" jsonschema:"required,Geographic location where the dataset and its tables reside. Use multi-regional locations (e.g.; 'US'; 'EU') for maximum availability; or regional locations (e.g.; 'us-central1'; 'europe-west1') for d..."`
	// User-friendly display name for the dataset.
	FriendlyName string `json:"friendly_name,omitempty" jsonschema:"User-friendly display name for the dataset."`
	// Description of the dataset's contents or purpose.
	Description string `json:"description,omitempty" jsonschema:"Description of the dataset's contents or purpose."`
	// Default lifetime for all tables created in the dataset, in milliseconds.
	//  Tables created in this dataset will be automatically deleted after this
	//  duration from their creation time. Minimum: 3600000 (1 hour).
	//  If not set (0), tables do not automatically expire.
	DefaultTableExpirationMs int64 `json:"default_table_expiration_ms,omitempty" jsonschema:"Default lifetime for all tables created in the dataset; in milliseconds. Tables created in this dataset will be automatically deleted after this duration from their creation time. Minimum: 3600000 (1 ..."`
	// Default expiration for partitions in partitioned tables, in milliseconds.
	//  Applies to all partitioned tables created in this dataset.
	//  If not set (0), partitions do not automatically expire.
	DefaultPartitionExpirationMs int64 `json:"default_partition_expiration_ms,omitempty" jsonschema:"Default expiration for partitions in partitioned tables; in milliseconds. Applies to all partitioned tables created in this dataset. If not set (0); partitions do not automatically expire."`
	// Maximum hours of time travel for the dataset (point-in-time snapshots).
	//  Range: 48 to 168 hours (2 to 7 days). Default: 168 (7 days) if not set.
	//  Lower values reduce storage costs; higher values provide longer recovery windows.
	MaxTimeTravelHours int32 `json:"max_time_travel_hours,omitempty" jsonschema:"Maximum hours of time travel for the dataset (point-in-time snapshots). Range: 48 to 168 hours (2 to 7 days). Default: 168 (7 days) if not set. Lower values reduce storage costs; higher values provide..."`
	// Whether dataset and table names are treated as case-insensitive.
	//  When true, "MyTable" and "mytable" refer to the same table.
	//  Immutable after creation. Default: false (case-sensitive).
	IsCaseInsensitive bool `json:"is_case_insensitive,omitempty" jsonschema:"Whether dataset and table names are treated as case-insensitive. When true; 'MyTable' and 'mytable' refer to the same table. Immutable after creation. Default: false (case-sensitive)."`
	// Default collation specification for string columns in new tables.
	//  Use "und:ci" for case-insensitive collation, or leave empty for
	//  case-sensitive (default) collation.
	DefaultCollation string `json:"default_collation,omitempty" jsonschema:"Default collation specification for string columns in new tables. Use 'und:ci' for case-insensitive collation; or leave empty for case-sensitive (default) collation."`
	// Storage billing model for the dataset.
	//  "LOGICAL" (default) charges based on logical (uncompressed) bytes.
	//  "PHYSICAL" charges based on physical (compressed) bytes on disk,
	//  which can reduce costs 60-80% for highly compressible data.
	StorageBillingModel string `json:"storage_billing_model,omitempty" jsonschema:"Storage billing model for the dataset. 'LOGICAL' (default) charges based on logical (uncompressed) bytes. 'PHYSICAL' charges based on physical (compressed) bytes on disk; which can reduce costs 60-80%..."`
	// If true, all tables in the dataset are deleted when the dataset is
	//  destroyed. If false (default), destroy fails when the dataset contains
	//  tables, preventing accidental data loss.
	DeleteContentsOnDestroy bool `json:"delete_contents_on_destroy,omitempty" jsonschema:"If true; all tables in the dataset are deleted when the dataset is destroyed. If false (default); destroy fails when the dataset contains tables; preventing accidental data loss."`
	// Cloud KMS encryption key for default table encryption (CMEK).
	//  All new tables in the dataset will be encrypted with this key unless
	//  they specify their own encryption configuration.
	//  Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
	//  If not set, tables are encrypted...
	KmsKeyName string `json:"kms_key_name,omitempty" jsonschema:"Cloud KMS encryption key for default table encryption (CMEK). All new tables in the dataset will be encrypted with this key unless they specify their own encryption configuration. Format: projects/{pr..."`
	// Access control entries for the dataset.
	//
	//  This field is authoritative: BigQuery will remove any access entries
	//  not listed here. If omitted entirely, BigQuery applies default access:
	//    - Project owners: OWNER
	//    - Project editors: WRITER
	//    - Project viewers: READER
	//
	//  Each entry grants a role to on...
	Access []*GcpBigQueryDatasetAccessEntryInput `json:"access,omitempty" jsonschema:"Access control entries for the dataset. This field is authoritative: BigQuery will remove any access entries not listed here. If omitted entirely; BigQuery applies default access: - Project owners: OW..."`
}

func (s *GcpBigQueryDatasetSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.DatasetId == "" {
		return fmt.Errorf("dataset_id is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	for i, v := range s.Access {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("access[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpBigQueryDatasetSpecInput) applyDefaults() {
}

func (s *GcpBigQueryDatasetSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["dataset_id"] = s.DatasetId
	m["location"] = s.Location
	if s.FriendlyName != "" {
		m["friendly_name"] = s.FriendlyName
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.DefaultTableExpirationMs != 0 {
		m["default_table_expiration_ms"] = s.DefaultTableExpirationMs
	}
	if s.DefaultPartitionExpirationMs != 0 {
		m["default_partition_expiration_ms"] = s.DefaultPartitionExpirationMs
	}
	if s.MaxTimeTravelHours != 0 {
		m["max_time_travel_hours"] = s.MaxTimeTravelHours
	}
	if s.IsCaseInsensitive {
		m["is_case_insensitive"] = s.IsCaseInsensitive
	}
	if s.DefaultCollation != "" {
		m["default_collation"] = s.DefaultCollation
	}
	if s.StorageBillingModel != "" {
		m["storage_billing_model"] = s.StorageBillingModel
	}
	if s.DeleteContentsOnDestroy {
		m["delete_contents_on_destroy"] = s.DeleteContentsOnDestroy
	}
	if s.KmsKeyName != "" {
		m["kms_key_name"] = s.KmsKeyName
	}
	if len(s.Access) > 0 {
		items := make([]any, len(s.Access))
		for i, v := range s.Access {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["access"] = items
	}
	return m
}

// GcpBigQueryDatasetAccessEntry defines a single access control entry for
//
//	the dataset. Each entry grants a role to exactly one identity, or grants
//	a view direct access to the dataset's data.
//
//	Exactly one identity field must be set: user_by_email, group_by_email,
//	domain, special_group, iam_member, or view.
//
//	When view is set, role should be omitted (BigQuery grants the view
//	implicit read access to the underlying data).
type GcpBigQueryDatasetAccessEntryInput struct {
	// The IAM role to grant. Use basic roles (OWNER, WRITER, READER) or
	//  predefined roles (roles/bigquery.dataOwner, roles/bigquery.dataEditor,
	//  roles/bigquery.dataViewer, etc.).
	//
	//  Required unless view is set.
	Role string `json:"role,omitempty" jsonschema:"The IAM role to grant. Use basic roles (OWNER; WRITER; READER) or predefined roles (roles/bigquery.dataOwner; roles/bigquery.dataEditor; roles/bigquery.dataViewer; etc.). Required unless view is set."`
	// An email address of a Google Account to grant access to.
	UserByEmail string `json:"user_by_email,omitempty" jsonschema:"An email address of a Google Account to grant access to."`
	// An email address of a Google Group to grant access to.
	GroupByEmail string `json:"group_by_email,omitempty" jsonschema:"An email address of a Google Group to grant access to."`
	// A domain to grant access to. All users signed in with the domain's
	//  account will be granted access (e.g., "example.com").
	Domain string `json:"domain,omitempty" jsonschema:"A domain to grant access to. All users signed in with the domain's account will be granted access (e.g.; 'example.com')."`
	// A special group to grant access to. Valid values:
	//    "projectOwners"  -- all project owners
	//    "projectReaders" -- all project viewers
	//    "projectWriters" -- all project editors
	//    "allAuthenticatedUsers" -- all authenticated Google accounts
	SpecialGroup string `json:"special_group,omitempty" jsonschema:"A special group to grant access to. Valid values: 'projectOwners' -- all project owners 'projectReaders' -- all project viewers 'projectWriters' -- all project editors 'allAuthenticatedUsers' -- all a..."`
	// An IAM member expression to grant access to.
	//  Examples: "allUsers", "serviceAccount:sa@project.iam.gserviceaccount.com"
	IamMember string `json:"iam_member,omitempty" jsonschema:"An IAM member expression to grant access to. Examples: 'allUsers'; 'serviceAccount:sa@project.iam.gserviceaccount.com'"`
	// A view that is granted access to the dataset's data.
	//  When set, role is typically omitted.
	View *GcpBigQueryDatasetAccessViewInput `json:"view,omitempty" jsonschema:"A view that is granted access to the dataset's data. When set; role is typically omitted."`
}

func (s *GcpBigQueryDatasetAccessEntryInput) validate() error {
	if s.View != nil {
		if err := s.View.validate(); err != nil {
			return fmt.Errorf("view: %w", err)
		}
	}
	return nil
}

func (s *GcpBigQueryDatasetAccessEntryInput) applyDefaults() {
	if s.View != nil {
		s.View.applyDefaults()
	}
}

func (s *GcpBigQueryDatasetAccessEntryInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Role != "" {
		m["role"] = s.Role
	}
	if s.UserByEmail != "" {
		m["user_by_email"] = s.UserByEmail
	}
	if s.GroupByEmail != "" {
		m["group_by_email"] = s.GroupByEmail
	}
	if s.Domain != "" {
		m["domain"] = s.Domain
	}
	if s.SpecialGroup != "" {
		m["special_group"] = s.SpecialGroup
	}
	if s.IamMember != "" {
		m["iam_member"] = s.IamMember
	}
	if s.View != nil {
		m["view"] = s.View.toMap()
	}
	return m
}

// GcpBigQueryDatasetAccessView identifies a BigQuery view that is granted
//
//	access to the dataset's data without needing a role assignment.
type GcpBigQueryDatasetAccessViewInput struct {
	// The GCP project that contains the view's dataset.
	ProjectId string `json:"project_id" jsonschema:"required,The GCP project that contains the view's dataset."`
	// The dataset that contains the view.
	DatasetId string `json:"dataset_id" jsonschema:"required,The dataset that contains the view."`
	// The ID of the authorized view (table resource).
	TableId string `json:"table_id" jsonschema:"required,The ID of the authorized view (table resource)."`
}

func (s *GcpBigQueryDatasetAccessViewInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.DatasetId == "" {
		return fmt.Errorf("dataset_id is required")
	}
	if s.TableId == "" {
		return fmt.Errorf("table_id is required")
	}
	return nil
}

func (s *GcpBigQueryDatasetAccessViewInput) applyDefaults() {
}

func (s *GcpBigQueryDatasetAccessViewInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["dataset_id"] = s.DatasetId
	m["table_id"] = s.TableId
	return m
}

// ParseGcpBigQueryDataset validates and normalizes a GcpBigQueryDataset cloud_object.
func ParseGcpBigQueryDataset(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpBigQueryDataset"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpBigQueryDatasetSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
