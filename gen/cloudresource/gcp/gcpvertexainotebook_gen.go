// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-vertex-ai-notebook
type GcpVertexAiNotebookSpecInput struct {
	// GCP project where the notebook instance will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the notebook instance will be created."`
	// GCP zone where the notebook instance will be created (e.g., "us-central1-a").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,GCP zone where the notebook instance will be created (e.g.; 'us-central1-a'). Immutable after creation."`
	// Compute Engine machine type for the instance.
	//  Examples: "e2-standard-4", "n1-standard-8", "a2-highgpu-1g".
	//  Choose based on workload requirements -- CPU-only for data processing,
	//  N1/A2 for GPU-accelerated ML training.
	MachineType string `json:"machine_type" jsonschema:"required,Compute Engine machine type for the instance. Examples: 'e2-standard-4'; 'n1-standard-8'; 'a2-highgpu-1g'. Choose based on workload requirements -- CPU-only for data processing; N1/A2 for GPU-accelera..."`
	// Name of the Workbench instance in GCP.
	//  If not specified, defaults to metadata.name.
	//  Immutable after creation. Must be a valid RFC1035 hostname.
	InstanceName string `json:"instance_name,omitempty" jsonschema:"Name of the Workbench instance in GCP. If not specified; defaults to metadata.name. Immutable after creation. Must be a valid RFC1035 hostname."`
	// Email addresses of users who own the instance.
	//  Format: alias@example.com. Currently GCP supports one owner only.
	//  If set, access mode is Single User (only this owner can access).
	//  Immutable after creation.
	InstanceOwners []string `json:"instance_owners,omitempty" jsonschema:"Email addresses of users who own the instance. Format: alias@example.com. Currently GCP supports one owner only. If set; access mode is Single User (only this owner can access). Immutable after creati..."`
	// Desired state of the instance: ACTIVE (running) or STOPPED.
	//  Use STOPPED to suspend the instance and stop billing for compute
	//  (storage charges still apply). Defaults to ACTIVE.
	DesiredState string `json:"desired_state,omitempty" jsonschema:"Desired state of the instance: ACTIVE (running) or STOPPED. Use STOPPED to suspend the instance and stop billing for compute (storage charges still apply). Defaults to ACTIVE."`
	// If true, the notebook instance will not register with the proxy
	//  and no JupyterLab proxy URL will be generated. Use this for
	//  instances accessed only via SSH or other direct methods.
	//  Immutable after creation.
	DisableProxyAccess bool `json:"disable_proxy_access,omitempty" jsonschema:"If true; the notebook instance will not register with the proxy and no JupyterLab proxy URL will be generated. Use this for instances accessed only via SSH or other direct methods. Immutable after cre..."`
	// Custom metadata key-value pairs for the instance.
	//  Some keys trigger special behaviors (e.g., install-monitoring-agent).
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"Custom metadata key-value pairs for the instance. Some keys trigger special behaviors (e.g.; install-monitoring-agent)."`
	// Boot disk configuration for the notebook instance.
	//  If not specified, GCP provisions a 150 GB PD_SSD boot disk with
	//  Google-managed encryption.
	BootDisk *GcpVertexAiNotebookBootDiskInput `json:"boot_disk,omitempty" jsonschema:"Boot disk configuration for the notebook instance. If not specified; GCP provisions a 150 GB PD_SSD boot disk with Google-managed encryption."`
	// Data disk configuration for the notebook instance.
	//  GCP supports exactly one data disk per Workbench instance.
	//  If not specified, GCP provisions a 100 GB data disk with
	//  Google-managed encryption.
	DataDisk *GcpVertexAiNotebookDataDiskInput `json:"data_disk,omitempty" jsonschema:"Data disk configuration for the notebook instance. GCP supports exactly one data disk per Workbench instance. If not specified; GCP provisions a 100 GB data disk with Google-managed encryption."`
	// GPU accelerator configuration for the notebook instance.
	//  GCP supports one accelerator configuration per instance.
	//  Requires compatible machine types (e.g., n1-standard-* for Tesla GPUs).
	AcceleratorConfig *GcpVertexAiNotebookAcceleratorConfigInput `json:"accelerator_config,omitempty" jsonschema:"GPU accelerator configuration for the notebook instance. GCP supports one accelerator configuration per instance. Requires compatible machine types (e.g.; n1-standard-* for Tesla GPUs)."`
	// Network interface configuration for the notebook instance.
	//  GCP supports one network interface per instance.
	//  If not specified, the instance uses the default VPC network.
	//  Immutable after creation.
	NetworkInterface *GcpVertexAiNotebookNetworkInterfaceInput `json:"network_interface,omitempty" jsonschema:"Network interface configuration for the notebook instance. GCP supports one network interface per instance. If not specified; the instance uses the default VPC network. Immutable after creation."`
	// If true, no external IP is assigned to the instance.
	//  Use this for instances that should only be accessible through
	//  the Vertex AI proxy or a VPN/Cloud IAP tunnel.
	//  Immutable after creation.
	DisablePublicIp bool `json:"disable_public_ip,omitempty" jsonschema:"If true; no external IP is assigned to the instance. Use this for instances that should only be accessible through the Vertex AI proxy or a VPN/Cloud IAP tunnel. Immutable after creation."`
	// If true, enable IP forwarding on the instance. Useful for
	//  instances acting as network gateways. Default false.
	//  Immutable after creation.
	EnableIpForwarding bool `json:"enable_ip_forwarding,omitempty" jsonschema:"If true; enable IP forwarding on the instance. Useful for instances acting as network gateways. Default false. Immutable after creation."`
	// Service account email for the notebook VM identity.
	//  The VM uses this service account to access GCP resources
	//  (BigQuery, GCS, Vertex AI, etc.). Scopes are fixed to
	//  "https://www.googleapis.com/auth/cloud-platform".
	//  Immutable after creation.
	ServiceAccount string `json:"service_account,omitempty" jsonschema:"Service account email for the notebook VM identity. The VM uses this service account to access GCP resources (BigQuery; GCS; Vertex AI; etc.). Scopes are fixed to 'https://www.googleapis.com/auth/clou..."`
	// Compute Engine network tags for firewall rules.
	//  Immutable after creation.
	Tags []string `json:"tags,omitempty" jsonschema:"Compute Engine network tags for firewall rules. Immutable after creation."`
	// VM image configuration for the notebook environment.
	//  Uses pre-built deep learning VM images from GCP with popular
	//  ML frameworks (TensorFlow, PyTorch, JAX) and JupyterLab.
	//  Mutually exclusive with container_image.
	//  Immutable after creation.
	VmImage *GcpVertexAiNotebookVmImageInput `json:"vm_image,omitempty" jsonschema:"VM image configuration for the notebook environment. Uses pre-built deep learning VM images from GCP with popular ML frameworks (TensorFlow; PyTorch; JAX) and JupyterLab. Mutually exclusive with conta..."`
	// Container image configuration for a custom notebook environment.
	//  Use this when pre-built VM images don't meet your needs.
	//  Mutually exclusive with vm_image.
	ContainerImage *GcpVertexAiNotebookContainerImageInput `json:"container_image,omitempty" jsonschema:"Container image configuration for a custom notebook environment. Use this when pre-built VM images don't meet your needs. Mutually exclusive with vm_image."`
	// Shielded VM configuration for enhanced security.
	//  Shielded VMs protect against rootkits and bootkits with
	//  Secure Boot, vTPM, and integrity monitoring.
	ShieldedInstanceConfig *GcpVertexAiNotebookShieldedInstanceConfigInput `json:"shielded_instance_config,omitempty" jsonschema:"Shielded VM configuration for enhanced security. Shielded VMs protect against rootkits and bootkits with Secure Boot; vTPM; and integrity monitoring."`
}

func (s *GcpVertexAiNotebookSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.MachineType == "" {
		return fmt.Errorf("machine_type is required")
	}
	if s.BootDisk != nil {
		if err := s.BootDisk.validate(); err != nil {
			return fmt.Errorf("boot_disk: %w", err)
		}
	}
	if s.DataDisk != nil {
		if err := s.DataDisk.validate(); err != nil {
			return fmt.Errorf("data_disk: %w", err)
		}
	}
	if s.AcceleratorConfig != nil {
		if err := s.AcceleratorConfig.validate(); err != nil {
			return fmt.Errorf("accelerator_config: %w", err)
		}
	}
	if s.NetworkInterface != nil {
		if err := s.NetworkInterface.validate(); err != nil {
			return fmt.Errorf("network_interface: %w", err)
		}
	}
	if s.VmImage != nil {
		if err := s.VmImage.validate(); err != nil {
			return fmt.Errorf("vm_image: %w", err)
		}
	}
	if s.ContainerImage != nil {
		if err := s.ContainerImage.validate(); err != nil {
			return fmt.Errorf("container_image: %w", err)
		}
	}
	if s.ShieldedInstanceConfig != nil {
		if err := s.ShieldedInstanceConfig.validate(); err != nil {
			return fmt.Errorf("shielded_instance_config: %w", err)
		}
	}
	return nil
}

func (s *GcpVertexAiNotebookSpecInput) applyDefaults() {
	if s.BootDisk != nil {
		s.BootDisk.applyDefaults()
	}
	if s.DataDisk != nil {
		s.DataDisk.applyDefaults()
	}
	if s.AcceleratorConfig != nil {
		s.AcceleratorConfig.applyDefaults()
	}
	if s.NetworkInterface != nil {
		s.NetworkInterface.applyDefaults()
	}
	if s.VmImage != nil {
		s.VmImage.applyDefaults()
	}
	if s.ContainerImage != nil {
		s.ContainerImage.applyDefaults()
	}
	if s.ShieldedInstanceConfig != nil {
		s.ShieldedInstanceConfig.applyDefaults()
	}
}

func (s *GcpVertexAiNotebookSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["location"] = s.Location
	m["machine_type"] = s.MachineType
	if s.InstanceName != "" {
		m["instance_name"] = s.InstanceName
	}
	if len(s.InstanceOwners) > 0 {
		m["instance_owners"] = s.InstanceOwners
	}
	if s.DesiredState != "" {
		m["desired_state"] = s.DesiredState
	}
	if s.DisableProxyAccess {
		m["disable_proxy_access"] = s.DisableProxyAccess
	}
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if s.BootDisk != nil {
		m["boot_disk"] = s.BootDisk.toMap()
	}
	if s.DataDisk != nil {
		m["data_disk"] = s.DataDisk.toMap()
	}
	if s.AcceleratorConfig != nil {
		m["accelerator_config"] = s.AcceleratorConfig.toMap()
	}
	if s.NetworkInterface != nil {
		m["network_interface"] = s.NetworkInterface.toMap()
	}
	if s.DisablePublicIp {
		m["disable_public_ip"] = s.DisablePublicIp
	}
	if s.EnableIpForwarding {
		m["enable_ip_forwarding"] = s.EnableIpForwarding
	}
	if s.ServiceAccount != "" {
		m["service_account"] = s.ServiceAccount
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.VmImage != nil {
		m["vm_image"] = s.VmImage.toMap()
	}
	if s.ContainerImage != nil {
		m["container_image"] = s.ContainerImage.toMap()
	}
	if s.ShieldedInstanceConfig != nil {
		m["shielded_instance_config"] = s.ShieldedInstanceConfig.toMap()
	}
	return m
}

// GcpVertexAiNotebookAcceleratorConfig defines a GPU accelerator attached
//
//	to the notebook instance. GCP supports exactly one accelerator
//	configuration per Workbench instance.
type GcpVertexAiNotebookAcceleratorConfigInput struct {
	// GPU accelerator type.
	//  See https://cloud.google.com/vertex-ai/docs/workbench/instances/create#accelerator
	//  for supported types per zone.
	Type string `json:"type,omitempty" jsonschema:"GPU accelerator type. See https://cloud.google.com/vertex-ai/docs/workbench/instances/create#accelerator for supported types per zone."`
	// Number of accelerator cores.
	//  Valid values depend on the accelerator type (typically 1, 2, 4, or 8).
	CoreCount int32 `json:"core_count,omitempty" jsonschema:"Number of accelerator cores. Valid values depend on the accelerator type (typically 1; 2; 4; or 8)."`
}

func (s *GcpVertexAiNotebookAcceleratorConfigInput) validate() error {
	return nil
}

func (s *GcpVertexAiNotebookAcceleratorConfigInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookAcceleratorConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.CoreCount != 0 {
		m["core_count"] = s.CoreCount
	}
	return m
}

// GcpVertexAiNotebookBootDisk defines the boot disk configuration for the
//
//	notebook instance. If not specified, GCP provisions a 150 GB PD_SSD
//	boot disk with Google-managed encryption.
type GcpVertexAiNotebookBootDiskInput struct {
	// Disk type for the boot disk.
	//  Valid values: PD_STANDARD, PD_SSD, PD_BALANCED, PD_EXTREME.
	//  If not specified, defaults to PD_SSD.
	DiskType string `json:"disk_type,omitempty" jsonschema:"Disk type for the boot disk. Valid values: PD_STANDARD; PD_SSD; PD_BALANCED; PD_EXTREME. If not specified; defaults to PD_SSD."`
	// Size of the boot disk in GB.
	//  Minimum 10 GB, maximum 64000 GB (64 TB).
	//  If not specified, defaults to 150 GB.
	DiskSizeGb int32 `json:"disk_size_gb,omitempty" jsonschema:"Size of the boot disk in GB. Minimum 10 GB; maximum 64000 GB (64 TB). If not specified; defaults to 150 GB."`
	// KMS key for CMEK encryption of the boot disk.
	//  Format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key}
	//  If not specified, Google-managed encryption (GMEK) is used.
	KmsKey string `json:"kms_key,omitempty" jsonschema:"KMS key for CMEK encryption of the boot disk. Format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key} If not specified; Google-managed encryption (GMEK) is used."`
}

func (s *GcpVertexAiNotebookBootDiskInput) validate() error {
	return nil
}

func (s *GcpVertexAiNotebookBootDiskInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookBootDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DiskType != "" {
		m["disk_type"] = s.DiskType
	}
	if s.DiskSizeGb != 0 {
		m["disk_size_gb"] = s.DiskSizeGb
	}
	if s.KmsKey != "" {
		m["kms_key"] = s.KmsKey
	}
	return m
}

// GcpVertexAiNotebookContainerImage defines a custom container image
//
//	to use as the notebook environment. Use this when you need a custom
//	JupyterLab environment with specific libraries, frameworks, or
//	configurations not available in the pre-built VM images.
//
//	Mutually exclusive with GcpVertexAiNotebookVmImage.
type GcpVertexAiNotebookContainerImageInput struct {
	// Container image repository path.
	//  Example: "gcr.io/deeplearning-platform-release/base-cu113.py310"
	Repository string `json:"repository" jsonschema:"required,Container image repository path. Example: 'gcr.io/deeplearning-platform-release/base-cu113.py310'"`
	// Container image tag. If not specified, the latest tag is used.
	Tag string `json:"tag,omitempty" jsonschema:"Container image tag. If not specified; the latest tag is used."`
}

func (s *GcpVertexAiNotebookContainerImageInput) validate() error {
	if s.Repository == "" {
		return fmt.Errorf("repository is required")
	}
	return nil
}

func (s *GcpVertexAiNotebookContainerImageInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookContainerImageInput) toMap() map[string]any {
	m := make(map[string]any)
	m["repository"] = s.Repository
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	return m
}

// GcpVertexAiNotebookDataDisk defines a data disk attached to the notebook
//
//	instance. GCP supports exactly one data disk per Workbench instance.
//	If not specified, GCP provisions a 100 GB data disk with Google-managed
//	encryption.
type GcpVertexAiNotebookDataDiskInput struct {
	// Disk type for the data disk.
	//  Valid values: PD_STANDARD, PD_SSD, PD_BALANCED, PD_EXTREME.
	//  If not specified, defaults to PD_STANDARD.
	DiskType string `json:"disk_type,omitempty" jsonschema:"Disk type for the data disk. Valid values: PD_STANDARD; PD_SSD; PD_BALANCED; PD_EXTREME. If not specified; defaults to PD_STANDARD."`
	// Size of the data disk in GB.
	//  Minimum 10 GB, maximum 64000 GB (64 TB).
	//  If not specified, defaults to 100 GB.
	DiskSizeGb int32 `json:"disk_size_gb,omitempty" jsonschema:"Size of the data disk in GB. Minimum 10 GB; maximum 64000 GB (64 TB). If not specified; defaults to 100 GB."`
	// KMS key for CMEK encryption of the data disk.
	//  Format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key}
	//  If not specified, Google-managed encryption (GMEK) is used.
	KmsKey string `json:"kms_key,omitempty" jsonschema:"KMS key for CMEK encryption of the data disk. Format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key} If not specified; Google-managed encryption (GMEK) is used."`
}

func (s *GcpVertexAiNotebookDataDiskInput) validate() error {
	return nil
}

func (s *GcpVertexAiNotebookDataDiskInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookDataDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DiskType != "" {
		m["disk_type"] = s.DiskType
	}
	if s.DiskSizeGb != 0 {
		m["disk_size_gb"] = s.DiskSizeGb
	}
	if s.KmsKey != "" {
		m["kms_key"] = s.KmsKey
	}
	return m
}

// GcpVertexAiNotebookNetworkInterface defines the network configuration
//
//	for the notebook instance. GCP supports exactly one network interface
//	per Workbench instance.
type GcpVertexAiNotebookNetworkInterfaceInput struct {
	// VPC network for the instance.
	//  Can be a literal value (VPC name or self_link) or a reference to
	//  a GcpVpc resource.
	Network string `json:"network,omitempty" jsonschema:"VPC network for the instance. Can be a literal value (VPC name or self_link) or a reference to a GcpVpc resource."`
	// Subnetwork for the instance.
	//  Can be a literal value (subnet name or self_link) or a reference to
	//  a GcpSubnetwork resource.
	Subnet string `json:"subnet,omitempty" jsonschema:"Subnetwork for the instance. Can be a literal value (subnet name or self_link) or a reference to a GcpSubnetwork resource."`
	// NIC type for the network interface.
	//  Valid values: VIRTIO_NET, GVNIC.
	//  GVNIC provides higher bandwidth and lower latency.
	//  If not specified, defaults to VIRTIO_NET.
	NicType string `json:"nic_type,omitempty" jsonschema:"NIC type for the network interface. Valid values: VIRTIO_NET; GVNIC. GVNIC provides higher bandwidth and lower latency. If not specified; defaults to VIRTIO_NET."`
}

func (s *GcpVertexAiNotebookNetworkInterfaceInput) validate() error {
	return nil
}

func (s *GcpVertexAiNotebookNetworkInterfaceInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookNetworkInterfaceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Network != "" {
		m["network"] = s.Network
	}
	if s.Subnet != "" {
		m["subnet"] = s.Subnet
	}
	if s.NicType != "" {
		m["nic_type"] = s.NicType
	}
	return m
}

// GcpVertexAiNotebookShieldedInstanceConfig defines Shielded VM settings
//
//	for the notebook instance. Shielded VMs provide verifiable integrity
//	to protect against rootkits and bootkits.
type GcpVertexAiNotebookShieldedInstanceConfigInput struct {
	// Enable Secure Boot. Ensures only verified boot software runs.
	//  Disabled by default because some ML libraries may not have signed
	//  boot loaders.
	EnableSecureBoot bool `json:"enable_secure_boot,omitempty" jsonschema:"Enable Secure Boot. Ensures only verified boot software runs. Disabled by default because some ML libraries may not have signed boot loaders."`
	// Enable vTPM (Virtual Trusted Platform Module).
	//  Provides measured boot integrity and key generation.
	//  Enabled by default.
	EnableVtpm bool `json:"enable_vtpm,omitempty" jsonschema:"Enable vTPM (Virtual Trusted Platform Module). Provides measured boot integrity and key generation. Enabled by default."`
	// Enable integrity monitoring. Compares boot measurements against
	//  a trusted baseline.
	//  Enabled by default.
	EnableIntegrityMonitoring bool `json:"enable_integrity_monitoring,omitempty" jsonschema:"Enable integrity monitoring. Compares boot measurements against a trusted baseline. Enabled by default."`
}

func (s *GcpVertexAiNotebookShieldedInstanceConfigInput) validate() error {
	return nil
}

func (s *GcpVertexAiNotebookShieldedInstanceConfigInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookShieldedInstanceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EnableSecureBoot {
		m["enable_secure_boot"] = s.EnableSecureBoot
	}
	if s.EnableVtpm {
		m["enable_vtpm"] = s.EnableVtpm
	}
	if s.EnableIntegrityMonitoring {
		m["enable_integrity_monitoring"] = s.EnableIntegrityMonitoring
	}
	return m
}

// GcpVertexAiNotebookVmImage defines a Compute Engine VM image to use
//
//	as the notebook environment. This is the most common configuration --
//	GCP provides pre-built deep learning VM images with popular ML frameworks
//	(TensorFlow, PyTorch, JAX) and JupyterLab pre-installed.
//
//	Mutually exclusive with GcpVertexAiNotebookContainerImage.
type GcpVertexAiNotebookVmImageInput struct {
	// Google Cloud project that the VM image belongs to.
	//  Defaults to "deeplearning-platform-release" for GCP's pre-built
	//  deep learning images.
	Project string `json:"project,omitempty" jsonschema:"Google Cloud project that the VM image belongs to. Defaults to 'deeplearning-platform-release' for GCP's pre-built deep learning images."`
	// VM image family. The newest image in this family will be used.
	//  Example families: "common-cpu-notebooks", "tf-latest-gpu",
	//  "pytorch-latest-gpu", "r-latest-cpu-experimental".
	//  Mutually exclusive with name (within this message).
	Family string `json:"family,omitempty" jsonschema:"VM image family. The newest image in this family will be used. Example families: 'common-cpu-notebooks'; 'tf-latest-gpu'; 'pytorch-latest-gpu'; 'r-latest-cpu-experimental'. Mutually exclusive with nam..."`
	// Specific VM image name. Use this instead of family when you need
	//  to pin to an exact image version.
	//  Mutually exclusive with family (within this message).
	Name string `json:"name,omitempty" jsonschema:"Specific VM image name. Use this instead of family when you need to pin to an exact image version. Mutually exclusive with family (within this message)."`
}

func (s *GcpVertexAiNotebookVmImageInput) validate() error {
	return nil
}

func (s *GcpVertexAiNotebookVmImageInput) applyDefaults() {
}

func (s *GcpVertexAiNotebookVmImageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Project != "" {
		m["project"] = s.Project
	}
	if s.Family != "" {
		m["family"] = s.Family
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	return m
}

// ParseGcpVertexAiNotebook validates and normalizes a GcpVertexAiNotebook cloud_object.
func ParseGcpVertexAiNotebook(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpVertexAiNotebook"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpVertexAiNotebookSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
