// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-router-nat
type GcpRouterNatSpecInput struct {
	// GCP project ID where the Cloud Router and NAT will be created.
	//  Example: "my-gcp-project-123"
	ProjectId string `json:"project_id" jsonschema:"required,GCP project ID where the Cloud Router and NAT will be created. Example: 'my-gcp-project-123'"`
	// Reference to the target VPC network (self-link or name of an existing GCP VPC).
	VpcSelfLink string `json:"vpc_self_link" jsonschema:"required,Reference to the target VPC network (self-link or name of an existing GCP VPC)."`
	// GCP region for the Cloud Router and NAT.
	Region string `json:"region" jsonschema:"required,GCP region for the Cloud Router and NAT."`
	// Optional specific subnets to enable NAT on (if empty or not set, NAT covers all subnets in the region).
	SubnetworkSelfLinks []string `json:"subnetwork_self_links,omitempty" jsonschema:"Optional specific subnets to enable NAT on (if empty or not set; NAT covers all subnets in the region)."`
	// Optional static external IP addresses to use for NAT (if empty, NAT will auto-allocate IPs).
	NatIpNames []string `json:"nat_ip_names,omitempty" jsonschema:"Optional static external IP addresses to use for NAT (if empty; NAT will auto-allocate IPs)."`
	// Log filter for NAT translation logging.
	//  **Default:** ERRORS_ONLY (recommended for production to detect port exhaustion and connection failures).
	//  Use DISABLED for non-production environments to reduce costs.
	//  Use ALL for security auditing or detailed troubleshooting (generates significant log volum...
	LogFilter string `json:"log_filter,omitempty" jsonschema:"enum=ERRORS_ONLY|ALL,Log filter for NAT translation logging. **Default:** ERRORS_ONLY (recommended for production to detect port exhaustion and connection failures). Use DISABLED for non-production environments to reduce ..."`
	// Name of the Cloud Router to create in GCP.
	//  Must be 1-63 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a lowercase letter or number.
	//  Example: "my-router", "prod-uswest1-router"
	RouterName string `json:"router_name" jsonschema:"required,Name of the Cloud Router to create in GCP. Must be 1-63 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a lowercase letter or number. Example: 'my-r..."`
	// Name of the NAT configuration on the Cloud Router.
	//  Must be 1-63 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a lowercase letter or number.
	//  Example: "my-nat", "prod-nat-config"
	NatName string `json:"nat_name" jsonschema:"required,Name of the NAT configuration on the Cloud Router. Must be 1-63 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a lowercase letter or number. Exampl..."`
}

func (s *GcpRouterNatSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.VpcSelfLink == "" {
		return fmt.Errorf("vpc_self_link is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.LogFilter {
	case "", "ERRORS_ONLY", "ALL":
	default:
		return fmt.Errorf("invalid log_filter: %q", s.LogFilter)
	}
	if s.RouterName == "" {
		return fmt.Errorf("router_name is required")
	}
	if s.NatName == "" {
		return fmt.Errorf("nat_name is required")
	}
	return nil
}

func (s *GcpRouterNatSpecInput) applyDefaults() {
	if s.LogFilter == "" {
		s.LogFilter = "ERRORS_ONLY"
	}
}

func (s *GcpRouterNatSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["vpc_self_link"] = s.VpcSelfLink
	m["region"] = s.Region
	if len(s.SubnetworkSelfLinks) > 0 {
		m["subnetwork_self_links"] = s.SubnetworkSelfLinks
	}
	if len(s.NatIpNames) > 0 {
		m["nat_ip_names"] = s.NatIpNames
	}
	if s.LogFilter != "" {
		m["log_filter"] = s.LogFilter
	}
	m["router_name"] = s.RouterName
	m["nat_name"] = s.NatName
	return m
}

// ParseGcpRouterNat validates and normalizes a GcpRouterNat cloud_object.
func ParseGcpRouterNat(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpRouterNat"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpRouterNatSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
