// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-vertex-ai-endpoint
type GcpVertexAiEndpointSpecInput struct {
	// GCP project where the endpoint will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the endpoint will be created."`
	// Region where the endpoint will be created (e.g., "us-central1").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,Region where the endpoint will be created (e.g.; 'us-central1'). Immutable after creation."`
	// Display name of the endpoint (up to 128 UTF-8 characters).
	//  This is the primary human-readable identifier for the endpoint.
	DisplayName string `json:"display_name" jsonschema:"required,Display name of the endpoint (up to 128 UTF-8 characters). This is the primary human-readable identifier for the endpoint."`
	// Description of the endpoint.
	Description string `json:"description,omitempty" jsonschema:"Description of the endpoint."`
	// VPC network for private endpoints via VPC peering.
	//  Format: projects/{project}/global/networks/{network}
	//  Requires Private Services Access configured on the VPC.
	//  Mutually exclusive with private_service_connect_config.
	//  Immutable after creation.
	Network string `json:"network,omitempty" jsonschema:"VPC network for private endpoints via VPC peering. Format: projects/{project}/global/networks/{network} Requires Private Services Access configured on the VPC. Mutually exclusive with private_service_..."`
	// KMS key for customer-managed encryption (CMEK).
	//  Format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key}
	//  If not specified, Google-managed encryption is used.
	//  Immutable after creation.
	KmsKeyName string `json:"kms_key_name,omitempty" jsonschema:"KMS key for customer-managed encryption (CMEK). Format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key} If not specified; Google-managed encryption is used. Immutable after cr..."`
	// If true, the endpoint is exposed through a dedicated DNS name
	//  (https://{endpointId}.{region}-{projectNumber}.prediction.vertexai.goog)
	//  rather than the shared regional DNS. Dedicated endpoints provide
	//  better performance, reliability, and traffic isolation.
	//  Mutually exclusive with private_service_...
	DedicatedEndpointEnabled bool `json:"dedicated_endpoint_enabled,omitempty" jsonschema:"If true; the endpoint is exposed through a dedicated DNS name (https://{endpointId}.{region}-{projectNumber}.prediction.vertexai.goog) rather than the shared regional DNS. Dedicated endpoints provide ..."`
	// Private Service Connect configuration. When present, the endpoint
	//  is exposed via a PSC service attachment rather than VPC peering.
	//  Mutually exclusive with network and dedicated_endpoint_enabled.
	PrivateServiceConnectConfig *GcpVertexAiEndpointPrivateServiceConnectConfigInput `json:"private_service_connect_config,omitempty" jsonschema:"Private Service Connect configuration. When present; the endpoint is exposed via a PSC service attachment rather than VPC peering. Mutually exclusive with network and dedicated_endpoint_enabled."`
	// GCP endpoint name (numeric identifier, max 10 digits).
	//  GCP requires Vertex AI endpoint names to be numeric only --
	//  this is the resource ID in the fully qualified path
	//  projects/{project}/locations/{location}/endpoints/{name}.
	//
	//  If not specified, the IaC module auto-generates a numeric
	//  identifier....
	EndpointName string `json:"endpoint_name,omitempty" jsonschema:"GCP endpoint name (numeric identifier; max 10 digits). GCP requires Vertex AI endpoint names to be numeric only -- this is the resource ID in the fully qualified path projects/{project}/locations/{loc..."`
}

func (s *GcpVertexAiEndpointSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.DisplayName == "" {
		return fmt.Errorf("display_name is required")
	}
	if s.PrivateServiceConnectConfig != nil {
		if err := s.PrivateServiceConnectConfig.validate(); err != nil {
			return fmt.Errorf("private_service_connect_config: %w", err)
		}
	}
	return nil
}

func (s *GcpVertexAiEndpointSpecInput) applyDefaults() {
	if s.PrivateServiceConnectConfig != nil {
		s.PrivateServiceConnectConfig.applyDefaults()
	}
}

func (s *GcpVertexAiEndpointSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["location"] = s.Location
	m["display_name"] = s.DisplayName
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Network != "" {
		m["network"] = s.Network
	}
	if s.KmsKeyName != "" {
		m["kms_key_name"] = s.KmsKeyName
	}
	if s.DedicatedEndpointEnabled {
		m["dedicated_endpoint_enabled"] = s.DedicatedEndpointEnabled
	}
	if s.PrivateServiceConnectConfig != nil {
		m["private_service_connect_config"] = s.PrivateServiceConnectConfig.toMap()
	}
	if s.EndpointName != "" {
		m["endpoint_name"] = s.EndpointName
	}
	return m
}

// GcpVertexAiEndpointPrivateServiceConnectConfig configures Private Service
//
//	Connect (PSC) networking for the endpoint. When this block is present,
//	the endpoint is exposed via PSC rather than VPC peering.
//
//	PSC provides a private, secure connection to the endpoint without
//	requiring VPC peering. It is the modern networking model for Vertex AI
//	endpoints and supports fine-grained access control via project allowlists.
type GcpVertexAiEndpointPrivateServiceConnectConfigInput struct {
	// Projects allowed to create forwarding rules targeting this endpoint's
	//  service attachment. Each entry is a GCP project ID or project number.
	//  If empty, any project in the same organization can connect.
	ProjectAllowlist []string `json:"project_allowlist,omitempty" jsonschema:"Projects allowed to create forwarding rules targeting this endpoint's service attachment. Each entry is a GCP project ID or project number. If empty; any project in the same organization can connect."`
}

func (s *GcpVertexAiEndpointPrivateServiceConnectConfigInput) validate() error {
	return nil
}

func (s *GcpVertexAiEndpointPrivateServiceConnectConfigInput) applyDefaults() {
}

func (s *GcpVertexAiEndpointPrivateServiceConnectConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.ProjectAllowlist) > 0 {
		m["project_allowlist"] = s.ProjectAllowlist
	}
	return m
}

// ParseGcpVertexAiEndpoint validates and normalizes a GcpVertexAiEndpoint cloud_object.
func ParseGcpVertexAiEndpoint(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpVertexAiEndpoint"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpVertexAiEndpointSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
