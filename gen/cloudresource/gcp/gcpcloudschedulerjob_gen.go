// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-scheduler-job
type GcpCloudSchedulerJobSpecInput struct {
	// GCP project where the scheduler job will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the scheduler job will be created."`
	// Name of the Cloud Scheduler job.
	//  If not specified, defaults to metadata.name.
	//  Immutable after creation.
	JobName string `json:"job_name,omitempty" jsonschema:"Name of the Cloud Scheduler job. If not specified; defaults to metadata.name. Immutable after creation."`
	// GCP region where the scheduler job will be created (e.g., "us-central1").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,GCP region where the scheduler job will be created (e.g.; 'us-central1'). Immutable after creation."`
	// Cron schedule on which the job will be executed.
	//  Uses unix-cron format (e.g., "* /5 * * * *" for every 5 minutes,
	//  "0 9 * * 1" for every Monday at 9:00 AM).
	//  The schedule is interpreted in the time zone specified by time_zone.
	Schedule string `json:"schedule" jsonschema:"required,Cron schedule on which the job will be executed. Uses unix-cron format (e.g.; '*/5 * * * *' for every 5 minutes; '0 9 * * 1' for every Monday at 9:00 AM). The schedule is interpreted in the time zone ..."`
	// Time zone name from the tz database (e.g., "America/New_York", "Europe/London").
	//  If not specified, defaults to "Etc/UTC".
	//  See: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
	TimeZone string `json:"time_zone,omitempty" jsonschema:"Time zone name from the tz database (e.g.; 'America/New_York'; 'Europe/London'). If not specified; defaults to 'Etc/UTC'. See: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones"`
	// Human-readable description of the job.
	//  Maximum 500 characters.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the job. Maximum 500 characters."`
	// The deadline for job attempts. If the request handler does not respond
	//  by this deadline, the request is cancelled and the attempt is marked
	//  as a DEADLINE_EXCEEDED failure.
	//
	//  For HTTP targets: between 15 seconds and 30 minutes.
	//  For App Engine targets: between 15 seconds and 24 hours 15 seconds.
	//  F...
	AttemptDeadline string `json:"attempt_deadline,omitempty" jsonschema:"The deadline for job attempts. If the request handler does not respond by this deadline; the request is cancelled and the attempt is marked as a DEADLINE_EXCEEDED failure. For HTTP targets: between 15..."`
	// If true, the job will be created in a paused state (will not execute
	//  on schedule until resumed). Defaults to false (job starts enabled).
	Paused bool `json:"paused,omitempty" jsonschema:"If true; the job will be created in a paused state (will not execute on schedule until resumed). Defaults to false (job starts enabled)."`
	// HTTP target configuration. Dispatches the job to an HTTP endpoint.
	//  This is the most common target type, used for triggering Cloud Run
	//  services, Cloud Functions, webhooks, or any HTTP-accessible endpoint.
	//  Exactly one target must be specified.
	HttpTarget *GcpCloudSchedulerJobHttpTargetInput `json:"http_target,omitempty" jsonschema:"HTTP target configuration. Dispatches the job to an HTTP endpoint. This is the most common target type; used for triggering Cloud Run services; Cloud Functions; webhooks; or any HTTP-accessible endpoi..."`
	// Pub/Sub target configuration. Publishes a message to a Pub/Sub topic
	//  when the job executes. Use this for event-driven architectures where
	//  downstream consumers process messages asynchronously.
	//  Exactly one target must be specified.
	PubsubTarget *GcpCloudSchedulerJobPubsubTargetInput `json:"pubsub_target,omitempty" jsonschema:"Pub/Sub target configuration. Publishes a message to a Pub/Sub topic when the job executes. Use this for event-driven architectures where downstream consumers process messages asynchronously. Exactly ..."`
	// App Engine HTTP target configuration. Dispatches the job to an
	//  App Engine handler within the same project. Use this when the
	//  target handler runs on App Engine.
	//  Exactly one target must be specified.
	AppEngineHttpTarget *GcpCloudSchedulerJobAppEngineHttpTargetInput `json:"app_engine_http_target,omitempty" jsonschema:"App Engine HTTP target configuration. Dispatches the job to an App Engine handler within the same project. Use this when the target handler runs on App Engine. Exactly one target must be specified."`
	// Retry configuration for failed job attempts.
	//  Controls exponential backoff behavior, maximum attempts, and
	//  retry duration limits.
	RetryConfig *GcpCloudSchedulerJobRetryConfigInput `json:"retry_config,omitempty" jsonschema:"Retry configuration for failed job attempts. Controls exponential backoff behavior; maximum attempts; and retry duration limits."`
}

func (s *GcpCloudSchedulerJobSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.Schedule == "" {
		return fmt.Errorf("schedule is required")
	}
	if s.HttpTarget != nil {
		if err := s.HttpTarget.validate(); err != nil {
			return fmt.Errorf("http_target: %w", err)
		}
	}
	if s.PubsubTarget != nil {
		if err := s.PubsubTarget.validate(); err != nil {
			return fmt.Errorf("pubsub_target: %w", err)
		}
	}
	if s.AppEngineHttpTarget != nil {
		if err := s.AppEngineHttpTarget.validate(); err != nil {
			return fmt.Errorf("app_engine_http_target: %w", err)
		}
	}
	if s.RetryConfig != nil {
		if err := s.RetryConfig.validate(); err != nil {
			return fmt.Errorf("retry_config: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudSchedulerJobSpecInput) applyDefaults() {
	if s.HttpTarget != nil {
		s.HttpTarget.applyDefaults()
	}
	if s.PubsubTarget != nil {
		s.PubsubTarget.applyDefaults()
	}
	if s.AppEngineHttpTarget != nil {
		s.AppEngineHttpTarget.applyDefaults()
	}
	if s.RetryConfig != nil {
		s.RetryConfig.applyDefaults()
	}
}

func (s *GcpCloudSchedulerJobSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	if s.JobName != "" {
		m["job_name"] = s.JobName
	}
	m["location"] = s.Location
	m["schedule"] = s.Schedule
	if s.TimeZone != "" {
		m["time_zone"] = s.TimeZone
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.AttemptDeadline != "" {
		m["attempt_deadline"] = s.AttemptDeadline
	}
	if s.Paused {
		m["paused"] = s.Paused
	}
	if s.HttpTarget != nil {
		m["http_target"] = s.HttpTarget.toMap()
	}
	if s.PubsubTarget != nil {
		m["pubsub_target"] = s.PubsubTarget.toMap()
	}
	if s.AppEngineHttpTarget != nil {
		m["app_engine_http_target"] = s.AppEngineHttpTarget.toMap()
	}
	if s.RetryConfig != nil {
		m["retry_config"] = s.RetryConfig.toMap()
	}
	return m
}

// GcpCloudSchedulerJobAppEngineHttpTarget defines an App Engine endpoint as
//
//	the target for scheduled job execution. Use this when the target handler
//	runs on App Engine within the same project.
type GcpCloudSchedulerJobAppEngineHttpTargetInput struct {
	// The relative URI of the App Engine handler.
	//  Must begin with "/" and have a maximum length of 2083 characters.
	RelativeUri string `json:"relative_uri" jsonschema:"required,The relative URI of the App Engine handler. Must begin with '/' and have a maximum length of 2083 characters."`
	// HTTP request method.
	//  If not specified, defaults to POST.
	//  Valid values: "POST", "GET", "HEAD", "PUT", "DELETE", "PATCH", "OPTIONS".
	HttpMethod string `json:"http_method,omitempty" jsonschema:"HTTP request method. If not specified; defaults to POST. Valid values: 'POST'; 'GET'; 'HEAD'; 'PUT'; 'DELETE'; 'PATCH'; 'OPTIONS'."`
	// HTTP request body.
	//  A request body is allowed only if the HTTP method is POST or PUT.
	//  Must be base64-encoded.
	Body string `json:"body,omitempty" jsonschema:"HTTP request body. A request body is allowed only if the HTTP method is POST or PUT. Must be base64-encoded."`
	// HTTP request headers.
	//  The following headers cannot be set: Content-Length, Host, User-Agent,
	//  and headers matching X-Google-* or X-AppEngine-*.
	Headers map[string]string `json:"headers,omitempty" jsonschema:"HTTP request headers. The following headers cannot be set: Content-Length; Host; User-Agent; and headers matching X-Google-* or X-AppEngine-*."`
	// App Engine routing configuration.
	//  Controls which App Engine service, version, and instance handles
	//  the request. If not set, the default service and version are used.
	AppEngineRouting *GcpCloudSchedulerJobAppEngineRoutingInput `json:"app_engine_routing,omitempty" jsonschema:"App Engine routing configuration. Controls which App Engine service; version; and instance handles the request. If not set; the default service and version are used."`
}

func (s *GcpCloudSchedulerJobAppEngineHttpTargetInput) validate() error {
	if s.RelativeUri == "" {
		return fmt.Errorf("relative_uri is required")
	}
	if s.AppEngineRouting != nil {
		if err := s.AppEngineRouting.validate(); err != nil {
			return fmt.Errorf("app_engine_routing: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudSchedulerJobAppEngineHttpTargetInput) applyDefaults() {
	if s.AppEngineRouting != nil {
		s.AppEngineRouting.applyDefaults()
	}
}

func (s *GcpCloudSchedulerJobAppEngineHttpTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["relative_uri"] = s.RelativeUri
	if s.HttpMethod != "" {
		m["http_method"] = s.HttpMethod
	}
	if s.Body != "" {
		m["body"] = s.Body
	}
	if len(s.Headers) > 0 {
		m["headers"] = s.Headers
	}
	if s.AppEngineRouting != nil {
		m["app_engine_routing"] = s.AppEngineRouting.toMap()
	}
	return m
}

// GcpCloudSchedulerJobAppEngineRouting defines routing configuration for
//
//	App Engine HTTP target requests. Specifies which App Engine service,
//	version, and instance handles the request.
type GcpCloudSchedulerJobAppEngineRoutingInput struct {
	// The App Engine service to route the request to.
	//  If not specified, the default service is used.
	Service string `json:"service,omitempty" jsonschema:"The App Engine service to route the request to. If not specified; the default service is used."`
	// The App Engine version to route the request to.
	//  If not specified, the default version is used.
	Version string `json:"version,omitempty" jsonschema:"The App Engine version to route the request to. If not specified; the default version is used."`
	// The App Engine instance to route the request to.
	//  If not specified, the request is routed according to the service/version
	//  traffic splitting configuration.
	Instance string `json:"instance,omitempty" jsonschema:"The App Engine instance to route the request to. If not specified; the request is routed according to the service/version traffic splitting configuration."`
}

func (s *GcpCloudSchedulerJobAppEngineRoutingInput) validate() error {
	return nil
}

func (s *GcpCloudSchedulerJobAppEngineRoutingInput) applyDefaults() {
}

func (s *GcpCloudSchedulerJobAppEngineRoutingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Service != "" {
		m["service"] = s.Service
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.Instance != "" {
		m["instance"] = s.Instance
	}
	return m
}

// GcpCloudSchedulerJobHttpTarget defines an HTTP endpoint as the target
//
//	for scheduled job execution. This is the most common target type,
//	used for triggering Cloud Run services, Cloud Functions, or any HTTP endpoint.
type GcpCloudSchedulerJobHttpTargetInput struct {
	// The full URI of the HTTP target.
	//  Required. Must be a valid HTTP or HTTPS URL.
	Uri string `json:"uri" jsonschema:"required,The full URI of the HTTP target. Required. Must be a valid HTTP or HTTPS URL."`
	// HTTP request method.
	//  If not specified, defaults to POST.
	//  Valid values: "POST", "GET", "HEAD", "PUT", "DELETE", "PATCH", "OPTIONS".
	HttpMethod string `json:"http_method,omitempty" jsonschema:"HTTP request method. If not specified; defaults to POST. Valid values: 'POST'; 'GET'; 'HEAD'; 'PUT'; 'DELETE'; 'PATCH'; 'OPTIONS'."`
	// HTTP request body.
	//  A request body is allowed only if the HTTP method is POST, PUT, or PATCH.
	//  Must be base64-encoded.
	Body string `json:"body,omitempty" jsonschema:"HTTP request body. A request body is allowed only if the HTTP method is POST; PUT; or PATCH. Must be base64-encoded."`
	// HTTP request headers.
	//  The following headers cannot be set: Content-Length, User-Agent,
	//  and headers matching X-Google-* or X-AppEngine-*.
	Headers map[string]string `json:"headers,omitempty" jsonschema:"HTTP request headers. The following headers cannot be set: Content-Length; User-Agent; and headers matching X-Google-* or X-AppEngine-*."`
	// OAuth2 access token configuration for authenticating requests.
	//  Use for calling Google APIs on *.googleapis.com.
	//  Mutually exclusive with oidc_token.
	OauthToken *GcpCloudSchedulerJobOAuthTokenInput `json:"oauth_token,omitempty" jsonschema:"OAuth2 access token configuration for authenticating requests. Use for calling Google APIs on *.googleapis.com. Mutually exclusive with oidc_token."`
	// OIDC token configuration for authenticating requests.
	//  Use for calling Cloud Run, Cloud Functions, or custom endpoints.
	//  Mutually exclusive with oauth_token.
	OidcToken *GcpCloudSchedulerJobOidcTokenInput `json:"oidc_token,omitempty" jsonschema:"OIDC token configuration for authenticating requests. Use for calling Cloud Run; Cloud Functions; or custom endpoints. Mutually exclusive with oauth_token."`
}

func (s *GcpCloudSchedulerJobHttpTargetInput) validate() error {
	if s.Uri == "" {
		return fmt.Errorf("uri is required")
	}
	if s.OauthToken != nil {
		if err := s.OauthToken.validate(); err != nil {
			return fmt.Errorf("oauth_token: %w", err)
		}
	}
	if s.OidcToken != nil {
		if err := s.OidcToken.validate(); err != nil {
			return fmt.Errorf("oidc_token: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudSchedulerJobHttpTargetInput) applyDefaults() {
	if s.OauthToken != nil {
		s.OauthToken.applyDefaults()
	}
	if s.OidcToken != nil {
		s.OidcToken.applyDefaults()
	}
}

func (s *GcpCloudSchedulerJobHttpTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["uri"] = s.Uri
	if s.HttpMethod != "" {
		m["http_method"] = s.HttpMethod
	}
	if s.Body != "" {
		m["body"] = s.Body
	}
	if len(s.Headers) > 0 {
		m["headers"] = s.Headers
	}
	if s.OauthToken != nil {
		m["oauth_token"] = s.OauthToken.toMap()
	}
	if s.OidcToken != nil {
		m["oidc_token"] = s.OidcToken.toMap()
	}
	return m
}

// GcpCloudSchedulerJobOAuthToken configures OAuth2 access token generation for
//
//	authenticating HTTP target requests. Use this when calling Google APIs
//	hosted on *.googleapis.com.
//
//	Mutually exclusive with GcpCloudSchedulerJobOidcToken.
type GcpCloudSchedulerJobOAuthTokenInput struct {
	// Service account email to generate the OAuth token.
	//  The service account must be within the same project as the job.
	//  The caller must have iam.serviceAccounts.actAs on this service account.
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,Service account email to generate the OAuth token. The service account must be within the same project as the job. The caller must have iam.serviceAccounts.actAs on this service account."`
	// OAuth scope for the generated access token.
	//  If not specified, defaults to "https://www.googleapis.com/auth/cloud-platform".
	Scope string `json:"scope,omitempty" jsonschema:"OAuth scope for the generated access token. If not specified; defaults to 'https://www.googleapis.com/auth/cloud-platform'."`
}

func (s *GcpCloudSchedulerJobOAuthTokenInput) validate() error {
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	return nil
}

func (s *GcpCloudSchedulerJobOAuthTokenInput) applyDefaults() {
}

func (s *GcpCloudSchedulerJobOAuthTokenInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_account_email"] = s.ServiceAccountEmail
	if s.Scope != "" {
		m["scope"] = s.Scope
	}
	return m
}

// GcpCloudSchedulerJobOidcToken configures OIDC token generation for
//
//	authenticating HTTP target requests. Use this for calling Cloud Run,
//	Cloud Functions, or any endpoint where you validate the token yourself.
//
//	Mutually exclusive with GcpCloudSchedulerJobOAuthToken.
type GcpCloudSchedulerJobOidcTokenInput struct {
	// Service account email to generate the OIDC token.
	//  The service account must be within the same project as the job.
	//  The caller must have iam.serviceAccounts.actAs on this service account.
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,Service account email to generate the OIDC token. The service account must be within the same project as the job. The caller must have iam.serviceAccounts.actAs on this service account."`
	// Audience for the generated OIDC token.
	//  If not specified, the URI of the HTTP target will be used.
	Audience string `json:"audience,omitempty" jsonschema:"Audience for the generated OIDC token. If not specified; the URI of the HTTP target will be used."`
}

func (s *GcpCloudSchedulerJobOidcTokenInput) validate() error {
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	return nil
}

func (s *GcpCloudSchedulerJobOidcTokenInput) applyDefaults() {
}

func (s *GcpCloudSchedulerJobOidcTokenInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_account_email"] = s.ServiceAccountEmail
	if s.Audience != "" {
		m["audience"] = s.Audience
	}
	return m
}

// GcpCloudSchedulerJobPubsubTarget defines a Pub/Sub topic as the target
//
//	for scheduled job execution. When the job runs, a message is published
//	to the specified topic.
type GcpCloudSchedulerJobPubsubTargetInput struct {
	// The fully qualified Pub/Sub topic name to publish to.
	//  Format: projects/{project}/topics/{topic}
	TopicName string `json:"topic_name" jsonschema:"required,The fully qualified Pub/Sub topic name to publish to. Format: projects/{project}/topics/{topic}"`
	// The message payload for the Pub/Sub message.
	//  Must be base64-encoded.
	//  The message must contain either non-empty data OR at least one attribute.
	Data string `json:"data,omitempty" jsonschema:"The message payload for the Pub/Sub message. Must be base64-encoded. The message must contain either non-empty data OR at least one attribute."`
	// Attributes for the Pub/Sub message.
	//  Key-value pairs attached to the message as metadata.
	//  The message must contain either non-empty data OR at least one attribute.
	Attributes map[string]string `json:"attributes,omitempty" jsonschema:"Attributes for the Pub/Sub message. Key-value pairs attached to the message as metadata. The message must contain either non-empty data OR at least one attribute."`
}

func (s *GcpCloudSchedulerJobPubsubTargetInput) validate() error {
	if s.TopicName == "" {
		return fmt.Errorf("topic_name is required")
	}
	return nil
}

func (s *GcpCloudSchedulerJobPubsubTargetInput) applyDefaults() {
}

func (s *GcpCloudSchedulerJobPubsubTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["topic_name"] = s.TopicName
	if s.Data != "" {
		m["data"] = s.Data
	}
	if len(s.Attributes) > 0 {
		m["attributes"] = s.Attributes
	}
	return m
}

// GcpCloudSchedulerJobRetryConfig controls retry behavior for failed job
//
//	execution attempts. A job attempt is retried between min_backoff_duration
//	and max_backoff_duration after it fails, with exponential backoff that
//	doubles max_doublings times before becoming linear.
type GcpCloudSchedulerJobRetryConfigInput struct {
	// The number of attempts that the system will make to run a job using
	//  the exponential backoff procedure. Values greater than 5 and negative
	//  values are not allowed.
	RetryCount int32 `json:"retry_count,omitempty" jsonschema:"The number of attempts that the system will make to run a job using the exponential backoff procedure. Values greater than 5 and negative values are not allowed."`
	// The time limit for retrying a failed job, measured from when the job
	//  was first attempted. Once elapsed, no further attempts are made.
	//  Format: duration string (e.g., "3600s" for 1 hour).
	//  Set to "0s" for unlimited retry duration.
	MaxRetryDuration string `json:"max_retry_duration,omitempty" jsonschema:"The time limit for retrying a failed job; measured from when the job was first attempted. Once elapsed; no further attempts are made. Format: duration string (e.g.; '3600s' for 1 hour). Set to '0s' fo..."`
	// The minimum amount of time to wait before retrying a job after it fails.
	//  Format: duration string (e.g., "5s" for 5 seconds).
	MinBackoffDuration string `json:"min_backoff_duration,omitempty" jsonschema:"The minimum amount of time to wait before retrying a job after it fails. Format: duration string (e.g.; '5s' for 5 seconds)."`
	// The maximum amount of time to wait before retrying a job after it fails.
	//  Format: duration string (e.g., "3600s" for 1 hour).
	MaxBackoffDuration string `json:"max_backoff_duration,omitempty" jsonschema:"The maximum amount of time to wait before retrying a job after it fails. Format: duration string (e.g.; '3600s' for 1 hour)."`
	// The number of times that the retry interval doubles before becoming
	//  constant. The retry interval starts at min_backoff_duration, then
	//  doubles max_doublings times, and increases linearly thereafter.
	MaxDoublings int32 `json:"max_doublings,omitempty" jsonschema:"The number of times that the retry interval doubles before becoming constant. The retry interval starts at min_backoff_duration; then doubles max_doublings times; and increases linearly thereafter."`
}

func (s *GcpCloudSchedulerJobRetryConfigInput) validate() error {
	return nil
}

func (s *GcpCloudSchedulerJobRetryConfigInput) applyDefaults() {
}

func (s *GcpCloudSchedulerJobRetryConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RetryCount != 0 {
		m["retry_count"] = s.RetryCount
	}
	if s.MaxRetryDuration != "" {
		m["max_retry_duration"] = s.MaxRetryDuration
	}
	if s.MinBackoffDuration != "" {
		m["min_backoff_duration"] = s.MinBackoffDuration
	}
	if s.MaxBackoffDuration != "" {
		m["max_backoff_duration"] = s.MaxBackoffDuration
	}
	if s.MaxDoublings != 0 {
		m["max_doublings"] = s.MaxDoublings
	}
	return m
}

// ParseGcpCloudSchedulerJob validates and normalizes a GcpCloudSchedulerJob cloud_object.
func ParseGcpCloudSchedulerJob(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudSchedulerJob"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudSchedulerJobSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
