// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-firewall-rule
type GcpFirewallRuleSpecInput struct {
	// The GCP project ID in which to create this firewall rule.
	//  Example: "my-prod-project-123"
	ProjectId string `json:"project_id" jsonschema:"required,The GCP project ID in which to create this firewall rule. Example: 'my-prod-project-123'"`
	// VPC network to which this firewall rule applies.
	//  Accepts a network name (e.g., "default") or a full self-link URL.
	Network string `json:"network" jsonschema:"required,VPC network to which this firewall rule applies. Accepts a network name (e.g.; 'default') or a full self-link URL."`
	// Name of the firewall rule in GCP.
	//  Must be 1-63 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a letter or number.
	//  Example: "allow-http-ingress", "deny-all-egress"
	RuleName string `json:"rule_name" jsonschema:"required,Name of the firewall rule in GCP. Must be 1-63 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a letter or number. Example: 'allow-http-ingress'; 'd..."`
	// Traffic direction this rule applies to.
	//  "INGRESS" matches inbound traffic to instances; "EGRESS" matches outbound traffic.
	Direction string `json:"direction" jsonschema:"required,Traffic direction this rule applies to. 'INGRESS' matches inbound traffic to instances; 'EGRESS' matches outbound traffic."`
	// Action to take when the rule matches traffic.
	//  "ALLOW" permits the matched traffic; "DENY" blocks it.
	Action string `json:"action" jsonschema:"required,Action to take when the rule matches traffic. 'ALLOW' permits the matched traffic; 'DENY' blocks it."`
	// Protocol and port combinations this rule matches.
	//  At least one rule must be specified.
	Rules []*GcpFirewallProtocolPortInput `json:"rules,omitempty" jsonschema:"Protocol and port combinations this rule matches. At least one rule must be specified."`
	// Rule priority. Range: 0-65535. Lower values indicate higher priority.
	//  At the same priority, DENY rules take precedence over ALLOW rules.
	//  Default: 1000
	Priority int32 `json:"priority,omitempty" jsonschema:"Rule priority. Range: 0-65535. Lower values indicate higher priority. At the same priority; DENY rules take precedence over ALLOW rules. Default: 1000"`
	// Human-readable description for the firewall rule.
	//  Example: "Allow HTTP/HTTPS traffic from the internet"
	Description string `json:"description,omitempty" jsonschema:"Human-readable description for the firewall rule. Example: 'Allow HTTP/HTTPS traffic from the internet'"`
	// Source IPv4 or IPv6 CIDR ranges for INGRESS rules.
	//  Traffic is only matched when the source IP falls within one of these ranges.
	//  For INGRESS rules, at least one of source_ranges, source_tags, or source_service_accounts is required.
	//  Example: ["0.0.0.0/0"] to match all IPv4 traffic, ["10.0.0.0/8"] f...
	SourceRanges []string `json:"source_ranges,omitempty" jsonschema:"Source IPv4 or IPv6 CIDR ranges for INGRESS rules. Traffic is only matched when the source IP falls within one of these ranges. For INGRESS rules; at least one of source_ranges; source_tags; or source..."`
	// Destination IPv4 or IPv6 CIDR ranges for EGRESS rules.
	//  Traffic is only matched when the destination IP falls within one of these ranges.
	//  If omitted on EGRESS rules, GCP defaults to ["0.0.0.0/0"] (all destinations).
	DestinationRanges []string `json:"destination_ranges,omitempty" jsonschema:"Destination IPv4 or IPv6 CIDR ranges for EGRESS rules. Traffic is only matched when the destination IP falls within one of these ranges. If omitted on EGRESS rules; GCP defaults to ['0.0.0.0/0'] (all ..."`
	// Source instance network tags for INGRESS rules.
	//  Traffic from instances with any of these tags is matched.
	//  Cannot be combined with source_service_accounts or target_service_accounts.
	SourceTags []string `json:"source_tags,omitempty" jsonschema:"Source instance network tags for INGRESS rules. Traffic from instances with any of these tags is matched. Cannot be combined with source_service_accounts or target_service_accounts."`
	// Target instance network tags.
	//  The rule applies only to instances that have one of these tags.
	//  If omitted, the rule applies to all instances in the network.
	//  Cannot be combined with source_service_accounts or target_service_accounts.
	TargetTags []string `json:"target_tags,omitempty" jsonschema:"Target instance network tags. The rule applies only to instances that have one of these tags. If omitted; the rule applies to all instances in the network. Cannot be combined with source_service_accou..."`
	// Source service accounts for INGRESS rules. Max 10.
	//  Traffic from instances running as any of these service accounts is matched.
	//  Cannot be combined with source_tags or target_tags.
	SourceServiceAccounts []string `json:"source_service_accounts,omitempty" jsonschema:"Source service accounts for INGRESS rules. Max 10. Traffic from instances running as any of these service accounts is matched. Cannot be combined with source_tags or target_tags."`
	// Target service accounts. Max 10.
	//  The rule applies only to instances running as one of these service accounts.
	//  If omitted, the rule applies to all instances in the network.
	//  Cannot be combined with source_tags or target_tags.
	TargetServiceAccounts []string `json:"target_service_accounts,omitempty" jsonschema:"Target service accounts. Max 10. The rule applies only to instances running as one of these service accounts. If omitted; the rule applies to all instances in the network. Cannot be combined with sour..."`
	// Whether the firewall rule is disabled.
	//  A disabled rule exists in the configuration but is not enforced.
	//  Useful for temporarily suspending a rule without deleting it.
	Disabled bool `json:"disabled,omitempty" jsonschema:"Whether the firewall rule is disabled. A disabled rule exists in the configuration but is not enforced. Useful for temporarily suspending a rule without deleting it."`
	// Logging configuration. When present, firewall logging is enabled.
	//  Omit this field to disable logging (the default).
	LogConfig *GcpFirewallLogConfigInput `json:"log_config,omitempty" jsonschema:"Logging configuration. When present; firewall logging is enabled. Omit this field to disable logging (the default)."`
}

func (s *GcpFirewallRuleSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Network == "" {
		return fmt.Errorf("network is required")
	}
	if s.RuleName == "" {
		return fmt.Errorf("rule_name is required")
	}
	if s.Direction == "" {
		return fmt.Errorf("direction is required")
	}
	if s.Action == "" {
		return fmt.Errorf("action is required")
	}
	if len(s.Rules) < 1 {
		return fmt.Errorf("rules requires at least 1 items, got %d", len(s.Rules))
	}
	for i, v := range s.Rules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rules[%d]: %w", i, err)
			}
		}
	}
	if s.LogConfig != nil {
		if err := s.LogConfig.validate(); err != nil {
			return fmt.Errorf("log_config: %w", err)
		}
	}
	return nil
}

func (s *GcpFirewallRuleSpecInput) applyDefaults() {
	if s.Priority == 0 {
		s.Priority = 1000
	}
	if s.LogConfig != nil {
		s.LogConfig.applyDefaults()
	}
}

func (s *GcpFirewallRuleSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["network"] = s.Network
	m["rule_name"] = s.RuleName
	m["direction"] = s.Direction
	m["action"] = s.Action
	if len(s.Rules) > 0 {
		items := make([]any, len(s.Rules))
		for i, v := range s.Rules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rules"] = items
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.SourceRanges) > 0 {
		m["source_ranges"] = s.SourceRanges
	}
	if len(s.DestinationRanges) > 0 {
		m["destination_ranges"] = s.DestinationRanges
	}
	if len(s.SourceTags) > 0 {
		m["source_tags"] = s.SourceTags
	}
	if len(s.TargetTags) > 0 {
		m["target_tags"] = s.TargetTags
	}
	if len(s.SourceServiceAccounts) > 0 {
		m["source_service_accounts"] = s.SourceServiceAccounts
	}
	if len(s.TargetServiceAccounts) > 0 {
		m["target_service_accounts"] = s.TargetServiceAccounts
	}
	if s.Disabled {
		m["disabled"] = s.Disabled
	}
	if s.LogConfig != nil {
		m["log_config"] = s.LogConfig.toMap()
	}
	return m
}

// Logging configuration for the firewall rule.
//
//	When this message is present on the spec, logging is enabled for matched traffic.
type GcpFirewallLogConfigInput struct {
	// Metadata inclusion mode for firewall logs.
	Metadata string `json:"metadata" jsonschema:"required,Metadata inclusion mode for firewall logs."`
}

func (s *GcpFirewallLogConfigInput) validate() error {
	if s.Metadata == "" {
		return fmt.Errorf("metadata is required")
	}
	return nil
}

func (s *GcpFirewallLogConfigInput) applyDefaults() {
}

func (s *GcpFirewallLogConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["metadata"] = s.Metadata
	return m
}

// A protocol and optional port range for firewall rule traffic matching.
//
//	Each entry defines an IP protocol and, for TCP/UDP, a set of ports or port ranges.
type GcpFirewallProtocolPortInput struct {
	// IP protocol to match. Accepted values: "tcp", "udp", "icmp", "esp", "ah", "sctp", "ipip", "all",
	//  or an IANA protocol number (e.g., "6" for TCP).
	Protocol string `json:"protocol" jsonschema:"required,IP protocol to match. Accepted values: 'tcp'; 'udp'; 'icmp'; 'esp'; 'ah'; 'sctp'; 'ipip'; 'all'; or an IANA protocol number (e.g.; '6' for TCP)."`
	// Ports or port ranges to match. Only applicable when protocol is "tcp" or "udp".
	//  Each entry is a single port (e.g., "80") or a range (e.g., "8000-9000").
	//  Omit for protocols that do not use ports (icmp, esp, ah, etc.).
	Ports []string `json:"ports,omitempty" jsonschema:"Ports or port ranges to match. Only applicable when protocol is 'tcp' or 'udp'. Each entry is a single port (e.g.; '80') or a range (e.g.; '8000-9000'). Omit for protocols that do not use ports (icmp;..."`
}

func (s *GcpFirewallProtocolPortInput) validate() error {
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	return nil
}

func (s *GcpFirewallProtocolPortInput) applyDefaults() {
}

func (s *GcpFirewallProtocolPortInput) toMap() map[string]any {
	m := make(map[string]any)
	m["protocol"] = s.Protocol
	if len(s.Ports) > 0 {
		m["ports"] = s.Ports
	}
	return m
}

// ParseGcpFirewallRule validates and normalizes a GcpFirewallRule cloud_object.
func ParseGcpFirewallRule(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpFirewallRule"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpFirewallRuleSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
