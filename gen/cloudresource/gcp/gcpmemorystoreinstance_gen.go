// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-memorystore-instance
type GcpMemorystoreInstanceSpecInput struct {
	// GCP project where the Memorystore instance will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the Memorystore instance will be created."`
	// Name of the Memorystore instance. This becomes the GCP resource name.
	//  Must start with a lowercase letter, contain only lowercase letters,
	//  numbers, and hyphens, and end with a lowercase letter or number.
	//  4-63 characters. Immutable after creation.
	InstanceName string `json:"instance_name" jsonschema:"required,Name of the Memorystore instance. This becomes the GCP resource name. Must start with a lowercase letter; contain only lowercase letters; numbers; and hyphens; and end with a lowercase letter or numbe..."`
	// GCP region where the instance will be deployed (e.g., "us-central1").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,GCP region where the instance will be deployed (e.g.; 'us-central1'). Immutable after creation."`
	// Number of shards for the instance. Each shard handles a portion of
	//  the keyspace. Minimum 1 shard.
	//
	//  For CLUSTER mode: multiple shards distribute data across nodes.
	//  For CLUSTER_DISABLED mode: typically 1 shard (single primary).
	ShardCount int32 `json:"shard_count" jsonschema:"required,Number of shards for the instance. Each shard handles a portion of the keyspace. Minimum 1 shard. For CLUSTER mode: multiple shards distribute data across nodes. For CLUSTER_DISABLED mode: typically 1..."`
	// Instance mode controlling cluster topology.
	//  CLUSTER: sharded mode with native cluster protocol support.
	//    Clients must use cluster-aware drivers.
	//  CLUSTER_DISABLED: standalone mode with a single primary endpoint.
	//    Compatible with any Valkey/Redis client.
	//  Immutable after creation.
	Mode string `json:"mode,omitempty" jsonschema:"Instance mode controlling cluster topology. CLUSTER: sharded mode with native cluster protocol support. Clients must use cluster-aware drivers. CLUSTER_DISABLED: standalone mode with a single primary ..."`
	// Predefined node type determining CPU and memory per node.
	//  SHARED_CORE_NANO: shared-core, smallest (dev/test).
	//  STANDARD_SMALL: dedicated core, small workloads.
	//  HIGHMEM_MEDIUM: high memory, medium production workloads.
	//  HIGHMEM_XLARGE: high memory, large production workloads.
	//  If not specified, GCP...
	NodeType string `json:"node_type,omitempty" jsonschema:"Predefined node type determining CPU and memory per node. SHARED_CORE_NANO: shared-core; smallest (dev/test). STANDARD_SMALL: dedicated core; small workloads. HIGHMEM_MEDIUM: high memory; medium produ..."`
	// Engine version (e.g., "VALKEY_8_0", "VALKEY_7_2").
	//  If not specified, the latest supported version is used.
	EngineVersion string `json:"engine_version,omitempty" jsonschema:"Engine version (e.g.; 'VALKEY_8_0'; 'VALKEY_7_2'). If not specified; the latest supported version is used."`
	// Engine configuration parameters as key-value pairs.
	//  See Valkey/Redis configuration reference for supported parameters
	//  (e.g., "maxmemory-policy", "notify-keyspace-events").
	EngineConfigs map[string]string `json:"engine_configs,omitempty" jsonschema:"Engine configuration parameters as key-value pairs. See Valkey/Redis configuration reference for supported parameters (e.g.; 'maxmemory-policy'; 'notify-keyspace-events')."`
	// Number of read replicas per shard (0-5). Default: 0 (no replicas).
	//  Replicas provide read scaling and automatic failover.
	ReplicaCount int32 `json:"replica_count,omitempty" jsonschema:"Number of read replicas per shard (0-5). Default: 0 (no replicas). Replicas provide read scaling and automatic failover."`
	// Private Service Connect (PSC) endpoints for VPC connectivity.
	//  Each entry creates a PSC endpoint in the specified consumer VPC,
	//  allowing applications in that VPC to reach the instance.
	//
	//  At least one PSC connection is recommended for the instance to be
	//  reachable. Multiple connections enable cross-...
	PscAutoConnections []*GcpMemorystoreInstancePscAutoConnectionInput `json:"psc_auto_connections,omitempty" jsonschema:"Private Service Connect (PSC) endpoints for VPC connectivity. Each entry creates a PSC endpoint in the specified consumer VPC; allowing applications in that VPC to reach the instance. At least one PSC..."`
	// Authentication mode for client connections.
	//  AUTH_DISABLED: no authentication required (default).
	//  IAM_AUTH: clients authenticate using GCP IAM credentials.
	//  Immutable after creation.
	AuthorizationMode string `json:"authorization_mode,omitempty" jsonschema:"Authentication mode for client connections. AUTH_DISABLED: no authentication required (default). IAM_AUTH: clients authenticate using GCP IAM credentials. Immutable after creation."`
	// TLS encryption mode for client-to-server traffic.
	//  TRANSIT_ENCRYPTION_DISABLED: no encryption (default).
	//  SERVER_AUTHENTICATION: clients verify the server's identity via TLS.
	//  Immutable after creation.
	TransitEncryptionMode string `json:"transit_encryption_mode,omitempty" jsonschema:"TLS encryption mode for client-to-server traffic. TRANSIT_ENCRYPTION_DISABLED: no encryption (default). SERVER_AUTHENTICATION: clients verify the server's identity via TLS. Immutable after creation."`
	// Cloud KMS key for customer-managed encryption at rest (CMEK).
	//  Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
	//  If not specified, data is encrypted with Google-managed keys.
	//  Immutable after creation.
	KmsKey string `json:"kms_key,omitempty" jsonschema:"Cloud KMS key for customer-managed encryption at rest (CMEK). Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key} If not specified; data is encrypted with Google-manage..."`
	// Persistence configuration for data durability.
	//  Controls whether and how data is written to disk.
	PersistenceConfig *GcpMemorystoreInstancePersistenceConfigInput `json:"persistence_config,omitempty" jsonschema:"Persistence configuration for data durability. Controls whether and how data is written to disk."`
	// Zone distribution configuration.
	//  Controls how nodes are spread across availability zones.
	//  Immutable after creation.
	ZoneDistributionConfig *GcpMemorystoreInstanceZoneDistributionConfigInput `json:"zone_distribution_config,omitempty" jsonschema:"Zone distribution configuration. Controls how nodes are spread across availability zones. Immutable after creation."`
	// Maintenance policy for scheduled maintenance windows.
	MaintenancePolicy *GcpMemorystoreInstanceMaintenancePolicyInput `json:"maintenance_policy,omitempty" jsonschema:"Maintenance policy for scheduled maintenance windows."`
	// Automated backup configuration.
	//  When configured, GCP takes daily backups at the specified hour
	//  and retains them for the specified duration.
	AutomatedBackupConfig *GcpMemorystoreInstanceAutomatedBackupConfigInput `json:"automated_backup_config,omitempty" jsonschema:"Automated backup configuration. When configured; GCP takes daily backups at the specified hour and retains them for the specified duration."`
	// Whether deletion protection is enabled. When true, the instance
	//  cannot be deleted without first disabling this flag.
	//  GCP defaults to true for new instances.
	DeletionProtectionEnabled bool `json:"deletion_protection_enabled,omitempty" jsonschema:"Whether deletion protection is enabled. When true; the instance cannot be deleted without first disabling this flag. GCP defaults to true for new instances."`
}

func (s *GcpMemorystoreInstanceSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.InstanceName == "" {
		return fmt.Errorf("instance_name is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	for i, v := range s.PscAutoConnections {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("psc_auto_connections[%d]: %w", i, err)
			}
		}
	}
	if s.PersistenceConfig != nil {
		if err := s.PersistenceConfig.validate(); err != nil {
			return fmt.Errorf("persistence_config: %w", err)
		}
	}
	if s.ZoneDistributionConfig != nil {
		if err := s.ZoneDistributionConfig.validate(); err != nil {
			return fmt.Errorf("zone_distribution_config: %w", err)
		}
	}
	if s.MaintenancePolicy != nil {
		if err := s.MaintenancePolicy.validate(); err != nil {
			return fmt.Errorf("maintenance_policy: %w", err)
		}
	}
	if s.AutomatedBackupConfig != nil {
		if err := s.AutomatedBackupConfig.validate(); err != nil {
			return fmt.Errorf("automated_backup_config: %w", err)
		}
	}
	return nil
}

func (s *GcpMemorystoreInstanceSpecInput) applyDefaults() {
	if s.PersistenceConfig != nil {
		s.PersistenceConfig.applyDefaults()
	}
	if s.ZoneDistributionConfig != nil {
		s.ZoneDistributionConfig.applyDefaults()
	}
	if s.MaintenancePolicy != nil {
		s.MaintenancePolicy.applyDefaults()
	}
	if s.AutomatedBackupConfig != nil {
		s.AutomatedBackupConfig.applyDefaults()
	}
}

func (s *GcpMemorystoreInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["instance_name"] = s.InstanceName
	m["location"] = s.Location
	m["shard_count"] = s.ShardCount
	if s.Mode != "" {
		m["mode"] = s.Mode
	}
	if s.NodeType != "" {
		m["node_type"] = s.NodeType
	}
	if s.EngineVersion != "" {
		m["engine_version"] = s.EngineVersion
	}
	if len(s.EngineConfigs) > 0 {
		m["engine_configs"] = s.EngineConfigs
	}
	if s.ReplicaCount != 0 {
		m["replica_count"] = s.ReplicaCount
	}
	if len(s.PscAutoConnections) > 0 {
		items := make([]any, len(s.PscAutoConnections))
		for i, v := range s.PscAutoConnections {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["psc_auto_connections"] = items
	}
	if s.AuthorizationMode != "" {
		m["authorization_mode"] = s.AuthorizationMode
	}
	if s.TransitEncryptionMode != "" {
		m["transit_encryption_mode"] = s.TransitEncryptionMode
	}
	if s.KmsKey != "" {
		m["kms_key"] = s.KmsKey
	}
	if s.PersistenceConfig != nil {
		m["persistence_config"] = s.PersistenceConfig.toMap()
	}
	if s.ZoneDistributionConfig != nil {
		m["zone_distribution_config"] = s.ZoneDistributionConfig.toMap()
	}
	if s.MaintenancePolicy != nil {
		m["maintenance_policy"] = s.MaintenancePolicy.toMap()
	}
	if s.AutomatedBackupConfig != nil {
		m["automated_backup_config"] = s.AutomatedBackupConfig.toMap()
	}
	if s.DeletionProtectionEnabled {
		m["deletion_protection_enabled"] = s.DeletionProtectionEnabled
	}
	return m
}

// GcpMemorystoreInstanceAofConfig controls Append-Only File persistence.
//
//	AOF logs every write operation, providing stronger durability guarantees
//	than RDB at the cost of higher I/O.
type GcpMemorystoreInstanceAofConfigInput struct {
	// How often the AOF buffer is flushed to disk.
	//  NEVER: OS decides (best performance, risk of data loss on crash).
	//  EVERY_SEC: flush once per second (good balance).
	//  ALWAYS: flush on every write (strongest durability, lowest performance).
	AppendFsync string `json:"append_fsync" jsonschema:"required,How often the AOF buffer is flushed to disk. NEVER: OS decides (best performance; risk of data loss on crash). EVERY_SEC: flush once per second (good balance). ALWAYS: flush on every write (strongest ..."`
}

func (s *GcpMemorystoreInstanceAofConfigInput) validate() error {
	if s.AppendFsync == "" {
		return fmt.Errorf("append_fsync is required")
	}
	return nil
}

func (s *GcpMemorystoreInstanceAofConfigInput) applyDefaults() {
}

func (s *GcpMemorystoreInstanceAofConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["append_fsync"] = s.AppendFsync
	return m
}

// GcpMemorystoreInstanceAutomatedBackupConfig configures scheduled backups
//
//	for the Memorystore instance. Backups are stored in a managed backup
//	collection and can be used to restore data.
type GcpMemorystoreInstanceAutomatedBackupConfigInput struct {
	// Hour of day (0-23, UTC) when the daily backup starts.
	StartHour int32 `json:"start_hour,omitempty" jsonschema:"Hour of day (0-23; UTC) when the daily backup starts."`
	// Backup retention duration in seconds.
	//  Minimum: 86400s (1 day). Maximum: 31536000s (365 days).
	//  Example: "3024000s" for 35 days.
	Retention string `json:"retention" jsonschema:"required,Backup retention duration in seconds. Minimum: 86400s (1 day). Maximum: 31536000s (365 days). Example: '3024000s' for 35 days."`
}

func (s *GcpMemorystoreInstanceAutomatedBackupConfigInput) validate() error {
	if s.Retention == "" {
		return fmt.Errorf("retention is required")
	}
	return nil
}

func (s *GcpMemorystoreInstanceAutomatedBackupConfigInput) applyDefaults() {
}

func (s *GcpMemorystoreInstanceAutomatedBackupConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.StartHour != 0 {
		m["start_hour"] = s.StartHour
	}
	m["retention"] = s.Retention
	return m
}

// GcpMemorystoreInstanceMaintenancePolicy defines the maintenance schedule
//
//	for the Memorystore instance.
type GcpMemorystoreInstanceMaintenancePolicyInput struct {
	// Weekly maintenance window schedule.
	WeeklyMaintenanceWindow *GcpMemorystoreInstanceMaintenanceWindowInput `json:"weekly_maintenance_window" jsonschema:"required,Weekly maintenance window schedule."`
}

func (s *GcpMemorystoreInstanceMaintenancePolicyInput) validate() error {
	if s.WeeklyMaintenanceWindow == nil {
		return fmt.Errorf("weekly_maintenance_window is required")
	}
	if s.WeeklyMaintenanceWindow != nil {
		if err := s.WeeklyMaintenanceWindow.validate(); err != nil {
			return fmt.Errorf("weekly_maintenance_window: %w", err)
		}
	}
	return nil
}

func (s *GcpMemorystoreInstanceMaintenancePolicyInput) applyDefaults() {
	if s.WeeklyMaintenanceWindow != nil {
		s.WeeklyMaintenanceWindow.applyDefaults()
	}
}

func (s *GcpMemorystoreInstanceMaintenancePolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.WeeklyMaintenanceWindow != nil {
		m["weekly_maintenance_window"] = s.WeeklyMaintenanceWindow.toMap()
	}
	return m
}

// GcpMemorystoreInstanceMaintenanceWindow defines when GCP may perform
//
//	maintenance on the instance. The window is fixed at 1 hour duration.
type GcpMemorystoreInstanceMaintenanceWindowInput struct {
	// Day of the week for the maintenance window.
	Day string `json:"day" jsonschema:"required,Day of the week for the maintenance window."`
	// Hour of day (0-23, UTC) when the maintenance window starts.
	Hour int32 `json:"hour,omitempty" jsonschema:"Hour of day (0-23; UTC) when the maintenance window starts."`
}

func (s *GcpMemorystoreInstanceMaintenanceWindowInput) validate() error {
	if s.Day == "" {
		return fmt.Errorf("day is required")
	}
	return nil
}

func (s *GcpMemorystoreInstanceMaintenanceWindowInput) applyDefaults() {
}

func (s *GcpMemorystoreInstanceMaintenanceWindowInput) toMap() map[string]any {
	m := make(map[string]any)
	m["day"] = s.Day
	if s.Hour != 0 {
		m["hour"] = s.Hour
	}
	return m
}

// GcpMemorystoreInstancePersistenceConfig controls data persistence for
//
//	the Memorystore instance. Persistence ensures data survives restarts
//	and failovers.
type GcpMemorystoreInstancePersistenceConfigInput struct {
	// Persistence mode.
	//  DISABLED: no persistence, data is in-memory only.
	//  RDB: periodic point-in-time snapshots.
	//  AOF: append-only file logging every write.
	Mode string `json:"mode" jsonschema:"required,Persistence mode. DISABLED: no persistence; data is in-memory only. RDB: periodic point-in-time snapshots. AOF: append-only file logging every write."`
	// RDB snapshot configuration. Required when mode is RDB.
	RdbConfig *GcpMemorystoreInstanceRdbConfigInput `json:"rdb_config,omitempty" jsonschema:"RDB snapshot configuration. Required when mode is RDB."`
	// AOF configuration. Required when mode is AOF.
	AofConfig *GcpMemorystoreInstanceAofConfigInput `json:"aof_config,omitempty" jsonschema:"AOF configuration. Required when mode is AOF."`
}

func (s *GcpMemorystoreInstancePersistenceConfigInput) validate() error {
	if s.Mode == "" {
		return fmt.Errorf("mode is required")
	}
	if s.RdbConfig != nil {
		if err := s.RdbConfig.validate(); err != nil {
			return fmt.Errorf("rdb_config: %w", err)
		}
	}
	if s.AofConfig != nil {
		if err := s.AofConfig.validate(); err != nil {
			return fmt.Errorf("aof_config: %w", err)
		}
	}
	return nil
}

func (s *GcpMemorystoreInstancePersistenceConfigInput) applyDefaults() {
	if s.RdbConfig != nil {
		s.RdbConfig.applyDefaults()
	}
	if s.AofConfig != nil {
		s.AofConfig.applyDefaults()
	}
}

func (s *GcpMemorystoreInstancePersistenceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["mode"] = s.Mode
	if s.RdbConfig != nil {
		m["rdb_config"] = s.RdbConfig.toMap()
	}
	if s.AofConfig != nil {
		m["aof_config"] = s.AofConfig.toMap()
	}
	return m
}

// GcpMemorystoreInstancePscAutoConnection defines a Private Service Connect
//
//	auto-created endpoint that connects the Memorystore instance to a consumer
//	VPC network. GCP creates and manages the PSC forwarding rules automatically.
//
//	At least one PSC connection is needed for applications to reach the instance.
//	Multiple connections can be defined for cross-project or multi-VPC access.
//	PSC connections are immutable after instance creation.
type GcpMemorystoreInstancePscAutoConnectionInput struct {
	// Consumer VPC network where the PSC endpoint will be created.
	//  Format: projects/{project_id}/global/networks/{network_id}
	Network string `json:"network" jsonschema:"required,Consumer VPC network where the PSC endpoint will be created. Format: projects/{project_id}/global/networks/{network_id}"`
	// Consumer project ID where the PSC endpoint will be created.
	//  Usually the same project as the Memorystore instance, but can differ
	//  for cross-project connectivity.
	ProjectId string `json:"project_id" jsonschema:"required,Consumer project ID where the PSC endpoint will be created. Usually the same project as the Memorystore instance; but can differ for cross-project connectivity."`
}

func (s *GcpMemorystoreInstancePscAutoConnectionInput) validate() error {
	if s.Network == "" {
		return fmt.Errorf("network is required")
	}
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	return nil
}

func (s *GcpMemorystoreInstancePscAutoConnectionInput) applyDefaults() {
}

func (s *GcpMemorystoreInstancePscAutoConnectionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["network"] = s.Network
	m["project_id"] = s.ProjectId
	return m
}

// GcpMemorystoreInstanceRdbConfig controls RDB snapshot persistence.
//
//	RDB creates point-in-time snapshots at a configurable interval.
type GcpMemorystoreInstanceRdbConfigInput struct {
	// How often RDB snapshots are taken.
	RdbSnapshotPeriod string `json:"rdb_snapshot_period" jsonschema:"required,How often RDB snapshots are taken."`
	// Optional RFC3339 timestamp for when to start the first snapshot.
	//  If not specified, GCP picks an appropriate time.
	RdbSnapshotStartTime string `json:"rdb_snapshot_start_time,omitempty" jsonschema:"Optional RFC3339 timestamp for when to start the first snapshot. If not specified; GCP picks an appropriate time."`
}

func (s *GcpMemorystoreInstanceRdbConfigInput) validate() error {
	if s.RdbSnapshotPeriod == "" {
		return fmt.Errorf("rdb_snapshot_period is required")
	}
	return nil
}

func (s *GcpMemorystoreInstanceRdbConfigInput) applyDefaults() {
}

func (s *GcpMemorystoreInstanceRdbConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["rdb_snapshot_period"] = s.RdbSnapshotPeriod
	if s.RdbSnapshotStartTime != "" {
		m["rdb_snapshot_start_time"] = s.RdbSnapshotStartTime
	}
	return m
}

// GcpMemorystoreInstanceZoneDistributionConfig controls how the instance
//
//	is distributed across availability zones within the region.
type GcpMemorystoreInstanceZoneDistributionConfigInput struct {
	// Zone distribution mode.
	//  MULTI_ZONE: nodes spread across multiple zones for high availability (default).
	//  SINGLE_ZONE: all nodes in a single zone for lowest latency.
	Mode string `json:"mode" jsonschema:"required,Zone distribution mode. MULTI_ZONE: nodes spread across multiple zones for high availability (default). SINGLE_ZONE: all nodes in a single zone for lowest latency."`
	// Zone for SINGLE_ZONE mode (e.g., "us-central1-a").
	//  Required when mode is SINGLE_ZONE. Ignored for MULTI_ZONE.
	Zone string `json:"zone,omitempty" jsonschema:"Zone for SINGLE_ZONE mode (e.g.; 'us-central1-a'). Required when mode is SINGLE_ZONE. Ignored for MULTI_ZONE."`
}

func (s *GcpMemorystoreInstanceZoneDistributionConfigInput) validate() error {
	if s.Mode == "" {
		return fmt.Errorf("mode is required")
	}
	return nil
}

func (s *GcpMemorystoreInstanceZoneDistributionConfigInput) applyDefaults() {
}

func (s *GcpMemorystoreInstanceZoneDistributionConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["mode"] = s.Mode
	if s.Zone != "" {
		m["zone"] = s.Zone
	}
	return m
}

// ParseGcpMemorystoreInstance validates and normalizes a GcpMemorystoreInstance cloud_object.
func ParseGcpMemorystoreInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpMemorystoreInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpMemorystoreInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
