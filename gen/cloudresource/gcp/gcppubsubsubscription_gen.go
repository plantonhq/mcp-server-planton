// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-pubsub-subscription
type GcpPubSubSubscriptionSpecInput struct {
	// GCP project where the subscription will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the subscription will be created."`
	// Name of the Pub/Sub subscription.
	//  Must be 3-255 characters, start with a letter, and contain only letters,
	//  numbers, hyphens, underscores, periods, tildes, plus signs, and percent signs.
	//  Immutable after creation.
	SubscriptionName string `json:"subscription_name" jsonschema:"required,Name of the Pub/Sub subscription. Must be 3-255 characters; start with a letter; and contain only letters; numbers; hyphens; underscores; periods; tildes; plus signs; and percent signs. Immutable afte..."`
	// The topic from which this subscription receives messages.
	//  Format: projects/{project}/topics/{name} or just the topic name if
	//  the topic is in the same project as the subscription.
	//  Immutable after creation.
	Topic string `json:"topic" jsonschema:"required,The topic from which this subscription receives messages. Format: projects/{project}/topics/{name} or just the topic name if the topic is in the same project as the subscription. Immutable after creat..."`
	// Maximum time (in seconds) after a subscriber receives a message before the
	//  subscriber should acknowledge the message. After the deadline expires,
	//  the message is redelivered.
	//  Range: 10 to 600 seconds. Defaults to 10 seconds.
	AckDeadlineSeconds int32 `json:"ack_deadline_seconds,omitempty" jsonschema:"Maximum time (in seconds) after a subscriber receives a message before the subscriber should acknowledge the message. After the deadline expires; the message is redelivered. Range: 10 to 600 seconds. ..."`
	// How long to retain unacknowledged messages in the subscription's backlog.
	//  If retain_acked_messages is true, this also controls retention of acknowledged
	//  messages and determines how far back a seek operation can go.
	//  Format: duration string (e.g., "604800s" for 7 days).
	//  Range: 600s (10 minutes) to...
	MessageRetentionDuration string `json:"message_retention_duration,omitempty" jsonschema:"How long to retain unacknowledged messages in the subscription's backlog. If retain_acked_messages is true; this also controls retention of acknowledged messages and determines how far back a seek ope..."`
	// When true, acknowledged messages are retained in the backlog until they
	//  fall out of the message_retention_duration window. Enables replay via seek.
	RetainAckedMessages bool `json:"retain_acked_messages,omitempty" jsonschema:"When true; acknowledged messages are retained in the backlog until they fall out of the message_retention_duration window. Enables replay via seek."`
	// Expiration policy for the subscription. Controls automatic deletion of
	//  inactive subscriptions. If not set, GCP defaults to 31 days TTL.
	ExpirationPolicy *GcpPubSubSubscriptionExpirationPolicyInput `json:"expiration_policy,omitempty" jsonschema:"Expiration policy for the subscription. Controls automatic deletion of inactive subscriptions. If not set; GCP defaults to 31 days TTL."`
	// Message attribute filter expression. Only messages matching the filter are
	//  delivered; non-matching messages are automatically acknowledged.
	//  Maximum length: 256 bytes. Immutable after creation.
	Filter string `json:"filter,omitempty" jsonschema:"Message attribute filter expression. Only messages matching the filter are delivered; non-matching messages are automatically acknowledged. Maximum length: 256 bytes. Immutable after creation."`
	// When true, messages with the same ordering key are delivered to subscribers
	//  in the order they were published. Immutable after creation.
	EnableMessageOrdering bool `json:"enable_message_ordering,omitempty" jsonschema:"When true; messages with the same ordering key are delivered to subscribers in the order they were published. Immutable after creation."`
	// When true, Pub/Sub guarantees that a message is not resent before its
	//  acknowledgement deadline expires. An acknowledged message will not be
	//  resent. Note: subscribers may still receive duplicates if the publisher
	//  sends the same message multiple times.
	EnableExactlyOnceDelivery bool `json:"enable_exactly_once_delivery,omitempty" jsonschema:"When true; Pub/Sub guarantees that a message is not resent before its acknowledgement deadline expires. An acknowledged message will not be resent. Note: subscribers may still receive duplicates if th..."`
	// Dead-letter policy. Messages that cannot be processed after repeated
	//  delivery attempts are forwarded to the configured dead-letter topic.
	DeadLetterPolicy *GcpPubSubSubscriptionDeadLetterPolicyInput `json:"dead_letter_policy,omitempty" jsonschema:"Dead-letter policy. Messages that cannot be processed after repeated delivery attempts are forwarded to the configured dead-letter topic."`
	// Retry policy. Controls the backoff between consecutive delivery attempts
	//  after a NACK or ack deadline exceeded event.
	RetryPolicy *GcpPubSubSubscriptionRetryPolicyInput `json:"retry_policy,omitempty" jsonschema:"Retry policy. Controls the backoff between consecutive delivery attempts after a NACK or ack deadline exceeded event."`
	// Push delivery configuration. When set, Pub/Sub sends messages as HTTP POST
	//  requests to the configured endpoint. Mutually exclusive with bigquery_config
	//  and cloud_storage_config.
	PushConfig *GcpPubSubSubscriptionPushConfigInput `json:"push_config,omitempty" jsonschema:"Push delivery configuration. When set; Pub/Sub sends messages as HTTP POST requests to the configured endpoint. Mutually exclusive with bigquery_config and cloud_storage_config."`
	// BigQuery delivery configuration. When set, Pub/Sub writes messages directly
	//  to a BigQuery table. Mutually exclusive with push_config and
	//  cloud_storage_config.
	BigqueryConfig *GcpPubSubSubscriptionBigQueryConfigInput `json:"bigquery_config,omitempty" jsonschema:"BigQuery delivery configuration. When set; Pub/Sub writes messages directly to a BigQuery table. Mutually exclusive with push_config and cloud_storage_config."`
	// Cloud Storage delivery configuration. When set, Pub/Sub writes messages to
	//  Cloud Storage objects in batches. Mutually exclusive with push_config and
	//  bigquery_config.
	CloudStorageConfig *GcpPubSubSubscriptionCloudStorageConfigInput `json:"cloud_storage_config,omitempty" jsonschema:"Cloud Storage delivery configuration. When set; Pub/Sub writes messages to Cloud Storage objects in batches. Mutually exclusive with push_config and bigquery_config."`
}

func (s *GcpPubSubSubscriptionSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.SubscriptionName == "" {
		return fmt.Errorf("subscription_name is required")
	}
	if s.Topic == "" {
		return fmt.Errorf("topic is required")
	}
	if s.ExpirationPolicy != nil {
		if err := s.ExpirationPolicy.validate(); err != nil {
			return fmt.Errorf("expiration_policy: %w", err)
		}
	}
	if s.DeadLetterPolicy != nil {
		if err := s.DeadLetterPolicy.validate(); err != nil {
			return fmt.Errorf("dead_letter_policy: %w", err)
		}
	}
	if s.RetryPolicy != nil {
		if err := s.RetryPolicy.validate(); err != nil {
			return fmt.Errorf("retry_policy: %w", err)
		}
	}
	if s.PushConfig != nil {
		if err := s.PushConfig.validate(); err != nil {
			return fmt.Errorf("push_config: %w", err)
		}
	}
	if s.BigqueryConfig != nil {
		if err := s.BigqueryConfig.validate(); err != nil {
			return fmt.Errorf("bigquery_config: %w", err)
		}
	}
	if s.CloudStorageConfig != nil {
		if err := s.CloudStorageConfig.validate(); err != nil {
			return fmt.Errorf("cloud_storage_config: %w", err)
		}
	}
	return nil
}

func (s *GcpPubSubSubscriptionSpecInput) applyDefaults() {
	if s.ExpirationPolicy != nil {
		s.ExpirationPolicy.applyDefaults()
	}
	if s.DeadLetterPolicy != nil {
		s.DeadLetterPolicy.applyDefaults()
	}
	if s.RetryPolicy != nil {
		s.RetryPolicy.applyDefaults()
	}
	if s.PushConfig != nil {
		s.PushConfig.applyDefaults()
	}
	if s.BigqueryConfig != nil {
		s.BigqueryConfig.applyDefaults()
	}
	if s.CloudStorageConfig != nil {
		s.CloudStorageConfig.applyDefaults()
	}
}

func (s *GcpPubSubSubscriptionSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["subscription_name"] = s.SubscriptionName
	m["topic"] = s.Topic
	if s.AckDeadlineSeconds != 0 {
		m["ack_deadline_seconds"] = s.AckDeadlineSeconds
	}
	if s.MessageRetentionDuration != "" {
		m["message_retention_duration"] = s.MessageRetentionDuration
	}
	if s.RetainAckedMessages {
		m["retain_acked_messages"] = s.RetainAckedMessages
	}
	if s.ExpirationPolicy != nil {
		m["expiration_policy"] = s.ExpirationPolicy.toMap()
	}
	if s.Filter != "" {
		m["filter"] = s.Filter
	}
	if s.EnableMessageOrdering {
		m["enable_message_ordering"] = s.EnableMessageOrdering
	}
	if s.EnableExactlyOnceDelivery {
		m["enable_exactly_once_delivery"] = s.EnableExactlyOnceDelivery
	}
	if s.DeadLetterPolicy != nil {
		m["dead_letter_policy"] = s.DeadLetterPolicy.toMap()
	}
	if s.RetryPolicy != nil {
		m["retry_policy"] = s.RetryPolicy.toMap()
	}
	if s.PushConfig != nil {
		m["push_config"] = s.PushConfig.toMap()
	}
	if s.BigqueryConfig != nil {
		m["bigquery_config"] = s.BigqueryConfig.toMap()
	}
	if s.CloudStorageConfig != nil {
		m["cloud_storage_config"] = s.CloudStorageConfig.toMap()
	}
	return m
}

// GcpPubSubSubscriptionBigQueryConfig configures delivery to a BigQuery table.
//
//	Each message is written as a row. Pub/Sub handles batching and streaming inserts.
//
//	Mutually exclusive with push_config and cloud_storage_config.
type GcpPubSubSubscriptionBigQueryConfigInput struct {
	// The BigQuery table to write messages to.
	//  Format: {project_id}.{dataset_id}.{table_id}
	Table string `json:"table" jsonschema:"required,The BigQuery table to write messages to. Format: {project_id}.{dataset_id}.{table_id}"`
	// When true, use the Pub/Sub topic's schema to map message fields to BigQuery columns.
	//  Only one of use_topic_schema and use_table_schema can be true.
	UseTopicSchema bool `json:"use_topic_schema,omitempty" jsonschema:"When true; use the Pub/Sub topic's schema to map message fields to BigQuery columns. Only one of use_topic_schema and use_table_schema can be true."`
	// When true, use the BigQuery table's schema to determine which message fields
	//  to write. Only one of use_topic_schema and use_table_schema can be true.
	UseTableSchema bool `json:"use_table_schema,omitempty" jsonschema:"When true; use the BigQuery table's schema to determine which message fields to write. Only one of use_topic_schema and use_table_schema can be true."`
	// When true (and use_topic_schema or use_table_schema is true), message fields
	//  not present in the BigQuery table schema are silently dropped. When false,
	//  messages with extra fields are not written and remain in the backlog.
	DropUnknownFields bool `json:"drop_unknown_fields,omitempty" jsonschema:"When true (and use_topic_schema or use_table_schema is true); message fields not present in the BigQuery table schema are silently dropped. When false; messages with extra fields are not written and r..."`
	// When true, the subscription name, messageId, publishTime, attributes, and
	//  orderingKey are written to additional columns in the BigQuery table.
	WriteMetadata bool `json:"write_metadata,omitempty" jsonschema:"When true; the subscription name; messageId; publishTime; attributes; and orderingKey are written to additional columns in the BigQuery table."`
	// Service account to use for writing to BigQuery. Defaults to the Pub/Sub
	//  service agent if not specified.
	ServiceAccountEmail string `json:"service_account_email,omitempty" jsonschema:"Service account to use for writing to BigQuery. Defaults to the Pub/Sub service agent if not specified."`
}

func (s *GcpPubSubSubscriptionBigQueryConfigInput) validate() error {
	if s.Table == "" {
		return fmt.Errorf("table is required")
	}
	return nil
}

func (s *GcpPubSubSubscriptionBigQueryConfigInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionBigQueryConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["table"] = s.Table
	if s.UseTopicSchema {
		m["use_topic_schema"] = s.UseTopicSchema
	}
	if s.UseTableSchema {
		m["use_table_schema"] = s.UseTableSchema
	}
	if s.DropUnknownFields {
		m["drop_unknown_fields"] = s.DropUnknownFields
	}
	if s.WriteMetadata {
		m["write_metadata"] = s.WriteMetadata
	}
	if s.ServiceAccountEmail != "" {
		m["service_account_email"] = s.ServiceAccountEmail
	}
	return m
}

// GcpPubSubSubscriptionCloudStorageConfig configures delivery to a Cloud Storage
//
//	bucket. Messages are batched and written as objects based on size, duration,
//	or message count thresholds.
//
//	Mutually exclusive with push_config and bigquery_config.
type GcpPubSubSubscriptionCloudStorageConfigInput struct {
	// The Cloud Storage bucket to write messages to (without "gs://" prefix).
	//  The bucket must already exist.
	Bucket string `json:"bucket" jsonschema:"required,The Cloud Storage bucket to write messages to (without 'gs://' prefix). The bucket must already exist."`
	// Prefix for Cloud Storage filenames.
	FilenamePrefix string `json:"filename_prefix,omitempty" jsonschema:"Prefix for Cloud Storage filenames."`
	// Suffix for Cloud Storage filenames. Must not end in "/".
	FilenameSuffix string `json:"filename_suffix,omitempty" jsonschema:"Suffix for Cloud Storage filenames. Must not end in '/'."`
	// Format string for datetime in Cloud Storage filenames.
	FilenameDatetimeFormat string `json:"filename_datetime_format,omitempty" jsonschema:"Format string for datetime in Cloud Storage filenames."`
	// Maximum bytes per Cloud Storage file before a new file is created.
	//  Range: 1024 (1 KB) to 10737418240 (10 GiB).
	MaxBytes int64 `json:"max_bytes,omitempty" jsonschema:"Maximum bytes per Cloud Storage file before a new file is created. Range: 1024 (1 KB) to 10737418240 (10 GiB)."`
	// Maximum duration before a new Cloud Storage file is created.
	//  Format: duration string (e.g., "300s").
	//  Range: 60s (1 minute) to 600s (10 minutes). Default: 300s (5 minutes).
	//  Must not exceed the subscription's ack_deadline_seconds.
	MaxDuration string `json:"max_duration,omitempty" jsonschema:"Maximum duration before a new Cloud Storage file is created. Format: duration string (e.g.; '300s'). Range: 60s (1 minute) to 600s (10 minutes). Default: 300s (5 minutes). Must not exceed the subscrip..."`
	// Maximum number of messages per Cloud Storage file. Minimum: 1000.
	MaxMessages int64 `json:"max_messages,omitempty" jsonschema:"Maximum number of messages per Cloud Storage file. Minimum: 1000."`
	// Avro format configuration. When set, messages are written in Avro format.
	//  If not set, messages are written in their raw format.
	AvroConfig *GcpPubSubSubscriptionCloudStorageConfigAvroConfigInput `json:"avro_config,omitempty" jsonschema:"Avro format configuration. When set; messages are written in Avro format. If not set; messages are written in their raw format."`
	// Service account to use for writing to Cloud Storage. Defaults to the Pub/Sub
	//  service agent if not specified.
	ServiceAccountEmail string `json:"service_account_email,omitempty" jsonschema:"Service account to use for writing to Cloud Storage. Defaults to the Pub/Sub service agent if not specified."`
}

func (s *GcpPubSubSubscriptionCloudStorageConfigInput) validate() error {
	if s.Bucket == "" {
		return fmt.Errorf("bucket is required")
	}
	if s.AvroConfig != nil {
		if err := s.AvroConfig.validate(); err != nil {
			return fmt.Errorf("avro_config: %w", err)
		}
	}
	return nil
}

func (s *GcpPubSubSubscriptionCloudStorageConfigInput) applyDefaults() {
	if s.AvroConfig != nil {
		s.AvroConfig.applyDefaults()
	}
}

func (s *GcpPubSubSubscriptionCloudStorageConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket"] = s.Bucket
	if s.FilenamePrefix != "" {
		m["filename_prefix"] = s.FilenamePrefix
	}
	if s.FilenameSuffix != "" {
		m["filename_suffix"] = s.FilenameSuffix
	}
	if s.FilenameDatetimeFormat != "" {
		m["filename_datetime_format"] = s.FilenameDatetimeFormat
	}
	if s.MaxBytes != 0 {
		m["max_bytes"] = s.MaxBytes
	}
	if s.MaxDuration != "" {
		m["max_duration"] = s.MaxDuration
	}
	if s.MaxMessages != 0 {
		m["max_messages"] = s.MaxMessages
	}
	if s.AvroConfig != nil {
		m["avro_config"] = s.AvroConfig.toMap()
	}
	if s.ServiceAccountEmail != "" {
		m["service_account_email"] = s.ServiceAccountEmail
	}
	return m
}

// GcpPubSubSubscriptionCloudStorageConfigAvroConfig configures Avro format
//
//	for Cloud Storage delivery.
type GcpPubSubSubscriptionCloudStorageConfigAvroConfigInput struct {
	// When true, serialize output using the topic schema.
	UseTopicSchema bool `json:"use_topic_schema,omitempty" jsonschema:"When true; serialize output using the topic schema."`
	// When true, include subscription name, messageId, publishTime, attributes,
	//  and orderingKey as additional fields in the Avro output.
	WriteMetadata bool `json:"write_metadata,omitempty" jsonschema:"When true; include subscription name; messageId; publishTime; attributes; and orderingKey as additional fields in the Avro output."`
}

func (s *GcpPubSubSubscriptionCloudStorageConfigAvroConfigInput) validate() error {
	return nil
}

func (s *GcpPubSubSubscriptionCloudStorageConfigAvroConfigInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionCloudStorageConfigAvroConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.UseTopicSchema {
		m["use_topic_schema"] = s.UseTopicSchema
	}
	if s.WriteMetadata {
		m["write_metadata"] = s.WriteMetadata
	}
	return m
}

// GcpPubSubSubscriptionDeadLetterPolicy configures dead-letter handling for
//
//	messages that cannot be processed after repeated delivery attempts. Messages
//	exceeding the maximum delivery attempts are forwarded to the dead-letter topic.
//
//	The Pub/Sub service account (service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com)
//	must have Subscriber permissions on this subscription and Publisher permissions
//	on the dead-letter topic.
type GcpPubSubSubscriptionDeadLetterPolicyInput struct {
	// The topic to which dead-letter messages are published.
	//  Format: projects/{project}/topics/{topic}
	DeadLetterTopic string `json:"dead_letter_topic,omitempty" jsonschema:"The topic to which dead-letter messages are published. Format: projects/{project}/topics/{topic}"`
	// Maximum number of delivery attempts before a message is dead-lettered.
	//  A delivery attempt is counted as 1 + (NACKs + ack deadline exceeded events).
	//  Range: 5 to 100. Defaults to 5 when set to 0.
	MaxDeliveryAttempts int32 `json:"max_delivery_attempts,omitempty" jsonschema:"Maximum number of delivery attempts before a message is dead-lettered. A delivery attempt is counted as 1 + (NACKs + ack deadline exceeded events). Range: 5 to 100. Defaults to 5 when set to 0."`
}

func (s *GcpPubSubSubscriptionDeadLetterPolicyInput) validate() error {
	return nil
}

func (s *GcpPubSubSubscriptionDeadLetterPolicyInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionDeadLetterPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DeadLetterTopic != "" {
		m["dead_letter_topic"] = s.DeadLetterTopic
	}
	if s.MaxDeliveryAttempts != 0 {
		m["max_delivery_attempts"] = s.MaxDeliveryAttempts
	}
	return m
}

// GcpPubSubSubscriptionExpirationPolicy configures when an inactive subscription
//
//	expires and is automatically deleted. A subscription is considered active when
//	any connected subscriber is successfully consuming messages or issuing operations.
//
//	If not set, GCP applies a default TTL of 31 days. Set ttl to an empty string
//	("") to create a subscription that never expires.
type GcpPubSubSubscriptionExpirationPolicyInput struct {
	// Duration after which the subscription expires if inactive.
	//  Format: duration string (e.g., "2592000s" for 30 days).
	//  Minimum: 86400s (1 day). Set to "" for a subscription that never expires.
	Ttl string `json:"ttl,omitempty" jsonschema:"Duration after which the subscription expires if inactive. Format: duration string (e.g.; '2592000s' for 30 days). Minimum: 86400s (1 day). Set to '' for a subscription that never expires."`
}

func (s *GcpPubSubSubscriptionExpirationPolicyInput) validate() error {
	return nil
}

func (s *GcpPubSubSubscriptionExpirationPolicyInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionExpirationPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Ttl != "" {
		m["ttl"] = s.Ttl
	}
	return m
}

// GcpPubSubSubscriptionPushConfig configures push delivery to an HTTPS endpoint.
//
//	Pub/Sub sends each message as an HTTP POST request to the configured endpoint.
//
//	Mutually exclusive with bigquery_config and cloud_storage_config.
//	If none of the three delivery configs are set, the subscription uses pull delivery.
type GcpPubSubSubscriptionPushConfigInput struct {
	// URL to which Pub/Sub pushes messages. Must use HTTPS.
	PushEndpoint string `json:"push_endpoint" jsonschema:"required,URL to which Pub/Sub pushes messages. Must use HTTPS."`
	// Endpoint configuration attributes. The supported attribute is "x-goog-version"
	//  which controls the push message format ("v1beta1" or "v1").
	Attributes map[string]string `json:"attributes,omitempty" jsonschema:"Endpoint configuration attributes. The supported attribute is 'x-goog-version' which controls the push message format ('v1beta1' or 'v1')."`
	// OIDC token configuration for authenticating push requests.
	OidcToken *GcpPubSubSubscriptionPushConfigOidcTokenInput `json:"oidc_token,omitempty" jsonschema:"OIDC token configuration for authenticating push requests."`
	// When set, the message payload is sent unwrapped (no Pub/Sub envelope).
	NoWrapper *GcpPubSubSubscriptionPushConfigNoWrapperInput `json:"no_wrapper,omitempty" jsonschema:"When set; the message payload is sent unwrapped (no Pub/Sub envelope)."`
}

func (s *GcpPubSubSubscriptionPushConfigInput) validate() error {
	if s.PushEndpoint == "" {
		return fmt.Errorf("push_endpoint is required")
	}
	if s.OidcToken != nil {
		if err := s.OidcToken.validate(); err != nil {
			return fmt.Errorf("oidc_token: %w", err)
		}
	}
	if s.NoWrapper != nil {
		if err := s.NoWrapper.validate(); err != nil {
			return fmt.Errorf("no_wrapper: %w", err)
		}
	}
	return nil
}

func (s *GcpPubSubSubscriptionPushConfigInput) applyDefaults() {
	if s.OidcToken != nil {
		s.OidcToken.applyDefaults()
	}
	if s.NoWrapper != nil {
		s.NoWrapper.applyDefaults()
	}
}

func (s *GcpPubSubSubscriptionPushConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["push_endpoint"] = s.PushEndpoint
	if len(s.Attributes) > 0 {
		m["attributes"] = s.Attributes
	}
	if s.OidcToken != nil {
		m["oidc_token"] = s.OidcToken.toMap()
	}
	if s.NoWrapper != nil {
		m["no_wrapper"] = s.NoWrapper.toMap()
	}
	return m
}

// GcpPubSubSubscriptionPushConfigNoWrapper configures unwrapped payload delivery.
//
//	When set, the raw message data is sent as the HTTP body without the standard
//	Pub/Sub message envelope. Useful for webhook integrations that expect
//	application-specific payloads.
type GcpPubSubSubscriptionPushConfigNoWrapperInput struct {
	// When true, Pub/Sub message metadata is written as HTTP headers
	//  (x-goog-pubsub-<key>:<value>) and message attributes as plain headers.
	WriteMetadata bool `json:"write_metadata,omitempty" jsonschema:"When true; Pub/Sub message metadata is written as HTTP headers (x-goog-pubsub-<key>:<value>) and message attributes as plain headers."`
}

func (s *GcpPubSubSubscriptionPushConfigNoWrapperInput) validate() error {
	return nil
}

func (s *GcpPubSubSubscriptionPushConfigNoWrapperInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionPushConfigNoWrapperInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.WriteMetadata {
		m["write_metadata"] = s.WriteMetadata
	}
	return m
}

// GcpPubSubSubscriptionPushConfigOidcToken configures OIDC-based authentication
//
//	for push deliveries. Pub/Sub generates a signed JWT and attaches it as an
//	Authorization header in each HTTP request to the push endpoint.
type GcpPubSubSubscriptionPushConfigOidcTokenInput struct {
	// Service account email used to generate the OIDC token.
	//  The caller must have iam.serviceAccounts.actAs permission on this account.
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,Service account email used to generate the OIDC token. The caller must have iam.serviceAccounts.actAs permission on this account."`
	// Audience claim for the OIDC token. Identifies the intended recipient.
	//  Defaults to the push endpoint URL if not specified.
	Audience string `json:"audience,omitempty" jsonschema:"Audience claim for the OIDC token. Identifies the intended recipient. Defaults to the push endpoint URL if not specified."`
}

func (s *GcpPubSubSubscriptionPushConfigOidcTokenInput) validate() error {
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	return nil
}

func (s *GcpPubSubSubscriptionPushConfigOidcTokenInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionPushConfigOidcTokenInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_account_email"] = s.ServiceAccountEmail
	if s.Audience != "" {
		m["audience"] = s.Audience
	}
	return m
}

// GcpPubSubSubscriptionRetryPolicy configures how Pub/Sub retries message
//
//	delivery after a NACK or acknowledgement deadline exceeded event. If not set,
//	messages are retried as soon as possible.
type GcpPubSubSubscriptionRetryPolicyInput struct {
	// Minimum delay between consecutive delivery attempts of a given message.
	//  Format: duration string (e.g., "10s").
	//  Range: 0s to 600s. Defaults to 10s.
	MinimumBackoff string `json:"minimum_backoff,omitempty" jsonschema:"Minimum delay between consecutive delivery attempts of a given message. Format: duration string (e.g.; '10s'). Range: 0s to 600s. Defaults to 10s."`
	// Maximum delay between consecutive delivery attempts of a given message.
	//  Format: duration string (e.g., "600s").
	//  Range: 0s to 600s. Defaults to 600s.
	MaximumBackoff string `json:"maximum_backoff,omitempty" jsonschema:"Maximum delay between consecutive delivery attempts of a given message. Format: duration string (e.g.; '600s'). Range: 0s to 600s. Defaults to 600s."`
}

func (s *GcpPubSubSubscriptionRetryPolicyInput) validate() error {
	return nil
}

func (s *GcpPubSubSubscriptionRetryPolicyInput) applyDefaults() {
}

func (s *GcpPubSubSubscriptionRetryPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinimumBackoff != "" {
		m["minimum_backoff"] = s.MinimumBackoff
	}
	if s.MaximumBackoff != "" {
		m["maximum_backoff"] = s.MaximumBackoff
	}
	return m
}

// ParseGcpPubSubSubscription validates and normalizes a GcpPubSubSubscription cloud_object.
func ParseGcpPubSubSubscription(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpPubSubSubscription"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpPubSubSubscriptionSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
