// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-gcs-bucket
type GcpGcsBucketSpecInput struct {
	// The ID of the GCP project where the storage bucket will be created.
	//  Can be a literal value or a reference to another resource (e.g., GcpProject).
	//  Required field.
	GcpProjectId string `json:"gcp_project_id" jsonschema:"required,The ID of the GCP project where the storage bucket will be created. Can be a literal value or a reference to another resource (e.g.; GcpProject). Required field."`
	// The location for the bucket. Can be a region (e.g., "us-east1"), dual-region (e.g., "NAM4"),
	//  or multi-region (e.g., "US", "EU", "ASIA").
	//  This field is immutable after bucket creation.
	//  Required field.
	Location string `json:"location" jsonschema:"required,The location for the bucket. Can be a region (e.g.; 'us-east1'); dual-region (e.g.; 'NAM4'); or multi-region (e.g.; 'US'; 'EU'; 'ASIA'). This field is immutable after bucket creation. Required field."`
	// Enable Uniform Bucket-Level Access (UBLA) for simplified IAM-only access control.
	//  When enabled, all access is controlled via IAM policies (no object ACLs).
	//  Recommended: true (modern security model).
	//  Defaults to true if not specified.
	UniformBucketLevelAccessEnabled bool `json:"uniform_bucket_level_access_enabled,omitempty" jsonschema:"Enable Uniform Bucket-Level Access (UBLA) for simplified IAM-only access control. When enabled; all access is controlled via IAM policies (no object ACLs). Recommended: true (modern security model). D..."`
	// Storage class for the bucket. Determines pricing and availability.
	//  Optional. Defaults to STANDARD if not specified.
	StorageClass string `json:"storage_class,omitempty" jsonschema:"enum=STANDARD|NEARLINE|COLDLINE|ARCHIVE,Storage class for the bucket. Determines pricing and availability. Optional. Defaults to STANDARD if not specified."`
	// Enable object versioning to protect against accidental deletion/overwrite.
	//  Versioning should be combined with lifecycle rules to prevent unbounded storage growth.
	//  Optional. Defaults to false.
	VersioningEnabled bool `json:"versioning_enabled,omitempty" jsonschema:"Enable object versioning to protect against accidental deletion/overwrite. Versioning should be combined with lifecycle rules to prevent unbounded storage growth. Optional. Defaults to false."`
	// Lifecycle rules for automatic object management (deletion, storage class transitions).
	//  Essential for cost optimization when versioning is enabled.
	//  Optional.
	LifecycleRules []*GcpGcsLifecycleRuleInput `json:"lifecycle_rules,omitempty" jsonschema:"Lifecycle rules for automatic object management (deletion; storage class transitions). Essential for cost optimization when versioning is enabled. Optional."`
	// IAM bindings for bucket-level access control.
	//  Each binding grants a specific role to a set of members.
	//  Required when UBLA is enabled for any public or service account access.
	//  Optional.
	IamBindings []*GcpGcsIamBindingInput `json:"iam_bindings,omitempty" jsonschema:"IAM bindings for bucket-level access control. Each binding grants a specific role to a set of members. Required when UBLA is enabled for any public or service account access. Optional."`
	// Encryption configuration using Customer-Managed Encryption Keys (CMEK).
	//  Optional. If not specified, Google-managed encryption is used (default).
	Encryption *GcpGcsEncryptionInput `json:"encryption,omitempty" jsonschema:"Encryption configuration using Customer-Managed Encryption Keys (CMEK). Optional. If not specified; Google-managed encryption is used (default)."`
	// CORS rules for cross-origin browser access.
	//  Required for buckets accessed directly from web browsers (e.g., font hosting, direct uploads).
	//  Optional.
	CorsRules []*GcpGcsCorsRuleInput `json:"cors_rules,omitempty" jsonschema:"CORS rules for cross-origin browser access. Required for buckets accessed directly from web browsers (e.g.; font hosting; direct uploads). Optional."`
	// Website configuration for static website hosting.
	//  Note: For production websites, use Cloud CDN + Load Balancer instead for HTTPS support.
	//  Optional.
	Website *GcpGcsWebsiteInput `json:"website,omitempty" jsonschema:"Website configuration for static website hosting. Note: For production websites; use Cloud CDN + Load Balancer instead for HTTPS support. Optional."`
	// Retention policy for WORM (Write Once, Read Many) compliance.
	//  Once locked, objects cannot be deleted until retention period expires.
	//  Optional.
	RetentionPolicy *GcpGcsRetentionPolicyInput `json:"retention_policy,omitempty" jsonschema:"Retention policy for WORM (Write Once; Read Many) compliance. Once locked; objects cannot be deleted until retention period expires. Optional."`
	// Enable requester pays mode. Requesters pay for data access and egress charges.
	//  Useful for public datasets where the bucket owner doesn't want to pay for all access costs.
	//  Optional. Defaults to false.
	RequesterPays bool `json:"requester_pays,omitempty" jsonschema:"Enable requester pays mode. Requesters pay for data access and egress charges. Useful for public datasets where the bucket owner doesn't want to pay for all access costs. Optional. Defaults to false."`
	// Logging configuration for legacy access logs.
	//  Note: Modern deployments should use Cloud Logging instead.
	//  Optional.
	Logging *GcpGcsLoggingInput `json:"logging,omitempty" jsonschema:"Logging configuration for legacy access logs. Note: Modern deployments should use Cloud Logging instead. Optional."`
	// Public access prevention policy.
	//  Values: "inherited" (default), "enforced" (prevent all public access).
	//  Recommended: "enforced" for private buckets to prevent accidental public exposure.
	//  Optional.
	PublicAccessPrevention string `json:"public_access_prevention,omitempty" jsonschema:"Public access prevention policy. Values: 'inherited' (default); 'enforced' (prevent all public access). Recommended: 'enforced' for private buckets to prevent accidental public exposure. Optional."`
	// Custom labels for the bucket (cost tracking, governance, compliance).
	//  These are merged with auto-generated labels (planton-cloud-resource-*).
	//  Optional.
	GcpLabels map[string]string `json:"gcp_labels,omitempty" jsonschema:"Custom labels for the bucket (cost tracking; governance; compliance). These are merged with auto-generated labels (planton-cloud-resource-*). Optional."`
	// Name of the GCS bucket to create in GCP.
	//  Must be globally unique across all GCP projects.
	//  Must be 3-63 characters, lowercase letters, numbers, hyphens, or dots.
	//  Must start and end with a lowercase letter or number.
	//  Cannot contain consecutive dots or be formatted as an IP address.
	//  Example: "my-b...
	BucketName string `json:"bucket_name" jsonschema:"required,Name of the GCS bucket to create in GCP. Must be globally unique across all GCP projects. Must be 3-63 characters; lowercase letters; numbers; hyphens; or dots. Must start and end with a lowercase let..."`
}

func (s *GcpGcsBucketSpecInput) validate() error {
	if s.GcpProjectId == "" {
		return fmt.Errorf("gcp_project_id is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	switch s.StorageClass {
	case "", "STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE":
	default:
		return fmt.Errorf("invalid storage_class: %q", s.StorageClass)
	}
	for i, v := range s.LifecycleRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("lifecycle_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.IamBindings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("iam_bindings[%d]: %w", i, err)
			}
		}
	}
	if s.Encryption != nil {
		if err := s.Encryption.validate(); err != nil {
			return fmt.Errorf("encryption: %w", err)
		}
	}
	for i, v := range s.CorsRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("cors_rules[%d]: %w", i, err)
			}
		}
	}
	if s.Website != nil {
		if err := s.Website.validate(); err != nil {
			return fmt.Errorf("website: %w", err)
		}
	}
	if s.RetentionPolicy != nil {
		if err := s.RetentionPolicy.validate(); err != nil {
			return fmt.Errorf("retention_policy: %w", err)
		}
	}
	if s.Logging != nil {
		if err := s.Logging.validate(); err != nil {
			return fmt.Errorf("logging: %w", err)
		}
	}
	if s.BucketName == "" {
		return fmt.Errorf("bucket_name is required")
	}
	return nil
}

func (s *GcpGcsBucketSpecInput) applyDefaults() {
	if s.Encryption != nil {
		s.Encryption.applyDefaults()
	}
	if s.Website != nil {
		s.Website.applyDefaults()
	}
	if s.RetentionPolicy != nil {
		s.RetentionPolicy.applyDefaults()
	}
	if s.Logging != nil {
		s.Logging.applyDefaults()
	}
}

func (s *GcpGcsBucketSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["gcp_project_id"] = s.GcpProjectId
	m["location"] = s.Location
	if s.UniformBucketLevelAccessEnabled {
		m["uniform_bucket_level_access_enabled"] = s.UniformBucketLevelAccessEnabled
	}
	if s.StorageClass != "" {
		m["storage_class"] = s.StorageClass
	}
	if s.VersioningEnabled {
		m["versioning_enabled"] = s.VersioningEnabled
	}
	if len(s.LifecycleRules) > 0 {
		items := make([]any, len(s.LifecycleRules))
		for i, v := range s.LifecycleRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["lifecycle_rules"] = items
	}
	if len(s.IamBindings) > 0 {
		items := make([]any, len(s.IamBindings))
		for i, v := range s.IamBindings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["iam_bindings"] = items
	}
	if s.Encryption != nil {
		m["encryption"] = s.Encryption.toMap()
	}
	if len(s.CorsRules) > 0 {
		items := make([]any, len(s.CorsRules))
		for i, v := range s.CorsRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["cors_rules"] = items
	}
	if s.Website != nil {
		m["website"] = s.Website.toMap()
	}
	if s.RetentionPolicy != nil {
		m["retention_policy"] = s.RetentionPolicy.toMap()
	}
	if s.RequesterPays {
		m["requester_pays"] = s.RequesterPays
	}
	if s.Logging != nil {
		m["logging"] = s.Logging.toMap()
	}
	if s.PublicAccessPrevention != "" {
		m["public_access_prevention"] = s.PublicAccessPrevention
	}
	if len(s.GcpLabels) > 0 {
		m["gcp_labels"] = s.GcpLabels
	}
	m["bucket_name"] = s.BucketName
	return m
}

// CORS rule for cross-origin browser access
type GcpGcsCorsRuleInput struct {
	// HTTP methods allowed for CORS requests
	Methods []string `json:"methods" jsonschema:"required,HTTP methods allowed for CORS requests"`
	// Origins allowed for CORS requests (e.g., "https://example.com")
	Origins []string `json:"origins" jsonschema:"required,Origins allowed for CORS requests (e.g.; 'https://example.com')"`
	// Response headers that browsers can access
	ResponseHeaders []string `json:"response_headers,omitempty" jsonschema:"Response headers that browsers can access"`
	// Maximum time (seconds) browsers can cache preflight responses
	MaxAgeSeconds int32 `json:"max_age_seconds,omitempty" jsonschema:"Maximum time (seconds) browsers can cache preflight responses"`
}

func (s *GcpGcsCorsRuleInput) validate() error {
	if len(s.Methods) == 0 {
		return fmt.Errorf("methods is required")
	}
	if len(s.Origins) == 0 {
		return fmt.Errorf("origins is required")
	}
	return nil
}

func (s *GcpGcsCorsRuleInput) applyDefaults() {
}

func (s *GcpGcsCorsRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["methods"] = s.Methods
	m["origins"] = s.Origins
	if len(s.ResponseHeaders) > 0 {
		m["response_headers"] = s.ResponseHeaders
	}
	if s.MaxAgeSeconds != 0 {
		m["max_age_seconds"] = s.MaxAgeSeconds
	}
	return m
}

// Customer-Managed Encryption Keys (CMEK) configuration
type GcpGcsEncryptionInput struct {
	// Cloud KMS key name for encryption
	//  Format: projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY
	KmsKeyName string `json:"kms_key_name" jsonschema:"required,Cloud KMS key name for encryption Format: projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY"`
}

func (s *GcpGcsEncryptionInput) validate() error {
	if s.KmsKeyName == "" {
		return fmt.Errorf("kms_key_name is required")
	}
	return nil
}

func (s *GcpGcsEncryptionInput) applyDefaults() {
}

func (s *GcpGcsEncryptionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["kms_key_name"] = s.KmsKeyName
	return m
}

// IAM binding for bucket-level access control
type GcpGcsIamBindingInput struct {
	// IAM role to grant (e.g., "roles/storage.objectViewer", "roles/storage.objectAdmin")
	Role string `json:"role" jsonschema:"required,IAM role to grant (e.g.; 'roles/storage.objectViewer'; 'roles/storage.objectAdmin')"`
	// List of members to grant the role to
	//  Format: "user:email", "group:email", "serviceAccount:email", "allUsers", "allAuthenticatedUsers"
	Members []string `json:"members" jsonschema:"required,List of members to grant the role to Format: 'user:email'; 'group:email'; 'serviceAccount:email'; 'allUsers'; 'allAuthenticatedUsers'"`
	// IAM condition expression (CEL syntax) for conditional access
	//  Optional. If not specified, binding applies unconditionally.
	Condition string `json:"condition,omitempty" jsonschema:"IAM condition expression (CEL syntax) for conditional access Optional. If not specified; binding applies unconditionally."`
}

func (s *GcpGcsIamBindingInput) validate() error {
	if s.Role == "" {
		return fmt.Errorf("role is required")
	}
	if len(s.Members) == 0 {
		return fmt.Errorf("members is required")
	}
	return nil
}

func (s *GcpGcsIamBindingInput) applyDefaults() {
}

func (s *GcpGcsIamBindingInput) toMap() map[string]any {
	m := make(map[string]any)
	m["role"] = s.Role
	m["members"] = s.Members
	if s.Condition != "" {
		m["condition"] = s.Condition
	}
	return m
}

// Lifecycle action (Delete or SetStorageClass)
type GcpGcsLifecycleActionInput struct {
	// Action type: "Delete" or "SetStorageClass"
	Type string `json:"type" jsonschema:"required,Action type: 'Delete' or 'SetStorageClass'"`
	// Storage class to transition to (only for SetStorageClass action)
	StorageClass string `json:"storage_class,omitempty" jsonschema:"enum=STANDARD|NEARLINE|COLDLINE|ARCHIVE,Storage class to transition to (only for SetStorageClass action)"`
}

func (s *GcpGcsLifecycleActionInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.StorageClass {
	case "", "STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE":
	default:
		return fmt.Errorf("invalid storage_class: %q", s.StorageClass)
	}
	return nil
}

func (s *GcpGcsLifecycleActionInput) applyDefaults() {
}

func (s *GcpGcsLifecycleActionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.StorageClass != "" {
		m["storage_class"] = s.StorageClass
	}
	return m
}

// Lifecycle condition (when to trigger the action)
type GcpGcsLifecycleConditionInput struct {
	// Age in days since object creation
	AgeDays int32 `json:"age_days,omitempty" jsonschema:"Age in days since object creation"`
	// RFC 3339 date before which objects should match
	CreatedBefore string `json:"created_before,omitempty" jsonschema:"RFC 3339 date before which objects should match"`
	// Match objects that are live (current version) or noncurrent
	IsLive bool `json:"is_live,omitempty" jsonschema:"Match objects that are live (current version) or noncurrent"`
	// Number of newer versions to keep (for version cleanup)
	NumNewerVersions int32 `json:"num_newer_versions,omitempty" jsonschema:"Number of newer versions to keep (for version cleanup)"`
	// Match only objects in these storage classes
	MatchesStorageClass []string `json:"matches_storage_class,omitempty" jsonschema:"Match only objects in these storage classes"`
}

func (s *GcpGcsLifecycleConditionInput) validate() error {
	return nil
}

func (s *GcpGcsLifecycleConditionInput) applyDefaults() {
}

func (s *GcpGcsLifecycleConditionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AgeDays != 0 {
		m["age_days"] = s.AgeDays
	}
	if s.CreatedBefore != "" {
		m["created_before"] = s.CreatedBefore
	}
	if s.IsLive {
		m["is_live"] = s.IsLive
	}
	if s.NumNewerVersions != 0 {
		m["num_newer_versions"] = s.NumNewerVersions
	}
	if len(s.MatchesStorageClass) > 0 {
		m["matches_storage_class"] = s.MatchesStorageClass
	}
	return m
}

// Lifecycle rule for automatic object management
type GcpGcsLifecycleRuleInput struct {
	// Action to take when conditions are met
	Action *GcpGcsLifecycleActionInput `json:"action" jsonschema:"required,Action to take when conditions are met"`
	// Condition that triggers the action
	Condition *GcpGcsLifecycleConditionInput `json:"condition" jsonschema:"required,Condition that triggers the action"`
}

func (s *GcpGcsLifecycleRuleInput) validate() error {
	if s.Action == nil {
		return fmt.Errorf("action is required")
	}
	if s.Action != nil {
		if err := s.Action.validate(); err != nil {
			return fmt.Errorf("action: %w", err)
		}
	}
	if s.Condition == nil {
		return fmt.Errorf("condition is required")
	}
	if s.Condition != nil {
		if err := s.Condition.validate(); err != nil {
			return fmt.Errorf("condition: %w", err)
		}
	}
	return nil
}

func (s *GcpGcsLifecycleRuleInput) applyDefaults() {
	if s.Action != nil {
		s.Action.applyDefaults()
	}
	if s.Condition != nil {
		s.Condition.applyDefaults()
	}
}

func (s *GcpGcsLifecycleRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Action != nil {
		m["action"] = s.Action.toMap()
	}
	if s.Condition != nil {
		m["condition"] = s.Condition.toMap()
	}
	return m
}

// Legacy access logging configuration
type GcpGcsLoggingInput struct {
	// Destination bucket for access logs
	LogBucket string `json:"log_bucket" jsonschema:"required,Destination bucket for access logs"`
	// Prefix for log object names
	LogObjectPrefix string `json:"log_object_prefix,omitempty" jsonschema:"Prefix for log object names"`
}

func (s *GcpGcsLoggingInput) validate() error {
	if s.LogBucket == "" {
		return fmt.Errorf("log_bucket is required")
	}
	return nil
}

func (s *GcpGcsLoggingInput) applyDefaults() {
}

func (s *GcpGcsLoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	m["log_bucket"] = s.LogBucket
	if s.LogObjectPrefix != "" {
		m["log_object_prefix"] = s.LogObjectPrefix
	}
	return m
}

// Retention policy for WORM compliance
type GcpGcsRetentionPolicyInput struct {
	// Minimum retention period in seconds
	RetentionPeriodSeconds int64 `json:"retention_period_seconds" jsonschema:"required,Minimum retention period in seconds"`
	// Lock the retention policy (irreversible operation!)
	//  Once locked, objects cannot be deleted until retention period expires.
	//  WARNING: This cannot be undone. Test thoroughly before locking.
	IsLocked bool `json:"is_locked,omitempty" jsonschema:"Lock the retention policy (irreversible operation!) Once locked; objects cannot be deleted until retention period expires. WARNING: This cannot be undone. Test thoroughly before locking."`
}

func (s *GcpGcsRetentionPolicyInput) validate() error {
	return nil
}

func (s *GcpGcsRetentionPolicyInput) applyDefaults() {
}

func (s *GcpGcsRetentionPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["retention_period_seconds"] = s.RetentionPeriodSeconds
	if s.IsLocked {
		m["is_locked"] = s.IsLocked
	}
	return m
}

// Static website hosting configuration
type GcpGcsWebsiteInput struct {
	// Main page suffix (e.g., "index.html")
	MainPageSuffix string `json:"main_page_suffix,omitempty" jsonschema:"Main page suffix (e.g.; 'index.html')"`
	// Custom 404 page (e.g., "404.html")
	NotFoundPage string `json:"not_found_page,omitempty" jsonschema:"Custom 404 page (e.g.; '404.html')"`
}

func (s *GcpGcsWebsiteInput) validate() error {
	return nil
}

func (s *GcpGcsWebsiteInput) applyDefaults() {
}

func (s *GcpGcsWebsiteInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MainPageSuffix != "" {
		m["main_page_suffix"] = s.MainPageSuffix
	}
	if s.NotFoundPage != "" {
		m["not_found_page"] = s.NotFoundPage
	}
	return m
}

// ParseGcpGcsBucket validates and normalizes a GcpGcsBucket cloud_object.
func ParseGcpGcsBucket(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpGcsBucket"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpGcsBucketSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
