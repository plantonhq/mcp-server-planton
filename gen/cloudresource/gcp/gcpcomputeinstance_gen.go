// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-compute-instance
type GcpComputeInstanceSpecInput struct {
	// GCP project ID where the Compute Engine instance will be created.
	//  Can be a literal value or a reference to a GcpProject resource.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project ID where the Compute Engine instance will be created. Can be a literal value or a reference to a GcpProject resource."`
	// Zone where the instance will be deployed, for example "us-central1-a".
	Zone string `json:"zone" jsonschema:"required,Zone where the instance will be deployed; for example 'us-central1-a'."`
	// Machine type for the instance, for example "e2-medium", "n1-standard-1", "n2-standard-2".
	MachineType string `json:"machine_type" jsonschema:"required,Machine type for the instance; for example 'e2-medium'; 'n1-standard-1'; 'n2-standard-2'."`
	// Boot disk configuration for the instance.
	BootDisk *GcpComputeInstanceBootDiskInput `json:"boot_disk" jsonschema:"required,Boot disk configuration for the instance."`
	// Network interface configurations for the instance.
	//  At least one network interface is required.
	NetworkInterfaces []*GcpComputeInstanceNetworkInterfaceInput `json:"network_interfaces" jsonschema:"required,Network interface configurations for the instance. At least one network interface is required."`
	// Additional attached disks (non-boot disks).
	AttachedDisks []*GcpComputeInstanceAttachedDiskInput `json:"attached_disks,omitempty" jsonschema:"Additional attached disks (non-boot disks)."`
	// Service account configuration for the instance.
	ServiceAccount *GcpComputeInstanceServiceAccountInput `json:"service_account,omitempty" jsonschema:"Service account configuration for the instance."`
	// Whether the instance should be preemptible (deprecated, use spot instead).
	Preemptible bool `json:"preemptible,omitempty" jsonschema:"Whether the instance should be preemptible (deprecated; use spot instead)."`
	// Whether the instance should be a Spot VM (cost-effective, can be preempted).
	Spot bool `json:"spot,omitempty" jsonschema:"Whether the instance should be a Spot VM (cost-effective; can be preempted)."`
	// Whether to enable deletion protection.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"Whether to enable deletion protection."`
	// Custom metadata key-value pairs for the instance.
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"Custom metadata key-value pairs for the instance."`
	// Labels to apply to the instance.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"Labels to apply to the instance."`
	// Network tags for firewall rules.
	Tags []string `json:"tags,omitempty" jsonschema:"Network tags for firewall rules."`
	// SSH keys for accessing the instance (in "username:ssh-key" format).
	SshKeys []string `json:"ssh_keys,omitempty" jsonschema:"SSH keys for accessing the instance (in 'username:ssh-key' format)."`
	// Startup script to run when the instance boots.
	StartupScript string `json:"startup_script,omitempty" jsonschema:"Startup script to run when the instance boots."`
	// Whether to allow stopping the instance for update operations.
	AllowStoppingForUpdate bool `json:"allow_stopping_for_update,omitempty" jsonschema:"Whether to allow stopping the instance for update operations."`
	// Scheduling configuration for the instance.
	Scheduling *GcpComputeInstanceSchedulingInput `json:"scheduling,omitempty" jsonschema:"Scheduling configuration for the instance."`
}

func (s *GcpComputeInstanceSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Zone == "" {
		return fmt.Errorf("zone is required")
	}
	if s.MachineType == "" {
		return fmt.Errorf("machine_type is required")
	}
	if s.BootDisk == nil {
		return fmt.Errorf("boot_disk is required")
	}
	if s.BootDisk != nil {
		if err := s.BootDisk.validate(); err != nil {
			return fmt.Errorf("boot_disk: %w", err)
		}
	}
	if len(s.NetworkInterfaces) == 0 {
		return fmt.Errorf("network_interfaces is required")
	}
	if len(s.NetworkInterfaces) < 1 {
		return fmt.Errorf("network_interfaces requires at least 1 items, got %d", len(s.NetworkInterfaces))
	}
	for i, v := range s.NetworkInterfaces {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("network_interfaces[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.AttachedDisks {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("attached_disks[%d]: %w", i, err)
			}
		}
	}
	if s.ServiceAccount != nil {
		if err := s.ServiceAccount.validate(); err != nil {
			return fmt.Errorf("service_account: %w", err)
		}
	}
	if s.Scheduling != nil {
		if err := s.Scheduling.validate(); err != nil {
			return fmt.Errorf("scheduling: %w", err)
		}
	}
	return nil
}

func (s *GcpComputeInstanceSpecInput) applyDefaults() {
	if s.BootDisk != nil {
		s.BootDisk.applyDefaults()
	}
	if s.ServiceAccount != nil {
		s.ServiceAccount.applyDefaults()
	}
	if s.Scheduling != nil {
		s.Scheduling.applyDefaults()
	}
}

func (s *GcpComputeInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["zone"] = s.Zone
	m["machine_type"] = s.MachineType
	if s.BootDisk != nil {
		m["boot_disk"] = s.BootDisk.toMap()
	}
	if len(s.NetworkInterfaces) > 0 {
		items := make([]any, len(s.NetworkInterfaces))
		for i, v := range s.NetworkInterfaces {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["network_interfaces"] = items
	}
	if len(s.AttachedDisks) > 0 {
		items := make([]any, len(s.AttachedDisks))
		for i, v := range s.AttachedDisks {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["attached_disks"] = items
	}
	if s.ServiceAccount != nil {
		m["service_account"] = s.ServiceAccount.toMap()
	}
	if s.Preemptible {
		m["preemptible"] = s.Preemptible
	}
	if s.Spot {
		m["spot"] = s.Spot
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if len(s.SshKeys) > 0 {
		m["ssh_keys"] = s.SshKeys
	}
	if s.StartupScript != "" {
		m["startup_script"] = s.StartupScript
	}
	if s.AllowStoppingForUpdate {
		m["allow_stopping_for_update"] = s.AllowStoppingForUpdate
	}
	if s.Scheduling != nil {
		m["scheduling"] = s.Scheduling.toMap()
	}
	return m
}

// GcpComputeInstanceAccessConfig defines external IP configuration.
type GcpComputeInstanceAccessConfigInput struct {
	// Type of access config (ONE_TO_ONE_NAT is the only supported type).
	NatIp string `json:"nat_ip,omitempty" jsonschema:"Type of access config (ONE_TO_ONE_NAT is the only supported type)."`
	// Network tier (PREMIUM or STANDARD).
	NetworkTier string `json:"network_tier,omitempty" jsonschema:"Network tier (PREMIUM or STANDARD)."`
}

func (s *GcpComputeInstanceAccessConfigInput) validate() error {
	return nil
}

func (s *GcpComputeInstanceAccessConfigInput) applyDefaults() {
}

func (s *GcpComputeInstanceAccessConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.NatIp != "" {
		m["nat_ip"] = s.NatIp
	}
	if s.NetworkTier != "" {
		m["network_tier"] = s.NetworkTier
	}
	return m
}

// GcpComputeInstanceAliasIpRange defines alias IP range for a network interface.
type GcpComputeInstanceAliasIpRangeInput struct {
	// IP CIDR range for alias IPs.
	IpCidrRange string `json:"ip_cidr_range" jsonschema:"required,IP CIDR range for alias IPs."`
	// Subnetwork range name (optional).
	SubnetworkRangeName string `json:"subnetwork_range_name,omitempty" jsonschema:"Subnetwork range name (optional)."`
}

func (s *GcpComputeInstanceAliasIpRangeInput) validate() error {
	if s.IpCidrRange == "" {
		return fmt.Errorf("ip_cidr_range is required")
	}
	return nil
}

func (s *GcpComputeInstanceAliasIpRangeInput) applyDefaults() {
}

func (s *GcpComputeInstanceAliasIpRangeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["ip_cidr_range"] = s.IpCidrRange
	if s.SubnetworkRangeName != "" {
		m["subnetwork_range_name"] = s.SubnetworkRangeName
	}
	return m
}

// GcpComputeInstanceAttachedDisk defines an additional disk attached to the instance.
type GcpComputeInstanceAttachedDiskInput struct {
	// Source disk self-link or name.
	Source string `json:"source" jsonschema:"required,Source disk self-link or name."`
	// Device name for the disk.
	DeviceName string `json:"device_name,omitempty" jsonschema:"Device name for the disk."`
	// Mode of the disk (READ_WRITE or READ_ONLY).
	Mode string `json:"mode,omitempty" jsonschema:"Mode of the disk (READ_WRITE or READ_ONLY)."`
}

func (s *GcpComputeInstanceAttachedDiskInput) validate() error {
	if s.Source == "" {
		return fmt.Errorf("source is required")
	}
	return nil
}

func (s *GcpComputeInstanceAttachedDiskInput) applyDefaults() {
}

func (s *GcpComputeInstanceAttachedDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	m["source"] = s.Source
	if s.DeviceName != "" {
		m["device_name"] = s.DeviceName
	}
	if s.Mode != "" {
		m["mode"] = s.Mode
	}
	return m
}

// GcpComputeInstanceBootDisk defines the boot disk configuration.
type GcpComputeInstanceBootDiskInput struct {
	// Source image for the boot disk (e.g., "debian-cloud/debian-11", "ubuntu-os-cloud/ubuntu-2204-lts").
	Image string `json:"image" jsonschema:"required,Source image for the boot disk (e.g.; 'debian-cloud/debian-11'; 'ubuntu-os-cloud/ubuntu-2204-lts')."`
	// Size of the boot disk in GB.
	SizeGb int32 `json:"size_gb,omitempty" jsonschema:"Size of the boot disk in GB."`
	// Type of the boot disk (e.g., "pd-standard", "pd-ssd", "pd-balanced").
	Type string `json:"type,omitempty" jsonschema:"Type of the boot disk (e.g.; 'pd-standard'; 'pd-ssd'; 'pd-balanced')."`
	// Whether to auto-delete the boot disk when the instance is deleted.
	AutoDelete bool `json:"auto_delete,omitempty" jsonschema:"Whether to auto-delete the boot disk when the instance is deleted."`
}

func (s *GcpComputeInstanceBootDiskInput) validate() error {
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	return nil
}

func (s *GcpComputeInstanceBootDiskInput) applyDefaults() {
}

func (s *GcpComputeInstanceBootDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	m["image"] = s.Image
	if s.SizeGb != 0 {
		m["size_gb"] = s.SizeGb
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.AutoDelete {
		m["auto_delete"] = s.AutoDelete
	}
	return m
}

// GcpComputeInstanceNetworkInterface defines a network interface configuration.
type GcpComputeInstanceNetworkInterfaceInput struct {
	// VPC network for this interface.
	//  Can be a literal value or a reference to a GcpVpc resource.
	Network string `json:"network,omitempty" jsonschema:"VPC network for this interface. Can be a literal value or a reference to a GcpVpc resource."`
	// Subnetwork for this interface.
	//  Can be a literal value or a reference to a GcpSubnetwork resource.
	Subnetwork string `json:"subnetwork,omitempty" jsonschema:"Subnetwork for this interface. Can be a literal value or a reference to a GcpSubnetwork resource."`
	// Access configurations for external IPs (NAT).
	//  If empty, the instance will not have an external IP.
	AccessConfigs []*GcpComputeInstanceAccessConfigInput `json:"access_configs,omitempty" jsonschema:"Access configurations for external IPs (NAT). If empty; the instance will not have an external IP."`
	// Alias IP ranges for this interface.
	AliasIpRanges []*GcpComputeInstanceAliasIpRangeInput `json:"alias_ip_ranges,omitempty" jsonschema:"Alias IP ranges for this interface."`
}

func (s *GcpComputeInstanceNetworkInterfaceInput) validate() error {
	for i, v := range s.AccessConfigs {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("access_configs[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.AliasIpRanges {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("alias_ip_ranges[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpComputeInstanceNetworkInterfaceInput) applyDefaults() {
}

func (s *GcpComputeInstanceNetworkInterfaceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Network != "" {
		m["network"] = s.Network
	}
	if s.Subnetwork != "" {
		m["subnetwork"] = s.Subnetwork
	}
	if len(s.AccessConfigs) > 0 {
		items := make([]any, len(s.AccessConfigs))
		for i, v := range s.AccessConfigs {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["access_configs"] = items
	}
	if len(s.AliasIpRanges) > 0 {
		items := make([]any, len(s.AliasIpRanges))
		for i, v := range s.AliasIpRanges {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["alias_ip_ranges"] = items
	}
	return m
}

// GcpComputeInstanceScheduling defines scheduling options for the instance.
type GcpComputeInstanceSchedulingInput struct {
	// Whether the instance is preemptible.
	Preemptible bool `json:"preemptible,omitempty" jsonschema:"Whether the instance is preemptible."`
	// Automatic restart policy on failure.
	AutomaticRestart bool `json:"automatic_restart,omitempty" jsonschema:"Automatic restart policy on failure."`
	// Behavior when host maintenance occurs (MIGRATE or TERMINATE).
	OnHostMaintenance string `json:"on_host_maintenance,omitempty" jsonschema:"Behavior when host maintenance occurs (MIGRATE or TERMINATE)."`
	// Provisioning model (STANDARD or SPOT).
	ProvisioningModel string `json:"provisioning_model,omitempty" jsonschema:"Provisioning model (STANDARD or SPOT)."`
	// Instance termination action for Spot VMs (STOP or DELETE).
	InstanceTerminationAction string `json:"instance_termination_action,omitempty" jsonschema:"Instance termination action for Spot VMs (STOP or DELETE)."`
}

func (s *GcpComputeInstanceSchedulingInput) validate() error {
	return nil
}

func (s *GcpComputeInstanceSchedulingInput) applyDefaults() {
}

func (s *GcpComputeInstanceSchedulingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Preemptible {
		m["preemptible"] = s.Preemptible
	}
	if s.AutomaticRestart {
		m["automatic_restart"] = s.AutomaticRestart
	}
	if s.OnHostMaintenance != "" {
		m["on_host_maintenance"] = s.OnHostMaintenance
	}
	if s.ProvisioningModel != "" {
		m["provisioning_model"] = s.ProvisioningModel
	}
	if s.InstanceTerminationAction != "" {
		m["instance_termination_action"] = s.InstanceTerminationAction
	}
	return m
}

// GcpComputeInstanceServiceAccount defines the service account configuration.
type GcpComputeInstanceServiceAccountInput struct {
	// Email of the service account to use.
	//  Can be a literal value or a reference to a GcpServiceAccount resource.
	//  If not specified, the default Compute Engine service account is used.
	Email string `json:"email,omitempty" jsonschema:"Email of the service account to use. Can be a literal value or a reference to a GcpServiceAccount resource. If not specified; the default Compute Engine service account is used."`
	// List of OAuth scopes for the service account.
	//  Common scopes: "https://www.googleapis.com/auth/cloud-platform"
	Scopes []string `json:"scopes,omitempty" jsonschema:"List of OAuth scopes for the service account. Common scopes: 'https://www.googleapis.com/auth/cloud-platform'"`
}

func (s *GcpComputeInstanceServiceAccountInput) validate() error {
	return nil
}

func (s *GcpComputeInstanceServiceAccountInput) applyDefaults() {
}

func (s *GcpComputeInstanceServiceAccountInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Email != "" {
		m["email"] = s.Email
	}
	if len(s.Scopes) > 0 {
		m["scopes"] = s.Scopes
	}
	return m
}

// ParseGcpComputeInstance validates and normalizes a GcpComputeInstance cloud_object.
func ParseGcpComputeInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpComputeInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpComputeInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
