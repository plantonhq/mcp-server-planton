// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-tasks-queue
type GcpCloudTasksQueueSpecInput struct {
	// GCP project where the queue will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the queue will be created."`
	// Name of the Cloud Tasks queue.
	//  Must start with a letter, contain only letters, numbers, and hyphens,
	//  and be between 1 and 63 characters.
	//  Immutable after creation.
	QueueName string `json:"queue_name" jsonschema:"required,Name of the Cloud Tasks queue. Must start with a letter; contain only letters; numbers; and hyphens; and be between 1 and 63 characters. Immutable after creation."`
	// GCP region where the queue will be created (e.g., "us-central1").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,GCP region where the queue will be created (e.g.; 'us-central1'). Immutable after creation."`
	// Desired state of the queue. Controls whether tasks are actively dispatched.
	//  RUNNING: Tasks are dispatched normally (default).
	//  PAUSED: Tasks are held in the queue without being dispatched. New tasks
	//    can still be added. Resume by setting back to RUNNING.
	DesiredState string `json:"desired_state,omitempty" jsonschema:"Desired state of the queue. Controls whether tasks are actively dispatched. RUNNING: Tasks are dispatched normally (default). PAUSED: Tasks are held in the queue without being dispatched. New tasks ca..."`
	// Queue-level HTTP target configuration. When set, these settings apply
	//  to all HTTP tasks dispatched from this queue, overriding task-level
	//  HTTP configuration.
	//
	//  This is the recommended pattern for microservices: configure auth and
	//  routing at the queue level, then enqueue tasks with just a request ...
	HttpTarget *GcpCloudTasksQueueHttpTargetInput `json:"http_target,omitempty" jsonschema:"Queue-level HTTP target configuration. When set; these settings apply to all HTTP tasks dispatched from this queue; overriding task-level HTTP configuration. This is the recommended pattern for micros..."`
	// Rate limits for task dispatches. Controls how fast and how many tasks
	//  are dispatched concurrently.
	RateLimits *GcpCloudTasksQueueRateLimitsInput `json:"rate_limits,omitempty" jsonschema:"Rate limits for task dispatches. Controls how fast and how many tasks are dispatched concurrently."`
	// Retry configuration for failed task attempts. Controls backoff behavior,
	//  maximum attempts, and retry duration.
	RetryConfig *GcpCloudTasksQueueRetryConfigInput `json:"retry_config,omitempty" jsonschema:"Retry configuration for failed task attempts. Controls backoff behavior; maximum attempts; and retry duration."`
	// Cloud Logging configuration for task dispatch operations.
	StackdriverLoggingConfig *GcpCloudTasksQueueLoggingConfigInput `json:"stackdriver_logging_config,omitempty" jsonschema:"Cloud Logging configuration for task dispatch operations."`
}

func (s *GcpCloudTasksQueueSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.QueueName == "" {
		return fmt.Errorf("queue_name is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.HttpTarget != nil {
		if err := s.HttpTarget.validate(); err != nil {
			return fmt.Errorf("http_target: %w", err)
		}
	}
	if s.RateLimits != nil {
		if err := s.RateLimits.validate(); err != nil {
			return fmt.Errorf("rate_limits: %w", err)
		}
	}
	if s.RetryConfig != nil {
		if err := s.RetryConfig.validate(); err != nil {
			return fmt.Errorf("retry_config: %w", err)
		}
	}
	if s.StackdriverLoggingConfig != nil {
		if err := s.StackdriverLoggingConfig.validate(); err != nil {
			return fmt.Errorf("stackdriver_logging_config: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudTasksQueueSpecInput) applyDefaults() {
	if s.HttpTarget != nil {
		s.HttpTarget.applyDefaults()
	}
	if s.RateLimits != nil {
		s.RateLimits.applyDefaults()
	}
	if s.RetryConfig != nil {
		s.RetryConfig.applyDefaults()
	}
	if s.StackdriverLoggingConfig != nil {
		s.StackdriverLoggingConfig.applyDefaults()
	}
}

func (s *GcpCloudTasksQueueSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["queue_name"] = s.QueueName
	m["location"] = s.Location
	if s.DesiredState != "" {
		m["desired_state"] = s.DesiredState
	}
	if s.HttpTarget != nil {
		m["http_target"] = s.HttpTarget.toMap()
	}
	if s.RateLimits != nil {
		m["rate_limits"] = s.RateLimits.toMap()
	}
	if s.RetryConfig != nil {
		m["retry_config"] = s.RetryConfig.toMap()
	}
	if s.StackdriverLoggingConfig != nil {
		m["stackdriver_logging_config"] = s.StackdriverLoggingConfig.toMap()
	}
	return m
}

// GcpCloudTasksQueueHttpHeaderOverride defines a single HTTP header key-value pair
//
//	that overrides task-level headers for all tasks dispatched from this queue.
type GcpCloudTasksQueueHttpHeaderOverrideInput struct {
	// The header field name.
	Key string `json:"key" jsonschema:"required,The header field name."`
	// The header field value.
	Value string `json:"value" jsonschema:"required,The header field value."`
}

func (s *GcpCloudTasksQueueHttpHeaderOverrideInput) validate() error {
	if s.Key == "" {
		return fmt.Errorf("key is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *GcpCloudTasksQueueHttpHeaderOverrideInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueHttpHeaderOverrideInput) toMap() map[string]any {
	m := make(map[string]any)
	m["key"] = s.Key
	m["value"] = s.Value
	return m
}

// GcpCloudTasksQueueHttpTarget configures queue-level HTTP target settings that
//
//	apply to all HTTP tasks in this queue. These settings override task-level
//	HTTP configuration when specified.
//
//	This is the modern pattern for Cloud Tasks: configure queue-level auth and
//	routing, then enqueue tasks with just a body. Ideal for microservices where
//	all tasks in a queue target the same Cloud Run / Cloud Functions endpoint.
type GcpCloudTasksQueueHttpTargetInput struct {
	// HTTP method override for all tasks in this queue.
	//  When specified, overrides the method on individual tasks.
	//  Note: if set to GET, the task body is ignored at execution time.
	//  Valid values: "POST", "GET", "HEAD", "PUT", "DELETE", "PATCH", "OPTIONS".
	HttpMethod string `json:"http_method,omitempty" jsonschema:"HTTP method override for all tasks in this queue. When specified; overrides the method on individual tasks. Note: if set to GET; the task body is ignored at execution time. Valid values: 'POST'; 'GET'..."`
	// HTTP headers to set on all tasks dispatched from this queue.
	//  These headers override any task-level headers with the same key.
	//  Header size must be less than 80KB total.
	HeaderOverrides []*GcpCloudTasksQueueHttpHeaderOverrideInput `json:"header_overrides,omitempty" jsonschema:"HTTP headers to set on all tasks dispatched from this queue. These headers override any task-level headers with the same key. Header size must be less than 80KB total."`
	// OAuth2 access token configuration for authenticating HTTP task requests.
	//  Use for calling Google APIs on *.googleapis.com.
	//  Mutually exclusive with oidc_token.
	OauthToken *GcpCloudTasksQueueOAuthTokenInput `json:"oauth_token,omitempty" jsonschema:"OAuth2 access token configuration for authenticating HTTP task requests. Use for calling Google APIs on *.googleapis.com. Mutually exclusive with oidc_token."`
	// OIDC token configuration for authenticating HTTP task requests.
	//  Use for calling Cloud Run, Cloud Functions, or custom endpoints.
	//  Mutually exclusive with oauth_token.
	OidcToken *GcpCloudTasksQueueOidcTokenInput `json:"oidc_token,omitempty" jsonschema:"OIDC token configuration for authenticating HTTP task requests. Use for calling Cloud Run; Cloud Functions; or custom endpoints. Mutually exclusive with oauth_token."`
	// URI override settings. When specified, modifies the URI of all tasks
	//  dispatched from this queue before dispatch.
	UriOverride *GcpCloudTasksQueueUriOverrideInput `json:"uri_override,omitempty" jsonschema:"URI override settings. When specified; modifies the URI of all tasks dispatched from this queue before dispatch."`
}

func (s *GcpCloudTasksQueueHttpTargetInput) validate() error {
	for i, v := range s.HeaderOverrides {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("header_overrides[%d]: %w", i, err)
			}
		}
	}
	if s.OauthToken != nil {
		if err := s.OauthToken.validate(); err != nil {
			return fmt.Errorf("oauth_token: %w", err)
		}
	}
	if s.OidcToken != nil {
		if err := s.OidcToken.validate(); err != nil {
			return fmt.Errorf("oidc_token: %w", err)
		}
	}
	if s.UriOverride != nil {
		if err := s.UriOverride.validate(); err != nil {
			return fmt.Errorf("uri_override: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudTasksQueueHttpTargetInput) applyDefaults() {
	if s.OauthToken != nil {
		s.OauthToken.applyDefaults()
	}
	if s.OidcToken != nil {
		s.OidcToken.applyDefaults()
	}
	if s.UriOverride != nil {
		s.UriOverride.applyDefaults()
	}
}

func (s *GcpCloudTasksQueueHttpTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.HttpMethod != "" {
		m["http_method"] = s.HttpMethod
	}
	if len(s.HeaderOverrides) > 0 {
		items := make([]any, len(s.HeaderOverrides))
		for i, v := range s.HeaderOverrides {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["header_overrides"] = items
	}
	if s.OauthToken != nil {
		m["oauth_token"] = s.OauthToken.toMap()
	}
	if s.OidcToken != nil {
		m["oidc_token"] = s.OidcToken.toMap()
	}
	if s.UriOverride != nil {
		m["uri_override"] = s.UriOverride.toMap()
	}
	return m
}

// GcpCloudTasksQueueLoggingConfig configures Cloud Logging for task dispatch
//
//	operations. Controls the fraction of operations written to Stackdriver Logging.
type GcpCloudTasksQueueLoggingConfigInput struct {
	// Fraction of operations to log. Must be between 0.0 and 1.0 inclusive.
	//  0.0 means no logging (default), 1.0 means log every dispatch operation.
	SamplingRatio float64 `json:"sampling_ratio,omitempty" jsonschema:"Fraction of operations to log. Must be between 0.0 and 1.0 inclusive. 0.0 means no logging (default); 1.0 means log every dispatch operation."`
}

func (s *GcpCloudTasksQueueLoggingConfigInput) validate() error {
	return nil
}

func (s *GcpCloudTasksQueueLoggingConfigInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueLoggingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SamplingRatio != 0 {
		m["sampling_ratio"] = s.SamplingRatio
	}
	return m
}

// GcpCloudTasksQueueOAuthToken configures OAuth2 access token generation for
//
//	queue-level HTTP task authentication. Use this when calling Google APIs
//	hosted on *.googleapis.com.
//
//	Both service_account_email and scope MUST be specified when using
//	queue-level authorization override.
type GcpCloudTasksQueueOAuthTokenInput struct {
	// Service account email to generate the OAuth token.
	//  The service account must be within the same project as the queue.
	//  The caller must have iam.serviceAccounts.actAs on this service account.
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,Service account email to generate the OAuth token. The service account must be within the same project as the queue. The caller must have iam.serviceAccounts.actAs on this service account."`
	// OAuth scope for the generated access token.
	//  If not specified, defaults to "https://www.googleapis.com/auth/cloud-platform".
	Scope string `json:"scope,omitempty" jsonschema:"OAuth scope for the generated access token. If not specified; defaults to 'https://www.googleapis.com/auth/cloud-platform'."`
}

func (s *GcpCloudTasksQueueOAuthTokenInput) validate() error {
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	return nil
}

func (s *GcpCloudTasksQueueOAuthTokenInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueOAuthTokenInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_account_email"] = s.ServiceAccountEmail
	if s.Scope != "" {
		m["scope"] = s.Scope
	}
	return m
}

// GcpCloudTasksQueueOidcToken configures OIDC token generation for queue-level
//
//	HTTP task authentication. Use this for calling Cloud Run, Cloud Functions,
//	or any endpoint where you validate the token yourself.
//
//	Both service_account_email and audience MUST be specified when using
//	queue-level authorization override.
type GcpCloudTasksQueueOidcTokenInput struct {
	// Service account email to generate the OIDC token.
	//  The service account must be within the same project as the queue.
	//  The caller must have iam.serviceAccounts.actAs on this service account.
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,Service account email to generate the OIDC token. The service account must be within the same project as the queue. The caller must have iam.serviceAccounts.actAs on this service account."`
	// Audience for the generated OIDC token.
	//  If not specified, the URI specified in the target will be used.
	Audience string `json:"audience,omitempty" jsonschema:"Audience for the generated OIDC token. If not specified; the URI specified in the target will be used."`
}

func (s *GcpCloudTasksQueueOidcTokenInput) validate() error {
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	return nil
}

func (s *GcpCloudTasksQueueOidcTokenInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueOidcTokenInput) toMap() map[string]any {
	m := make(map[string]any)
	m["service_account_email"] = s.ServiceAccountEmail
	if s.Audience != "" {
		m["audience"] = s.Audience
	}
	return m
}

// GcpCloudTasksQueueRateLimits controls the rate at which tasks are dispatched
//
//	from the queue. The actual dispatch rate is determined by the combination of
//	these settings, the number of tasks in the queue, and system throttling
//	(429/503 responses, high error rates, traffic smoothing).
//
//	Note: max_burst_size is computed by GCP from max_dispatches_per_second
//	and is NOT configurable. It is reported in stack outputs instead.
type GcpCloudTasksQueueRateLimitsInput struct {
	// Maximum rate at which tasks are dispatched from this queue (tasks/second).
	//  If unspecified, Cloud Tasks picks a default based on queue configuration.
	MaxDispatchesPerSecond float64 `json:"max_dispatches_per_second,omitempty" jsonschema:"Maximum rate at which tasks are dispatched from this queue (tasks/second). If unspecified; Cloud Tasks picks a default based on queue configuration."`
	// Maximum number of concurrent tasks that Cloud Tasks allows to be
	//  dispatched for this queue. After this threshold, Cloud Tasks stops
	//  dispatching until the concurrency drops.
	//  If unspecified, Cloud Tasks picks a default.
	MaxConcurrentDispatches int32 `json:"max_concurrent_dispatches,omitempty" jsonschema:"Maximum number of concurrent tasks that Cloud Tasks allows to be dispatched for this queue. After this threshold; Cloud Tasks stops dispatching until the concurrency drops. If unspecified; Cloud Tasks..."`
}

func (s *GcpCloudTasksQueueRateLimitsInput) validate() error {
	return nil
}

func (s *GcpCloudTasksQueueRateLimitsInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueRateLimitsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MaxDispatchesPerSecond != 0 {
		m["max_dispatches_per_second"] = s.MaxDispatchesPerSecond
	}
	if s.MaxConcurrentDispatches != 0 {
		m["max_concurrent_dispatches"] = s.MaxConcurrentDispatches
	}
	return m
}

// GcpCloudTasksQueueRetryConfig controls retry behavior for failed task attempts.
//
//	A task is retried between min_backoff and max_backoff after it fails, with
//	exponential backoff that doubles max_doublings times before becoming linear.
type GcpCloudTasksQueueRetryConfigInput struct {
	// Number of attempts per task. Includes the first attempt.
	//  Must be >= -1. Set to -1 for unlimited attempts.
	//  If unspecified, Cloud Tasks picks a default.
	MaxAttempts int32 `json:"max_attempts,omitempty" jsonschema:"Number of attempts per task. Includes the first attempt. Must be >= -1. Set to -1 for unlimited attempts. If unspecified; Cloud Tasks picks a default."`
	// Maximum time limit for retrying a failed task, measured from the first attempt.
	//  Once elapsed, no further attempts are made regardless of max_attempts.
	//  Set to "0s" for unlimited retry duration.
	//  Format: duration string (e.g., "3600s" for 1 hour).
	MaxRetryDuration string `json:"max_retry_duration,omitempty" jsonschema:"Maximum time limit for retrying a failed task; measured from the first attempt. Once elapsed; no further attempts are made regardless of max_attempts. Set to '0s' for unlimited retry duration. Format:..."`
	// Minimum wait time between retry attempts.
	//  Format: duration string (e.g., "0.100s" for 100ms).
	MinBackoff string `json:"min_backoff,omitempty" jsonschema:"Minimum wait time between retry attempts. Format: duration string (e.g.; '0.100s' for 100ms)."`
	// Maximum wait time between retry attempts.
	//  Format: duration string (e.g., "3600s" for 1 hour).
	MaxBackoff string `json:"max_backoff,omitempty" jsonschema:"Maximum wait time between retry attempts. Format: duration string (e.g.; '3600s' for 1 hour)."`
	// The number of times the retry interval doubles before becoming constant.
	//  The retry interval starts at min_backoff, doubles max_doublings times,
	//  then increases linearly until reaching max_backoff.
	MaxDoublings int32 `json:"max_doublings,omitempty" jsonschema:"The number of times the retry interval doubles before becoming constant. The retry interval starts at min_backoff; doubles max_doublings times; then increases linearly until reaching max_backoff."`
}

func (s *GcpCloudTasksQueueRetryConfigInput) validate() error {
	return nil
}

func (s *GcpCloudTasksQueueRetryConfigInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueRetryConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MaxAttempts != 0 {
		m["max_attempts"] = s.MaxAttempts
	}
	if s.MaxRetryDuration != "" {
		m["max_retry_duration"] = s.MaxRetryDuration
	}
	if s.MinBackoff != "" {
		m["min_backoff"] = s.MinBackoff
	}
	if s.MaxBackoff != "" {
		m["max_backoff"] = s.MaxBackoff
	}
	if s.MaxDoublings != 0 {
		m["max_doublings"] = s.MaxDoublings
	}
	return m
}

// GcpCloudTasksQueueUriOverride defines URI override settings that apply to all
//
//	HTTP tasks dispatched from this queue. Individual task URIs are modified
//	according to these overrides before dispatch.
//
//	Flattened from the Terraform/Pulumi nested structure for clarity:
//	path_override.path -> path, query_override.query_params -> query_params.
type GcpCloudTasksQueueUriOverrideInput struct {
	// Scheme override. Replaces the task URI scheme with HTTP or HTTPS.
	//  Valid values: "HTTP", "HTTPS".
	Scheme string `json:"scheme,omitempty" jsonschema:"Scheme override. Replaces the task URI scheme with HTTP or HTTPS. Valid values: 'HTTP'; 'HTTPS'."`
	// Host override. Replaces the host part of the task URL.
	//  For example, if the task URL is "https://www.google.com" and host is
	//  "example.net", the overridden URI becomes "https://example.net".
	//  Must not be empty when set (INVALID_ARGUMENT).
	Host string `json:"host,omitempty" jsonschema:"Host override. Replaces the host part of the task URL. For example; if the task URL is 'https://www.google.com' and host is 'example.net'; the overridden URI becomes 'https://example.net'. Must not be..."`
	// Port override. Replaces the port part of the task URI.
	//  Must be a positive integer. Setting to "0" clears the URI port.
	Port string `json:"port,omitempty" jsonschema:"Port override. Replaces the port part of the task URI. Must be a positive integer. Setting to '0' clears the URI port."`
	// Path override. Replaces the existing path of the task URL.
	//  Setting to an empty string clears the URI path segment.
	Path string `json:"path,omitempty" jsonschema:"Path override. Replaces the existing path of the task URL. Setting to an empty string clears the URI path segment."`
	// Query parameters override. Replaces the query part of the task URI.
	//  For example: "qparam1=123&qparam2=456".
	//  Setting to an empty string clears the URI query segment.
	QueryParams string `json:"query_params,omitempty" jsonschema:"Query parameters override. Replaces the query part of the task URI. For example: 'qparam1=123&qparam2=456'. Setting to an empty string clears the URI query segment."`
	// URI Override Enforce Mode.
	//  ALWAYS: Always override the task URI (default).
	//  IF_NOT_EXISTS: Only apply the override if the task does not already have
	//  the corresponding URI component set.
	EnforceMode string `json:"enforce_mode,omitempty" jsonschema:"URI Override Enforce Mode. ALWAYS: Always override the task URI (default). IF_NOT_EXISTS: Only apply the override if the task does not already have the corresponding URI component set."`
}

func (s *GcpCloudTasksQueueUriOverrideInput) validate() error {
	return nil
}

func (s *GcpCloudTasksQueueUriOverrideInput) applyDefaults() {
}

func (s *GcpCloudTasksQueueUriOverrideInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Scheme != "" {
		m["scheme"] = s.Scheme
	}
	if s.Host != "" {
		m["host"] = s.Host
	}
	if s.Port != "" {
		m["port"] = s.Port
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.QueryParams != "" {
		m["query_params"] = s.QueryParams
	}
	if s.EnforceMode != "" {
		m["enforce_mode"] = s.EnforceMode
	}
	return m
}

// ParseGcpCloudTasksQueue validates and normalizes a GcpCloudTasksQueue cloud_object.
func ParseGcpCloudTasksQueue(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudTasksQueue"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudTasksQueueSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
