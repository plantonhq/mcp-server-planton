// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-function
type GcpCloudFunctionSpecInput struct {
	// GCP project ID where the Cloud Function will be created.
	//  Supports either a literal value or a reference to another resource's output.
	//  Example literal: {value: "my-gcp-project-123"}
	//  Example reference: {value_from: {kind: GcpProject, name: "main-project", field_path: "status.outputs.project_id"}}
	ProjectId string `json:"project_id" jsonschema:"required,GCP project ID where the Cloud Function will be created. Supports either a literal value or a reference to another resource's output. Example literal: {value: 'my-gcp-project-123'} Example reference: ..."`
	// Region where the function is deployed, for example "us-central1" or "europe-west1".
	Region string `json:"region" jsonschema:"required,Region where the function is deployed; for example 'us-central1' or 'europe-west1'."`
	// Name of the Cloud Function. If not specified, defaults to metadata.name.
	//  Must be 1-63 characters, start with a letter, and contain only lowercase letters,
	//  numbers, and hyphens.
	FunctionName string `json:"function_name,omitempty" jsonschema:"Name of the Cloud Function. If not specified; defaults to metadata.name. Must be 1-63 characters; start with a letter; and contain only lowercase letters; numbers; and hyphens."`
	// Build configuration for the function (runtime, entry point, source code).
	BuildConfig *GcpCloudFunctionBuildConfigInput `json:"build_config" jsonschema:"required,Build configuration for the function (runtime; entry point; source code)."`
	// Service configuration (compute resources, networking, environment, scaling).
	ServiceConfig *GcpCloudFunctionServiceConfigInput `json:"service_config,omitempty" jsonschema:"Service configuration (compute resources; networking; environment; scaling)."`
	// Trigger configuration. If not specified, defaults to HTTP trigger.
	Trigger *GcpCloudFunctionTriggerInput `json:"trigger,omitempty" jsonschema:"Trigger configuration. If not specified; defaults to HTTP trigger."`
}

func (s *GcpCloudFunctionSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.BuildConfig == nil {
		return fmt.Errorf("build_config is required")
	}
	if s.BuildConfig != nil {
		if err := s.BuildConfig.validate(); err != nil {
			return fmt.Errorf("build_config: %w", err)
		}
	}
	if s.ServiceConfig != nil {
		if err := s.ServiceConfig.validate(); err != nil {
			return fmt.Errorf("service_config: %w", err)
		}
	}
	if s.Trigger != nil {
		if err := s.Trigger.validate(); err != nil {
			return fmt.Errorf("trigger: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudFunctionSpecInput) applyDefaults() {
	if s.BuildConfig != nil {
		s.BuildConfig.applyDefaults()
	}
	if s.ServiceConfig != nil {
		s.ServiceConfig.applyDefaults()
	}
	if s.Trigger != nil {
		s.Trigger.applyDefaults()
	}
}

func (s *GcpCloudFunctionSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["region"] = s.Region
	if s.FunctionName != "" {
		m["function_name"] = s.FunctionName
	}
	if s.BuildConfig != nil {
		m["build_config"] = s.BuildConfig.toMap()
	}
	if s.ServiceConfig != nil {
		m["service_config"] = s.ServiceConfig.toMap()
	}
	if s.Trigger != nil {
		m["trigger"] = s.Trigger.toMap()
	}
	return m
}

// GcpCloudFunctionBuildConfig defines how the function is built from source code.
type GcpCloudFunctionBuildConfigInput struct {
	// Runtime environment for the function. Must be a supported Gen 2 runtime.
	//  Examples: "python311", "python312", "nodejs20", "nodejs22", "go121", "go122",
	//  "java17", "java21", "dotnet6", "dotnet8", "ruby32", "php82".
	//  Only current, non-deprecated runtimes should be used in production.
	Runtime string `json:"runtime" jsonschema:"required,Runtime environment for the function. Must be a supported Gen 2 runtime. Examples: 'python311'; 'python312'; 'nodejs20'; 'nodejs22'; 'go121'; 'go122'; 'java17'; 'java21'; 'dotnet6'; 'dotnet8'; 'ruby32..."`
	// Name of the function in source code that will be executed (the entry point).
	//  For example: "hello_http" in Python, "helloHttp" in Node.js.
	EntryPoint string `json:"entry_point" jsonschema:"required,Name of the function in source code that will be executed (the entry point). For example: 'hello_http' in Python; 'helloHttp' in Node.js."`
	// Source code location in Google Cloud Storage.
	Source *GcpCloudFunctionSourceInput `json:"source" jsonschema:"required,Source code location in Google Cloud Storage."`
	// Environment variables set at build time. These are available during the build
	//  process (e.g., for customizing buildpack behavior).
	BuildEnvironmentVariables map[string]string `json:"build_environment_variables,omitempty" jsonschema:"Environment variables set at build time. These are available during the build process (e.g.; for customizing buildpack behavior)."`
}

func (s *GcpCloudFunctionBuildConfigInput) validate() error {
	if s.Runtime == "" {
		return fmt.Errorf("runtime is required")
	}
	if s.EntryPoint == "" {
		return fmt.Errorf("entry_point is required")
	}
	if s.Source == nil {
		return fmt.Errorf("source is required")
	}
	if s.Source != nil {
		if err := s.Source.validate(); err != nil {
			return fmt.Errorf("source: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudFunctionBuildConfigInput) applyDefaults() {
	if s.Source != nil {
		s.Source.applyDefaults()
	}
}

func (s *GcpCloudFunctionBuildConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["runtime"] = s.Runtime
	m["entry_point"] = s.EntryPoint
	if s.Source != nil {
		m["source"] = s.Source.toMap()
	}
	if len(s.BuildEnvironmentVariables) > 0 {
		m["build_environment_variables"] = s.BuildEnvironmentVariables
	}
	return m
}

// GcpCloudFunctionEventFilter filters events based on attribute values.
type GcpCloudFunctionEventFilterInput struct {
	// Attribute name to filter on (e.g., "bucket" for Storage events).
	Attribute string `json:"attribute" jsonschema:"required,Attribute name to filter on (e.g.; 'bucket' for Storage events)."`
	// Value to match. Supports wildcards (*) for pattern matching.
	Value string `json:"value" jsonschema:"required,Value to match. Supports wildcards (*) for pattern matching."`
	// Optional: Operator for matching. Defaults to exact match.
	//  Supports "match-path-pattern" for Firestore document path patterns.
	Operator string `json:"operator,omitempty" jsonschema:"Optional: Operator for matching. Defaults to exact match. Supports 'match-path-pattern' for Firestore document path patterns."`
}

func (s *GcpCloudFunctionEventFilterInput) validate() error {
	if s.Attribute == "" {
		return fmt.Errorf("attribute is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *GcpCloudFunctionEventFilterInput) applyDefaults() {
}

func (s *GcpCloudFunctionEventFilterInput) toMap() map[string]any {
	m := make(map[string]any)
	m["attribute"] = s.Attribute
	m["value"] = s.Value
	if s.Operator != "" {
		m["operator"] = s.Operator
	}
	return m
}

// GcpCloudFunctionEventTrigger defines event-driven triggers (Pub/Sub, Storage, Firestore, etc.).
type GcpCloudFunctionEventTriggerInput struct {
	// Event type that triggers the function. Uses CloudEvents format.
	//  Common examples:
	//  - "google.cloud.pubsub.topic.v1.messagePublished" (Pub/Sub)
	//  - "google.cloud.storage.object.v1.finalized" (Storage object created)
	//  - "google.cloud.storage.object.v1.deleted" (Storage object deleted)
	//  - "google.cloud....
	EventType string `json:"event_type" jsonschema:"required,Event type that triggers the function. Uses CloudEvents format. Common examples: - 'google.cloud.pubsub.topic.v1.messagePublished' (Pub/Sub) - 'google.cloud.storage.object.v1.finalized' (Storage objec..."`
	// Pub/Sub topic resource name for Pub/Sub triggers.
	//  Format: "projects/{project}/topics/{topic-name}".
	//  Required for Pub/Sub event types.
	PubsubTopic string `json:"pubsub_topic,omitempty" jsonschema:"Pub/Sub topic resource name for Pub/Sub triggers. Format: 'projects/{project}/topics/{topic-name}'. Required for Pub/Sub event types."`
	// Event filters. Used to filter events based on attributes.
	//  For Storage triggers, filter by bucket: attribute="bucket" value="my-bucket".
	//  For Firestore triggers, filter by document path pattern.
	EventFilters []*GcpCloudFunctionEventFilterInput `json:"event_filters,omitempty" jsonschema:"Event filters. Used to filter events based on attributes. For Storage triggers; filter by bucket: attribute='bucket' value='my-bucket'. For Firestore triggers; filter by document path pattern."`
	// Region where the event trigger listens for events. Should typically match
	//  the function region for optimal performance and data locality.
	TriggerRegion string `json:"trigger_region,omitempty" jsonschema:"Region where the event trigger listens for events. Should typically match the function region for optimal performance and data locality."`
	// Retry policy for event delivery. If RETRY_POLICY_RETRY, failed invocations
	//  are automatically retried. If RETRY_POLICY_DO_NOT_RETRY, events are delivered once.
	RetryPolicy string `json:"retry_policy,omitempty" jsonschema:"enum=RETRY_POLICY_RETRY,Retry policy for event delivery. If RETRY_POLICY_RETRY; failed invocations are automatically retried. If RETRY_POLICY_DO_NOT_RETRY; events are delivered once."`
	// Service account used by Eventarc to invoke the function.
	//  If not specified, uses the default Eventarc service account.
	ServiceAccountEmail string `json:"service_account_email,omitempty" jsonschema:"Service account used by Eventarc to invoke the function. If not specified; uses the default Eventarc service account."`
}

func (s *GcpCloudFunctionEventTriggerInput) validate() error {
	if s.EventType == "" {
		return fmt.Errorf("event_type is required")
	}
	for i, v := range s.EventFilters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("event_filters[%d]: %w", i, err)
			}
		}
	}
	switch s.RetryPolicy {
	case "", "RETRY_POLICY_RETRY":
	default:
		return fmt.Errorf("invalid retry_policy: %q", s.RetryPolicy)
	}
	return nil
}

func (s *GcpCloudFunctionEventTriggerInput) applyDefaults() {
}

func (s *GcpCloudFunctionEventTriggerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["event_type"] = s.EventType
	if s.PubsubTopic != "" {
		m["pubsub_topic"] = s.PubsubTopic
	}
	if len(s.EventFilters) > 0 {
		items := make([]any, len(s.EventFilters))
		for i, v := range s.EventFilters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["event_filters"] = items
	}
	if s.TriggerRegion != "" {
		m["trigger_region"] = s.TriggerRegion
	}
	if s.RetryPolicy != "" {
		m["retry_policy"] = s.RetryPolicy
	}
	if s.ServiceAccountEmail != "" {
		m["service_account_email"] = s.ServiceAccountEmail
	}
	return m
}

// GcpCloudFunctionScalingConfig defines auto-scaling behavior: min/max instances.
type GcpCloudFunctionScalingConfigInput struct {
	// Minimum number of instances to keep warm. Setting min_instance_count > 0
	//  eliminates cold starts but incurs cost for idle compute.
	//  Use for latency-sensitive, production workloads.
	MinInstanceCount int32 `json:"min_instance_count,omitempty" jsonschema:"Minimum number of instances to keep warm. Setting min_instance_count > 0 eliminates cold starts but incurs cost for idle compute. Use for latency-sensitive; production workloads."`
	// Maximum number of instances. Controls cost and concurrency.
	//  Set to limit maximum scale-out and prevent runaway costs.
	MaxInstanceCount int32 `json:"max_instance_count,omitempty" jsonschema:"Maximum number of instances. Controls cost and concurrency. Set to limit maximum scale-out and prevent runaway costs."`
}

func (s *GcpCloudFunctionScalingConfigInput) validate() error {
	return nil
}

func (s *GcpCloudFunctionScalingConfigInput) applyDefaults() {
}

func (s *GcpCloudFunctionScalingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinInstanceCount != 0 {
		m["min_instance_count"] = s.MinInstanceCount
	}
	if s.MaxInstanceCount != 0 {
		m["max_instance_count"] = s.MaxInstanceCount
	}
	return m
}

// GcpCloudFunctionServiceConfig defines runtime configuration: compute resources,
//
//	networking, environment, secrets, and scaling behavior.
type GcpCloudFunctionServiceConfigInput struct {
	// Service account email that the function runs as. This is the identity the function
	//  uses when calling other GCP services. Should follow least-privilege principle.
	//  If not specified, uses the default Compute Engine service account (not recommended
	//  for production due to overly broad permissions).
	ServiceAccountEmail string `json:"service_account_email,omitempty" jsonschema:"Service account email that the function runs as. This is the identity the function uses when calling other GCP services. Should follow least-privilege principle. If not specified; uses the default Com..."`
	// Memory allocated to each function instance in megabytes.
	//  Valid values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768.
	//  Higher memory allocation also increases CPU allocation.
	AvailableMemoryMb int32 `json:"available_memory_mb,omitempty" jsonschema:"Memory allocated to each function instance in megabytes. Valid values: 128; 256; 512; 1024; 2048; 4096; 8192; 16384; 32768. Higher memory allocation also increases CPU allocation."`
	// Timeout for function execution in seconds.
	//  Gen 2 HTTP functions support up to 3600 seconds (60 minutes).
	//  Event-driven functions typically use shorter timeouts.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Timeout for function execution in seconds. Gen 2 HTTP functions support up to 3600 seconds (60 minutes). Event-driven functions typically use shorter timeouts."`
	// Maximum number of concurrent requests that each function instance can handle.
	//  Gen 2 supports up to 1000 concurrent requests per instance.
	//  Higher concurrency reduces the number of instances needed, improving efficiency.
	MaxInstanceRequestConcurrency int32 `json:"max_instance_request_concurrency,omitempty" jsonschema:"Maximum number of concurrent requests that each function instance can handle. Gen 2 supports up to 1000 concurrent requests per instance. Higher concurrency reduces the number of instances needed; imp..."`
	// Environment variables injected into the function runtime as plain-text KEY=VALUE pairs.
	//  Use for non-sensitive configuration. For sensitive values, use secret_environment_variables.
	EnvironmentVariables map[string]string `json:"environment_variables,omitempty" jsonschema:"Environment variables injected into the function runtime as plain-text KEY=VALUE pairs. Use for non-sensitive configuration. For sensitive values; use secret_environment_variables."`
	// Secret Manager references injected as environment variables.
	//  Format: KEY=secret_name where secret_name is the Secret Manager secret ID.
	//  The version "latest" is used automatically unless specified otherwise in the secret name.
	SecretEnvironmentVariables map[string]string `json:"secret_environment_variables,omitempty" jsonschema:"Secret Manager references injected as environment variables. Format: KEY=secret_name where secret_name is the Secret Manager secret ID. The version 'latest' is used automatically unless specified othe..."`
	// VPC connector for accessing resources in a VPC network (e.g., Cloud SQL, Memorystore).
	//  Format: "projects/{project}/locations/{region}/connectors/{connector-name}".
	//  The connector must exist before deploying the function.
	VpcConnector string `json:"vpc_connector,omitempty" jsonschema:"VPC connector for accessing resources in a VPC network (e.g.; Cloud SQL; Memorystore). Format: 'projects/{project}/locations/{region}/connectors/{connector-name}'. The connector must exist before depl..."`
	// Egress settings for VPC connectivity.
	//  Determines which traffic is routed through the VPC connector.
	VpcConnectorEgressSettings string `json:"vpc_connector_egress_settings,omitempty" jsonschema:"enum=ALL_TRAFFIC,Egress settings for VPC connectivity. Determines which traffic is routed through the VPC connector."`
	// Ingress settings control who can invoke the function.
	//  Use ALLOW_INTERNAL_ONLY for private functions accessible only within the VPC/project.
	IngressSettings string `json:"ingress_settings,omitempty" jsonschema:"enum=ALLOW_INTERNAL_ONLY|ALLOW_INTERNAL_AND_GCLB,Ingress settings control who can invoke the function. Use ALLOW_INTERNAL_ONLY for private functions accessible only within the VPC/project."`
	// Scaling configuration: minimum and maximum number of function instances.
	Scaling *GcpCloudFunctionScalingConfigInput `json:"scaling,omitempty" jsonschema:"Scaling configuration: minimum and maximum number of function instances."`
	// If true, makes the function publicly invokable by unauthenticated users.
	//  Grants the Cloud Run Invoker role to allUsers.
	//  For private functions, set to false and explicitly grant invoker role to specific identities.
	AllowUnauthenticated bool `json:"allow_unauthenticated,omitempty" jsonschema:"If true; makes the function publicly invokable by unauthenticated users. Grants the Cloud Run Invoker role to allUsers. For private functions; set to false and explicitly grant invoker role to specifi..."`
}

func (s *GcpCloudFunctionServiceConfigInput) validate() error {
	switch s.VpcConnectorEgressSettings {
	case "", "ALL_TRAFFIC":
	default:
		return fmt.Errorf("invalid vpc_connector_egress_settings: %q", s.VpcConnectorEgressSettings)
	}
	switch s.IngressSettings {
	case "", "ALLOW_INTERNAL_ONLY", "ALLOW_INTERNAL_AND_GCLB":
	default:
		return fmt.Errorf("invalid ingress_settings: %q", s.IngressSettings)
	}
	if s.Scaling != nil {
		if err := s.Scaling.validate(); err != nil {
			return fmt.Errorf("scaling: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudFunctionServiceConfigInput) applyDefaults() {
	if s.Scaling != nil {
		s.Scaling.applyDefaults()
	}
}

func (s *GcpCloudFunctionServiceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ServiceAccountEmail != "" {
		m["service_account_email"] = s.ServiceAccountEmail
	}
	if s.AvailableMemoryMb != 0 {
		m["available_memory_mb"] = s.AvailableMemoryMb
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.MaxInstanceRequestConcurrency != 0 {
		m["max_instance_request_concurrency"] = s.MaxInstanceRequestConcurrency
	}
	if len(s.EnvironmentVariables) > 0 {
		m["environment_variables"] = s.EnvironmentVariables
	}
	if len(s.SecretEnvironmentVariables) > 0 {
		m["secret_environment_variables"] = s.SecretEnvironmentVariables
	}
	if s.VpcConnector != "" {
		m["vpc_connector"] = s.VpcConnector
	}
	if s.VpcConnectorEgressSettings != "" {
		m["vpc_connector_egress_settings"] = s.VpcConnectorEgressSettings
	}
	if s.IngressSettings != "" {
		m["ingress_settings"] = s.IngressSettings
	}
	if s.Scaling != nil {
		m["scaling"] = s.Scaling.toMap()
	}
	if s.AllowUnauthenticated {
		m["allow_unauthenticated"] = s.AllowUnauthenticated
	}
	return m
}

// GcpCloudFunctionSource specifies where the source code is stored.
//
//	Gen 2 Cloud Functions require source code in a GCS bucket (Cloud Source Repositories
//	was deprecated for new customers in June 2024).
type GcpCloudFunctionSourceInput struct {
	// GCS bucket name containing the source code archive.
	//  The bucket must be in the same project or accessible to the Cloud Build service account.
	Bucket string `json:"bucket" jsonschema:"required,GCS bucket name containing the source code archive. The bucket must be in the same project or accessible to the Cloud Build service account."`
	// Object name (path) of the source code archive in the bucket.
	//  Should be a .zip file containing the function code and dependencies.
	//  Example: "functions/my-function-v1.2.3.zip"
	Object string `json:"object" jsonschema:"required,Object name (path) of the source code archive in the bucket. Should be a .zip file containing the function code and dependencies. Example: 'functions/my-function-v1.2.3.zip'"`
	// Optional: Generation number of the object. If specified, the function will use
	//  this specific version of the object. If not specified, uses the latest version.
	Generation int64 `json:"generation,omitempty" jsonschema:"Optional: Generation number of the object. If specified; the function will use this specific version of the object. If not specified; uses the latest version."`
}

func (s *GcpCloudFunctionSourceInput) validate() error {
	if s.Bucket == "" {
		return fmt.Errorf("bucket is required")
	}
	if s.Object == "" {
		return fmt.Errorf("object is required")
	}
	return nil
}

func (s *GcpCloudFunctionSourceInput) applyDefaults() {
}

func (s *GcpCloudFunctionSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["bucket"] = s.Bucket
	m["object"] = s.Object
	if s.Generation != 0 {
		m["generation"] = s.Generation
	}
	return m
}

// GcpCloudFunctionTrigger defines what invokes the function: HTTP requests or cloud events.
type GcpCloudFunctionTriggerInput struct {
	// Type of trigger. Defaults to HTTP if not specified.
	TriggerType string `json:"trigger_type,omitempty" jsonschema:"enum=EVENT_TRIGGER,Type of trigger. Defaults to HTTP if not specified."`
	// Event trigger configuration. Required if trigger_type is EVENT_TRIGGER.
	EventTrigger *GcpCloudFunctionEventTriggerInput `json:"event_trigger,omitempty" jsonschema:"Event trigger configuration. Required if trigger_type is EVENT_TRIGGER."`
}

func (s *GcpCloudFunctionTriggerInput) validate() error {
	switch s.TriggerType {
	case "", "EVENT_TRIGGER":
	default:
		return fmt.Errorf("invalid trigger_type: %q", s.TriggerType)
	}
	if s.EventTrigger != nil {
		if err := s.EventTrigger.validate(); err != nil {
			return fmt.Errorf("event_trigger: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudFunctionTriggerInput) applyDefaults() {
	if s.EventTrigger != nil {
		s.EventTrigger.applyDefaults()
	}
}

func (s *GcpCloudFunctionTriggerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TriggerType != "" {
		m["trigger_type"] = s.TriggerType
	}
	if s.EventTrigger != nil {
		m["event_trigger"] = s.EventTrigger.toMap()
	}
	return m
}

// ParseGcpCloudFunction validates and normalizes a GcpCloudFunction cloud_object.
func ParseGcpCloudFunction(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudFunction"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudFunctionSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
