// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-gke-workload-identity-binding
type GcpGkeWorkloadIdentityBindingSpecInput struct {
	// The GCP project that hosts the GKE cluster (and therefore the
	//  Workload-Identity pool <project>.svc.id.goog).
	ProjectId string `json:"project_id" jsonschema:"required,The GCP project that hosts the GKE cluster (and therefore the Workload-Identity pool <project>.svc.id.goog)."`
	// The email of the Google Service Account to impersonate.
	//  Example: "cert-manager@my-project.iam.gserviceaccount.com"
	ServiceAccountEmail string `json:"service_account_email" jsonschema:"required,The email of the Google Service Account to impersonate. Example: 'cert-manager@my-project.iam.gserviceaccount.com'"`
	// Kubernetes namespace of the ServiceAccount running in the cluster.
	KsaNamespace string `json:"ksa_namespace" jsonschema:"required,Kubernetes namespace of the ServiceAccount running in the cluster."`
	// Name of the Kubernetes ServiceAccount.
	KsaName string `json:"ksa_name" jsonschema:"required,Name of the Kubernetes ServiceAccount."`
}

func (s *GcpGkeWorkloadIdentityBindingSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.ServiceAccountEmail == "" {
		return fmt.Errorf("service_account_email is required")
	}
	if s.KsaNamespace == "" {
		return fmt.Errorf("ksa_namespace is required")
	}
	if s.KsaName == "" {
		return fmt.Errorf("ksa_name is required")
	}
	return nil
}

func (s *GcpGkeWorkloadIdentityBindingSpecInput) applyDefaults() {
}

func (s *GcpGkeWorkloadIdentityBindingSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["service_account_email"] = s.ServiceAccountEmail
	m["ksa_namespace"] = s.KsaNamespace
	m["ksa_name"] = s.KsaName
	return m
}

// ParseGcpGkeWorkloadIdentityBinding validates and normalizes a GcpGkeWorkloadIdentityBinding cloud_object.
func ParseGcpGkeWorkloadIdentityBinding(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpGkeWorkloadIdentityBinding"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpGkeWorkloadIdentityBindingSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
