// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// GcpDnsRecord is a Kubernetes Resource Model (KRM) style resource for managing
//
//	individual DNS records within a Google Cloud DNS Managed Zone.
//
//	This component provides declarative management of DNS records including:
//	- A, AAAA, CNAME, MX, TXT, SRV, NS, PTR, CAA, and SOA record types
//	- TTL configuration
//	- Round-robin support with multiple values
//	- Wildcard records
type GcpDnsRecordSpecInput struct {
	// The ID of the GCP project where the Managed Zone exists.
	//  This is used to locate the DNS zone where the record will be created.
	ProjectId string `json:"project_id" jsonschema:"required,The ID of the GCP project where the Managed Zone exists. This is used to locate the DNS zone where the record will be created."`
	// The name of the Managed Zone where this DNS record will be created.
	//  This can be a direct value or a reference to a GcpDnsZone resource's output.
	//  Example: "example-zone" (the zone name, not the DNS name).
	ManagedZone string `json:"managed_zone" jsonschema:"required,The name of the Managed Zone where this DNS record will be created. This can be a direct value or a reference to a GcpDnsZone resource's output. Example: 'example-zone' (the zone name; not the DNS nam..."`
	// The DNS record type to create.
	//  Supported types: A, AAAA, CNAME, MX, TXT, SRV, NS, PTR, CAA, SOA.
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|CNAME|MX|TXT|SRV|NS|PTR|CAA|SOA,The DNS record type to create. Supported types: A; AAAA; CNAME; MX; TXT; SRV; NS; PTR; CAA; SOA."`
	// The fully qualified domain name for this record.
	//  Must end with a trailing dot to indicate FQDN.
	//  Example: "www.example.com." or "api.example.com."
	Name string `json:"name" jsonschema:"required,The fully qualified domain name for this record. Must end with a trailing dot to indicate FQDN. Example: 'www.example.com.' or 'api.example.com.'"`
	// The values/targets for the DNS record.
	//  For A records: IPv4 addresses (e.g., "192.0.2.1")
	//  For AAAA records: IPv6 addresses (e.g., "2001:db8::1")
	//  For CNAME records: target hostname with trailing dot (e.g., "target.example.com.")
	//  For MX records: mail server with priority (priority handled separatel...
	Values []string `json:"values,omitempty" jsonschema:"The values/targets for the DNS record. For A records: IPv4 addresses (e.g.; '192.0.2.1') For AAAA records: IPv6 addresses (e.g.; '2001:db8::1') For CNAME records: target hostname with trailing dot (e...."`
	// Time to live (TTL) for the DNS record in seconds.
	//  Determines how long resolvers should cache this record.
	//  Common values: 60 (1 min), 300 (5 min), 3600 (1 hour), 86400 (1 day).
	//  Default: 300 seconds (5 minutes).
	TtlSeconds int32 `json:"ttl_seconds,omitempty" jsonschema:"Time to live (TTL) for the DNS record in seconds. Determines how long resolvers should cache this record. Common values: 60 (1 min); 300 (5 min); 3600 (1 hour); 86400 (1 day). Default: 300 seconds (5 ..."`
}

func (s *GcpDnsRecordSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.ManagedZone == "" {
		return fmt.Errorf("managed_zone is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "NS", "PTR", "CAA", "SOA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.Values) < 1 {
		return fmt.Errorf("values requires at least 1 items, got %d", len(s.Values))
	}
	return nil
}

func (s *GcpDnsRecordSpecInput) applyDefaults() {
	if s.TtlSeconds == 0 {
		s.TtlSeconds = 300
	}
}

func (s *GcpDnsRecordSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["managed_zone"] = s.ManagedZone
	m["type"] = s.Type
	m["name"] = s.Name
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	return m
}

// ParseGcpDnsRecord validates and normalizes a GcpDnsRecord cloud_object.
func ParseGcpDnsRecord(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpDnsRecord"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpDnsRecordSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
