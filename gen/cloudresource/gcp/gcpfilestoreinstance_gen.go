// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-filestore-instance
type GcpFilestoreInstanceSpecInput struct {
	// GCP project where the Filestore instance will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the Filestore instance will be created."`
	// Name of the Filestore instance. This becomes the GCP resource name.
	//  Must start with a lowercase letter, contain only lowercase letters, numbers,
	//  and hyphens, and be 1-63 characters long.
	//  Immutable after creation.
	InstanceName string `json:"instance_name" jsonschema:"required,Name of the Filestore instance. This becomes the GCP resource name. Must start with a lowercase letter; contain only lowercase letters; numbers; and hyphens; and be 1-63 characters long. Immutable aft..."`
	// Location where the instance will be deployed.
	//  For BASIC_HDD, BASIC_SSD, STANDARD, PREMIUM, HIGH_SCALE_SSD, and ZONAL
	//  tiers: specify a zone (e.g., "us-central1-a").
	//  For ENTERPRISE and REGIONAL tiers: specify a region (e.g., "us-central1").
	//  Immutable after creation.
	Location string `json:"location" jsonschema:"required,Location where the instance will be deployed. For BASIC_HDD; BASIC_SSD; STANDARD; PREMIUM; HIGH_SCALE_SSD; and ZONAL tiers: specify a zone (e.g.; 'us-central1-a'). For ENTERPRISE and REGIONAL tiers: s..."`
	// Service tier controlling performance, availability, and pricing.
	//  STANDARD / BASIC_HDD: cost-effective HDD-backed (1 TiB minimum).
	//  PREMIUM / BASIC_SSD: mid-tier SSD-backed (2.5 TiB minimum).
	//  HIGH_SCALE_SSD: legacy high-performance SSD (10 TiB minimum).
	//  ZONAL: modern single-zone SSD with IOPS tuni...
	Tier string `json:"tier" jsonschema:"required,Service tier controlling performance; availability; and pricing. STANDARD / BASIC_HDD: cost-effective HDD-backed (1 TiB minimum). PREMIUM / BASIC_SSD: mid-tier SSD-backed (2.5 TiB minimum). HIGH_SCALE..."`
	// Human-readable description of the instance.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the instance."`
	// NFS protocol version.
	//  NFS_V3 (default): NFSv3. Broad compatibility, no built-in auth.
	//  NFS_V4_1: NFSv4.1. Supports Kerberos security. Available on
	//    HIGH_SCALE_SSD, ZONAL, REGIONAL, and ENTERPRISE tiers.
	//  Immutable after creation.
	Protocol string `json:"protocol,omitempty" jsonschema:"NFS protocol version. NFS_V3 (default): NFSv3. Broad compatibility; no built-in auth. NFS_V4_1: NFSv4.1. Supports Kerberos security. Available on HIGH_SCALE_SSD; ZONAL; REGIONAL; and ENTERPRISE tiers...."`
	// Cloud KMS key for customer-managed encryption at rest (CMEK).
	//  Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
	//  If not specified, data is encrypted with Google-managed keys.
	//  Immutable after creation.
	KmsKeyName string `json:"kms_key_name,omitempty" jsonschema:"Cloud KMS key for customer-managed encryption at rest (CMEK). Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key} If not specified; data is encrypted with Google-manage..."`
	// Whether deletion protection is enabled. When true, the instance cannot
	//  be deleted until this flag is set to false.
	DeletionProtectionEnabled bool `json:"deletion_protection_enabled,omitempty" jsonschema:"Whether deletion protection is enabled. When true; the instance cannot be deleted until this flag is set to false."`
	// Reason for enabling deletion protection. Informational only.
	DeletionProtectionReason string `json:"deletion_protection_reason,omitempty" jsonschema:"Reason for enabling deletion protection. Informational only."`
	// File share configuration. Each Filestore instance has exactly one file share.
	FileShare *GcpFilestoreInstanceFileShareInput `json:"file_share" jsonschema:"required,File share configuration. Each Filestore instance has exactly one file share."`
	// VPC network configuration. Each Filestore instance connects to exactly one network.
	NetworkConfig *GcpFilestoreInstanceNetworkConfigInput `json:"network_config" jsonschema:"required,VPC network configuration. Each Filestore instance connects to exactly one network."`
	// Performance configuration for IOPS tuning.
	//  Available on ZONAL, REGIONAL, and ENTERPRISE tiers.
	//  If not specified, the instance uses the default performance for its tier.
	PerformanceConfig *GcpFilestoreInstancePerformanceConfigInput `json:"performance_config,omitempty" jsonschema:"Performance configuration for IOPS tuning. Available on ZONAL; REGIONAL; and ENTERPRISE tiers. If not specified; the instance uses the default performance for its tier."`
}

func (s *GcpFilestoreInstanceSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.InstanceName == "" {
		return fmt.Errorf("instance_name is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.Tier == "" {
		return fmt.Errorf("tier is required")
	}
	if s.FileShare == nil {
		return fmt.Errorf("file_share is required")
	}
	if s.FileShare != nil {
		if err := s.FileShare.validate(); err != nil {
			return fmt.Errorf("file_share: %w", err)
		}
	}
	if s.NetworkConfig == nil {
		return fmt.Errorf("network_config is required")
	}
	if s.NetworkConfig != nil {
		if err := s.NetworkConfig.validate(); err != nil {
			return fmt.Errorf("network_config: %w", err)
		}
	}
	if s.PerformanceConfig != nil {
		if err := s.PerformanceConfig.validate(); err != nil {
			return fmt.Errorf("performance_config: %w", err)
		}
	}
	return nil
}

func (s *GcpFilestoreInstanceSpecInput) applyDefaults() {
	if s.FileShare != nil {
		s.FileShare.applyDefaults()
	}
	if s.NetworkConfig != nil {
		s.NetworkConfig.applyDefaults()
	}
	if s.PerformanceConfig != nil {
		s.PerformanceConfig.applyDefaults()
	}
}

func (s *GcpFilestoreInstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["instance_name"] = s.InstanceName
	m["location"] = s.Location
	m["tier"] = s.Tier
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.KmsKeyName != "" {
		m["kms_key_name"] = s.KmsKeyName
	}
	if s.DeletionProtectionEnabled {
		m["deletion_protection_enabled"] = s.DeletionProtectionEnabled
	}
	if s.DeletionProtectionReason != "" {
		m["deletion_protection_reason"] = s.DeletionProtectionReason
	}
	if s.FileShare != nil {
		m["file_share"] = s.FileShare.toMap()
	}
	if s.NetworkConfig != nil {
		m["network_config"] = s.NetworkConfig.toMap()
	}
	if s.PerformanceConfig != nil {
		m["performance_config"] = s.PerformanceConfig.toMap()
	}
	return m
}

// GcpFilestoreInstanceFileShare defines the single file share on a Filestore
//
//	instance. Each Filestore instance supports exactly one file share.
//
//	The file share name becomes part of the NFS mount path:
//	  mount <instance-ip>:/<file_share_name> /mnt/nfs
//
//	Capacity minimums depend on the instance tier:
//	  - BASIC_HDD / STANDARD: 1 TiB (1024 GiB)
//	  - BASIC_SSD / PREMIUM: 2.5 TiB (2560 GiB)
//	  - HIGH_SCALE_SSD: 10 TiB (10240 GiB)
//	  - ZONAL / REGIONAL / ENTERPRISE: 1 TiB (1024 GiB)
type GcpFilestoreInstanceFileShareInput struct {
	// Name of the file share. Becomes the NFS export path.
	//  Must start with a letter, followed by letters, numbers, or underscores.
	//  Maximum 16 characters.
	//  Immutable after creation.
	Name string `json:"name" jsonschema:"required,Name of the file share. Becomes the NFS export path. Must start with a letter; followed by letters; numbers; or underscores. Maximum 16 characters. Immutable after creation."`
	// Capacity of the file share in GiB.
	//  Minimum 1024 GiB (1 TiB) for most tiers. BASIC_SSD/PREMIUM requires
	//  2560 GiB minimum. HIGH_SCALE_SSD requires 10240 GiB minimum.
	//  The GCP API enforces tier-specific minimums.
	CapacityGb int32 `json:"capacity_gb" jsonschema:"required,Capacity of the file share in GiB. Minimum 1024 GiB (1 TiB) for most tiers. BASIC_SSD/PREMIUM requires 2560 GiB minimum. HIGH_SCALE_SSD requires 10240 GiB minimum. The GCP API enforces tier-specific m..."`
	// NFS export options controlling client access to the file share.
	//  Maximum 10 export options per file share.
	//  If empty, all clients are allowed with READ_WRITE access and NO_ROOT_SQUASH.
	NfsExportOptions []*GcpFilestoreInstanceNfsExportOptionInput `json:"nfs_export_options,omitempty" jsonschema:"NFS export options controlling client access to the file share. Maximum 10 export options per file share. If empty; all clients are allowed with READ_WRITE access and NO_ROOT_SQUASH."`
}

func (s *GcpFilestoreInstanceFileShareInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.NfsExportOptions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("nfs_export_options[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpFilestoreInstanceFileShareInput) applyDefaults() {
}

func (s *GcpFilestoreInstanceFileShareInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["capacity_gb"] = s.CapacityGb
	if len(s.NfsExportOptions) > 0 {
		items := make([]any, len(s.NfsExportOptions))
		for i, v := range s.NfsExportOptions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["nfs_export_options"] = items
	}
	return m
}

// GcpFilestoreInstanceFixedIops configures a fixed IOPS provisioning model
//
//	where the instance always has the same IOPS regardless of capacity changes.
type GcpFilestoreInstanceFixedIopsInput struct {
	// The number of IOPS to provision. Must be a multiple of 1000.
	MaxIops int32 `json:"max_iops" jsonschema:"required,The number of IOPS to provision. Must be a multiple of 1000."`
}

func (s *GcpFilestoreInstanceFixedIopsInput) validate() error {
	return nil
}

func (s *GcpFilestoreInstanceFixedIopsInput) applyDefaults() {
}

func (s *GcpFilestoreInstanceFixedIopsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["max_iops"] = s.MaxIops
	return m
}

// GcpFilestoreInstanceIopsPerTb configures a dynamic IOPS provisioning model
//
//	where IOPS scales proportionally with instance capacity.
//	Effective IOPS = capacity_tb * max_iops_per_tb, rounded to nearest 1000.
type GcpFilestoreInstanceIopsPerTbInput struct {
	// Maximum IOPS per terabyte of capacity.
	MaxIopsPerTb int32 `json:"max_iops_per_tb" jsonschema:"required,Maximum IOPS per terabyte of capacity."`
}

func (s *GcpFilestoreInstanceIopsPerTbInput) validate() error {
	return nil
}

func (s *GcpFilestoreInstanceIopsPerTbInput) applyDefaults() {
}

func (s *GcpFilestoreInstanceIopsPerTbInput) toMap() map[string]any {
	m := make(map[string]any)
	m["max_iops_per_tb"] = s.MaxIopsPerTb
	return m
}

// GcpFilestoreInstanceNetworkConfig defines the VPC network configuration
//
//	for a Filestore instance. Each instance connects to exactly one VPC network.
//
//	The network configuration is immutable after creation. Changing it requires
//	replacing the instance.
type GcpFilestoreInstanceNetworkConfigInput struct {
	// VPC network to which the Filestore instance is connected.
	//  Immutable after creation.
	Network string `json:"network" jsonschema:"required,VPC network to which the Filestore instance is connected. Immutable after creation."`
	// Network connection mode.
	//  DIRECT_PEERING (default): VPC peering. Simplest setup.
	//  PRIVATE_SERVICE_ACCESS: uses a private services connection. Required for
	//    Shared VPC and some enterprise network configurations.
	//  PRIVATE_SERVICE_CONNECT: uses Private Service Connect endpoints.
	//  Immutable after crea...
	ConnectMode string `json:"connect_mode,omitempty" jsonschema:"Network connection mode. DIRECT_PEERING (default): VPC peering. Simplest setup. PRIVATE_SERVICE_ACCESS: uses a private services connection. Required for Shared VPC and some enterprise network configur..."`
	// A /29 CIDR block for internal IP addresses reserved for this instance.
	//  Must be unique and non-overlapping with existing subnets in the VPC.
	//  If not specified, GCP automatically selects an unused range.
	//  Immutable after creation.
	ReservedIpRange string `json:"reserved_ip_range,omitempty" jsonschema:"A /29 CIDR block for internal IP addresses reserved for this instance. Must be unique and non-overlapping with existing subnets in the VPC. If not specified; GCP automatically selects an unused range...."`
}

func (s *GcpFilestoreInstanceNetworkConfigInput) validate() error {
	if s.Network == "" {
		return fmt.Errorf("network is required")
	}
	return nil
}

func (s *GcpFilestoreInstanceNetworkConfigInput) applyDefaults() {
}

func (s *GcpFilestoreInstanceNetworkConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["network"] = s.Network
	if s.ConnectMode != "" {
		m["connect_mode"] = s.ConnectMode
	}
	if s.ReservedIpRange != "" {
		m["reserved_ip_range"] = s.ReservedIpRange
	}
	return m
}

// GcpFilestoreInstanceNfsExportOption defines access controls for an NFS
//
//	export on a Filestore file share. Each export option specifies which clients
//	can access the share, with what permissions, and how root users are mapped.
//
//	Up to 10 export options can be defined per file share. IP ranges must not
//	overlap across export options within the same file share.
type GcpFilestoreInstanceNfsExportOptionInput struct {
	// List of IPv4 addresses or CIDR ranges that are allowed to mount
	//  the file share. If empty, all clients are allowed.
	//  Maximum 64 IP ranges/addresses across all export options per file share.
	IpRanges []string `json:"ip_ranges,omitempty" jsonschema:"List of IPv4 addresses or CIDR ranges that are allowed to mount the file share. If empty; all clients are allowed. Maximum 64 IP ranges/addresses across all export options per file share."`
	// Access mode for the export.
	//  READ_WRITE (default): clients can read and write.
	//  READ_ONLY: clients can only read.
	AccessMode string `json:"access_mode,omitempty" jsonschema:"Access mode for the export. READ_WRITE (default): clients can read and write. READ_ONLY: clients can only read."`
	// Root squash mode for the export.
	//  NO_ROOT_SQUASH (default): root users on clients have root access on the file share.
	//  ROOT_SQUASH: root users on clients are mapped to anon_uid/anon_gid.
	SquashMode string `json:"squash_mode,omitempty" jsonschema:"Root squash mode for the export. NO_ROOT_SQUASH (default): root users on clients have root access on the file share. ROOT_SQUASH: root users on clients are mapped to anon_uid/anon_gid."`
	// Anonymous user ID used when squash_mode is ROOT_SQUASH.
	//  Defaults to 65534 (nobody) if not specified.
	//  Only valid when squash_mode is ROOT_SQUASH.
	AnonUid int32 `json:"anon_uid,omitempty" jsonschema:"Anonymous user ID used when squash_mode is ROOT_SQUASH. Defaults to 65534 (nobody) if not specified. Only valid when squash_mode is ROOT_SQUASH."`
	// Anonymous group ID used when squash_mode is ROOT_SQUASH.
	//  Defaults to 65534 (nogroup) if not specified.
	//  Only valid when squash_mode is ROOT_SQUASH.
	AnonGid int32 `json:"anon_gid,omitempty" jsonschema:"Anonymous group ID used when squash_mode is ROOT_SQUASH. Defaults to 65534 (nogroup) if not specified. Only valid when squash_mode is ROOT_SQUASH."`
}

func (s *GcpFilestoreInstanceNfsExportOptionInput) validate() error {
	return nil
}

func (s *GcpFilestoreInstanceNfsExportOptionInput) applyDefaults() {
}

func (s *GcpFilestoreInstanceNfsExportOptionInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.IpRanges) > 0 {
		m["ip_ranges"] = s.IpRanges
	}
	if s.AccessMode != "" {
		m["access_mode"] = s.AccessMode
	}
	if s.SquashMode != "" {
		m["squash_mode"] = s.SquashMode
	}
	if s.AnonUid != 0 {
		m["anon_uid"] = s.AnonUid
	}
	if s.AnonGid != 0 {
		m["anon_gid"] = s.AnonGid
	}
	return m
}

// GcpFilestoreInstancePerformanceConfig defines the IOPS performance model
//
//	for a Filestore instance. Only one of fixed_iops or iops_per_tb may be set.
//
//	If not specified, the instance uses the default performance characteristics
//	for its tier.
//
//	Performance configuration is available on ZONAL, REGIONAL, and ENTERPRISE tiers.
type GcpFilestoreInstancePerformanceConfigInput struct {
	// Fixed IOPS provisioning. IOPS remains constant regardless of capacity.
	//  Mutually exclusive with iops_per_tb.
	FixedIops *GcpFilestoreInstanceFixedIopsInput `json:"fixed_iops,omitempty" jsonschema:"Fixed IOPS provisioning. IOPS remains constant regardless of capacity. Mutually exclusive with iops_per_tb."`
	// Dynamic IOPS provisioning. IOPS scales with instance capacity.
	//  Mutually exclusive with fixed_iops.
	IopsPerTb *GcpFilestoreInstanceIopsPerTbInput `json:"iops_per_tb,omitempty" jsonschema:"Dynamic IOPS provisioning. IOPS scales with instance capacity. Mutually exclusive with fixed_iops."`
}

func (s *GcpFilestoreInstancePerformanceConfigInput) validate() error {
	if s.FixedIops != nil {
		if err := s.FixedIops.validate(); err != nil {
			return fmt.Errorf("fixed_iops: %w", err)
		}
	}
	if s.IopsPerTb != nil {
		if err := s.IopsPerTb.validate(); err != nil {
			return fmt.Errorf("iops_per_tb: %w", err)
		}
	}
	return nil
}

func (s *GcpFilestoreInstancePerformanceConfigInput) applyDefaults() {
	if s.FixedIops != nil {
		s.FixedIops.applyDefaults()
	}
	if s.IopsPerTb != nil {
		s.IopsPerTb.applyDefaults()
	}
}

func (s *GcpFilestoreInstancePerformanceConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.FixedIops != nil {
		m["fixed_iops"] = s.FixedIops.toMap()
	}
	if s.IopsPerTb != nil {
		m["iops_per_tb"] = s.IopsPerTb.toMap()
	}
	return m
}

// ParseGcpFilestoreInstance validates and normalizes a GcpFilestoreInstance cloud_object.
func ParseGcpFilestoreInstance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpFilestoreInstance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpFilestoreInstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
