// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cert-manager-cert
type GcpCertManagerCertSpecInput struct {
	// gcp_project_id is the ID of the GCP project where the certificate will be created.
	//  This is a required field.
	GcpProjectId string `json:"gcp_project_id" jsonschema:"required,gcp_project_id is the ID of the GCP project where the certificate will be created. This is a required field."`
	// primary_domain_name is a required field representing the main (apex or wildcard) domain name.
	//  Examples include "example.com" or "*.example.com" (wildcard).
	//  This domain will be set as the primary domain in the GCP certificate.
	//
	//  The pattern enforces a domain-like structure, allowing an optional wil...
	PrimaryDomainName string `json:"primary_domain_name" jsonschema:"required,primary_domain_name is a required field representing the main (apex or wildcard) domain name. Examples include 'example.com' or '*.example.com' (wildcard). This domain will be set as the primary domai..."`
	// alternate_domain_names is an optional list of Subject Alternative Names (SANs) for the certificate.
	//  Each entry must follow the same pattern as primary_domain_name and cannot contain duplicates.
	//  Primary domain should not be added to this list.
	AlternateDomainNames []string `json:"alternate_domain_names,omitempty" jsonschema:"alternate_domain_names is an optional list of Subject Alternative Names (SANs) for the certificate. Each entry must follow the same pattern as primary_domain_name and cannot contain duplicates. Primar..."`
	// cloud_dns_zone_id is the identifier of the Cloud DNS managed zone
	//  where DNS validation records will be created automatically.
	//  Must be a public managed zone matching the domain names.
	//  Example: "my-dns-zone" or a full zone name.
	CloudDnsZoneId string `json:"cloud_dns_zone_id" jsonschema:"required,cloud_dns_zone_id is the identifier of the Cloud DNS managed zone where DNS validation records will be created automatically. Must be a public managed zone matching the domain names. Example: 'my-dns-..."`
	// certificate_type indicates which type of certificate to create.
	//  MANAGED uses Google Certificate Manager (newer, more flexible).
	//  LOAD_BALANCER uses Google-managed SSL certificates (classic, for load balancers).
	//  By default, MANAGED is used.
	CertificateType string `json:"certificate_type,omitempty" jsonschema:"enum=LOAD_BALANCER,certificate_type indicates which type of certificate to create. MANAGED uses Google Certificate Manager (newer; more flexible). LOAD_BALANCER uses Google-managed SSL certificates (classic; for load ba..."`
	// validation_method indicates how the certificate verifies domain ownership.
	//  By default, DNS validation is used.
	ValidationMethod string `json:"validation_method,omitempty" jsonschema:"validation_method indicates how the certificate verifies domain ownership. By default; DNS validation is used."`
}

func (s *GcpCertManagerCertSpecInput) validate() error {
	if s.GcpProjectId == "" {
		return fmt.Errorf("gcp_project_id is required")
	}
	if s.PrimaryDomainName == "" {
		return fmt.Errorf("primary_domain_name is required")
	}
	if s.CloudDnsZoneId == "" {
		return fmt.Errorf("cloud_dns_zone_id is required")
	}
	switch s.CertificateType {
	case "", "LOAD_BALANCER":
	default:
		return fmt.Errorf("invalid certificate_type: %q", s.CertificateType)
	}
	return nil
}

func (s *GcpCertManagerCertSpecInput) applyDefaults() {
	if s.CertificateType == "" {
		s.CertificateType = "MANAGED"
	}
	if s.ValidationMethod == "" {
		s.ValidationMethod = "DNS"
	}
}

func (s *GcpCertManagerCertSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["gcp_project_id"] = s.GcpProjectId
	m["primary_domain_name"] = s.PrimaryDomainName
	if len(s.AlternateDomainNames) > 0 {
		m["alternate_domain_names"] = s.AlternateDomainNames
	}
	m["cloud_dns_zone_id"] = s.CloudDnsZoneId
	if s.CertificateType != "" {
		m["certificate_type"] = s.CertificateType
	}
	if s.ValidationMethod != "" {
		m["validation_method"] = s.ValidationMethod
	}
	return m
}

// ParseGcpCertManagerCert validates and normalizes a GcpCertManagerCert cloud_object.
func ParseGcpCertManagerCert(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCertManagerCert"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCertManagerCertSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
