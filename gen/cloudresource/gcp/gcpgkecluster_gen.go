// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-gke-cluster
type GcpGkeClusterSpecInput struct {
	// GCP project in which to create the cluster (reference to GcpProject resource).
	ProjectId string `json:"project_id" jsonschema:"required,GCP project in which to create the cluster (reference to GcpProject resource)."`
	// VPC Network to use for this cluster (must exist).
	NetworkSelfLink string `json:"network_self_link" jsonschema:"required,VPC Network to use for this cluster (must exist)."`
	// Location for the cluster: region (for regional) or zone (for zonal).
	Location string `json:"location" jsonschema:"required,Location for the cluster: region (for regional) or zone (for zonal)."`
	// VPC Subnetwork to attach this cluster (must exist; carries primary & secondary IP ranges).
	SubnetworkSelfLink string `json:"subnetwork_self_link" jsonschema:"required,VPC Subnetwork to attach this cluster (must exist; carries primary & secondary IP ranges)."`
	// Name of the secondary range on the subnetwork for Pod IPs (VPC-native aliasing).
	ClusterSecondaryRangeName string `json:"cluster_secondary_range_name" jsonschema:"required,Name of the secondary range on the subnetwork for Pod IPs (VPC-native aliasing)."`
	// Name of the secondary range on the subnetwork for Service IPs.
	ServicesSecondaryRangeName string `json:"services_secondary_range_name" jsonschema:"required,Name of the secondary range on the subnetwork for Service IPs."`
	// RFC1918 /28 CIDR block for the Kubernetes control-plane masters (private endpoint range).
	MasterIpv4CidrBlock string `json:"master_ipv4_cidr_block" jsonschema:"required,RFC1918 /28 CIDR block for the Kubernetes control-plane masters (private endpoint range)."`
	// Whether nodes should be created with public IPs
	EnablePublicNodes bool `json:"enable_public_nodes,omitempty" jsonschema:"Whether nodes should be created with public IPs"`
	// Kubernetes release channel for auto-upgrades (Rapid, Regular, Stable, or NONE).
	ReleaseChannel string `json:"release_channel,omitempty" jsonschema:"enum=RAPID|REGULAR|STABLE|NONE,Kubernetes release channel for auto-upgrades (Rapid; Regular; Stable; or NONE)."`
	// Disable network policy enforcement (Calico)
	DisableNetworkPolicy bool `json:"disable_network_policy,omitempty" jsonschema:"Disable network policy enforcement (Calico)"`
	// Disable Workload Identity for pods (mapping KSA to GCP service accounts).
	DisableWorkloadIdentity bool `json:"disable_workload_identity,omitempty" jsonschema:"Disable Workload Identity for pods (mapping KSA to GCP service accounts)."`
	// Reference to a Cloud NAT configuration to allow outbound internet for private nodes.
	RouterNatName string `json:"router_nat_name" jsonschema:"required,Reference to a Cloud NAT configuration to allow outbound internet for private nodes."`
	// Name of the GKE cluster to create in GCP.
	//  Must be 1-40 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a lowercase letter or number.
	//  Example: "my-gke-cluster", "prod-cluster"
	ClusterName string `json:"cluster_name" jsonschema:"required,Name of the GKE cluster to create in GCP. Must be 1-40 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a lowercase letter or number. Example: 'my-gk..."`
}

func (s *GcpGkeClusterSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.NetworkSelfLink == "" {
		return fmt.Errorf("network_self_link is required")
	}
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	if s.SubnetworkSelfLink == "" {
		return fmt.Errorf("subnetwork_self_link is required")
	}
	if s.ClusterSecondaryRangeName == "" {
		return fmt.Errorf("cluster_secondary_range_name is required")
	}
	if s.ServicesSecondaryRangeName == "" {
		return fmt.Errorf("services_secondary_range_name is required")
	}
	if s.MasterIpv4CidrBlock == "" {
		return fmt.Errorf("master_ipv4_cidr_block is required")
	}
	switch s.ReleaseChannel {
	case "", "RAPID", "REGULAR", "STABLE", "NONE":
	default:
		return fmt.Errorf("invalid release_channel: %q", s.ReleaseChannel)
	}
	if s.RouterNatName == "" {
		return fmt.Errorf("router_nat_name is required")
	}
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	return nil
}

func (s *GcpGkeClusterSpecInput) applyDefaults() {
	if s.ReleaseChannel == "" {
		s.ReleaseChannel = "REGULAR"
	}
}

func (s *GcpGkeClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["network_self_link"] = s.NetworkSelfLink
	m["location"] = s.Location
	m["subnetwork_self_link"] = s.SubnetworkSelfLink
	m["cluster_secondary_range_name"] = s.ClusterSecondaryRangeName
	m["services_secondary_range_name"] = s.ServicesSecondaryRangeName
	m["master_ipv4_cidr_block"] = s.MasterIpv4CidrBlock
	if s.EnablePublicNodes {
		m["enable_public_nodes"] = s.EnablePublicNodes
	}
	if s.ReleaseChannel != "" {
		m["release_channel"] = s.ReleaseChannel
	}
	if s.DisableNetworkPolicy {
		m["disable_network_policy"] = s.DisableNetworkPolicy
	}
	if s.DisableWorkloadIdentity {
		m["disable_workload_identity"] = s.DisableWorkloadIdentity
	}
	m["router_nat_name"] = s.RouterNatName
	m["cluster_name"] = s.ClusterName
	return m
}

// ParseGcpGkeCluster validates and normalizes a GcpGkeCluster cloud_object.
func ParseGcpGkeCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpGkeCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpGkeClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
