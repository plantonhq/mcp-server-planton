// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-run
type GcpCloudRunSpecInput struct {
	// GCP project ID where the Cloud Run service will be created.
	//  Can be a direct value or a reference to a GcpProject resource.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project ID where the Cloud Run service will be created. Can be a direct value or a reference to a GcpProject resource."`
	// Region where the service is deployed, for example "us-central1".
	Region string `json:"region" jsonschema:"required,Region where the service is deployed; for example 'us-central1'."`
	// Name of the Cloud Run service to create on GCP.
	//  If not specified, defaults to metadata.name.
	ServiceName string `json:"service_name,omitempty" jsonschema:"Name of the Cloud Run service to create on GCP. If not specified; defaults to metadata.name."`
	// Service account email that the Cloud Run service runs as.
	//  If not specified, uses the default Compute Engine service account.
	ServiceAccount string `json:"service_account,omitempty" jsonschema:"Service account email that the Cloud Run service runs as. If not specified; uses the default Compute Engine service account."`
	// Container configuration for the Cloud Run service.
	Container *GcpCloudRunContainerInput `json:"container" jsonschema:"required,Container configuration for the Cloud Run service."`
	// Maximum concurrent requests handled by one instance.
	MaxConcurrency int32 `json:"max_concurrency,omitempty" jsonschema:"Maximum concurrent requests handled by one instance."`
	// Request timeout in seconds (1-3600). Default is 300 (5 minutes).
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Request timeout in seconds (1-3600). Default is 300 (5 minutes)."`
	// Ingress settings control which traffic sources can reach the service.
	Ingress string `json:"ingress,omitempty" jsonschema:"enum=INGRESS_TRAFFIC_ALL|INGRESS_TRAFFIC_INTERNAL_ONLY|INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER,Ingress settings control which traffic sources can reach the service."`
	// If true, the service is publicly invokable by unauthenticated callers.
	AllowUnauthenticated bool `json:"allow_unauthenticated,omitempty" jsonschema:"If true; the service is publicly invokable by unauthenticated callers."`
	// VPC access configuration for private resource access.
	VpcAccess *GcpCloudRunVpcAccessInput `json:"vpc_access,omitempty" jsonschema:"VPC access configuration for private resource access."`
	// Execution environment generation (GEN1 or GEN2).
	//  GEN2 offers full Linux compatibility but slower cold starts.
	ExecutionEnvironment string `json:"execution_environment,omitempty" jsonschema:"enum=EXECUTION_ENVIRONMENT_GEN1|EXECUTION_ENVIRONMENT_GEN2,Execution environment generation (GEN1 or GEN2). GEN2 offers full Linux compatibility but slower cold starts."`
	// Custom DNS mapping for the Cloud Run service.
	Dns *GcpCloudRunDnsInput `json:"dns,omitempty" jsonschema:"Custom DNS mapping for the Cloud Run service."`
	// If true, prevents accidental deletion of the Cloud Run service.
	//  When enabled, the service cannot be deleted until this flag is set to false.
	DeleteProtection bool `json:"delete_protection,omitempty" jsonschema:"If true; prevents accidental deletion of the Cloud Run service. When enabled; the service cannot be deleted until this flag is set to false."`
}

func (s *GcpCloudRunSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	switch s.Ingress {
	case "", "INGRESS_TRAFFIC_ALL", "INGRESS_TRAFFIC_INTERNAL_ONLY", "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER":
	default:
		return fmt.Errorf("invalid ingress: %q", s.Ingress)
	}
	if s.VpcAccess != nil {
		if err := s.VpcAccess.validate(); err != nil {
			return fmt.Errorf("vpc_access: %w", err)
		}
	}
	switch s.ExecutionEnvironment {
	case "", "EXECUTION_ENVIRONMENT_GEN1", "EXECUTION_ENVIRONMENT_GEN2":
	default:
		return fmt.Errorf("invalid execution_environment: %q", s.ExecutionEnvironment)
	}
	if s.Dns != nil {
		if err := s.Dns.validate(); err != nil {
			return fmt.Errorf("dns: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudRunSpecInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.VpcAccess != nil {
		s.VpcAccess.applyDefaults()
	}
	if s.Dns != nil {
		s.Dns.applyDefaults()
	}
}

func (s *GcpCloudRunSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["region"] = s.Region
	if s.ServiceName != "" {
		m["service_name"] = s.ServiceName
	}
	if s.ServiceAccount != "" {
		m["service_account"] = s.ServiceAccount
	}
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.MaxConcurrency != 0 {
		m["max_concurrency"] = s.MaxConcurrency
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.Ingress != "" {
		m["ingress"] = s.Ingress
	}
	if s.AllowUnauthenticated {
		m["allow_unauthenticated"] = s.AllowUnauthenticated
	}
	if s.VpcAccess != nil {
		m["vpc_access"] = s.VpcAccess.toMap()
	}
	if s.ExecutionEnvironment != "" {
		m["execution_environment"] = s.ExecutionEnvironment
	}
	if s.Dns != nil {
		m["dns"] = s.Dns.toMap()
	}
	if s.DeleteProtection {
		m["delete_protection"] = s.DeleteProtection
	}
	return m
}

// GcpCloudRunContainer groups image, resources, environment, and port settings
//
//	for the Cloud Run container.
type GcpCloudRunContainerInput struct {
	// Container image URI, for example "us-docker.pkg.dev/prj/registry/app:1.0.0".
	Image *GcpCloudRunContainerImageInput `json:"image,omitempty" jsonschema:"Container image URI; for example 'us-docker.pkg.dev/prj/registry/app:1.0.0'."`
	// Environment variables and secrets injected into the container.
	Env *GcpCloudRunContainerEnvInput `json:"env,omitempty" jsonschema:"Environment variables and secrets injected into the container."`
	// Container port that receives HTTP traffic.  Defaults to 8080 if unset.
	Port int32 `json:"port,omitempty" jsonschema:"Container port that receives HTTP traffic. Defaults to 8080 if unset."`
	// vCPU units allocated per instance.  Allowed values: 1, 2, 4.
	Cpu int32 `json:"cpu" jsonschema:"required,vCPU units allocated per instance. Allowed values: 1; 2; 4."`
	// Memory in MiB allocated per instance.  Valid range 128 – 32768.
	Memory int32 `json:"memory" jsonschema:"required,Memory in MiB allocated per instance. Valid range 128 – 32768."`
	// Minimum and maximum number of container instances.
	Replicas *GcpCloudRunContainerReplicasInput `json:"replicas" jsonschema:"required,Minimum and maximum number of container instances."`
}

func (s *GcpCloudRunContainerInput) validate() error {
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	if s.Replicas == nil {
		return fmt.Errorf("replicas is required")
	}
	if s.Replicas != nil {
		if err := s.Replicas.validate(); err != nil {
			return fmt.Errorf("replicas: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudRunContainerInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.Replicas != nil {
		s.Replicas.applyDefaults()
	}
}

func (s *GcpCloudRunContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	m["cpu"] = s.Cpu
	m["memory"] = s.Memory
	if s.Replicas != nil {
		m["replicas"] = s.Replicas.toMap()
	}
	return m
}

// GcpCloudRunContainerEnv defines plain environment variables and secrets.
type GcpCloudRunContainerEnvInput struct {
	// Plain environment variables injected as KEY=VALUE pairs.
	Variables map[string]string `json:"variables,omitempty" jsonschema:"Plain environment variables injected as KEY=VALUE pairs."`
	// Secret Manager references injected as KEY=projects/* /secrets/*:version.
	Secrets map[string]string `json:"secrets,omitempty" jsonschema:"Secret Manager references injected as KEY=projects/*/secrets/*:version."`
}

func (s *GcpCloudRunContainerEnvInput) validate() error {
	return nil
}

func (s *GcpCloudRunContainerEnvInput) applyDefaults() {
}

func (s *GcpCloudRunContainerEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		m["secrets"] = s.Secrets
	}
	return m
}

// GcpCloudRunContainerImage specifies the repository and tag of the container
//
//	image.
type GcpCloudRunContainerImageInput struct {
	// Image repository, for example "us-docker.pkg.dev/prj/registry/app".
	Repo string `json:"repo" jsonschema:"required,Image repository; for example 'us-docker.pkg.dev/prj/registry/app'."`
	// Image tag, for example "1.0.0".  Using a fixed tag improves repeatability.
	Tag string `json:"tag" jsonschema:"required,Image tag; for example '1.0.0'. Using a fixed tag improves repeatability."`
}

func (s *GcpCloudRunContainerImageInput) validate() error {
	if s.Repo == "" {
		return fmt.Errorf("repo is required")
	}
	if s.Tag == "" {
		return fmt.Errorf("tag is required")
	}
	return nil
}

func (s *GcpCloudRunContainerImageInput) applyDefaults() {
}

func (s *GcpCloudRunContainerImageInput) toMap() map[string]any {
	m := make(map[string]any)
	m["repo"] = s.Repo
	m["tag"] = s.Tag
	return m
}

// / GcpCloudRunContainerReplicas defines the minimum and maximum number of container instances
type GcpCloudRunContainerReplicasInput struct {
	// Minimum number of container instances that remain warm.
	Min int32 `json:"min,omitempty" jsonschema:"Minimum number of container instances that remain warm."`
	// Maximum number of container instances Cloud Run may scale out to.
	Max int32 `json:"max,omitempty" jsonschema:"Maximum number of container instances Cloud Run may scale out to."`
}

func (s *GcpCloudRunContainerReplicasInput) validate() error {
	return nil
}

func (s *GcpCloudRunContainerReplicasInput) applyDefaults() {
}

func (s *GcpCloudRunContainerReplicasInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Min != 0 {
		m["min"] = s.Min
	}
	if s.Max != 0 {
		m["max"] = s.Max
	}
	return m
}

// GcpCloudRunDns configures optional custom-domain mapping.
type GcpCloudRunDnsInput struct {
	// Enables or disables custom-domain mapping.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enables or disables custom-domain mapping."`
	// Fully-qualified hostnames routed to the Cloud Run service.
	Hostnames []string `json:"hostnames,omitempty" jsonschema:"Fully-qualified hostnames routed to the Cloud Run service."`
	// Cloud DNS managed zone used for domain-verification records.
	ManagedZone string `json:"managed_zone,omitempty" jsonschema:"Cloud DNS managed zone used for domain-verification records."`
}

func (s *GcpCloudRunDnsInput) validate() error {
	return nil
}

func (s *GcpCloudRunDnsInput) applyDefaults() {
}

func (s *GcpCloudRunDnsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if len(s.Hostnames) > 0 {
		m["hostnames"] = s.Hostnames
	}
	if s.ManagedZone != "" {
		m["managed_zone"] = s.ManagedZone
	}
	return m
}

// GcpCloudRunVpcAccess configures Direct VPC Egress for accessing private resources.
type GcpCloudRunVpcAccessInput struct {
	// VPC network name for Direct VPC Egress.
	//  Can be a direct value or a reference to a GcpVpc resource.
	Network string `json:"network,omitempty" jsonschema:"VPC network name for Direct VPC Egress. Can be a direct value or a reference to a GcpVpc resource."`
	// VPC subnet name for Direct VPC Egress.
	//  Can be a direct value or a reference to a GcpSubnetwork resource.
	Subnet string `json:"subnet,omitempty" jsonschema:"VPC subnet name for Direct VPC Egress. Can be a direct value or a reference to a GcpSubnetwork resource."`
	// Egress setting: "ALL_TRAFFIC" or "PRIVATE_RANGES_ONLY"
	//  If "ALL_TRAFFIC", all egress goes through VPC
	//  If "PRIVATE_RANGES_ONLY", only private IP traffic uses VPC
	Egress string `json:"egress,omitempty" jsonschema:"Egress setting: 'ALL_TRAFFIC' or 'PRIVATE_RANGES_ONLY' If 'ALL_TRAFFIC'; all egress goes through VPC If 'PRIVATE_RANGES_ONLY'; only private IP traffic uses VPC"`
}

func (s *GcpCloudRunVpcAccessInput) validate() error {
	return nil
}

func (s *GcpCloudRunVpcAccessInput) applyDefaults() {
}

func (s *GcpCloudRunVpcAccessInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Network != "" {
		m["network"] = s.Network
	}
	if s.Subnet != "" {
		m["subnet"] = s.Subnet
	}
	if s.Egress != "" {
		m["egress"] = s.Egress
	}
	return m
}

// ParseGcpCloudRun validates and normalizes a GcpCloudRun cloud_object.
func ParseGcpCloudRun(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudRun"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudRunSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
