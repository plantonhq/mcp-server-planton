// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-sql
type GcpCloudSqlSpecInput struct {
	// GCP project ID where the Cloud SQL instance will be created.
	//  Can be a literal value or a reference to a GcpProject resource.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project ID where the Cloud SQL instance will be created. Can be a literal value or a reference to a GcpProject resource."`
	// Region where the instance is deployed, for example "us-central1".
	Region string `json:"region" jsonschema:"required,Region where the instance is deployed; for example 'us-central1'."`
	// Database engine type (MYSQL or POSTGRESQL).
	DatabaseEngine string `json:"database_engine" jsonschema:"required,enum=MYSQL|POSTGRESQL,Database engine type (MYSQL or POSTGRESQL)."`
	// Database version string, engine-specific (e.g., "MYSQL_8_0" or "POSTGRES_15").
	DatabaseVersion string `json:"database_version" jsonschema:"required,Database version string; engine-specific (e.g.; 'MYSQL_8_0' or 'POSTGRES_15')."`
	// Machine tier/type for the instance, for example "db-n1-standard-1".
	Tier string `json:"tier" jsonschema:"required,Machine tier/type for the instance; for example 'db-n1-standard-1'."`
	// Storage size in gigabytes for the database instance.
	StorageGb int32 `json:"storage_gb" jsonschema:"required,Storage size in gigabytes for the database instance."`
	// Whether storage should automatically resize when approaching capacity.
	//  Enabled by default to prevent out-of-space issues.
	DiskAutoresize bool `json:"disk_autoresize,omitempty" jsonschema:"Whether storage should automatically resize when approaching capacity. Enabled by default to prevent out-of-space issues."`
	// Cloud SQL edition: ENTERPRISE (standard) or ENTERPRISE_PLUS (premium with 99.99% SLA).
	//  Defaults to ENTERPRISE if not specified.
	Edition string `json:"edition,omitempty" jsonschema:"enum=ENTERPRISE|ENTERPRISE_PLUS,Cloud SQL edition: ENTERPRISE (standard) or ENTERPRISE_PLUS (premium with 99.99% SLA). Defaults to ENTERPRISE if not specified."`
	// Whether to enable deletion protection. When enabled, prevents accidental deletion of the instance.
	//  Highly recommended for production instances.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"Whether to enable deletion protection. When enabled; prevents accidental deletion of the instance. Highly recommended for production instances."`
	// Whether to enable Query Insights for performance monitoring and query analysis.
	QueryInsightsEnabled bool `json:"query_insights_enabled,omitempty" jsonschema:"Whether to enable Query Insights for performance monitoring and query analysis."`
	// Maintenance window configuration for scheduling updates during off-peak hours.
	MaintenanceWindow *GcpCloudSqlMaintenanceWindowInput `json:"maintenance_window,omitempty" jsonschema:"Maintenance window configuration for scheduling updates during off-peak hours."`
	// Network configuration for the Cloud SQL instance.
	Network *GcpCloudSqlNetworkInput `json:"network,omitempty" jsonschema:"Network configuration for the Cloud SQL instance."`
	// High availability configuration.
	HighAvailability *GcpCloudSqlHighAvailabilityInput `json:"high_availability,omitempty" jsonschema:"High availability configuration."`
	// Backup configuration settings.
	Backup *GcpCloudSqlBackupInput `json:"backup,omitempty" jsonschema:"Backup configuration settings."`
	// Database-specific configuration flags as key-value pairs.
	DatabaseFlags map[string]string `json:"database_flags,omitempty" jsonschema:"Database-specific configuration flags as key-value pairs."`
	// Initial root password for the database instance.
	RootPassword string `json:"root_password,omitempty" jsonschema:"Initial root password for the database instance."`
}

func (s *GcpCloudSqlSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.DatabaseEngine == "" {
		return fmt.Errorf("database_engine is required")
	}
	switch s.DatabaseEngine {
	case "MYSQL", "POSTGRESQL":
	default:
		return fmt.Errorf("invalid database_engine: %q", s.DatabaseEngine)
	}
	if s.DatabaseVersion == "" {
		return fmt.Errorf("database_version is required")
	}
	if s.Tier == "" {
		return fmt.Errorf("tier is required")
	}
	switch s.Edition {
	case "", "ENTERPRISE", "ENTERPRISE_PLUS":
	default:
		return fmt.Errorf("invalid edition: %q", s.Edition)
	}
	if s.MaintenanceWindow != nil {
		if err := s.MaintenanceWindow.validate(); err != nil {
			return fmt.Errorf("maintenance_window: %w", err)
		}
	}
	if s.Network != nil {
		if err := s.Network.validate(); err != nil {
			return fmt.Errorf("network: %w", err)
		}
	}
	if s.HighAvailability != nil {
		if err := s.HighAvailability.validate(); err != nil {
			return fmt.Errorf("high_availability: %w", err)
		}
	}
	if s.Backup != nil {
		if err := s.Backup.validate(); err != nil {
			return fmt.Errorf("backup: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudSqlSpecInput) applyDefaults() {
	if s.MaintenanceWindow != nil {
		s.MaintenanceWindow.applyDefaults()
	}
	if s.Network != nil {
		s.Network.applyDefaults()
	}
	if s.HighAvailability != nil {
		s.HighAvailability.applyDefaults()
	}
	if s.Backup != nil {
		s.Backup.applyDefaults()
	}
}

func (s *GcpCloudSqlSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	m["region"] = s.Region
	m["database_engine"] = s.DatabaseEngine
	m["database_version"] = s.DatabaseVersion
	m["tier"] = s.Tier
	m["storage_gb"] = s.StorageGb
	if s.DiskAutoresize {
		m["disk_autoresize"] = s.DiskAutoresize
	}
	if s.Edition != "" {
		m["edition"] = s.Edition
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if s.QueryInsightsEnabled {
		m["query_insights_enabled"] = s.QueryInsightsEnabled
	}
	if s.MaintenanceWindow != nil {
		m["maintenance_window"] = s.MaintenanceWindow.toMap()
	}
	if s.Network != nil {
		m["network"] = s.Network.toMap()
	}
	if s.HighAvailability != nil {
		m["high_availability"] = s.HighAvailability.toMap()
	}
	if s.Backup != nil {
		m["backup"] = s.Backup.toMap()
	}
	if len(s.DatabaseFlags) > 0 {
		m["database_flags"] = s.DatabaseFlags
	}
	if s.RootPassword != "" {
		m["root_password"] = s.RootPassword
	}
	return m
}

// GcpCloudSqlBackup defines backup configuration for the Cloud SQL instance.
type GcpCloudSqlBackupInput struct {
	// Whether automated backups are enabled.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether automated backups are enabled."`
	// Start time for daily backup window in HH:MM format (UTC).
	StartTime string `json:"start_time,omitempty" jsonschema:"Start time for daily backup window in HH:MM format (UTC)."`
	// Number of days to retain automated backups.
	RetentionDays int32 `json:"retention_days,omitempty" jsonschema:"Number of days to retain automated backups."`
	// Whether to enable Point-in-Time Recovery (PITR).
	//  Allows restoring to any specific second within the retention window.
	//  Requires automated backups to be enabled and uses transaction logs.
	//  Essential for protecting against human error (accidental deletes, bad migrations).
	PointInTimeRecoveryEnabled bool `json:"point_in_time_recovery_enabled,omitempty" jsonschema:"Whether to enable Point-in-Time Recovery (PITR). Allows restoring to any specific second within the retention window. Requires automated backups to be enabled and uses transaction logs. Essential for ..."`
}

func (s *GcpCloudSqlBackupInput) validate() error {
	return nil
}

func (s *GcpCloudSqlBackupInput) applyDefaults() {
}

func (s *GcpCloudSqlBackupInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.StartTime != "" {
		m["start_time"] = s.StartTime
	}
	if s.RetentionDays != 0 {
		m["retention_days"] = s.RetentionDays
	}
	if s.PointInTimeRecoveryEnabled {
		m["point_in_time_recovery_enabled"] = s.PointInTimeRecoveryEnabled
	}
	return m
}

// GcpCloudSqlHighAvailability defines high availability configuration.
type GcpCloudSqlHighAvailabilityInput struct {
	// Whether to enable high availability (regional failover).
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether to enable high availability (regional failover)."`
	// Secondary zone for high availability failover.
	Zone string `json:"zone,omitempty" jsonschema:"Secondary zone for high availability failover."`
}

func (s *GcpCloudSqlHighAvailabilityInput) validate() error {
	return nil
}

func (s *GcpCloudSqlHighAvailabilityInput) applyDefaults() {
}

func (s *GcpCloudSqlHighAvailabilityInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Zone != "" {
		m["zone"] = s.Zone
	}
	return m
}

// GcpCloudSqlMaintenanceWindow defines when Cloud SQL can perform maintenance updates.
type GcpCloudSqlMaintenanceWindowInput struct {
	// Day of the week for maintenance (1=Monday, 7=Sunday).
	Day int32 `json:"day,omitempty" jsonschema:"Day of the week for maintenance (1=Monday; 7=Sunday)."`
	// Hour of the day for maintenance start (0-23, UTC).
	Hour int32 `json:"hour,omitempty" jsonschema:"Hour of the day for maintenance start (0-23; UTC)."`
	// Update track: "canary" for early updates, "stable" for production (default).
	UpdateTrack string `json:"update_track,omitempty" jsonschema:"Update track: 'canary' for early updates; 'stable' for production (default)."`
}

func (s *GcpCloudSqlMaintenanceWindowInput) validate() error {
	return nil
}

func (s *GcpCloudSqlMaintenanceWindowInput) applyDefaults() {
}

func (s *GcpCloudSqlMaintenanceWindowInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Day != 0 {
		m["day"] = s.Day
	}
	if s.Hour != 0 {
		m["hour"] = s.Hour
	}
	if s.UpdateTrack != "" {
		m["update_track"] = s.UpdateTrack
	}
	return m
}

// GcpCloudSqlNetwork defines network configuration for the Cloud SQL instance.
type GcpCloudSqlNetworkInput struct {
	// VPC network ID for private IP connectivity.
	//  Can be a literal value or a reference to a GcpVpc resource.
	VpcId string `json:"vpc_id,omitempty" jsonschema:"VPC network ID for private IP connectivity. Can be a literal value or a reference to a GcpVpc resource."`
	// Whether to enable private IP for the instance.
	//  Recommended for secure in-VPC access.
	PrivateIpEnabled bool `json:"private_ip_enabled,omitempty" jsonschema:"Whether to enable private IP for the instance. Recommended for secure in-VPC access."`
	// Whether to enable public IP (IPv4) for the instance.
	//  Can be combined with private IP for "Smart Hybrid" pattern.
	//  When enabled with empty authorized_networks, access is via Cloud SQL Proxy only (IAM-based).
	Ipv4Enabled bool `json:"ipv4_enabled,omitempty" jsonschema:"Whether to enable public IP (IPv4) for the instance. Can be combined with private IP for 'Smart Hybrid' pattern. When enabled with empty authorized_networks; access is via Cloud SQL Proxy only (IAM-ba..."`
	// List of authorized networks (CIDR blocks) allowed to connect via public IP.
	//  Leave empty for maximum security (Cloud SQL Proxy with IAM authentication only).
	AuthorizedNetworks []string `json:"authorized_networks,omitempty" jsonschema:"List of authorized networks (CIDR blocks) allowed to connect via public IP. Leave empty for maximum security (Cloud SQL Proxy with IAM authentication only)."`
}

func (s *GcpCloudSqlNetworkInput) validate() error {
	return nil
}

func (s *GcpCloudSqlNetworkInput) applyDefaults() {
}

func (s *GcpCloudSqlNetworkInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.VpcId != "" {
		m["vpc_id"] = s.VpcId
	}
	if s.PrivateIpEnabled {
		m["private_ip_enabled"] = s.PrivateIpEnabled
	}
	if s.Ipv4Enabled {
		m["ipv4_enabled"] = s.Ipv4Enabled
	}
	if len(s.AuthorizedNetworks) > 0 {
		m["authorized_networks"] = s.AuthorizedNetworks
	}
	return m
}

// ParseGcpCloudSql validates and normalizes a GcpCloudSql cloud_object.
func ParseGcpCloudSql(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudSql"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudSqlSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
