// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-cloud-armor-policy
type GcpCloudArmorPolicySpecInput struct {
	// GCP project where the security policy will be created.
	ProjectId string `json:"project_id" jsonschema:"required,GCP project where the security policy will be created."`
	// Name of the security policy in GCP.
	//  Must be 1-63 characters, lowercase letters, numbers, or hyphens.
	//  Must start with a lowercase letter and end with a letter or number.
	//  If not specified, defaults to metadata.name.
	PolicyName string `json:"policy_name,omitempty" jsonschema:"Name of the security policy in GCP. Must be 1-63 characters; lowercase letters; numbers; or hyphens. Must start with a lowercase letter and end with a letter or number. If not specified; defaults to m..."`
	// Description of the security policy. Max 2048 characters.
	Description string `json:"description,omitempty" jsonschema:"Description of the security policy. Max 2048 characters."`
	// Policy type. Determines which features are available and where
	//  the policy can be attached.
	//
	//  Immutable after creation (ForceNew).
	Type string `json:"type,omitempty" jsonschema:"Policy type. Determines which features are available and where the policy can be attached. Immutable after creation (ForceNew)."`
	// Adaptive Protection configuration for automatic Layer 7 DDoS detection.
	AdaptiveProtectionConfig *GcpCloudArmorAdaptiveProtectionConfigInput `json:"adaptive_protection_config,omitempty" jsonschema:"Adaptive Protection configuration for automatic Layer 7 DDoS detection."`
	// Advanced policy-level options: JSON parsing, logging, IP resolution.
	AdvancedOptionsConfig *GcpCloudArmorAdvancedOptionsConfigInput `json:"advanced_options_config,omitempty" jsonschema:"Advanced policy-level options: JSON parsing; logging; IP resolution."`
	// Security rules. Rules are evaluated in priority order (lowest number
	//  first). Each rule matches traffic and applies an action.
	//
	//  If no rule with priority 2147483647 is included, the IaC modules
	//  auto-add a default "allow all" rule.
	Rules []*GcpCloudArmorRuleInput `json:"rules,omitempty" jsonschema:"Security rules. Rules are evaluated in priority order (lowest number first). Each rule matches traffic and applies an action. If no rule with priority 2147483647 is included; the IaC modules auto-add ..."`
}

func (s *GcpCloudArmorPolicySpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	if s.AdaptiveProtectionConfig != nil {
		if err := s.AdaptiveProtectionConfig.validate(); err != nil {
			return fmt.Errorf("adaptive_protection_config: %w", err)
		}
	}
	if s.AdvancedOptionsConfig != nil {
		if err := s.AdvancedOptionsConfig.validate(); err != nil {
			return fmt.Errorf("advanced_options_config: %w", err)
		}
	}
	for i, v := range s.Rules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpCloudArmorPolicySpecInput) applyDefaults() {
	if s.AdaptiveProtectionConfig != nil {
		s.AdaptiveProtectionConfig.applyDefaults()
	}
	if s.AdvancedOptionsConfig != nil {
		s.AdvancedOptionsConfig.applyDefaults()
	}
}

func (s *GcpCloudArmorPolicySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	if s.PolicyName != "" {
		m["policy_name"] = s.PolicyName
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.AdaptiveProtectionConfig != nil {
		m["adaptive_protection_config"] = s.AdaptiveProtectionConfig.toMap()
	}
	if s.AdvancedOptionsConfig != nil {
		m["advanced_options_config"] = s.AdvancedOptionsConfig.toMap()
	}
	if len(s.Rules) > 0 {
		items := make([]any, len(s.Rules))
		for i, v := range s.Rules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rules"] = items
	}
	return m
}

// GcpCloudArmorAdaptiveProtectionConfig configures Google Cloud Armor
//
//	Adaptive Protection (CAAP) for automatic Layer 7 DDoS detection.
//	When enabled, Adaptive Protection analyzes traffic patterns and
//	alerts on or auto-mitigates anomalous traffic spikes.
type GcpCloudArmorAdaptiveProtectionConfigInput struct {
	// Enable Cloud Armor Adaptive Protection for Layer 7 DDoS defense.
	//  When true, traffic anomalies are detected and alerts are generated.
	EnableLayer7DdosDefense bool `json:"enable_layer_7_ddos_defense,omitempty" jsonschema:"Enable Cloud Armor Adaptive Protection for Layer 7 DDoS defense. When true; traffic anomalies are detected and alerts are generated."`
	// Rule visibility mode for auto-generated adaptive protection rules.
	//  "STANDARD" (default) creates rules visible to all policy viewers.
	//  "PREMIUM" requires Cloud Armor Managed Protection Plus.
	RuleVisibility string `json:"rule_visibility,omitempty" jsonschema:"Rule visibility mode for auto-generated adaptive protection rules. 'STANDARD' (default) creates rules visible to all policy viewers. 'PREMIUM' requires Cloud Armor Managed Protection Plus."`
}

func (s *GcpCloudArmorAdaptiveProtectionConfigInput) validate() error {
	return nil
}

func (s *GcpCloudArmorAdaptiveProtectionConfigInput) applyDefaults() {
}

func (s *GcpCloudArmorAdaptiveProtectionConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EnableLayer7DdosDefense {
		m["enable_layer_7_ddos_defense"] = s.EnableLayer7DdosDefense
	}
	if s.RuleVisibility != "" {
		m["rule_visibility"] = s.RuleVisibility
	}
	return m
}

// GcpCloudArmorAdvancedOptionsConfig configures advanced security
//
//	features at the policy level, including JSON request body parsing,
//	logging verbosity, and client IP resolution.
type GcpCloudArmorAdvancedOptionsConfigInput struct {
	// JSON parsing mode for request body inspection.
	//  "DISABLED" (default): No JSON parsing.
	//  "STANDARD": Parse JSON bodies for WAF rule evaluation.
	//  "STANDARD_WITH_GRAPHQL": Parse JSON and GraphQL bodies.
	JsonParsing string `json:"json_parsing,omitempty" jsonschema:"JSON parsing mode for request body inspection. 'DISABLED' (default): No JSON parsing. 'STANDARD': Parse JSON bodies for WAF rule evaluation. 'STANDARD_WITH_GRAPHQL': Parse JSON and GraphQL bodies."`
	// Logging verbosity.
	//  "NORMAL" (default): Standard logging.
	//  "VERBOSE": Detailed logging including matched rule and request details.
	LogLevel string `json:"log_level,omitempty" jsonschema:"Logging verbosity. 'NORMAL' (default): Standard logging. 'VERBOSE': Detailed logging including matched rule and request details."`
	// Custom headers to check for the true client IP address.
	//  Used when traffic passes through a CDN or reverse proxy that
	//  sets the client IP in a custom header. If empty, GCP uses the
	//  connection source IP.
	UserIpRequestHeaders []string `json:"user_ip_request_headers,omitempty" jsonschema:"Custom headers to check for the true client IP address. Used when traffic passes through a CDN or reverse proxy that sets the client IP in a custom header. If empty; GCP uses the connection source IP."`
	// Maximum size of the request body to inspect for WAF rules.
	//  Larger values inspect more of the body but increase latency.
	//  Default: 8KB if not set.
	RequestBodyInspectionSize string `json:"request_body_inspection_size,omitempty" jsonschema:"Maximum size of the request body to inspect for WAF rules. Larger values inspect more of the body but increase latency. Default: 8KB if not set."`
}

func (s *GcpCloudArmorAdvancedOptionsConfigInput) validate() error {
	return nil
}

func (s *GcpCloudArmorAdvancedOptionsConfigInput) applyDefaults() {
}

func (s *GcpCloudArmorAdvancedOptionsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.JsonParsing != "" {
		m["json_parsing"] = s.JsonParsing
	}
	if s.LogLevel != "" {
		m["log_level"] = s.LogLevel
	}
	if len(s.UserIpRequestHeaders) > 0 {
		m["user_ip_request_headers"] = s.UserIpRequestHeaders
	}
	if s.RequestBodyInspectionSize != "" {
		m["request_body_inspection_size"] = s.RequestBodyInspectionSize
	}
	return m
}

// GcpCloudArmorHeaderAction injects custom headers into requests
//
//	that match the rule. Headers are added before the request is
//	forwarded to the backend. Useful for passing security context
//	or routing hints to backend services.
type GcpCloudArmorHeaderActionInput struct {
	// Headers to add to matching requests.
	RequestHeadersToAdds []*GcpCloudArmorRequestHeaderInput `json:"request_headers_to_adds,omitempty" jsonschema:"Headers to add to matching requests."`
}

func (s *GcpCloudArmorHeaderActionInput) validate() error {
	if len(s.RequestHeadersToAdds) < 1 {
		return fmt.Errorf("request_headers_to_adds requires at least 1 items, got %d", len(s.RequestHeadersToAdds))
	}
	for i, v := range s.RequestHeadersToAdds {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("request_headers_to_adds[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpCloudArmorHeaderActionInput) applyDefaults() {
}

func (s *GcpCloudArmorHeaderActionInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.RequestHeadersToAdds) > 0 {
		items := make([]any, len(s.RequestHeadersToAdds))
		for i, v := range s.RequestHeadersToAdds {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["request_headers_to_adds"] = items
	}
	return m
}

// GcpCloudArmorPreconfiguredWafConfig defines exclusions for preconfigured
//
//	WAF rules attached to this security rule. Without exclusions, legitimate
//	traffic that resembles attack patterns (SQL in search queries, HTML in
//	rich text fields) is blocked by WAF rules.
type GcpCloudArmorPreconfiguredWafConfigInput struct {
	// Exclusions from preconfigured WAF rules.
	Exclusions []*GcpCloudArmorWafExclusionInput `json:"exclusions,omitempty" jsonschema:"Exclusions from preconfigured WAF rules."`
}

func (s *GcpCloudArmorPreconfiguredWafConfigInput) validate() error {
	if len(s.Exclusions) < 1 {
		return fmt.Errorf("exclusions requires at least 1 items, got %d", len(s.Exclusions))
	}
	for i, v := range s.Exclusions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("exclusions[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpCloudArmorPreconfiguredWafConfigInput) applyDefaults() {
}

func (s *GcpCloudArmorPreconfiguredWafConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Exclusions) > 0 {
		items := make([]any, len(s.Exclusions))
		for i, v := range s.Exclusions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["exclusions"] = items
	}
	return m
}

// GcpCloudArmorRateLimitOptions configures rate limiting for throttle
//
//	and rate_based_ban actions.
type GcpCloudArmorRateLimitOptionsInput struct {
	// Action to take when traffic is below the threshold. Must be "allow".
	ConformAction string `json:"conform_action" jsonschema:"required,Action to take when traffic is below the threshold. Must be 'allow'."`
	// Action to take when traffic exceeds the threshold.
	//  Valid values: "redirect", "deny(403)", "deny(404)", "deny(429)", "deny(502)".
	ExceedAction string `json:"exceed_action" jsonschema:"required,Action to take when traffic exceeds the threshold. Valid values: 'redirect'; 'deny(403)'; 'deny(404)'; 'deny(429)'; 'deny(502)'."`
	// Key on which to enforce the rate limit. Determines how requests
	//  are grouped for counting. If empty, defaults to "ALL" (single
	//  counter for all matched traffic).
	//
	//  Common values:
	//    - "ALL": Single counter for all traffic
	//    - "IP": Per source IP
	//    - "HTTP_HEADER": Per value of a specific header (s...
	EnforceOnKey string `json:"enforce_on_key,omitempty" jsonschema:"Key on which to enforce the rate limit. Determines how requests are grouped for counting. If empty; defaults to 'ALL' (single counter for all matched traffic). Common values: - 'ALL': Single counter f..."`
	// Name of the HTTP header or cookie when enforce_on_key is
	//  HTTP_HEADER or HTTP_COOKIE.
	EnforceOnKeyName string `json:"enforce_on_key_name,omitempty" jsonschema:"Name of the HTTP header or cookie when enforce_on_key is HTTP_HEADER or HTTP_COOKIE."`
	// Rate limit threshold: when the request count exceeds this value
	//  within the interval, the exceed_action is applied.
	RateLimitThreshold *GcpCloudArmorRateThresholdInput `json:"rate_limit_threshold" jsonschema:"required,Rate limit threshold: when the request count exceeds this value within the interval; the exceed_action is applied."`
	// Ban threshold for rate_based_ban actions. When traffic exceeds
	//  this threshold after already exceeding the rate_limit_threshold,
	//  the source is banned entirely.
	BanThreshold *GcpCloudArmorRateThresholdInput `json:"ban_threshold,omitempty" jsonschema:"Ban threshold for rate_based_ban actions. When traffic exceeds this threshold after already exceeding the rate_limit_threshold; the source is banned entirely."`
	// Duration of the ban in seconds when using rate_based_ban.
	//  Range: 60 to 86400 (1 minute to 24 hours).
	BanDurationSec int32 `json:"ban_duration_sec,omitempty" jsonschema:"Duration of the ban in seconds when using rate_based_ban. Range: 60 to 86400 (1 minute to 24 hours)."`
	// Redirect configuration when exceed_action is "redirect".
	ExceedRedirectOptions *GcpCloudArmorRedirectConfigInput `json:"exceed_redirect_options,omitempty" jsonschema:"Redirect configuration when exceed_action is 'redirect'."`
}

func (s *GcpCloudArmorRateLimitOptionsInput) validate() error {
	if s.ConformAction == "" {
		return fmt.Errorf("conform_action is required")
	}
	if s.ExceedAction == "" {
		return fmt.Errorf("exceed_action is required")
	}
	if s.RateLimitThreshold == nil {
		return fmt.Errorf("rate_limit_threshold is required")
	}
	if s.RateLimitThreshold != nil {
		if err := s.RateLimitThreshold.validate(); err != nil {
			return fmt.Errorf("rate_limit_threshold: %w", err)
		}
	}
	if s.BanThreshold != nil {
		if err := s.BanThreshold.validate(); err != nil {
			return fmt.Errorf("ban_threshold: %w", err)
		}
	}
	if s.ExceedRedirectOptions != nil {
		if err := s.ExceedRedirectOptions.validate(); err != nil {
			return fmt.Errorf("exceed_redirect_options: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudArmorRateLimitOptionsInput) applyDefaults() {
	if s.RateLimitThreshold != nil {
		s.RateLimitThreshold.applyDefaults()
	}
	if s.BanThreshold != nil {
		s.BanThreshold.applyDefaults()
	}
	if s.ExceedRedirectOptions != nil {
		s.ExceedRedirectOptions.applyDefaults()
	}
}

func (s *GcpCloudArmorRateLimitOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["conform_action"] = s.ConformAction
	m["exceed_action"] = s.ExceedAction
	if s.EnforceOnKey != "" {
		m["enforce_on_key"] = s.EnforceOnKey
	}
	if s.EnforceOnKeyName != "" {
		m["enforce_on_key_name"] = s.EnforceOnKeyName
	}
	if s.RateLimitThreshold != nil {
		m["rate_limit_threshold"] = s.RateLimitThreshold.toMap()
	}
	if s.BanThreshold != nil {
		m["ban_threshold"] = s.BanThreshold.toMap()
	}
	if s.BanDurationSec != 0 {
		m["ban_duration_sec"] = s.BanDurationSec
	}
	if s.ExceedRedirectOptions != nil {
		m["exceed_redirect_options"] = s.ExceedRedirectOptions.toMap()
	}
	return m
}

// GcpCloudArmorRateThreshold defines a request-count threshold over a time
//
//	interval. Used by both rate_limit_threshold (when to start throttling)
//	and ban_threshold (when to escalate to a ban).
type GcpCloudArmorRateThresholdInput struct {
	// Number of requests that triggers the threshold.
	Count int32 `json:"count" jsonschema:"required,Number of requests that triggers the threshold."`
	// Window of time in seconds over which the count is measured.
	//  Allowed values: 60, 120, 180, 240, 300, 600, 900, 1200.
	IntervalSec int32 `json:"interval_sec" jsonschema:"required,Window of time in seconds over which the count is measured. Allowed values: 60; 120; 180; 240; 300; 600; 900; 1200."`
}

func (s *GcpCloudArmorRateThresholdInput) validate() error {
	return nil
}

func (s *GcpCloudArmorRateThresholdInput) applyDefaults() {
}

func (s *GcpCloudArmorRateThresholdInput) toMap() map[string]any {
	m := make(map[string]any)
	m["count"] = s.Count
	m["interval_sec"] = s.IntervalSec
	return m
}

// GcpCloudArmorRedirectConfig defines a redirect target for rule actions
//
//	or rate-limit exceed actions. Shared between rule-level redirect_options
//	and rate_limit_options.exceed_redirect_options.
type GcpCloudArmorRedirectConfigInput struct {
	// Redirect type. EXTERNAL_302 sends a 302 redirect to the target URL.
	//  GOOGLE_RECAPTCHA redirects to a Google reCAPTCHA challenge page.
	Type string `json:"type" jsonschema:"required,Redirect type. EXTERNAL_302 sends a 302 redirect to the target URL. GOOGLE_RECAPTCHA redirects to a Google reCAPTCHA challenge page."`
	// Target URL for EXTERNAL_302 redirects. Required when type is
	//  EXTERNAL_302; must not be set when type is GOOGLE_RECAPTCHA.
	Target string `json:"target,omitempty" jsonschema:"Target URL for EXTERNAL_302 redirects. Required when type is EXTERNAL_302; must not be set when type is GOOGLE_RECAPTCHA."`
}

func (s *GcpCloudArmorRedirectConfigInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *GcpCloudArmorRedirectConfigInput) applyDefaults() {
}

func (s *GcpCloudArmorRedirectConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.Target != "" {
		m["target"] = s.Target
	}
	return m
}

// GcpCloudArmorRequestHeader defines a header to add to requests
//
//	that match the rule.
type GcpCloudArmorRequestHeaderInput struct {
	// HTTP header name.
	HeaderName string `json:"header_name" jsonschema:"required,HTTP header name."`
	// HTTP header value. If the header already exists, it is overwritten.
	HeaderValue string `json:"header_value,omitempty" jsonschema:"HTTP header value. If the header already exists; it is overwritten."`
}

func (s *GcpCloudArmorRequestHeaderInput) validate() error {
	if s.HeaderName == "" {
		return fmt.Errorf("header_name is required")
	}
	return nil
}

func (s *GcpCloudArmorRequestHeaderInput) applyDefaults() {
}

func (s *GcpCloudArmorRequestHeaderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["header_name"] = s.HeaderName
	if s.HeaderValue != "" {
		m["header_value"] = s.HeaderValue
	}
	return m
}

// GcpCloudArmorRule defines a single security rule within the policy.
//
//	Rules are evaluated in priority order (lowest number = highest priority).
//	Every policy must have a default rule at priority 2147483647 -- if not
//	provided, the IaC modules auto-add a default "allow all" rule matching
//	the behavior of the GCP Terraform and Pulumi providers.
type GcpCloudArmorRuleInput struct {
	// Action to take when the rule matches.
	//  - "allow": Permit the request
	//  - "deny(403)": Block with 403 Forbidden
	//  - "deny(404)": Block with 404 Not Found
	//  - "deny(502)": Block with 502 Bad Gateway
	//  - "redirect": Redirect to a configured target (requires redirect_options)
	//  - "throttle": Rate-limit the t...
	Action string `json:"action" jsonschema:"required,Action to take when the rule matches. - 'allow': Permit the request - 'deny(403)': Block with 403 Forbidden - 'deny(404)': Block with 404 Not Found - 'deny(502)': Block with 502 Bad Gateway - 'redirec..."`
	// Rule priority. Lower values are evaluated first.
	//  Range: 0 to 2147483647. Each rule must have a unique priority.
	//  Priority 2147483647 is reserved for the default rule.
	Priority int32 `json:"priority" jsonschema:"required,Rule priority. Lower values are evaluated first. Range: 0 to 2147483647. Each rule must have a unique priority. Priority 2147483647 is reserved for the default rule."`
	// Traffic-matching condition. Defines which requests this rule applies to.
	Match *GcpCloudArmorRuleMatchInput `json:"match" jsonschema:"required,Traffic-matching condition. Defines which requests this rule applies to."`
	// Human-readable description of the rule (max 64 characters).
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the rule (max 64 characters)."`
	// If true, the rule is in preview mode: matched traffic is logged but
	//  the action is not enforced. Use preview to test rules before enabling.
	Preview bool `json:"preview,omitempty" jsonschema:"If true; the rule is in preview mode: matched traffic is logged but the action is not enforced. Use preview to test rules before enabling."`
	// Rate limit configuration. Required when action is "throttle" or
	//  "rate_based_ban".
	RateLimitOptions *GcpCloudArmorRateLimitOptionsInput `json:"rate_limit_options,omitempty" jsonschema:"Rate limit configuration. Required when action is 'throttle' or 'rate_based_ban'."`
	// Redirect configuration. Required when action is "redirect".
	RedirectOptions *GcpCloudArmorRedirectConfigInput `json:"redirect_options,omitempty" jsonschema:"Redirect configuration. Required when action is 'redirect'."`
	// Custom headers to inject into matching requests before forwarding
	//  to the backend. Only supported for CLOUD_ARMOR type policies.
	HeaderAction *GcpCloudArmorHeaderActionInput `json:"header_action,omitempty" jsonschema:"Custom headers to inject into matching requests before forwarding to the backend. Only supported for CLOUD_ARMOR type policies."`
	// Preconfigured WAF rule exclusions. Use this to carve out exceptions
	//  for specific request fields that trigger false positives in WAF rules.
	//  Only supported for CLOUD_ARMOR type policies.
	PreconfiguredWafConfig *GcpCloudArmorPreconfiguredWafConfigInput `json:"preconfigured_waf_config,omitempty" jsonschema:"Preconfigured WAF rule exclusions. Use this to carve out exceptions for specific request fields that trigger false positives in WAF rules. Only supported for CLOUD_ARMOR type policies."`
}

func (s *GcpCloudArmorRuleInput) validate() error {
	if s.Action == "" {
		return fmt.Errorf("action is required")
	}
	if s.Match == nil {
		return fmt.Errorf("match is required")
	}
	if s.Match != nil {
		if err := s.Match.validate(); err != nil {
			return fmt.Errorf("match: %w", err)
		}
	}
	if s.RateLimitOptions != nil {
		if err := s.RateLimitOptions.validate(); err != nil {
			return fmt.Errorf("rate_limit_options: %w", err)
		}
	}
	if s.RedirectOptions != nil {
		if err := s.RedirectOptions.validate(); err != nil {
			return fmt.Errorf("redirect_options: %w", err)
		}
	}
	if s.HeaderAction != nil {
		if err := s.HeaderAction.validate(); err != nil {
			return fmt.Errorf("header_action: %w", err)
		}
	}
	if s.PreconfiguredWafConfig != nil {
		if err := s.PreconfiguredWafConfig.validate(); err != nil {
			return fmt.Errorf("preconfigured_waf_config: %w", err)
		}
	}
	return nil
}

func (s *GcpCloudArmorRuleInput) applyDefaults() {
	if s.Match != nil {
		s.Match.applyDefaults()
	}
	if s.RateLimitOptions != nil {
		s.RateLimitOptions.applyDefaults()
	}
	if s.RedirectOptions != nil {
		s.RedirectOptions.applyDefaults()
	}
	if s.HeaderAction != nil {
		s.HeaderAction.applyDefaults()
	}
	if s.PreconfiguredWafConfig != nil {
		s.PreconfiguredWafConfig.applyDefaults()
	}
}

func (s *GcpCloudArmorRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["action"] = s.Action
	m["priority"] = s.Priority
	if s.Match != nil {
		m["match"] = s.Match.toMap()
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Preview {
		m["preview"] = s.Preview
	}
	if s.RateLimitOptions != nil {
		m["rate_limit_options"] = s.RateLimitOptions.toMap()
	}
	if s.RedirectOptions != nil {
		m["redirect_options"] = s.RedirectOptions.toMap()
	}
	if s.HeaderAction != nil {
		m["header_action"] = s.HeaderAction.toMap()
	}
	if s.PreconfiguredWafConfig != nil {
		m["preconfigured_waf_config"] = s.PreconfiguredWafConfig.toMap()
	}
	return m
}

// GcpCloudArmorRuleMatch defines the traffic-matching condition for a rule.
//
//	Two matching modes are available (mutually exclusive):
//
//	  - **IP-based**: Set versioned_expr to "SRC_IPS_V1" and provide
//	    src_ip_ranges. Matches traffic from the listed CIDR ranges.
//
//	  - **CEL expression**: Set expression with a Common Expression
//	    Language (CEL) rule. Supports request attributes like
//	    origin.region_code, request.headers, request.path, etc.
//
//	Use "*" in src_ip_ranges to match all traffic.
type GcpCloudArmorRuleMatchInput struct {
	// Predefined match expression. The only supported value is "SRC_IPS_V1",
	//  which matches traffic based on source IP address ranges.
	//  When set, src_ip_ranges must also be provided.
	VersionedExpr string `json:"versioned_expr,omitempty" jsonschema:"Predefined match expression. The only supported value is 'SRC_IPS_V1'; which matches traffic based on source IP address ranges. When set; src_ip_ranges must also be provided."`
	// Source IP CIDR ranges to match against.
	//  Required when versioned_expr is "SRC_IPS_V1". Max 10 ranges per rule.
	//  Use "*" to match all IP addresses.
	//  Examples: ["192.168.1.0/24", "10.0.0.0/8"] or ["*"]
	SrcIpRanges []string `json:"src_ip_ranges,omitempty" jsonschema:"Source IP CIDR ranges to match against. Required when versioned_expr is 'SRC_IPS_V1'. Max 10 ranges per rule. Use '*' to match all IP addresses. Examples: ['192.168.1.0/24'; '10.0.0.0/8'] or ['*']"`
	// CEL expression for advanced matching. Supports request attributes
	//  such as origin.region_code, request.headers['X-Custom'], request.path,
	//  inIpRange(origin.ip, '1.2.3.0/24'), and more.
	//  Mutually exclusive with versioned_expr.
	//  Example: "origin.region_code == 'US'" or "request.path.matches('/api/.*')...
	Expression string `json:"expression,omitempty" jsonschema:"CEL expression for advanced matching. Supports request attributes such as origin.region_code; request.headers['X-Custom']; request.path; inIpRange(origin.ip; '1.2.3.0/24'); and more. Mutually exclusiv..."`
}

func (s *GcpCloudArmorRuleMatchInput) validate() error {
	return nil
}

func (s *GcpCloudArmorRuleMatchInput) applyDefaults() {
}

func (s *GcpCloudArmorRuleMatchInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.VersionedExpr != "" {
		m["versioned_expr"] = s.VersionedExpr
	}
	if len(s.SrcIpRanges) > 0 {
		m["src_ip_ranges"] = s.SrcIpRanges
	}
	if s.Expression != "" {
		m["expression"] = s.Expression
	}
	return m
}

// GcpCloudArmorWafExclusion defines an exclusion from a preconfigured
//
//	WAF rule set. WAF exclusions are critical for production deployments
//	where false positives from OWASP rules may block legitimate traffic
//	(e.g., form submissions with SQL-like content, rich text editors,
//	GraphQL queries).
type GcpCloudArmorWafExclusionInput struct {
	// Target WAF rule set to exclude from. Uses the ModSecurity rule set
	//  identifiers such as "sqli-v33-stable", "xss-v33-stable",
	//  "rce-v33-stable", "lfi-v33-stable", etc.
	TargetRuleSet string `json:"target_rule_set" jsonschema:"required,Target WAF rule set to exclude from. Uses the ModSecurity rule set identifiers such as 'sqli-v33-stable'; 'xss-v33-stable'; 'rce-v33-stable'; 'lfi-v33-stable'; etc."`
	// Specific rule IDs within the rule set to exclude. If empty,
	//  the exclusion applies to all rules in the set.
	TargetRuleIds []string `json:"target_rule_ids,omitempty" jsonschema:"Specific rule IDs within the rule set to exclude. If empty; the exclusion applies to all rules in the set."`
	// Request headers to exclude from WAF evaluation.
	RequestHeaders []*GcpCloudArmorWafExclusionFieldParamsInput `json:"request_headers,omitempty" jsonschema:"Request headers to exclude from WAF evaluation."`
	// Request cookies to exclude from WAF evaluation.
	RequestCookies []*GcpCloudArmorWafExclusionFieldParamsInput `json:"request_cookies,omitempty" jsonschema:"Request cookies to exclude from WAF evaluation."`
	// Request URIs to exclude from WAF evaluation.
	RequestUris []*GcpCloudArmorWafExclusionFieldParamsInput `json:"request_uris,omitempty" jsonschema:"Request URIs to exclude from WAF evaluation."`
	// Request query parameters to exclude from WAF evaluation.
	RequestQueryParams []*GcpCloudArmorWafExclusionFieldParamsInput `json:"request_query_params,omitempty" jsonschema:"Request query parameters to exclude from WAF evaluation."`
}

func (s *GcpCloudArmorWafExclusionInput) validate() error {
	if s.TargetRuleSet == "" {
		return fmt.Errorf("target_rule_set is required")
	}
	for i, v := range s.RequestHeaders {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("request_headers[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RequestCookies {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("request_cookies[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RequestUris {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("request_uris[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.RequestQueryParams {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("request_query_params[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpCloudArmorWafExclusionInput) applyDefaults() {
}

func (s *GcpCloudArmorWafExclusionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["target_rule_set"] = s.TargetRuleSet
	if len(s.TargetRuleIds) > 0 {
		m["target_rule_ids"] = s.TargetRuleIds
	}
	if len(s.RequestHeaders) > 0 {
		items := make([]any, len(s.RequestHeaders))
		for i, v := range s.RequestHeaders {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["request_headers"] = items
	}
	if len(s.RequestCookies) > 0 {
		items := make([]any, len(s.RequestCookies))
		for i, v := range s.RequestCookies {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["request_cookies"] = items
	}
	if len(s.RequestUris) > 0 {
		items := make([]any, len(s.RequestUris))
		for i, v := range s.RequestUris {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["request_uris"] = items
	}
	if len(s.RequestQueryParams) > 0 {
		items := make([]any, len(s.RequestQueryParams))
		for i, v := range s.RequestQueryParams {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["request_query_params"] = items
	}
	return m
}

// GcpCloudArmorWafExclusionFieldParams identifies a specific request
//
//	component to exclude from WAF rule evaluation.
type GcpCloudArmorWafExclusionFieldParamsInput struct {
	// Comparison operator for matching the field.
	Operator string `json:"operator" jsonschema:"required,Comparison operator for matching the field."`
	// Value to match against. Required unless operator is EQUALS_ANY
	//  (which matches any value for the given field).
	Value string `json:"value,omitempty" jsonschema:"Value to match against. Required unless operator is EQUALS_ANY (which matches any value for the given field)."`
}

func (s *GcpCloudArmorWafExclusionFieldParamsInput) validate() error {
	if s.Operator == "" {
		return fmt.Errorf("operator is required")
	}
	return nil
}

func (s *GcpCloudArmorWafExclusionFieldParamsInput) applyDefaults() {
}

func (s *GcpCloudArmorWafExclusionFieldParamsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["operator"] = s.Operator
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// ParseGcpCloudArmorPolicy validates and normalizes a GcpCloudArmorPolicy cloud_object.
func ParseGcpCloudArmorPolicy(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpCloudArmorPolicy"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpCloudArmorPolicySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
