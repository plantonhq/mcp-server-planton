// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package gcp

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// gcp-dns-zone
type GcpDnsZoneSpecInput struct {
	// The ID of the GCP project where the Managed Zone is created.
	//  This can be a direct value or a reference to another resource's output.
	//  Example: "my-gcp-project-123" or a reference to a GcpProject resource.
	ProjectId string `json:"project_id" jsonschema:"required,The ID of the GCP project where the Managed Zone is created. This can be a direct value or a reference to another resource's output. Example: 'my-gcp-project-123' or a reference to a GcpProject resour..."`
	// An optional list of GCP service accounts that are granted permissions to manage DNS records in the Managed Zone.
	//  These accounts are typically workload identities, such as those used by cert-manager,
	//  and are added when new environments are created or updated.
	IamServiceAccounts []string `json:"iam_service_accounts,omitempty" jsonschema:"An optional list of GCP service accounts that are granted permissions to manage DNS records in the Managed Zone. These accounts are typically workload identities; such as those used by cert-manager; a..."`
	// The DNS records to be added to the Managed Zone.
	Records []*GcpDnsRecordInput `json:"records,omitempty" jsonschema:"The DNS records to be added to the Managed Zone."`
}

func (s *GcpDnsZoneSpecInput) validate() error {
	if s.ProjectId == "" {
		return fmt.Errorf("project_id is required")
	}
	for i, v := range s.Records {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("records[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *GcpDnsZoneSpecInput) applyDefaults() {
}

func (s *GcpDnsZoneSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["project_id"] = s.ProjectId
	if len(s.IamServiceAccounts) > 0 {
		m["iam_service_accounts"] = s.IamServiceAccounts
	}
	if len(s.Records) > 0 {
		items := make([]any, len(s.Records))
		for i, v := range s.Records {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["records"] = items
	}
	return m
}

// **GcpDnsRecord** represents a DNS record to be added to the Managed Zone.
//
//	It includes the record type, name, values, and TTL (Time To Live) settings.
type GcpDnsRecordInput struct {
	// The DNS record type (e.g., A, AAAA, CNAME).
	RecordType string `json:"record_type" jsonschema:"required,enum=A|AAAA|ALIAS|CNAME|MX|NS|PTR|SOA|SRV|TXT|CAA,The DNS record type (e.g.; A; AAAA; CNAME)."`
	// The name of the DNS record (e.g., "example.com." or "dev.example.com.").
	//  This value should always end with a dot to signify a fully qualified domain name.
	Name string `json:"name" jsonschema:"required,The name of the DNS record (e.g.; 'example.com.' or 'dev.example.com.'). This value should always end with a dot to signify a fully qualified domain name."`
	// The list of values for the DNS record.
	//  If the record type is CNAME, each value in the list should end with a dot.
	Values []string `json:"values,omitempty" jsonschema:"The list of values for the DNS record. If the record type is CNAME; each value in the list should end with a dot."`
	// The Time To Live (TTL) for the DNS record, in seconds.
	TtlSeconds int32 `json:"ttl_seconds,omitempty" jsonschema:"The Time To Live (TTL) for the DNS record; in seconds."`
}

func (s *GcpDnsRecordInput) validate() error {
	if s.RecordType == "" {
		return fmt.Errorf("record_type is required")
	}
	switch s.RecordType {
	case "A", "AAAA", "ALIAS", "CNAME", "MX", "NS", "PTR", "SOA", "SRV", "TXT", "CAA":
	default:
		return fmt.Errorf("invalid record_type: %q", s.RecordType)
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.Values) < 1 {
		return fmt.Errorf("values requires at least 1 items, got %d", len(s.Values))
	}
	return nil
}

func (s *GcpDnsRecordInput) applyDefaults() {
	if s.TtlSeconds == 0 {
		s.TtlSeconds = 60
	}
}

func (s *GcpDnsRecordInput) toMap() map[string]any {
	m := make(map[string]any)
	m["record_type"] = s.RecordType
	m["name"] = s.Name
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.TtlSeconds != 0 {
		m["ttl_seconds"] = s.TtlSeconds
	}
	return m
}

// ParseGcpDnsZone validates and normalizes a GcpDnsZone cloud_object.
func ParseGcpDnsZone(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "gcp.openmcf.org/v1", "GcpDnsZone"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec GcpDnsZoneSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
