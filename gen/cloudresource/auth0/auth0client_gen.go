// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package auth0

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// Auth0Client is a deployment component that configures an Application in Auth0.
//
//	In the Auth0 dashboard, these are shown as "Applications" - they represent clients
//	that can authenticate users and request access to APIs.
//
//	This component supports all Auth0 application types:
//	- Native applications (mobile, desktop, CLI)
//	- Single Page Applications (SPAs)
//	- Regular web applications (server-side rendered)
//	- Machine-to-Machine (M2M) applications
//
//	Example manifest for a SPA:
//	```yaml
//	apiVersion: auth0.openmcf.org/v1
//	kind: Auth0Client
//	metadata:
//	  name: my-spa-app
//	  org: my-organization
//	  env: production
//	spec:
//	  application_type: spa
//	  description: My React SPA
//	  callbacks:
//	    - https://myapp.com/callback
//	    - http://localhost:3000/callback
//	  allowed_logout_urls:
//	    - https://myapp.com
//	    - http://localhost:3000
//	  web_origins:
//	    - https://myapp.com
//	    - http://localhost:3000
//	  grant_types:
//	    - authorization_code
//	    - refresh_token
//	```
//
//	Example manifest for M2M application:
//	```yaml
//	apiVersion: auth0.openmcf.org/v1
//	kind: Auth0Client
//	metadata:
//	  name: backend-api-client
//	  org: my-organization
//	spec:
//	  application_type: non_interactive
//	  description: Backend API service client
//	  grant_types:
//	    - client_credentials
//	```
type Auth0ClientSpecInput struct {
	// application_type defines the type of application being registered.
	//  This determines the appropriate OAuth flows and security settings.
	//
	//  - "native": Mobile, desktop, or CLI applications that run natively on a device.
	//    Uses Authorization Code with PKCE. Cannot securely store secrets.
	//  - "spa": Sing...
	ApplicationType string `json:"application_type" jsonschema:"required,application_type defines the type of application being registered. This determines the appropriate OAuth flows and security settings. - 'native': Mobile; desktop; or CLI applications that run natively..."`
	// description is an optional free-text description of the application.
	//  Useful for documenting the purpose, owner, or other metadata.
	//  Maximum 140 characters.
	Description string `json:"description,omitempty" jsonschema:"description is an optional free-text description of the application. Useful for documenting the purpose; owner; or other metadata. Maximum 140 characters."`
	// logo_uri is the URL of the application's logo.
	//  This is displayed on the consent page and login page.
	//  Must be a valid HTTPS URL to an image file.
	LogoUri string `json:"logo_uri,omitempty" jsonschema:"logo_uri is the URL of the application's logo. This is displayed on the consent page and login page. Must be a valid HTTPS URL to an image file."`
	// callbacks are the allowed callback URLs for the application.
	//  After authentication, Auth0 will only redirect to URLs in this list.
	//  For SPAs and native apps, include your development and production URLs.
	//  Example: ["https://myapp.com/callback", "http://localhost:3000/callback"]
	Callbacks []string `json:"callbacks,omitempty" jsonschema:"callbacks are the allowed callback URLs for the application. After authentication; Auth0 will only redirect to URLs in this list. For SPAs and native apps; include your development and production URLs..."`
	// allowed_logout_urls are URLs that Auth0 can redirect to after logout.
	//  Must be registered here to be used with the logout endpoint.
	//  Example: ["https://myapp.com", "http://localhost:3000"]
	AllowedLogoutUrls []string `json:"allowed_logout_urls,omitempty" jsonschema:"allowed_logout_urls are URLs that Auth0 can redirect to after logout. Must be registered here to be used with the logout endpoint. Example: ['https://myapp.com'; 'http://localhost:3000']"`
	// web_origins are the allowed origins for web message response mode.
	//  Required for SPAs using popup or iframe-based authentication.
	//  Example: ["https://myapp.com", "http://localhost:3000"]
	WebOrigins []string `json:"web_origins,omitempty" jsonschema:"web_origins are the allowed origins for web message response mode. Required for SPAs using popup or iframe-based authentication. Example: ['https://myapp.com'; 'http://localhost:3000']"`
	// allowed_origins are CORS origins allowed for this application.
	//  Used for cross-origin requests from JavaScript applications.
	//  Example: ["https://myapp.com"]
	AllowedOrigins []string `json:"allowed_origins,omitempty" jsonschema:"allowed_origins are CORS origins allowed for this application. Used for cross-origin requests from JavaScript applications. Example: ['https://myapp.com']"`
	// grant_types specifies which OAuth grant types this application can use.
	//  If not specified, defaults are based on application_type.
	//
	//  Common grant types:
	//  - "authorization_code": Standard OAuth 2.0 authorization code flow
	//  - "implicit": Implicit flow (legacy, not recommended)
	//  - "refresh_token": Allo...
	GrantTypes []string `json:"grant_types,omitempty" jsonschema:"grant_types specifies which OAuth grant types this application can use. If not specified; defaults are based on application_type. Common grant types: - 'authorization_code': Standard OAuth 2.0 authori..."`
	// oidc_conformant enables stricter OIDC-conformant behavior.
	//  When true, the application will follow OIDC specification strictly.
	//  Recommended for new applications.
	//  Default: true
	OidcConformant bool `json:"oidc_conformant,omitempty" jsonschema:"oidc_conformant enables stricter OIDC-conformant behavior. When true; the application will follow OIDC specification strictly. Recommended for new applications. Default: true"`
	// is_first_party indicates whether this is a first-party application.
	//  First-party apps are owned by the same entity as the Auth0 tenant.
	//  They skip the consent prompt for users.
	//  Default: true
	IsFirstParty bool `json:"is_first_party,omitempty" jsonschema:"is_first_party indicates whether this is a first-party application. First-party apps are owned by the same entity as the Auth0 tenant. They skip the consent prompt for users. Default: true"`
	// cross_origin_authentication enables cross-origin authentication.
	//  Required for embedded login forms in SPAs.
	//  Only enable if you understand the security implications.
	//  Default: false
	CrossOriginAuthentication bool `json:"cross_origin_authentication,omitempty" jsonschema:"cross_origin_authentication enables cross-origin authentication. Required for embedded login forms in SPAs. Only enable if you understand the security implications. Default: false"`
	// cross_origin_loc is the URL for cross-origin verification fallback.
	//  Used with cross-origin authentication for certain browsers.
	CrossOriginLoc string `json:"cross_origin_loc,omitempty" jsonschema:"cross_origin_loc is the URL for cross-origin verification fallback. Used with cross-origin authentication for certain browsers."`
	// sso enables Single Sign-On for this application.
	//  When enabled, users who are already logged in won't need to re-authenticate.
	//  Default: true
	Sso bool `json:"sso,omitempty" jsonschema:"sso enables Single Sign-On for this application. When enabled; users who are already logged in won't need to re-authenticate. Default: true"`
	// sso_disabled explicitly disables SSO for this application.
	//  Set to true to require authentication for each session.
	//  Default: false
	SsoDisabled bool `json:"sso_disabled,omitempty" jsonschema:"sso_disabled explicitly disables SSO for this application. Set to true to require authentication for each session. Default: false"`
	// custom_login_page is the custom HTML for the login page.
	//  Allows complete customization of the login experience.
	//  Only used when custom_login_page_on is true.
	CustomLoginPage string `json:"custom_login_page,omitempty" jsonschema:"custom_login_page is the custom HTML for the login page. Allows complete customization of the login experience. Only used when custom_login_page_on is true."`
	// custom_login_page_on enables the custom login page.
	//  When true, uses custom_login_page instead of Universal Login.
	//  Default: false
	CustomLoginPageOn bool `json:"custom_login_page_on,omitempty" jsonschema:"custom_login_page_on enables the custom login page. When true; uses custom_login_page instead of Universal Login. Default: false"`
	// initiate_login_uri is the URL to initiate login (for OIDC third-party apps).
	//  Used for third-party initiated login flows.
	InitiateLoginUri string `json:"initiate_login_uri,omitempty" jsonschema:"initiate_login_uri is the URL to initiate login (for OIDC third-party apps). Used for third-party initiated login flows."`
	// organization_usage determines how organizations are used with this app.
	//  - "deny": Organizations cannot be used (default for most apps)
	//  - "allow": Organizations can be used optionally
	//  - "require": Organizations must be specified at login
	OrganizationUsage string `json:"organization_usage,omitempty" jsonschema:"organization_usage determines how organizations are used with this app. - 'deny': Organizations cannot be used (default for most apps) - 'allow': Organizations can be used optionally - 'require': Orga..."`
	// organization_require_behavior specifies when org is required.
	//  - "no_prompt": Fail silently if no organization specified
	//  - "pre_login_prompt": Show organization picker before login
	//  - "post_login_prompt": Show organization picker after login
	//  Only used when organization_usage is "require".
	OrganizationRequireBehavior string `json:"organization_require_behavior,omitempty" jsonschema:"organization_require_behavior specifies when org is required. - 'no_prompt': Fail silently if no organization specified - 'pre_login_prompt': Show organization picker before login - 'post_login_prompt..."`
	// jwt_configuration contains settings for JWT tokens issued to this client.
	JwtConfiguration *Auth0JwtConfigurationInput `json:"jwt_configuration,omitempty" jsonschema:"jwt_configuration contains settings for JWT tokens issued to this client."`
	// refresh_token contains settings for refresh token behavior.
	RefreshToken *Auth0RefreshTokenConfigurationInput `json:"refresh_token,omitempty" jsonschema:"refresh_token contains settings for refresh token behavior."`
	// native_social_login configures native social login for mobile apps.
	//  Only applicable for native application types.
	NativeSocialLogin *Auth0NativeSocialLoginInput `json:"native_social_login,omitempty" jsonschema:"native_social_login configures native social login for mobile apps. Only applicable for native application types."`
	// mobile configures mobile-specific settings.
	//  Only applicable for native application types.
	Mobile *Auth0MobileConfigurationInput `json:"mobile,omitempty" jsonschema:"mobile configures mobile-specific settings. Only applicable for native application types."`
	// client_metadata is a map of custom metadata key-value pairs.
	//  Useful for storing application-specific configuration.
	//  Maximum 10 key-value pairs.
	ClientMetadata map[string]string `json:"client_metadata,omitempty" jsonschema:"client_metadata is a map of custom metadata key-value pairs. Useful for storing application-specific configuration. Maximum 10 key-value pairs."`
	// client_aliases are alternative identifiers for this client.
	//  Can be used in authentication requests instead of client_id.
	ClientAliases []string `json:"client_aliases,omitempty" jsonschema:"client_aliases are alternative identifiers for this client. Can be used in authentication requests instead of client_id."`
	// is_token_endpoint_ip_header_trusted determines if IP header is trusted.
	//  When true, Auth0 uses X-Forwarded-For header for IP-based features.
	//  Default: false
	IsTokenEndpointIpHeaderTrusted bool `json:"is_token_endpoint_ip_header_trusted,omitempty" jsonschema:"is_token_endpoint_ip_header_trusted determines if IP header is trusted. When true; Auth0 uses X-Forwarded-For header for IP-based features. Default: false"`
	// oidc_backchannel_logout configures OIDC back-channel logout.
	OidcBackchannelLogout *Auth0OidcBackchannelLogoutInput `json:"oidc_backchannel_logout,omitempty" jsonschema:"oidc_backchannel_logout configures OIDC back-channel logout."`
	// enabled_connections limits which connections this app can use.
	//  If empty, all connections are available.
	//
	//  You can provide either:
	//  - Direct connection name: {value: "Username-Password-Authentication"}
	//  - Reference to Auth0Connection component: {value_from: {kind: Auth0Connection, name: "my-connecti...
	EnabledConnections []string `json:"enabled_connections,omitempty" jsonschema:"enabled_connections limits which connections this app can use. If empty; all connections are available. You can provide either: - Direct connection name: {value: 'Username-Password-Authentication'} - ..."`
	// api_grants configures which APIs this client is authorized to access.
	//  For M2M applications using client_credentials grant, at least one API grant is typically required.
	//  Each entry creates an auth0_client_grant resource linking this client to an API.
	//
	//  Without api_grants, an M2M application can aut...
	ApiGrants []*Auth0ClientApiGrantInput `json:"api_grants,omitempty" jsonschema:"api_grants configures which APIs this client is authorized to access. For M2M applications using client_credentials grant; at least one API grant is typically required. Each entry creates an auth0_cli..."`
}

func (s *Auth0ClientSpecInput) validate() error {
	if s.ApplicationType == "" {
		return fmt.Errorf("application_type is required")
	}
	if s.JwtConfiguration != nil {
		if err := s.JwtConfiguration.validate(); err != nil {
			return fmt.Errorf("jwt_configuration: %w", err)
		}
	}
	if s.RefreshToken != nil {
		if err := s.RefreshToken.validate(); err != nil {
			return fmt.Errorf("refresh_token: %w", err)
		}
	}
	if s.NativeSocialLogin != nil {
		if err := s.NativeSocialLogin.validate(); err != nil {
			return fmt.Errorf("native_social_login: %w", err)
		}
	}
	if s.Mobile != nil {
		if err := s.Mobile.validate(); err != nil {
			return fmt.Errorf("mobile: %w", err)
		}
	}
	if s.OidcBackchannelLogout != nil {
		if err := s.OidcBackchannelLogout.validate(); err != nil {
			return fmt.Errorf("oidc_backchannel_logout: %w", err)
		}
	}
	for i, v := range s.ApiGrants {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("api_grants[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *Auth0ClientSpecInput) applyDefaults() {
	if s.JwtConfiguration != nil {
		s.JwtConfiguration.applyDefaults()
	}
	if s.RefreshToken != nil {
		s.RefreshToken.applyDefaults()
	}
	if s.NativeSocialLogin != nil {
		s.NativeSocialLogin.applyDefaults()
	}
	if s.Mobile != nil {
		s.Mobile.applyDefaults()
	}
	if s.OidcBackchannelLogout != nil {
		s.OidcBackchannelLogout.applyDefaults()
	}
}

func (s *Auth0ClientSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["application_type"] = s.ApplicationType
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.LogoUri != "" {
		m["logo_uri"] = s.LogoUri
	}
	if len(s.Callbacks) > 0 {
		m["callbacks"] = s.Callbacks
	}
	if len(s.AllowedLogoutUrls) > 0 {
		m["allowed_logout_urls"] = s.AllowedLogoutUrls
	}
	if len(s.WebOrigins) > 0 {
		m["web_origins"] = s.WebOrigins
	}
	if len(s.AllowedOrigins) > 0 {
		m["allowed_origins"] = s.AllowedOrigins
	}
	if len(s.GrantTypes) > 0 {
		m["grant_types"] = s.GrantTypes
	}
	if s.OidcConformant {
		m["oidc_conformant"] = s.OidcConformant
	}
	if s.IsFirstParty {
		m["is_first_party"] = s.IsFirstParty
	}
	if s.CrossOriginAuthentication {
		m["cross_origin_authentication"] = s.CrossOriginAuthentication
	}
	if s.CrossOriginLoc != "" {
		m["cross_origin_loc"] = s.CrossOriginLoc
	}
	if s.Sso {
		m["sso"] = s.Sso
	}
	if s.SsoDisabled {
		m["sso_disabled"] = s.SsoDisabled
	}
	if s.CustomLoginPage != "" {
		m["custom_login_page"] = s.CustomLoginPage
	}
	if s.CustomLoginPageOn {
		m["custom_login_page_on"] = s.CustomLoginPageOn
	}
	if s.InitiateLoginUri != "" {
		m["initiate_login_uri"] = s.InitiateLoginUri
	}
	if s.OrganizationUsage != "" {
		m["organization_usage"] = s.OrganizationUsage
	}
	if s.OrganizationRequireBehavior != "" {
		m["organization_require_behavior"] = s.OrganizationRequireBehavior
	}
	if s.JwtConfiguration != nil {
		m["jwt_configuration"] = s.JwtConfiguration.toMap()
	}
	if s.RefreshToken != nil {
		m["refresh_token"] = s.RefreshToken.toMap()
	}
	if s.NativeSocialLogin != nil {
		m["native_social_login"] = s.NativeSocialLogin.toMap()
	}
	if s.Mobile != nil {
		m["mobile"] = s.Mobile.toMap()
	}
	if len(s.ClientMetadata) > 0 {
		m["client_metadata"] = s.ClientMetadata
	}
	if len(s.ClientAliases) > 0 {
		m["client_aliases"] = s.ClientAliases
	}
	if s.IsTokenEndpointIpHeaderTrusted {
		m["is_token_endpoint_ip_header_trusted"] = s.IsTokenEndpointIpHeaderTrusted
	}
	if s.OidcBackchannelLogout != nil {
		m["oidc_backchannel_logout"] = s.OidcBackchannelLogout.toMap()
	}
	if len(s.EnabledConnections) > 0 {
		m["enabled_connections"] = s.EnabledConnections
	}
	if len(s.ApiGrants) > 0 {
		items := make([]any, len(s.ApiGrants))
		for i, v := range s.ApiGrants {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["api_grants"] = items
	}
	return m
}

// Auth0ClientApiGrant configures API access for this client.
//
//	Each grant authorizes the client to call a specific API with specified scopes.
//	Maps to the auth0_client_grant Terraform resource and auth0.ClientGrant Pulumi resource.
//
//	This is essential for Machine-to-Machine (M2M) applications that need to be
//	authorized to access APIs (including the Auth0 Management API).
type Auth0ClientApiGrantInput struct {
	// audience is the API identifier (Resource Server identifier) the client is authorized to access.
	//  For Auth0 Management API: "https://{tenant}.{region}.auth0.com/api/v2/"
	//  For custom APIs: the identifier you configured when creating the API in Auth0
	//
	//  You can provide either:
	//  - Direct value: {value: "...
	Audience string `json:"audience" jsonschema:"required,audience is the API identifier (Resource Server identifier) the client is authorized to access. For Auth0 Management API: 'https://{tenant}.{region}.auth0.com/api/v2/' For custom APIs: the identifier ..."`
	// scopes are the permissions granted for this API.
	//  For Management API, common scopes include:
	//    - read:users, read:user_idp_tokens, create:users, update:users, delete:users
	//    - read:clients, update:clients, delete:clients
	//    - read:connections, update:connections
	//  For custom APIs: the scopes you de...
	Scopes []string `json:"scopes,omitempty" jsonschema:"scopes are the permissions granted for this API. For Management API; common scopes include: - read:users; read:user_idp_tokens; create:users; update:users; delete:users - read:clients; update:clients;..."`
	// allow_any_organization determines if any organization can be used with this grant.
	//  If false (default), the grant must be explicitly assigned to desired organizations.
	//  Only relevant when using Auth0 Organizations feature.
	AllowAnyOrganization bool `json:"allow_any_organization,omitempty" jsonschema:"allow_any_organization determines if any organization can be used with this grant. If false (default); the grant must be explicitly assigned to desired organizations. Only relevant when using Auth0 Or..."`
	// organization_usage defines whether organizations can be used with client credentials
	//  exchanges for this grant.
	//  - "deny": Organizations cannot be used (default)
	//  - "allow": Organizations can be used optionally
	//  - "require": Organizations must be specified
	OrganizationUsage string `json:"organization_usage,omitempty" jsonschema:"organization_usage defines whether organizations can be used with client credentials exchanges for this grant. - 'deny': Organizations cannot be used (default) - 'allow': Organizations can be used opt..."`
}

func (s *Auth0ClientApiGrantInput) validate() error {
	if s.Audience == "" {
		return fmt.Errorf("audience is required")
	}
	return nil
}

func (s *Auth0ClientApiGrantInput) applyDefaults() {
}

func (s *Auth0ClientApiGrantInput) toMap() map[string]any {
	m := make(map[string]any)
	m["audience"] = s.Audience
	if len(s.Scopes) > 0 {
		m["scopes"] = s.Scopes
	}
	if s.AllowAnyOrganization {
		m["allow_any_organization"] = s.AllowAnyOrganization
	}
	if s.OrganizationUsage != "" {
		m["organization_usage"] = s.OrganizationUsage
	}
	return m
}

// Auth0JwtConfiguration configures JWT token settings for the application.
type Auth0JwtConfigurationInput struct {
	// lifetime_in_seconds is the expiration time for JWTs in seconds.
	//  Default: 36000 (10 hours)
	//  Range: 0-2592000 (30 days max)
	LifetimeInSeconds int32 `json:"lifetime_in_seconds,omitempty" jsonschema:"lifetime_in_seconds is the expiration time for JWTs in seconds. Default: 36000 (10 hours) Range: 0-2592000 (30 days max)"`
	// scopes is a map of custom scopes and their descriptions.
	//  These scopes will be available for this application.
	//  Key: scope name, Value: scope description
	Scopes map[string]string `json:"scopes,omitempty" jsonschema:"scopes is a map of custom scopes and their descriptions. These scopes will be available for this application. Key: scope name; Value: scope description"`
	// alg is the algorithm used to sign the JWT.
	//  - "HS256": HMAC using SHA-256 (symmetric, uses client secret)
	//  - "RS256": RSA using SHA-256 (asymmetric, uses tenant keys)
	//  - "PS256": RSA-PSS using SHA-256
	//  Default: RS256 (recommended)
	Alg string `json:"alg,omitempty" jsonschema:"alg is the algorithm used to sign the JWT. - 'HS256': HMAC using SHA-256 (symmetric; uses client secret) - 'RS256': RSA using SHA-256 (asymmetric; uses tenant keys) - 'PS256': RSA-PSS using SHA-256 De..."`
	// secret_encoded indicates if the client secret is base64 encoded.
	//  Only relevant when alg is HS256.
	//  Default: false
	SecretEncoded bool `json:"secret_encoded,omitempty" jsonschema:"secret_encoded indicates if the client secret is base64 encoded. Only relevant when alg is HS256. Default: false"`
}

func (s *Auth0JwtConfigurationInput) validate() error {
	return nil
}

func (s *Auth0JwtConfigurationInput) applyDefaults() {
}

func (s *Auth0JwtConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.LifetimeInSeconds != 0 {
		m["lifetime_in_seconds"] = s.LifetimeInSeconds
	}
	if len(s.Scopes) > 0 {
		m["scopes"] = s.Scopes
	}
	if s.Alg != "" {
		m["alg"] = s.Alg
	}
	if s.SecretEncoded {
		m["secret_encoded"] = s.SecretEncoded
	}
	return m
}

// Auth0MobileAndroid configures Android-specific settings.
type Auth0MobileAndroidInput struct {
	// app_package_name is the Android application package name.
	//  Example: "com.example.myapp"
	AppPackageName string `json:"app_package_name,omitempty" jsonschema:"app_package_name is the Android application package name. Example: 'com.example.myapp'"`
	// sha256_cert_fingerprints are the SHA-256 fingerprints of signing certificates.
	//  Used for App Links and secure deep linking.
	//  Example: ["D8:A0:..."]
	Sha256CertFingerprints []string `json:"sha256_cert_fingerprints,omitempty" jsonschema:"sha256_cert_fingerprints are the SHA-256 fingerprints of signing certificates. Used for App Links and secure deep linking. Example: ['D8:A0:...']"`
}

func (s *Auth0MobileAndroidInput) validate() error {
	return nil
}

func (s *Auth0MobileAndroidInput) applyDefaults() {
}

func (s *Auth0MobileAndroidInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AppPackageName != "" {
		m["app_package_name"] = s.AppPackageName
	}
	if len(s.Sha256CertFingerprints) > 0 {
		m["sha256_cert_fingerprints"] = s.Sha256CertFingerprints
	}
	return m
}

// Auth0MobileConfiguration configures mobile-specific settings.
type Auth0MobileConfigurationInput struct {
	// android configures Android-specific settings.
	Android *Auth0MobileAndroidInput `json:"android,omitempty" jsonschema:"android configures Android-specific settings."`
	// ios configures iOS-specific settings.
	Ios *Auth0MobileIosInput `json:"ios,omitempty" jsonschema:"ios configures iOS-specific settings."`
}

func (s *Auth0MobileConfigurationInput) validate() error {
	if s.Android != nil {
		if err := s.Android.validate(); err != nil {
			return fmt.Errorf("android: %w", err)
		}
	}
	if s.Ios != nil {
		if err := s.Ios.validate(); err != nil {
			return fmt.Errorf("ios: %w", err)
		}
	}
	return nil
}

func (s *Auth0MobileConfigurationInput) applyDefaults() {
	if s.Android != nil {
		s.Android.applyDefaults()
	}
	if s.Ios != nil {
		s.Ios.applyDefaults()
	}
}

func (s *Auth0MobileConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Android != nil {
		m["android"] = s.Android.toMap()
	}
	if s.Ios != nil {
		m["ios"] = s.Ios.toMap()
	}
	return m
}

// Auth0MobileIos configures iOS-specific settings.
type Auth0MobileIosInput struct {
	// team_id is the Apple Developer Team ID.
	//  Required for universal links.
	TeamId string `json:"team_id,omitempty" jsonschema:"team_id is the Apple Developer Team ID. Required for universal links."`
	// app_bundle_identifier is the iOS application bundle identifier.
	//  Example: "com.example.myapp"
	AppBundleIdentifier string `json:"app_bundle_identifier,omitempty" jsonschema:"app_bundle_identifier is the iOS application bundle identifier. Example: 'com.example.myapp'"`
}

func (s *Auth0MobileIosInput) validate() error {
	return nil
}

func (s *Auth0MobileIosInput) applyDefaults() {
}

func (s *Auth0MobileIosInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TeamId != "" {
		m["team_id"] = s.TeamId
	}
	if s.AppBundleIdentifier != "" {
		m["app_bundle_identifier"] = s.AppBundleIdentifier
	}
	return m
}

// Auth0NativeSocialLogin configures native social login for mobile apps.
type Auth0NativeSocialLoginInput struct {
	// apple configures Sign in with Apple native integration.
	Apple *Auth0NativeSocialLoginProviderInput `json:"apple,omitempty" jsonschema:"apple configures Sign in with Apple native integration."`
	// facebook configures Facebook native login integration.
	Facebook *Auth0NativeSocialLoginProviderInput `json:"facebook,omitempty" jsonschema:"facebook configures Facebook native login integration."`
}

func (s *Auth0NativeSocialLoginInput) validate() error {
	if s.Apple != nil {
		if err := s.Apple.validate(); err != nil {
			return fmt.Errorf("apple: %w", err)
		}
	}
	if s.Facebook != nil {
		if err := s.Facebook.validate(); err != nil {
			return fmt.Errorf("facebook: %w", err)
		}
	}
	return nil
}

func (s *Auth0NativeSocialLoginInput) applyDefaults() {
	if s.Apple != nil {
		s.Apple.applyDefaults()
	}
	if s.Facebook != nil {
		s.Facebook.applyDefaults()
	}
}

func (s *Auth0NativeSocialLoginInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Apple != nil {
		m["apple"] = s.Apple.toMap()
	}
	if s.Facebook != nil {
		m["facebook"] = s.Facebook.toMap()
	}
	return m
}

// Auth0NativeSocialLoginProvider configures a specific native social provider.
type Auth0NativeSocialLoginProviderInput struct {
	// enabled determines if this native social provider is active.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled determines if this native social provider is active."`
}

func (s *Auth0NativeSocialLoginProviderInput) validate() error {
	return nil
}

func (s *Auth0NativeSocialLoginProviderInput) applyDefaults() {
}

func (s *Auth0NativeSocialLoginProviderInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	return m
}

// Auth0OidcBackchannelLogout configures OIDC back-channel logout.
type Auth0OidcBackchannelLogoutInput struct {
	// backchannel_logout_urls are the URLs to receive logout tokens.
	//  Auth0 will POST a logout token to these URLs on logout.
	BackchannelLogoutUrls []string `json:"backchannel_logout_urls,omitempty" jsonschema:"backchannel_logout_urls are the URLs to receive logout tokens. Auth0 will POST a logout token to these URLs on logout."`
}

func (s *Auth0OidcBackchannelLogoutInput) validate() error {
	return nil
}

func (s *Auth0OidcBackchannelLogoutInput) applyDefaults() {
}

func (s *Auth0OidcBackchannelLogoutInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.BackchannelLogoutUrls) > 0 {
		m["backchannel_logout_urls"] = s.BackchannelLogoutUrls
	}
	return m
}

// Auth0RefreshTokenConfiguration configures refresh token behavior.
type Auth0RefreshTokenConfigurationInput struct {
	// rotation_type determines refresh token rotation behavior.
	//  - "non-rotating": Refresh tokens don't rotate (legacy behavior)
	//  - "rotating": New refresh token issued with each use (recommended)
	//  Default: non-rotating
	RotationType string `json:"rotation_type,omitempty" jsonschema:"rotation_type determines refresh token rotation behavior. - 'non-rotating': Refresh tokens don't rotate (legacy behavior) - 'rotating': New refresh token issued with each use (recommended) Default: no..."`
	// expiration_type determines how refresh tokens expire.
	//  - "non-expiring": Tokens don't expire (not recommended)
	//  - "expiring": Tokens expire based on configured lifetimes
	//  Default: non-expiring
	ExpirationType string `json:"expiration_type,omitempty" jsonschema:"expiration_type determines how refresh tokens expire. - 'non-expiring': Tokens don't expire (not recommended) - 'expiring': Tokens expire based on configured lifetimes Default: non-expiring"`
	// token_lifetime is the absolute lifetime of a refresh token in seconds.
	//  The token will expire after this time regardless of activity.
	//  Only used when expiration_type is "expiring".
	//  Default: 2592000 (30 days)
	TokenLifetime int32 `json:"token_lifetime,omitempty" jsonschema:"token_lifetime is the absolute lifetime of a refresh token in seconds. The token will expire after this time regardless of activity. Only used when expiration_type is 'expiring'. Default: 2592000 (30 ..."`
	// idle_token_lifetime is the inactivity timeout for refresh tokens in seconds.
	//  Token expires if not used within this time.
	//  Only used when expiration_type is "expiring".
	//  Default: 1296000 (15 days)
	IdleTokenLifetime int32 `json:"idle_token_lifetime,omitempty" jsonschema:"idle_token_lifetime is the inactivity timeout for refresh tokens in seconds. Token expires if not used within this time. Only used when expiration_type is 'expiring'. Default: 1296000 (15 days)"`
	// infinite_token_lifetime allows tokens to never expire.
	//  Only valid when expiration_type is "non-expiring".
	//  Not recommended for security reasons.
	//  Default: false
	InfiniteTokenLifetime bool `json:"infinite_token_lifetime,omitempty" jsonschema:"infinite_token_lifetime allows tokens to never expire. Only valid when expiration_type is 'non-expiring'. Not recommended for security reasons. Default: false"`
	// infinite_idle_token_lifetime allows tokens to never expire due to inactivity.
	//  Only valid when expiration_type is "non-expiring".
	//  Not recommended for security reasons.
	//  Default: false
	InfiniteIdleTokenLifetime bool `json:"infinite_idle_token_lifetime,omitempty" jsonschema:"infinite_idle_token_lifetime allows tokens to never expire due to inactivity. Only valid when expiration_type is 'non-expiring'. Not recommended for security reasons. Default: false"`
	// leeway is the clock skew leeway in seconds for token validation.
	//  Allows for slight differences in server clocks.
	//  Default: 0
	Leeway int32 `json:"leeway,omitempty" jsonschema:"leeway is the clock skew leeway in seconds for token validation. Allows for slight differences in server clocks. Default: 0"`
}

func (s *Auth0RefreshTokenConfigurationInput) validate() error {
	return nil
}

func (s *Auth0RefreshTokenConfigurationInput) applyDefaults() {
}

func (s *Auth0RefreshTokenConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RotationType != "" {
		m["rotation_type"] = s.RotationType
	}
	if s.ExpirationType != "" {
		m["expiration_type"] = s.ExpirationType
	}
	if s.TokenLifetime != 0 {
		m["token_lifetime"] = s.TokenLifetime
	}
	if s.IdleTokenLifetime != 0 {
		m["idle_token_lifetime"] = s.IdleTokenLifetime
	}
	if s.InfiniteTokenLifetime {
		m["infinite_token_lifetime"] = s.InfiniteTokenLifetime
	}
	if s.InfiniteIdleTokenLifetime {
		m["infinite_idle_token_lifetime"] = s.InfiniteIdleTokenLifetime
	}
	if s.Leeway != 0 {
		m["leeway"] = s.Leeway
	}
	return m
}

// ParseAuth0Client validates and normalizes a Auth0Client cloud_object.
func ParseAuth0Client(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "auth0.openmcf.org/v1", "Auth0Client"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec Auth0ClientSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
