// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package auth0

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// Auth0Connection is a deployment component that configures an identity connection in Auth0.
//
//	Connections are the bridge between Auth0 and identity sources, enabling users to authenticate
//	using various methods including databases, social providers, and enterprise identity providers.
//
//	This component supports:
//	- Database connections (Auth0's hosted user database)
//	- Social connections (Google, Facebook, GitHub, LinkedIn, etc.)
//	- Enterprise connections (SAML, OIDC, Azure AD/Entra ID)
//
//	Example manifest:
//	```yaml
//	apiVersion: auth0.openmcf.org/v1
//	kind: Auth0Connection
//	metadata:
//	  name: google-social-login
//	  org: my-organization
//	  env: production
//	spec:
//	  strategy: google-oauth2
//	  display_name: Sign in with Google
//	  enabled_clients:
//	    - value: "abc123def456"
//	  social_options:
//	    client_id: "your-google-client-id.apps.googleusercontent.com"
//	    client_secret: "your-google-client-secret"
//	    scopes:
//	      - openid
//	      - profile
//	      - email
//	```
type Auth0ConnectionSpecInput struct {
	// strategy is the identity provider strategy/type for this connection.
	//  This determines how users authenticate and what additional configuration is required.
	//
	//  Database strategies:
	//  - "auth0": Auth0's hosted database (default, recommended for most use cases)
	//
	//  Social strategies:
	//  - "google-oauth2": Go...
	Strategy string `json:"strategy" jsonschema:"required,strategy is the identity provider strategy/type for this connection. This determines how users authenticate and what additional configuration is required. Database strategies: - 'auth0': Auth0's hoste..."`
	// display_name is the human-readable name shown in the Auth0 Universal Login page.
	//  This is the name users will see when choosing how to log in.
	//  If not specified, Auth0 will use a default name based on the strategy.
	//  Example: "Google", "Company SSO", "Sign up with Email"
	DisplayName string `json:"display_name,omitempty" jsonschema:"display_name is the human-readable name shown in the Auth0 Universal Login page. This is the name users will see when choosing how to log in. If not specified; Auth0 will use a default name based on t..."`
	// enabled_clients is a list of Auth0 application client IDs that can use this connection.
	//  Only applications in this list will show this connection as a login option.
	//  If empty, no applications will be able to use this connection.
	//
	//  You can provide either:
	//  - Direct client ID: {value: "abc123clientID"...
	EnabledClients []string `json:"enabled_clients,omitempty" jsonschema:"enabled_clients is a list of Auth0 application client IDs that can use this connection. Only applications in this list will show this connection as a login option. If empty; no applications will be ab..."`
	// is_domain_connection indicates whether this connection can be used for identifier-first
	//  authentication flows. When true, Auth0 will attempt to discover the appropriate
	//  connection based on the user's email domain.
	//  Default: false
	IsDomainConnection bool `json:"is_domain_connection,omitempty" jsonschema:"is_domain_connection indicates whether this connection can be used for identifier-first authentication flows. When true; Auth0 will attempt to discover the appropriate connection based on the user's e..."`
	// realms are the identifiers that can be used for this connection in authentication requests.
	//  This is useful for routing users to the correct connection.
	//  If not specified, defaults to the connection name.
	Realms []string `json:"realms,omitempty" jsonschema:"realms are the identifiers that can be used for this connection in authentication requests. This is useful for routing users to the correct connection. If not specified; defaults to the connection nam..."`
	// show_as_button controls whether this connection shows as a button on the Universal Login page.
	//  When false, the connection will only be used if explicitly requested or discovered via domain.
	//  Default: true
	ShowAsButton bool `json:"show_as_button,omitempty" jsonschema:"show_as_button controls whether this connection shows as a button on the Universal Login page. When false; the connection will only be used if explicitly requested or discovered via domain. Default: t..."`
	// metadata is a map of custom metadata key-value pairs to store with the connection.
	//  This can be used to store integration-specific identifiers or configuration.
	//  Maximum 10 key-value pairs, with keys and values up to 255 characters each.
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"metadata is a map of custom metadata key-value pairs to store with the connection. This can be used to store integration-specific identifiers or configuration. Maximum 10 key-value pairs; with keys an..."`
	// database_options configures database connection behavior.
	//  Only applicable when strategy is "auth0" (Auth0 database).
	DatabaseOptions *Auth0DatabaseOptionsInput `json:"database_options,omitempty" jsonschema:"database_options configures database connection behavior. Only applicable when strategy is 'auth0' (Auth0 database)."`
	// social_options configures social identity provider connections.
	//  Only applicable when strategy is a social provider (google-oauth2, facebook, github, etc.).
	SocialOptions *Auth0SocialOptionsInput `json:"social_options,omitempty" jsonschema:"social_options configures social identity provider connections. Only applicable when strategy is a social provider (google-oauth2; facebook; github; etc.)."`
	// saml_options configures SAML enterprise connections.
	//  Only applicable when strategy is "samlp".
	SamlOptions *Auth0SamlOptionsInput `json:"saml_options,omitempty" jsonschema:"saml_options configures SAML enterprise connections. Only applicable when strategy is 'samlp'."`
	// oidc_options configures OpenID Connect enterprise connections.
	//  Only applicable when strategy is "oidc".
	OidcOptions *Auth0OidcOptionsInput `json:"oidc_options,omitempty" jsonschema:"oidc_options configures OpenID Connect enterprise connections. Only applicable when strategy is 'oidc'."`
	// azure_ad_options configures Azure AD/Entra ID enterprise connections.
	//  Only applicable when strategy is "waad".
	AzureAdOptions *Auth0AzureAdOptionsInput `json:"azure_ad_options,omitempty" jsonschema:"azure_ad_options configures Azure AD/Entra ID enterprise connections. Only applicable when strategy is 'waad'."`
}

func (s *Auth0ConnectionSpecInput) validate() error {
	if s.Strategy == "" {
		return fmt.Errorf("strategy is required")
	}
	if s.DatabaseOptions != nil {
		if err := s.DatabaseOptions.validate(); err != nil {
			return fmt.Errorf("database_options: %w", err)
		}
	}
	if s.SocialOptions != nil {
		if err := s.SocialOptions.validate(); err != nil {
			return fmt.Errorf("social_options: %w", err)
		}
	}
	if s.SamlOptions != nil {
		if err := s.SamlOptions.validate(); err != nil {
			return fmt.Errorf("saml_options: %w", err)
		}
	}
	if s.OidcOptions != nil {
		if err := s.OidcOptions.validate(); err != nil {
			return fmt.Errorf("oidc_options: %w", err)
		}
	}
	if s.AzureAdOptions != nil {
		if err := s.AzureAdOptions.validate(); err != nil {
			return fmt.Errorf("azure_ad_options: %w", err)
		}
	}
	return nil
}

func (s *Auth0ConnectionSpecInput) applyDefaults() {
	if s.DatabaseOptions != nil {
		s.DatabaseOptions.applyDefaults()
	}
	if s.SocialOptions != nil {
		s.SocialOptions.applyDefaults()
	}
	if s.SamlOptions != nil {
		s.SamlOptions.applyDefaults()
	}
	if s.OidcOptions != nil {
		s.OidcOptions.applyDefaults()
	}
	if s.AzureAdOptions != nil {
		s.AzureAdOptions.applyDefaults()
	}
}

func (s *Auth0ConnectionSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["strategy"] = s.Strategy
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if len(s.EnabledClients) > 0 {
		m["enabled_clients"] = s.EnabledClients
	}
	if s.IsDomainConnection {
		m["is_domain_connection"] = s.IsDomainConnection
	}
	if len(s.Realms) > 0 {
		m["realms"] = s.Realms
	}
	if s.ShowAsButton {
		m["show_as_button"] = s.ShowAsButton
	}
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if s.DatabaseOptions != nil {
		m["database_options"] = s.DatabaseOptions.toMap()
	}
	if s.SocialOptions != nil {
		m["social_options"] = s.SocialOptions.toMap()
	}
	if s.SamlOptions != nil {
		m["saml_options"] = s.SamlOptions.toMap()
	}
	if s.OidcOptions != nil {
		m["oidc_options"] = s.OidcOptions.toMap()
	}
	if s.AzureAdOptions != nil {
		m["azure_ad_options"] = s.AzureAdOptions.toMap()
	}
	return m
}

// Auth0AzureAdOptions configures Azure Active Directory (Entra ID) enterprise connections.
//
//	Used for integrating with Microsoft Azure AD for enterprise SSO.
type Auth0AzureAdOptionsInput struct {
	// client_id is the Application (client) ID from Azure AD app registration.
	//  Found in Azure Portal > Azure Active Directory > App Registrations > Your App > Overview
	//  Required for Azure AD connections.
	ClientId string `json:"client_id" jsonschema:"required,client_id is the Application (client) ID from Azure AD app registration. Found in Azure Portal > Azure Active Directory > App Registrations > Your App > Overview Required for Azure AD connections."`
	// client_secret is the client secret from Azure AD app registration.
	//  Found in Azure Portal > Azure Active Directory > App Registrations > Your App > Certificates & secrets
	//  Required for Azure AD connections.
	ClientSecret string `json:"client_secret" jsonschema:"required,client_secret is the client secret from Azure AD app registration. Found in Azure Portal > Azure Active Directory > App Registrations > Your App > Certificates & secrets Required for Azure AD connecti..."`
	// domain is the Azure AD tenant domain.
	//  This can be the primary domain (e.g., "contoso.onmicrosoft.com")
	//  or a custom domain (e.g., "contoso.com").
	//  Required for Azure AD connections.
	Domain string `json:"domain" jsonschema:"required,domain is the Azure AD tenant domain. This can be the primary domain (e.g.; 'contoso.onmicrosoft.com') or a custom domain (e.g.; 'contoso.com'). Required for Azure AD connections."`
	// tenant_id is the Azure AD tenant ID (Directory ID).
	//  Found in Azure Portal > Azure Active Directory > Overview
	//  If not specified, "common" is used, allowing any Azure AD tenant.
	TenantId string `json:"tenant_id,omitempty" jsonschema:"tenant_id is the Azure AD tenant ID (Directory ID). Found in Azure Portal > Azure Active Directory > Overview If not specified; 'common' is used; allowing any Azure AD tenant."`
	// use_common_endpoint determines whether to use the common endpoint.
	//  When true, allows users from any Azure AD tenant (multi-tenant app).
	//  When false, restricts to the specified tenant.
	//  Default: false
	UseCommonEndpoint bool `json:"use_common_endpoint,omitempty" jsonschema:"use_common_endpoint determines whether to use the common endpoint. When true; allows users from any Azure AD tenant (multi-tenant app). When false; restricts to the specified tenant. Default: false"`
	// max_groups_to_retrieve limits the number of groups retrieved from Azure AD.
	//  Azure AD can return many groups; set this to limit the groups in the user profile.
	//  Set to 0 for no limit.
	//  Default: 50
	MaxGroupsToRetrieve int32 `json:"max_groups_to_retrieve,omitempty" jsonschema:"max_groups_to_retrieve limits the number of groups retrieved from Azure AD. Azure AD can return many groups; set this to limit the groups in the user profile. Set to 0 for no limit. Default: 50"`
	// should_trust_email_verified indicates whether to trust Azure AD's email_verified claim.
	//  When true, Auth0 trusts that Azure AD has verified the user's email.
	//  Default: true
	ShouldTrustEmailVerified bool `json:"should_trust_email_verified,omitempty" jsonschema:"should_trust_email_verified indicates whether to trust Azure AD's email_verified claim. When true; Auth0 trusts that Azure AD has verified the user's email. Default: true"`
	// api_enable_users enables the ability to retrieve users from the Azure AD directory.
	//  When true, you can use Auth0's Management API to list users from Azure AD.
	//  Requires additional Azure AD permissions (Directory.Read.All).
	//  Default: false
	ApiEnableUsers bool `json:"api_enable_users,omitempty" jsonschema:"api_enable_users enables the ability to retrieve users from the Azure AD directory. When true; you can use Auth0's Management API to list users from Azure AD. Requires additional Azure AD permissions ..."`
}

func (s *Auth0AzureAdOptionsInput) validate() error {
	if s.ClientId == "" {
		return fmt.Errorf("client_id is required")
	}
	if s.ClientSecret == "" {
		return fmt.Errorf("client_secret is required")
	}
	if s.Domain == "" {
		return fmt.Errorf("domain is required")
	}
	return nil
}

func (s *Auth0AzureAdOptionsInput) applyDefaults() {
}

func (s *Auth0AzureAdOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["client_id"] = s.ClientId
	m["client_secret"] = s.ClientSecret
	m["domain"] = s.Domain
	if s.TenantId != "" {
		m["tenant_id"] = s.TenantId
	}
	if s.UseCommonEndpoint {
		m["use_common_endpoint"] = s.UseCommonEndpoint
	}
	if s.MaxGroupsToRetrieve != 0 {
		m["max_groups_to_retrieve"] = s.MaxGroupsToRetrieve
	}
	if s.ShouldTrustEmailVerified {
		m["should_trust_email_verified"] = s.ShouldTrustEmailVerified
	}
	if s.ApiEnableUsers {
		m["api_enable_users"] = s.ApiEnableUsers
	}
	return m
}

// Auth0DatabaseOptions configures Auth0's hosted database connection.
//
//	These options control password policies, username requirements, and security settings.
type Auth0DatabaseOptionsInput struct {
	// password_policy defines the password complexity requirements.
	//  - "none": No password requirements
	//  - "low": At least 6 characters
	//  - "fair": At least 8 characters, including lower and upper case
	//  - "good": At least 8 characters, including lower, upper, numeric
	//  - "excellent": At least 10 characters,...
	PasswordPolicy string `json:"password_policy,omitempty" jsonschema:"password_policy defines the password complexity requirements. - 'none': No password requirements - 'low': At least 6 characters - 'fair': At least 8 characters; including lower and upper case - 'good'..."`
	// requires_username determines if users must provide a username in addition to email.
	//  When true, users sign up with both username and email.
	//  Default: false
	RequiresUsername bool `json:"requires_username,omitempty" jsonschema:"requires_username determines if users must provide a username in addition to email. When true; users sign up with both username and email. Default: false"`
	// disable_signup prevents new user signups through this connection.
	//  Useful when you only want existing users to log in, or when onboarding is done programmatically.
	//  Default: false
	DisableSignup bool `json:"disable_signup,omitempty" jsonschema:"disable_signup prevents new user signups through this connection. Useful when you only want existing users to log in; or when onboarding is done programmatically. Default: false"`
	// brute_force_protection enables protection against brute force login attacks.
	//  When enabled, Auth0 will block login attempts after multiple failures.
	//  Default: true (recommended)
	BruteForceProtection bool `json:"brute_force_protection,omitempty" jsonschema:"brute_force_protection enables protection against brute force login attacks. When enabled; Auth0 will block login attempts after multiple failures. Default: true (recommended)"`
	// password_history_size is the number of previous passwords to check against.
	//  Users cannot reuse passwords from their history. Set to 0 to disable.
	//  Valid range: 0-24
	//  Default: 5
	PasswordHistorySize int32 `json:"password_history_size,omitempty" jsonschema:"password_history_size is the number of previous passwords to check against. Users cannot reuse passwords from their history. Set to 0 to disable. Valid range: 0-24 Default: 5"`
	// password_no_personal_info prevents passwords containing user's personal information
	//  (name, username, email). Recommended for security.
	//  Default: true
	PasswordNoPersonalInfo bool `json:"password_no_personal_info,omitempty" jsonschema:"password_no_personal_info prevents passwords containing user's personal information (name; username; email). Recommended for security. Default: true"`
	// password_dictionary enables checking passwords against a dictionary of common passwords.
	//  When true, users cannot use common/weak passwords.
	//  Default: true
	PasswordDictionary bool `json:"password_dictionary,omitempty" jsonschema:"password_dictionary enables checking passwords against a dictionary of common passwords. When true; users cannot use common/weak passwords. Default: true"`
	// mfa_enabled enables Multi-Factor Authentication for this connection.
	//  When true, users will be prompted for a second factor during login.
	//  Default: false
	MfaEnabled bool `json:"mfa_enabled,omitempty" jsonschema:"mfa_enabled enables Multi-Factor Authentication for this connection. When true; users will be prompted for a second factor during login. Default: false"`
}

func (s *Auth0DatabaseOptionsInput) validate() error {
	return nil
}

func (s *Auth0DatabaseOptionsInput) applyDefaults() {
}

func (s *Auth0DatabaseOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.PasswordPolicy != "" {
		m["password_policy"] = s.PasswordPolicy
	}
	if s.RequiresUsername {
		m["requires_username"] = s.RequiresUsername
	}
	if s.DisableSignup {
		m["disable_signup"] = s.DisableSignup
	}
	if s.BruteForceProtection {
		m["brute_force_protection"] = s.BruteForceProtection
	}
	if s.PasswordHistorySize != 0 {
		m["password_history_size"] = s.PasswordHistorySize
	}
	if s.PasswordNoPersonalInfo {
		m["password_no_personal_info"] = s.PasswordNoPersonalInfo
	}
	if s.PasswordDictionary {
		m["password_dictionary"] = s.PasswordDictionary
	}
	if s.MfaEnabled {
		m["mfa_enabled"] = s.MfaEnabled
	}
	return m
}

// Auth0OidcOptions configures OpenID Connect enterprise connections.
//
//	Used for integrating with OIDC-compliant identity providers.
type Auth0OidcOptionsInput struct {
	// issuer is the OIDC issuer URL (the "iss" claim value).
	//  Auth0 will use OIDC Discovery to fetch configuration from /.well-known/openid-configuration
	//  Required for OIDC connections.
	Issuer string `json:"issuer" jsonschema:"required,issuer is the OIDC issuer URL (the 'iss' claim value). Auth0 will use OIDC Discovery to fetch configuration from /.well-known/openid-configuration Required for OIDC connections."`
	// client_id is the OAuth client ID from the OIDC provider.
	//  Obtained from the provider's application registration.
	//  Required for OIDC connections.
	ClientId string `json:"client_id" jsonschema:"required,client_id is the OAuth client ID from the OIDC provider. Obtained from the provider's application registration. Required for OIDC connections."`
	// client_secret is the OAuth client secret from the OIDC provider.
	//  Required for OIDC connections using authorization code flow.
	ClientSecret string `json:"client_secret,omitempty" jsonschema:"client_secret is the OAuth client secret from the OIDC provider. Required for OIDC connections using authorization code flow."`
	// scopes is a list of OIDC scopes to request.
	//  "openid" is always requested implicitly.
	//  Common scopes: "profile", "email", "address", "phone"
	//  Default: ["openid", "profile", "email"]
	Scopes []string `json:"scopes,omitempty" jsonschema:"scopes is a list of OIDC scopes to request. 'openid' is always requested implicitly. Common scopes: 'profile'; 'email'; 'address'; 'phone' Default: ['openid'; 'profile'; 'email']"`
	// type specifies the OIDC flow type.
	//  - "front_channel": Authorization Code Flow (recommended for web apps)
	//  - "back_channel": Uses token endpoint directly
	//  Default: front_channel
	Type string `json:"type,omitempty" jsonschema:"type specifies the OIDC flow type. - 'front_channel': Authorization Code Flow (recommended for web apps) - 'back_channel': Uses token endpoint directly Default: front_channel"`
	// authorization_endpoint overrides the authorization endpoint from discovery.
	//  Only set this if the provider's discovery document is incorrect.
	AuthorizationEndpoint string `json:"authorization_endpoint,omitempty" jsonschema:"authorization_endpoint overrides the authorization endpoint from discovery. Only set this if the provider's discovery document is incorrect."`
	// token_endpoint overrides the token endpoint from discovery.
	//  Only set this if the provider's discovery document is incorrect.
	TokenEndpoint string `json:"token_endpoint,omitempty" jsonschema:"token_endpoint overrides the token endpoint from discovery. Only set this if the provider's discovery document is incorrect."`
	// userinfo_endpoint overrides the userinfo endpoint from discovery.
	//  Only set this if the provider's discovery document is incorrect.
	UserinfoEndpoint string `json:"userinfo_endpoint,omitempty" jsonschema:"userinfo_endpoint overrides the userinfo endpoint from discovery. Only set this if the provider's discovery document is incorrect."`
	// jwks_uri overrides the JWKS URI from discovery.
	//  Only set this if the provider's discovery document is incorrect.
	JwksUri string `json:"jwks_uri,omitempty" jsonschema:"jwks_uri overrides the JWKS URI from discovery. Only set this if the provider's discovery document is incorrect."`
	// attribute_mappings maps OIDC claims to Auth0 user profile fields.
	//  Keys are Auth0 profile fields (email, name, given_name, family_name, nickname, picture).
	//  Values are OIDC claim names from the ID token or userinfo response.
	AttributeMappings map[string]string `json:"attribute_mappings,omitempty" jsonschema:"attribute_mappings maps OIDC claims to Auth0 user profile fields. Keys are Auth0 profile fields (email; name; given_name; family_name; nickname; picture). Values are OIDC claim names from the ID token..."`
}

func (s *Auth0OidcOptionsInput) validate() error {
	if s.Issuer == "" {
		return fmt.Errorf("issuer is required")
	}
	if s.ClientId == "" {
		return fmt.Errorf("client_id is required")
	}
	return nil
}

func (s *Auth0OidcOptionsInput) applyDefaults() {
}

func (s *Auth0OidcOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["issuer"] = s.Issuer
	m["client_id"] = s.ClientId
	if s.ClientSecret != "" {
		m["client_secret"] = s.ClientSecret
	}
	if len(s.Scopes) > 0 {
		m["scopes"] = s.Scopes
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.AuthorizationEndpoint != "" {
		m["authorization_endpoint"] = s.AuthorizationEndpoint
	}
	if s.TokenEndpoint != "" {
		m["token_endpoint"] = s.TokenEndpoint
	}
	if s.UserinfoEndpoint != "" {
		m["userinfo_endpoint"] = s.UserinfoEndpoint
	}
	if s.JwksUri != "" {
		m["jwks_uri"] = s.JwksUri
	}
	if len(s.AttributeMappings) > 0 {
		m["attribute_mappings"] = s.AttributeMappings
	}
	return m
}

// Auth0SamlOptions configures SAML enterprise connections.
//
//	SAML is commonly used for enterprise SSO integrations.
type Auth0SamlOptionsInput struct {
	// sign_in_endpoint is the SAML Identity Provider's Single Sign-On URL.
	//  This is where Auth0 sends SAML authentication requests.
	//  Also known as "SSO URL" or "Login URL".
	//  Required for SAML connections.
	SignInEndpoint string `json:"sign_in_endpoint" jsonschema:"required,sign_in_endpoint is the SAML Identity Provider's Single Sign-On URL. This is where Auth0 sends SAML authentication requests. Also known as 'SSO URL' or 'Login URL'. Required for SAML connections."`
	// signing_cert is the X.509 signing certificate from the Identity Provider.
	//  Used to verify the signature on SAML responses.
	//  Should be in PEM format (including BEGIN/END CERTIFICATE headers).
	//  Required for SAML connections.
	SigningCert string `json:"signing_cert" jsonschema:"required,signing_cert is the X.509 signing certificate from the Identity Provider. Used to verify the signature on SAML responses. Should be in PEM format (including BEGIN/END CERTIFICATE headers). Required fo..."`
	// sign_out_endpoint is the SAML Identity Provider's Single Logout URL.
	//  This is where Auth0 sends logout requests.
	//  Optional but recommended for complete logout functionality.
	SignOutEndpoint string `json:"sign_out_endpoint,omitempty" jsonschema:"sign_out_endpoint is the SAML Identity Provider's Single Logout URL. This is where Auth0 sends logout requests. Optional but recommended for complete logout functionality."`
	// entity_id is the unique identifier for the Identity Provider.
	//  Also known as "Issuer" or "EntityID".
	//  If not specified, Auth0 will attempt to derive it from the metadata.
	EntityId string `json:"entity_id,omitempty" jsonschema:"entity_id is the unique identifier for the Identity Provider. Also known as 'Issuer' or 'EntityID'. If not specified; Auth0 will attempt to derive it from the metadata."`
	// protocol_binding specifies how SAML requests should be sent.
	//  - "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect": URL-encoded in query string
	//  - "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST": Form POST
	//  Default: HTTP-Redirect
	ProtocolBinding string `json:"protocol_binding,omitempty" jsonschema:"protocol_binding specifies how SAML requests should be sent. - 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect': URL-encoded in query string - 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST': For..."`
	// user_id_attribute is the SAML attribute to use as the user identifier.
	//  Default: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier"
	UserIdAttribute string `json:"user_id_attribute,omitempty" jsonschema:"user_id_attribute is the SAML attribute to use as the user identifier. Default: 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier'"`
	// sign_request indicates whether Auth0 should sign SAML requests.
	//  Required by some Identity Providers.
	//  Default: false
	SignRequest bool `json:"sign_request,omitempty" jsonschema:"sign_request indicates whether Auth0 should sign SAML requests. Required by some Identity Providers. Default: false"`
	// signature_algorithm is the algorithm used for signing SAML requests.
	//  - "rsa-sha256": RSA with SHA-256 (recommended)
	//  - "rsa-sha1": RSA with SHA-1 (deprecated, use only for legacy systems)
	//  Default: rsa-sha256
	SignatureAlgorithm string `json:"signature_algorithm,omitempty" jsonschema:"signature_algorithm is the algorithm used for signing SAML requests. - 'rsa-sha256': RSA with SHA-256 (recommended) - 'rsa-sha1': RSA with SHA-1 (deprecated; use only for legacy systems) Default: rsa-..."`
	// digest_algorithm is the algorithm used for digest in SAML signatures.
	//  - "sha256": SHA-256 (recommended)
	//  - "sha1": SHA-1 (deprecated, use only for legacy systems)
	//  Default: sha256
	DigestAlgorithm string `json:"digest_algorithm,omitempty" jsonschema:"digest_algorithm is the algorithm used for digest in SAML signatures. - 'sha256': SHA-256 (recommended) - 'sha1': SHA-1 (deprecated; use only for legacy systems) Default: sha256"`
	// attribute_mappings maps SAML attributes to Auth0 user profile fields.
	//  Keys are Auth0 profile fields (email, name, given_name, family_name, nickname, picture).
	//  Values are SAML attribute names from the IdP response.
	AttributeMappings map[string]string `json:"attribute_mappings,omitempty" jsonschema:"attribute_mappings maps SAML attributes to Auth0 user profile fields. Keys are Auth0 profile fields (email; name; given_name; family_name; nickname; picture). Values are SAML attribute names from the ..."`
}

func (s *Auth0SamlOptionsInput) validate() error {
	if s.SignInEndpoint == "" {
		return fmt.Errorf("sign_in_endpoint is required")
	}
	if s.SigningCert == "" {
		return fmt.Errorf("signing_cert is required")
	}
	return nil
}

func (s *Auth0SamlOptionsInput) applyDefaults() {
}

func (s *Auth0SamlOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["sign_in_endpoint"] = s.SignInEndpoint
	m["signing_cert"] = s.SigningCert
	if s.SignOutEndpoint != "" {
		m["sign_out_endpoint"] = s.SignOutEndpoint
	}
	if s.EntityId != "" {
		m["entity_id"] = s.EntityId
	}
	if s.ProtocolBinding != "" {
		m["protocol_binding"] = s.ProtocolBinding
	}
	if s.UserIdAttribute != "" {
		m["user_id_attribute"] = s.UserIdAttribute
	}
	if s.SignRequest {
		m["sign_request"] = s.SignRequest
	}
	if s.SignatureAlgorithm != "" {
		m["signature_algorithm"] = s.SignatureAlgorithm
	}
	if s.DigestAlgorithm != "" {
		m["digest_algorithm"] = s.DigestAlgorithm
	}
	if len(s.AttributeMappings) > 0 {
		m["attribute_mappings"] = s.AttributeMappings
	}
	return m
}

// Auth0SocialOptions configures social identity provider connections (Google, Facebook, GitHub, etc.).
//
//	These credentials are obtained from the respective social provider's developer console.
type Auth0SocialOptionsInput struct {
	// client_id is the OAuth client ID from the social provider.
	//  This is obtained from the provider's developer console.
	//  Required for all social connections.
	ClientId string `json:"client_id" jsonschema:"required,client_id is the OAuth client ID from the social provider. This is obtained from the provider's developer console. Required for all social connections."`
	// client_secret is the OAuth client secret from the social provider.
	//  This is obtained from the provider's developer console.
	//  Required for all social connections.
	ClientSecret string `json:"client_secret" jsonschema:"required,client_secret is the OAuth client secret from the social provider. This is obtained from the provider's developer console. Required for all social connections."`
	// scopes is a list of OAuth scopes to request from the social provider.
	//  These determine what user information Auth0 can access.
	//  If not specified, default scopes for the strategy will be used.
	//  Example for Google: ["openid", "profile", "email"]
	Scopes []string `json:"scopes,omitempty" jsonschema:"scopes is a list of OAuth scopes to request from the social provider. These determine what user information Auth0 can access. If not specified; default scopes for the strategy will be used. Example fo..."`
	// allowed_audiences restricts which audiences (applications) can use this connection.
	//  Only applicable for providers that support audience restrictions.
	AllowedAudiences []string `json:"allowed_audiences,omitempty" jsonschema:"allowed_audiences restricts which audiences (applications) can use this connection. Only applicable for providers that support audience restrictions."`
	// upstream_params are custom parameters to pass to the upstream social provider.
	//  Useful for provider-specific features like login hints or prompt types.
	//  Example: {"login_hint": "user@example.com", "prompt": "select_account"}
	UpstreamParams map[string]string `json:"upstream_params,omitempty" jsonschema:"upstream_params are custom parameters to pass to the upstream social provider. Useful for provider-specific features like login hints or prompt types. Example: {'login_hint': 'user@example.com'; 'prom..."`
}

func (s *Auth0SocialOptionsInput) validate() error {
	if s.ClientId == "" {
		return fmt.Errorf("client_id is required")
	}
	if s.ClientSecret == "" {
		return fmt.Errorf("client_secret is required")
	}
	return nil
}

func (s *Auth0SocialOptionsInput) applyDefaults() {
}

func (s *Auth0SocialOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["client_id"] = s.ClientId
	m["client_secret"] = s.ClientSecret
	if len(s.Scopes) > 0 {
		m["scopes"] = s.Scopes
	}
	if len(s.AllowedAudiences) > 0 {
		m["allowed_audiences"] = s.AllowedAudiences
	}
	if len(s.UpstreamParams) > 0 {
		m["upstream_params"] = s.UpstreamParams
	}
	return m
}

// ParseAuth0Connection validates and normalizes a Auth0Connection cloud_object.
func ParseAuth0Connection(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "auth0.openmcf.org/v1", "Auth0Connection"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec Auth0ConnectionSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
