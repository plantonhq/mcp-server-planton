// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package auth0

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// Auth0ResourceServer is a deployment component that configures a Resource Server (API) in Auth0.
//
//	Resource Servers represent the APIs that your applications can request access to.
//	They are essential for implementing OAuth 2.0 API authorization with Auth0.
//
//	This component supports:
//	- Defining API identifiers (audiences) for authorization flows
//	- Configuring token settings (lifetime, signing algorithm, dialect)
//	- Setting up scopes (permissions) for fine-grained access control
//	- Enabling RBAC for role-based API access
//
//	Example manifest for a simple API:
//	```yaml
//	apiVersion: auth0.openmcf.org/v1
//	kind: Auth0ResourceServer
//	metadata:
//	  name: my-api
//	  org: my-organization
//	spec:
//	  identifier: https://api.example.com/
//	  name: My Example API
//	  signing_alg: RS256
//	  token_lifetime: 86400
//	  allow_offline_access: true
//	  scopes:
//	    - name: read:data
//	      description: Read access to data
//	    - name: write:data
//	      description: Write access to data
//	```
//
//	Example manifest for API with RBAC enabled:
//	```yaml
//	apiVersion: auth0.openmcf.org/v1
//	kind: Auth0ResourceServer
//	metadata:
//	  name: rbac-api
//	  org: my-organization
//	spec:
//	  identifier: https://api.example.com/v2
//	  name: My RBAC-Enabled API
//	  signing_alg: RS256
//	  token_lifetime: 3600
//	  enforce_policies: true
//	  token_dialect: access_token_authz
//	  skip_consent_for_verifiable_first_party_clients: true
//	  scopes:
//	    - name: read:users
//	      description: Read user profiles
//	    - name: write:users
//	      description: Create and update users
//	    - name: delete:users
//	      description: Delete users
//	```
type Auth0ResourceServerSpecInput struct {
	// identifier is the unique identifier for the resource server.
	//  This value is used as the "audience" parameter for authorization calls.
	//  Typically a URI representing your API (e.g., "https://api.example.com/").
	//  Cannot be changed once set.
	//
	//  Example: "https://api.mycompany.com/", "api.planton.live"
	Identifier string `json:"identifier" jsonschema:"required,identifier is the unique identifier for the resource server. This value is used as the 'audience' parameter for authorization calls. Typically a URI representing your API (e.g.; 'https://api.example.c..."`
	// name is a friendly display name for the resource server.
	//  This is shown in the Auth0 dashboard and consent screens.
	//  Cannot include `<` or `>` characters.
	Name string `json:"name,omitempty" jsonschema:"name is a friendly display name for the resource server. This is shown in the Auth0 dashboard and consent screens. Cannot include '<' or '>' characters."`
	// signing_alg is the algorithm used to sign access tokens for this API.
	//  Options:
	//  - "RS256": RSA using SHA-256 (asymmetric, recommended)
	//  - "HS256": HMAC using SHA-256 (symmetric, requires client secret)
	//  - "PS256": RSA-PSS using SHA-256
	//  Default: RS256
	SigningAlg string `json:"signing_alg,omitempty" jsonschema:"signing_alg is the algorithm used to sign access tokens for this API. Options: - 'RS256': RSA using SHA-256 (asymmetric; recommended) - 'HS256': HMAC using SHA-256 (symmetric; requires client secret) ..."`
	// allow_offline_access indicates whether refresh tokens can be issued for this API.
	//  When true, applications can request refresh tokens using the "offline_access" scope.
	//  This allows applications to obtain new access tokens without user interaction.
	//  Default: false
	AllowOfflineAccess bool `json:"allow_offline_access,omitempty" jsonschema:"allow_offline_access indicates whether refresh tokens can be issued for this API. When true; applications can request refresh tokens using the 'offline_access' scope. This allows applications to obtai..."`
	// token_lifetime is the duration (in seconds) that access tokens remain valid
	//  when issued from the token endpoint.
	//  Range: 0 to 2592000 (30 days)
	//  Default: 86400 (24 hours)
	TokenLifetime int32 `json:"token_lifetime,omitempty" jsonschema:"token_lifetime is the duration (in seconds) that access tokens remain valid when issued from the token endpoint. Range: 0 to 2592000 (30 days) Default: 86400 (24 hours)"`
	// token_lifetime_for_web is the duration (in seconds) that access tokens remain valid
	//  when issued via implicit or hybrid flows.
	//  This should typically be shorter than token_lifetime for security.
	//  Cannot be greater than token_lifetime.
	//  Range: 0 to 2592000 (30 days)
	//  Default: 7200 (2 hours)
	TokenLifetimeForWeb int32 `json:"token_lifetime_for_web,omitempty" jsonschema:"token_lifetime_for_web is the duration (in seconds) that access tokens remain valid when issued via implicit or hybrid flows. This should typically be shorter than token_lifetime for security. Cannot ..."`
	// skip_consent_for_verifiable_first_party_clients indicates whether to skip
	//  the consent prompt for applications flagged as first-party.
	//  When true, first-party applications don't show the consent screen to users.
	//  Default: true
	SkipConsentForVerifiableFirstPartyClients bool `json:"skip_consent_for_verifiable_first_party_clients,omitempty" jsonschema:"skip_consent_for_verifiable_first_party_clients indicates whether to skip the consent prompt for applications flagged as first-party. When true; first-party applications don't show the consent screen ..."`
	// enforce_policies enables RBAC authorization policies for this API.
	//  When true, role and permission assignments are evaluated during login.
	//  This allows you to use Auth0's built-in RBAC to control API access.
	//  Requires token_dialect to be set to a value that includes permissions.
	//  Default: false
	//
	//  ht...
	EnforcePolicies bool `json:"enforce_policies,omitempty" jsonschema:"enforce_policies enables RBAC authorization policies for this API. When true; role and permission assignments are evaluated during login. This allows you to use Auth0's built-in RBAC to control API ac..."`
	// token_dialect determines the format of access tokens issued for this API.
	//  Options:
	//  - "access_token": Standard Auth0 JWT with claims
	//  - "access_token_authz": Standard Auth0 JWT including RBAC permissions claims
	//  - "rfc9068_profile": IETF JWT Access Token Profile compliant
	//  - "rfc9068_profile_authz"...
	TokenDialect string `json:"token_dialect,omitempty" jsonschema:"token_dialect determines the format of access tokens issued for this API. Options: - 'access_token': Standard Auth0 JWT with claims - 'access_token_authz': Standard Auth0 JWT including RBAC permission..."`
	// scopes defines the permissions that can be granted for this API.
	//  Each scope represents a specific permission that applications can request.
	//  Applications request scopes during authorization, and granted scopes
	//  appear in the access token's "scope" claim.
	//
	//  Example scopes:
	//  - read:users (permission ...
	Scopes []*Auth0ResourceServerScopeInput `json:"scopes,omitempty" jsonschema:"scopes defines the permissions that can be granted for this API. Each scope represents a specific permission that applications can request. Applications request scopes during authorization; and grante..."`
}

func (s *Auth0ResourceServerSpecInput) validate() error {
	if s.Identifier == "" {
		return fmt.Errorf("identifier is required")
	}
	for i, v := range s.Scopes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("scopes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *Auth0ResourceServerSpecInput) applyDefaults() {
}

func (s *Auth0ResourceServerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["identifier"] = s.Identifier
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.SigningAlg != "" {
		m["signing_alg"] = s.SigningAlg
	}
	if s.AllowOfflineAccess {
		m["allow_offline_access"] = s.AllowOfflineAccess
	}
	if s.TokenLifetime != 0 {
		m["token_lifetime"] = s.TokenLifetime
	}
	if s.TokenLifetimeForWeb != 0 {
		m["token_lifetime_for_web"] = s.TokenLifetimeForWeb
	}
	if s.SkipConsentForVerifiableFirstPartyClients {
		m["skip_consent_for_verifiable_first_party_clients"] = s.SkipConsentForVerifiableFirstPartyClients
	}
	if s.EnforcePolicies {
		m["enforce_policies"] = s.EnforcePolicies
	}
	if s.TokenDialect != "" {
		m["token_dialect"] = s.TokenDialect
	}
	if len(s.Scopes) > 0 {
		items := make([]any, len(s.Scopes))
		for i, v := range s.Scopes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["scopes"] = items
	}
	return m
}

// Auth0ResourceServerScope represents a single permission/scope for the API.
//
//	Scopes are used for fine-grained access control, allowing you to define
//	what actions applications can perform when accessing your API.
type Auth0ResourceServerScopeInput struct {
	// name is the scope identifier used in OAuth flows.
	//  Should follow the pattern: action:resource (e.g., "read:users", "write:orders")
	//  This is what applications request and what appears in access tokens.
	Name string `json:"name" jsonschema:"required,name is the scope identifier used in OAuth flows. Should follow the pattern: action:resource (e.g.; 'read:users'; 'write:orders') This is what applications request and what appears in access tokens."`
	// description is a human-readable explanation of what this scope grants.
	//  Shown on consent screens and in the Auth0 dashboard.
	//  Example: "Read access to user profiles"
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable explanation of what this scope grants. Shown on consent screens and in the Auth0 dashboard. Example: 'Read access to user profiles'"`
}

func (s *Auth0ResourceServerScopeInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *Auth0ResourceServerScopeInput) applyDefaults() {
}

func (s *Auth0ResourceServerScopeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ParseAuth0ResourceServer validates and normalizes a Auth0ResourceServer cloud_object.
func ParseAuth0ResourceServer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "auth0.openmcf.org/v1", "Auth0ResourceServer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec Auth0ResourceServerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
