// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package civo

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// civo-certificate
type CivoCertificateSpecInput struct {
	// certificate_name is a unique, human‑readable identifier (≤ 64 chars).
	CertificateName string `json:"certificate_name" jsonschema:"required,certificate_name is a unique; human‑readable identifier (≤ 64 chars)."`
	// type must align with the branch chosen in certificate_source.
	Type        string                                 `json:"type" jsonschema:"required,enum=letsEncrypt|custom,type must align with the branch chosen in certificate_source."`
	LetsEncrypt *CivoCertificateLetsEncryptParamsInput `json:"lets_encrypt,omitempty" jsonschema:""`
	Custom      *CivoCertificateCustomParamsInput      `json:"custom,omitempty" jsonschema:""`
	// Optional free‑form description (≤ 128 chars).
	Description string `json:"description,omitempty" jsonschema:"Optional free‑form description (≤ 128 chars)."`
	// Optional tags; must be unique and lowercase kebab.
	Tags []string `json:"tags,omitempty" jsonschema:"Optional tags; must be unique and lowercase kebab."`
}

func (s *CivoCertificateSpecInput) validate() error {
	if s.CertificateName == "" {
		return fmt.Errorf("certificate_name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "letsEncrypt", "custom":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.LetsEncrypt != nil {
		if err := s.LetsEncrypt.validate(); err != nil {
			return fmt.Errorf("lets_encrypt: %w", err)
		}
	}
	if s.Custom != nil {
		if err := s.Custom.validate(); err != nil {
			return fmt.Errorf("custom: %w", err)
		}
	}
	return nil
}

func (s *CivoCertificateSpecInput) applyDefaults() {
	if s.LetsEncrypt != nil {
		s.LetsEncrypt.applyDefaults()
	}
	if s.Custom != nil {
		s.Custom.applyDefaults()
	}
}

func (s *CivoCertificateSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["certificate_name"] = s.CertificateName
	m["type"] = s.Type
	if s.LetsEncrypt != nil {
		m["lets_encrypt"] = s.LetsEncrypt.toMap()
	}
	if s.Custom != nil {
		m["custom"] = s.Custom.toMap()
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// Parameters specific to a custom (user‑supplied) certificate.
type CivoCertificateCustomParamsInput struct {
	// leaf_certificate is the PEM‑encoded public certificate.
	LeafCertificate string `json:"leaf_certificate" jsonschema:"required,leaf_certificate is the PEM‑encoded public certificate."`
	// private_key is the PEM‑encoded private key.
	PrivateKey string `json:"private_key" jsonschema:"required,private_key is the PEM‑encoded private key."`
	// certificate_chain is an optional PEM‑encoded intermediate chain.
	CertificateChain string `json:"certificate_chain,omitempty" jsonschema:"certificate_chain is an optional PEM‑encoded intermediate chain."`
}

func (s *CivoCertificateCustomParamsInput) validate() error {
	if s.LeafCertificate == "" {
		return fmt.Errorf("leaf_certificate is required")
	}
	if s.PrivateKey == "" {
		return fmt.Errorf("private_key is required")
	}
	return nil
}

func (s *CivoCertificateCustomParamsInput) applyDefaults() {
}

func (s *CivoCertificateCustomParamsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["leaf_certificate"] = s.LeafCertificate
	m["private_key"] = s.PrivateKey
	if s.CertificateChain != "" {
		m["certificate_chain"] = s.CertificateChain
	}
	return m
}

// Parameters specific to a Let's Encrypt certificate request.
type CivoCertificateLetsEncryptParamsInput struct {
	// domains is the list of FQDNs (or wildcard domains) to include.
	//  At least one domain is required.
	Domains []string `json:"domains" jsonschema:"required,domains is the list of FQDNs (or wildcard domains) to include. At least one domain is required."`
	// disable_auto_renew controls automatic renewal of the Let's Encrypt certificate.
	DisableAutoRenew bool `json:"disable_auto_renew,omitempty" jsonschema:"disable_auto_renew controls automatic renewal of the Let's Encrypt certificate."`
}

func (s *CivoCertificateLetsEncryptParamsInput) validate() error {
	if len(s.Domains) == 0 {
		return fmt.Errorf("domains is required")
	}
	return nil
}

func (s *CivoCertificateLetsEncryptParamsInput) applyDefaults() {
}

func (s *CivoCertificateLetsEncryptParamsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["domains"] = s.Domains
	if s.DisableAutoRenew {
		m["disable_auto_renew"] = s.DisableAutoRenew
	}
	return m
}

// ParseCivoCertificate validates and normalizes a CivoCertificate cloud_object.
func ParseCivoCertificate(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "civo.openmcf.org/v1", "CivoCertificate"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CivoCertificateSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
