// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package civo

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// civo-firewall
type CivoFirewallSpecInput struct {
	// Name of the firewall (must be unique per Civo account/project).
	Name string `json:"name" jsonschema:"required,Name of the firewall (must be unique per Civo account/project)."`
	// The network (VPC) in which to create this firewall. Must refer to an existing CivoNetwork.
	NetworkId string `json:"network_id" jsonschema:"required,The network (VPC) in which to create this firewall. Must refer to an existing CivoNetwork."`
	// Inbound (ingress) rules: traffic allowed **to** instances.
	//  Any traffic not matching an inbound rule is denied (stateful firewall).
	InboundRules []*CivoFirewallInboundRuleInput `json:"inbound_rules,omitempty" jsonschema:"Inbound (ingress) rules: traffic allowed **to** instances. Any traffic not matching an inbound rule is denied (stateful firewall)."`
	// Outbound (egress) rules: traffic allowed **from** instances.
	//  If no egress rules are specified, all outbound traffic is allowed by default.
	OutboundRules []*CivoFirewallOutboundRuleInput `json:"outbound_rules,omitempty" jsonschema:"Outbound (egress) rules: traffic allowed **from** instances. If no egress rules are specified; all outbound traffic is allowed by default."`
	// Instance tag selectors: names of instance tags to auto-apply this firewall to.
	//  Any instance in the same network with any of these tags will use this firewall.
	Tags []string `json:"tags,omitempty" jsonschema:"Instance tag selectors: names of instance tags to auto-apply this firewall to. Any instance in the same network with any of these tags will use this firewall."`
}

func (s *CivoFirewallSpecInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.NetworkId == "" {
		return fmt.Errorf("network_id is required")
	}
	for i, v := range s.InboundRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("inbound_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.OutboundRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("outbound_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *CivoFirewallSpecInput) applyDefaults() {
}

func (s *CivoFirewallSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["network_id"] = s.NetworkId
	if len(s.InboundRules) > 0 {
		items := make([]any, len(s.InboundRules))
		for i, v := range s.InboundRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["inbound_rules"] = items
	}
	if len(s.OutboundRules) > 0 {
		items := make([]any, len(s.OutboundRules))
		for i, v := range s.OutboundRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["outbound_rules"] = items
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	return m
}

// Definition of an inbound (ingress) firewall rule.
type CivoFirewallInboundRuleInput struct {
	// Protocol to allow ("tcp", "udp", or "icmp").
	Protocol string `json:"protocol,omitempty" jsonschema:"Protocol to allow ('tcp'; 'udp'; or 'icmp')."`
	// Port or port range to allow (e.g., "80", "443", "22", "8000-9000"; for "tcp"/"udp"
	//  leave empty or use "1-65535" to allow all ports).
	PortRange string `json:"port_range,omitempty" jsonschema:"Port or port range to allow (e.g.; '80'; '443'; '22'; '8000-9000'; for 'tcp'/'udp' leave empty or use '1-65535' to allow all ports)."`
	// CIDR blocks from which traffic is permitted (defaults to "0.0.0.0/0" if not specified).
	Cidrs []string `json:"cidrs,omitempty" jsonschema:"CIDR blocks from which traffic is permitted (defaults to '0.0.0.0/0' if not specified)."`
	// Action for this rule: "allow" (default) or "deny". Default is "allow" if unspecified.
	Action string `json:"action,omitempty" jsonschema:"Action for this rule: 'allow' (default) or 'deny'. Default is 'allow' if unspecified."`
	// Optional label for the rule (for user reference).
	Label string `json:"label,omitempty" jsonschema:"Optional label for the rule (for user reference)."`
}

func (s *CivoFirewallInboundRuleInput) validate() error {
	return nil
}

func (s *CivoFirewallInboundRuleInput) applyDefaults() {
}

func (s *CivoFirewallInboundRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRange != "" {
		m["port_range"] = s.PortRange
	}
	if len(s.Cidrs) > 0 {
		m["cidrs"] = s.Cidrs
	}
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.Label != "" {
		m["label"] = s.Label
	}
	return m
}

// Definition of an outbound (egress) firewall rule.
type CivoFirewallOutboundRuleInput struct {
	// Protocol to allow or deny ("tcp", "udp", or "icmp").
	Protocol string `json:"protocol,omitempty" jsonschema:"Protocol to allow or deny ('tcp'; 'udp'; or 'icmp')."`
	// Port or port range to allow/deny (format as in inbound rules).
	PortRange string `json:"port_range,omitempty" jsonschema:"Port or port range to allow/deny (format as in inbound rules)."`
	// CIDR blocks to which traffic is permitted (defaults to "0.0.0.0/0" if not specified).
	Cidrs []string `json:"cidrs,omitempty" jsonschema:"CIDR blocks to which traffic is permitted (defaults to '0.0.0.0/0' if not specified)."`
	// Action for this rule: "allow" (default) or "deny". Default is "allow" if unspecified.
	Action string `json:"action,omitempty" jsonschema:"Action for this rule: 'allow' (default) or 'deny'. Default is 'allow' if unspecified."`
	// Optional label for the rule.
	Label string `json:"label,omitempty" jsonschema:"Optional label for the rule."`
}

func (s *CivoFirewallOutboundRuleInput) validate() error {
	return nil
}

func (s *CivoFirewallOutboundRuleInput) applyDefaults() {
}

func (s *CivoFirewallOutboundRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.PortRange != "" {
		m["port_range"] = s.PortRange
	}
	if len(s.Cidrs) > 0 {
		m["cidrs"] = s.Cidrs
	}
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.Label != "" {
		m["label"] = s.Label
	}
	return m
}

// ParseCivoFirewall validates and normalizes a CivoFirewall cloud_object.
func ParseCivoFirewall(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "civo.openmcf.org/v1", "CivoFirewall"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CivoFirewallSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
