// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package civo

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// civo-kubernetes-cluster
type CivoKubernetesClusterSpecInput struct {
	// The name of the Kubernetes cluster.
	//  Constraints: Must be unique per account. No spaces allowed (alphanumeric and hyphens recommended). If left blank, a random name will be assigned.
	ClusterName string `json:"cluster_name" jsonschema:"required,The name of the Kubernetes cluster. Constraints: Must be unique per account. No spaces allowed (alphanumeric and hyphens recommended). If left blank; a random name will be assigned."`
	// The Civo region where the cluster will be created.
	//  Determines where the cluster's control plane and nodes are provisioned.
	Region string `json:"region" jsonschema:"required,enum=lon1|lon2|fra1|nyc1|phx1|mum1,The Civo region where the cluster will be created. Determines where the cluster's control plane and nodes are provisioned."`
	// The Kubernetes version to use for the cluster (semantic versioning).
	//  Must be a supported version on Civo (e.g., "1.26.3").
	KubernetesVersion string `json:"kubernetes_version" jsonschema:"required,The Kubernetes version to use for the cluster (semantic versioning). Must be a supported version on Civo (e.g.; '1.26.3')."`
	// Reference to the Civo network where the cluster will reside.
	//  This must be an existing network in the same region. The network's ID is used for the cluster's networking.
	Network string `json:"network" jsonschema:"required,Reference to the Civo network where the cluster will reside. This must be an existing network in the same region. The network's ID is used for the cluster's networking."`
	// Whether to enable a highly available control plane for the cluster.
	//  If true (when supported), the cluster is created with multiple master nodes for increased availability.
	//  Default: false.
	HighlyAvailable bool `json:"highly_available,omitempty" jsonschema:"Whether to enable a highly available control plane for the cluster. If true (when supported); the cluster is created with multiple master nodes for increased availability. Default: false."`
	// Whether to enable automatic Kubernetes version patch upgrades for the cluster.
	//  If true, the cluster will automatically upgrade to new patch releases of Kubernetes when available.
	AutoUpgrade bool `json:"auto_upgrade,omitempty" jsonschema:"Whether to enable automatic Kubernetes version patch upgrades for the cluster. If true; the cluster will automatically upgrade to new patch releases of Kubernetes when available."`
	// Whether to disable surge upgrades for the cluster.
	//  If false (default), cluster upgrades may temporarily provision extra resources to minimize downtime during updates.
	DisableSurgeUpgrade bool `json:"disable_surge_upgrade,omitempty" jsonschema:"Whether to disable surge upgrades for the cluster. If false (default); cluster upgrades may temporarily provision extra resources to minimize downtime during updates."`
	// A list of tags to apply to the cluster.
	//  Tags help organize and identify the cluster within Civo.
	Tags []string `json:"tags,omitempty" jsonschema:"A list of tags to apply to the cluster. Tags help organize and identify the cluster within Civo."`
	// Configuration for the cluster's default node pool.
	DefaultNodePool *CivoKubernetesClusterDefaultNodePoolInput `json:"default_node_pool" jsonschema:"required,Configuration for the cluster's default node pool."`
}

func (s *CivoKubernetesClusterSpecInput) validate() error {
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	switch s.Region {
	case "lon1", "lon2", "fra1", "nyc1", "phx1", "mum1":
	default:
		return fmt.Errorf("invalid region: %q", s.Region)
	}
	if s.KubernetesVersion == "" {
		return fmt.Errorf("kubernetes_version is required")
	}
	if s.Network == "" {
		return fmt.Errorf("network is required")
	}
	if s.DefaultNodePool == nil {
		return fmt.Errorf("default_node_pool is required")
	}
	if s.DefaultNodePool != nil {
		if err := s.DefaultNodePool.validate(); err != nil {
			return fmt.Errorf("default_node_pool: %w", err)
		}
	}
	return nil
}

func (s *CivoKubernetesClusterSpecInput) applyDefaults() {
	if s.DefaultNodePool != nil {
		s.DefaultNodePool.applyDefaults()
	}
}

func (s *CivoKubernetesClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cluster_name"] = s.ClusterName
	m["region"] = s.Region
	m["kubernetes_version"] = s.KubernetesVersion
	m["network"] = s.Network
	if s.HighlyAvailable {
		m["highly_available"] = s.HighlyAvailable
	}
	if s.AutoUpgrade {
		m["auto_upgrade"] = s.AutoUpgrade
	}
	if s.DisableSurgeUpgrade {
		m["disable_surge_upgrade"] = s.DisableSurgeUpgrade
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.DefaultNodePool != nil {
		m["default_node_pool"] = s.DefaultNodePool.toMap()
	}
	return m
}

// Civo Kubernetes Cluster Default Node Pool
type CivoKubernetesClusterDefaultNodePoolInput struct {
	// The instance size (node flavor) for each node in the default pool (e.g., "g4s.kube.medium").
	//  This defines the CPU and memory for the nodes.
	Size string `json:"size" jsonschema:"required,The instance size (node flavor) for each node in the default pool (e.g.; 'g4s.kube.medium'). This defines the CPU and memory for the nodes."`
	// The number of nodes to provision in the default node pool.
	//  Must be at least 1.
	NodeCount uint32 `json:"node_count" jsonschema:"required,The number of nodes to provision in the default node pool. Must be at least 1."`
}

func (s *CivoKubernetesClusterDefaultNodePoolInput) validate() error {
	if s.Size == "" {
		return fmt.Errorf("size is required")
	}
	return nil
}

func (s *CivoKubernetesClusterDefaultNodePoolInput) applyDefaults() {
}

func (s *CivoKubernetesClusterDefaultNodePoolInput) toMap() map[string]any {
	m := make(map[string]any)
	m["size"] = s.Size
	m["node_count"] = s.NodeCount
	return m
}

// ParseCivoKubernetesCluster validates and normalizes a CivoKubernetesCluster cloud_object.
func ParseCivoKubernetesCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "civo.openmcf.org/v1", "CivoKubernetesCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec CivoKubernetesClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
