// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureContainerApp is the top-level API resource for an Azure Container App.
//
//	It defines a serverless container workload running inside an Azure Container
//	Apps Managed Environment, with containers, scaling rules, ingress, secrets,
//	and optional Dapr sidecar.
type AzureContainerAppSpecInput struct {
	// The Azure Resource Group where the Container App will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	//
	//  **ForceNew**: Changing this destroys and recreates the app.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Container App will be created. Can be a literal string or a reference to an AzureResourceGroup output. **ForceNew**: Changing this destroys and recreates the app."`
	// The name of the Container App.
	//  Must be lowercase alphanumeric or hyphens, start with a letter, end with
	//  an alphanumeric character, no consecutive hyphens, max 32 characters.
	//
	//  This name is used in the app's FQDN: {name}.{environment-default-domain}
	//
	//  **ForceNew**: Changing this destroys and recrea...
	Name string `json:"name" jsonschema:"required,The name of the Container App. Must be lowercase alphanumeric or hyphens; start with a letter; end with an alphanumeric character; no consecutive hyphens; max 32 characters. This name is used in the a..."`
	// The Container App Environment where this app will run.
	//  The environment provides networking, logging, and compute capacity.
	//
	//  **ForceNew**: Changing this destroys and recreates the app.
	ContainerAppEnvironmentId string `json:"container_app_environment_id" jsonschema:"required,The Container App Environment where this app will run. The environment provides networking; logging; and compute capacity. **ForceNew**: Changing this destroys and recreates the app."`
	// The revision operating mode. Controls how many revisions can be active.
	//
	//  "Single": Only one revision active at a time (default, simplest).
	//  "Multiple": Multiple revisions active simultaneously with traffic splitting.
	//
	//  Default: "Single"
	RevisionMode string `json:"revision_mode,omitempty" jsonschema:"The revision operating mode. Controls how many revisions can be active. 'Single': Only one revision active at a time (default; simplest). 'Multiple': Multiple revisions active simultaneously with traf..."`
	// The workload profile name to run this app on.
	//  References a profile defined in the Container App Environment.
	//
	//  Omit to use the default Consumption (serverless) profile.
	//  Set to a named profile (e.g., "gpu-pool", "high-memory") for dedicated compute.
	WorkloadProfileName string `json:"workload_profile_name,omitempty" jsonschema:"The workload profile name to run this app on. References a profile defined in the Container App Environment. Omit to use the default Consumption (serverless) profile. Set to a named profile (e.g.; 'gp..."`
	// Maximum number of inactive revisions to retain.
	//  Older inactive revisions beyond this limit are automatically purged.
	//
	//  Range: 0-100. Omit to use Azure's default (typically 100).
	MaxInactiveRevisions int32 `json:"max_inactive_revisions,omitempty" jsonschema:"Maximum number of inactive revisions to retain. Older inactive revisions beyond this limit are automatically purged. Range: 0-100. Omit to use Azure's default (typically 100)."`
	// Main containers for the app. At least one container is required.
	//  Each container runs continuously and can have health probes.
	Containers []*AzureContainerAppContainerInput `json:"containers,omitempty" jsonschema:"Main containers for the app. At least one container is required. Each container runs continuously and can have health probes."`
	// Init containers run to completion before main containers start.
	//  Use for database migrations, configuration generation, or downloading
	//  assets. Init containers cannot have health probes.
	InitContainers []*AzureContainerAppInitContainerInput `json:"init_containers,omitempty" jsonschema:"Init containers run to completion before main containers start. Use for database migrations; configuration generation; or downloading assets. Init containers cannot have health probes."`
	// Volumes available to containers in this app.
	//  Containers reference volumes by name in their volume_mounts field.
	Volumes []*AzureContainerAppVolumeInput `json:"volumes,omitempty" jsonschema:"Volumes available to containers in this app. Containers reference volumes by name in their volume_mounts field."`
	// Minimum number of replicas. Set to 0 for scale-to-zero (no cost when idle).
	//
	//  Default: 0
	//  Range: 0-300
	MinReplicas int32 `json:"min_replicas,omitempty" jsonschema:"Minimum number of replicas. Set to 0 for scale-to-zero (no cost when idle). Default: 0 Range: 0-300"`
	// Maximum number of replicas the app can scale to.
	//
	//  Default: 10
	//  Range: 1-300
	MaxReplicas int32 `json:"max_replicas,omitempty" jsonschema:"Maximum number of replicas the app can scale to. Default: 10 Range: 1-300"`
	// Scale cooldown period in seconds. After a scale event, the scaler waits
	//  this duration before evaluating scale rules again.
	//
	//  Default: 300 (5 minutes)
	CooldownPeriodInSeconds int32 `json:"cooldown_period_in_seconds,omitempty" jsonschema:"Scale cooldown period in seconds. After a scale event; the scaler waits this duration before evaluating scale rules again. Default: 300 (5 minutes)"`
	// KEDA polling interval in seconds. How often scale rules are evaluated.
	//
	//  Default: 30
	PollingIntervalInSeconds int32 `json:"polling_interval_in_seconds,omitempty" jsonschema:"KEDA polling interval in seconds. How often scale rules are evaluated. Default: 30"`
	// Manual revision suffix. When set, the revision name becomes
	//  "{app-name}--{revision_suffix}". When omitted, Azure auto-generates a suffix.
	//
	//  Useful for canary deployments and explicit revision tracking.
	RevisionSuffix string `json:"revision_suffix,omitempty" jsonschema:"Manual revision suffix. When set; the revision name becomes '{app-name}--{revision_suffix}'. When omitted; Azure auto-generates a suffix. Useful for canary deployments and explicit revision tracking."`
	// Termination grace period in seconds. How long to wait for containers
	//  to gracefully shut down before forcefully terminating them.
	//
	//  Default: 0 (immediate termination)
	//  Range: 0-600
	TerminationGracePeriodSeconds int32 `json:"termination_grace_period_seconds,omitempty" jsonschema:"Termination grace period in seconds. How long to wait for containers to gracefully shut down before forcefully terminating them. Default: 0 (immediate termination) Range: 0-600"`
	// HTTP scale rules. Scale based on concurrent HTTP requests.
	//  Most common for web services and APIs.
	HttpScaleRules []*AzureContainerAppHttpScaleRuleInput `json:"http_scale_rules,omitempty" jsonschema:"HTTP scale rules. Scale based on concurrent HTTP requests. Most common for web services and APIs."`
	// TCP scale rules. Scale based on concurrent TCP connections.
	TcpScaleRules []*AzureContainerAppTcpScaleRuleInput `json:"tcp_scale_rules,omitempty" jsonschema:"TCP scale rules. Scale based on concurrent TCP connections."`
	// Azure Queue scale rules. Scale based on Azure Storage Queue depth.
	AzureQueueScaleRules []*AzureContainerAppAzureQueueScaleRuleInput `json:"azure_queue_scale_rules,omitempty" jsonschema:"Azure Queue scale rules. Scale based on Azure Storage Queue depth."`
	// Custom KEDA scale rules. Scale based on any KEDA-supported scaler
	//  (Kafka, Prometheus, Redis, cron, cpu, memory, etc.).
	CustomScaleRules []*AzureContainerAppCustomScaleRuleInput `json:"custom_scale_rules,omitempty" jsonschema:"Custom KEDA scale rules. Scale based on any KEDA-supported scaler (Kafka; Prometheus; Redis; cron; cpu; memory; etc.)."`
	// Secrets available to the app. Referenced by name in container env vars
	//  and registry password_secret_name.
	//
	//  Secrets can be plain-text values or Key Vault references. Key Vault
	//  references require a managed identity (set identity on secret or app level).
	Secrets []*AzureContainerAppSecretInput `json:"secrets,omitempty" jsonschema:"Secrets available to the app. Referenced by name in container env vars and registry password_secret_name. Secrets can be plain-text values or Key Vault references. Key Vault references require a manag..."`
	// Private container registry credentials. Required to pull images from
	//  private registries (ACR, Docker Hub, GitHub Container Registry, etc.).
	//
	//  Each registry authenticates via username/password (referencing a secret)
	//  or managed identity.
	Registries []*AzureContainerAppRegistryInput `json:"registries,omitempty" jsonschema:"Private container registry credentials. Required to pull images from private registries (ACR; Docker Hub; GitHub Container Registry; etc.). Each registry authenticates via username/password (referenci..."`
	// Ingress configuration. When set, the app is accessible via HTTP/TCP.
	//  When omitted, the app is only accessible from within the environment
	//  via service discovery (app name).
	Ingress *AzureContainerAppIngressInput `json:"ingress,omitempty" jsonschema:"Ingress configuration. When set; the app is accessible via HTTP/TCP. When omitted; the app is only accessible from within the environment via service discovery (app name)."`
	// Dapr sidecar configuration. When set, a Dapr sidecar is injected
	//  alongside the app container, enabling Dapr building blocks
	//  (service invocation, pub/sub, state management, etc.).
	Dapr *AzureContainerAppDaprInput `json:"dapr,omitempty" jsonschema:"Dapr sidecar configuration. When set; a Dapr sidecar is injected alongside the app container; enabling Dapr building blocks (service invocation; pub/sub; state management; etc.)."`
	// Managed identity configuration for the app. Enables the app to
	//  authenticate with Azure services (Key Vault, ACR, Storage, etc.)
	//  without managing credentials.
	Identity *AzureContainerAppIdentityInput `json:"identity,omitempty" jsonschema:"Managed identity configuration for the app. Enables the app to authenticate with Azure services (Key Vault; ACR; Storage; etc.) without managing credentials."`
}

func (s *AzureContainerAppSpecInput) validate() error {
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ContainerAppEnvironmentId == "" {
		return fmt.Errorf("container_app_environment_id is required")
	}
	if len(s.Containers) < 1 {
		return fmt.Errorf("containers requires at least 1 items, got %d", len(s.Containers))
	}
	for i, v := range s.Containers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("containers[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.InitContainers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("init_containers[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Volumes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volumes[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.HttpScaleRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("http_scale_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.TcpScaleRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("tcp_scale_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.AzureQueueScaleRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("azure_queue_scale_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.CustomScaleRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("custom_scale_rules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Secrets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("secrets[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Registries {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("registries[%d]: %w", i, err)
			}
		}
	}
	if s.Ingress != nil {
		if err := s.Ingress.validate(); err != nil {
			return fmt.Errorf("ingress: %w", err)
		}
	}
	if s.Dapr != nil {
		if err := s.Dapr.validate(); err != nil {
			return fmt.Errorf("dapr: %w", err)
		}
	}
	if s.Identity != nil {
		if err := s.Identity.validate(); err != nil {
			return fmt.Errorf("identity: %w", err)
		}
	}
	return nil
}

func (s *AzureContainerAppSpecInput) applyDefaults() {
	if s.RevisionMode == "" {
		s.RevisionMode = "Single"
	}
	if s.MinReplicas == 0 {
		s.MinReplicas = 0
	}
	if s.MaxReplicas == 0 {
		s.MaxReplicas = 10
	}
	if s.CooldownPeriodInSeconds == 0 {
		s.CooldownPeriodInSeconds = 300
	}
	if s.PollingIntervalInSeconds == 0 {
		s.PollingIntervalInSeconds = 30
	}
	if s.TerminationGracePeriodSeconds == 0 {
		s.TerminationGracePeriodSeconds = 0
	}
	if s.Ingress != nil {
		s.Ingress.applyDefaults()
	}
	if s.Dapr != nil {
		s.Dapr.applyDefaults()
	}
	if s.Identity != nil {
		s.Identity.applyDefaults()
	}
}

func (s *AzureContainerAppSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["container_app_environment_id"] = s.ContainerAppEnvironmentId
	if s.RevisionMode != "" {
		m["revision_mode"] = s.RevisionMode
	}
	if s.WorkloadProfileName != "" {
		m["workload_profile_name"] = s.WorkloadProfileName
	}
	if s.MaxInactiveRevisions != 0 {
		m["max_inactive_revisions"] = s.MaxInactiveRevisions
	}
	if len(s.Containers) > 0 {
		items := make([]any, len(s.Containers))
		for i, v := range s.Containers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["containers"] = items
	}
	if len(s.InitContainers) > 0 {
		items := make([]any, len(s.InitContainers))
		for i, v := range s.InitContainers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["init_containers"] = items
	}
	if len(s.Volumes) > 0 {
		items := make([]any, len(s.Volumes))
		for i, v := range s.Volumes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volumes"] = items
	}
	if s.MinReplicas != 0 {
		m["min_replicas"] = s.MinReplicas
	}
	if s.MaxReplicas != 0 {
		m["max_replicas"] = s.MaxReplicas
	}
	if s.CooldownPeriodInSeconds != 0 {
		m["cooldown_period_in_seconds"] = s.CooldownPeriodInSeconds
	}
	if s.PollingIntervalInSeconds != 0 {
		m["polling_interval_in_seconds"] = s.PollingIntervalInSeconds
	}
	if s.RevisionSuffix != "" {
		m["revision_suffix"] = s.RevisionSuffix
	}
	if s.TerminationGracePeriodSeconds != 0 {
		m["termination_grace_period_seconds"] = s.TerminationGracePeriodSeconds
	}
	if len(s.HttpScaleRules) > 0 {
		items := make([]any, len(s.HttpScaleRules))
		for i, v := range s.HttpScaleRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["http_scale_rules"] = items
	}
	if len(s.TcpScaleRules) > 0 {
		items := make([]any, len(s.TcpScaleRules))
		for i, v := range s.TcpScaleRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["tcp_scale_rules"] = items
	}
	if len(s.AzureQueueScaleRules) > 0 {
		items := make([]any, len(s.AzureQueueScaleRules))
		for i, v := range s.AzureQueueScaleRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["azure_queue_scale_rules"] = items
	}
	if len(s.CustomScaleRules) > 0 {
		items := make([]any, len(s.CustomScaleRules))
		for i, v := range s.CustomScaleRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["custom_scale_rules"] = items
	}
	if len(s.Secrets) > 0 {
		items := make([]any, len(s.Secrets))
		for i, v := range s.Secrets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["secrets"] = items
	}
	if len(s.Registries) > 0 {
		items := make([]any, len(s.Registries))
		for i, v := range s.Registries {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["registries"] = items
	}
	if s.Ingress != nil {
		m["ingress"] = s.Ingress.toMap()
	}
	if s.Dapr != nil {
		m["dapr"] = s.Dapr.toMap()
	}
	if s.Identity != nil {
		m["identity"] = s.Identity.toMap()
	}
	return m
}

// AzureContainerAppAzureQueueScaleRule scales the app based on Azure Storage Queue depth.
type AzureContainerAppAzureQueueScaleRuleInput struct {
	// Rule name.
	Name string `json:"name" jsonschema:"required,Rule name."`
	// Azure Storage Queue name.
	QueueName string `json:"queue_name" jsonschema:"required,Azure Storage Queue name."`
	// Queue length threshold. When the queue has more messages than this value,
	//  the app scales up.
	QueueLength int32 `json:"queue_length,omitempty" jsonschema:"Queue length threshold. When the queue has more messages than this value; the app scales up."`
	// Authentication configuration. Required for Azure Queue scale rules.
	//  Must include credentials to access the Azure Storage Queue.
	Authentication []*AzureContainerAppScaleRuleAuthInput `json:"authentication,omitempty" jsonschema:"Authentication configuration. Required for Azure Queue scale rules. Must include credentials to access the Azure Storage Queue."`
}

func (s *AzureContainerAppAzureQueueScaleRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.QueueName == "" {
		return fmt.Errorf("queue_name is required")
	}
	if len(s.Authentication) < 1 {
		return fmt.Errorf("authentication requires at least 1 items, got %d", len(s.Authentication))
	}
	for i, v := range s.Authentication {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("authentication[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppAzureQueueScaleRuleInput) applyDefaults() {
}

func (s *AzureContainerAppAzureQueueScaleRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["queue_name"] = s.QueueName
	if s.QueueLength != 0 {
		m["queue_length"] = s.QueueLength
	}
	if len(s.Authentication) > 0 {
		items := make([]any, len(s.Authentication))
		for i, v := range s.Authentication {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["authentication"] = items
	}
	return m
}

// AzureContainerAppContainer defines a main container within the app.
//
//	Each container specifies an image, CPU/memory allocation, environment variables,
//	optional entrypoint overrides, health probes, and volume mounts.
//
//	CPU and memory are required for main containers. Valid combinations depend on
//	the workload profile:
//	- Consumption: 0.25/0.5/0.75/1.0/1.25/1.5/1.75/2.0 vCPU
//	- Dedicated: up to profile limits (e.g., D4 = 4 vCPU, 8 GiB)
//
//	Memory must be specified in Gi format (e.g., "0.5Gi", "1Gi", "2Gi").
type AzureContainerAppContainerInput struct {
	// Container name. Must be unique within the app.
	//  Lowercase alphanumeric, hyphens, or dots, max 46 characters.
	Name string `json:"name" jsonschema:"required,Container name. Must be unique within the app. Lowercase alphanumeric; hyphens; or dots; max 46 characters."`
	// Container image in repository:tag format.
	//  Examples: "mcr.microsoft.com/k8se/quickstart:latest", "myregistry.azurecr.io/myapp:v1.2.3"
	Image string `json:"image" jsonschema:"required,Container image in repository:tag format. Examples: 'mcr.microsoft.com/k8se/quickstart:latest'; 'myregistry.azurecr.io/myapp:v1.2.3'"`
	// CPU allocation in vCPU cores.
	//  Examples: 0.25, 0.5, 1.0, 2.0
	//
	//  Valid values depend on the workload profile. For Consumption plan:
	//  0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0
	Cpu float64 `json:"cpu,omitempty" jsonschema:"CPU allocation in vCPU cores. Examples: 0.25; 0.5; 1.0; 2.0 Valid values depend on the workload profile. For Consumption plan: 0.25; 0.5; 0.75; 1.0; 1.25; 1.5; 1.75; 2.0"`
	// Memory allocation in Gi format.
	//  Examples: "0.5Gi", "1Gi", "2Gi", "4Gi"
	//
	//  Must match the CPU allocation. For Consumption plan with 0.25 vCPU,
	//  memory must be "0.5Gi". See Azure docs for valid CPU/memory pairs.
	Memory string `json:"memory" jsonschema:"required,Memory allocation in Gi format. Examples: '0.5Gi'; '1Gi'; '2Gi'; '4Gi' Must match the CPU allocation. For Consumption plan with 0.25 vCPU; memory must be '0.5Gi'. See Azure docs for valid CPU/memory p..."`
	// Environment variables for the container.
	//  Each variable is a literal value or a reference to a secret by name.
	Env []*AzureContainerAppEnvVarInput `json:"env,omitempty" jsonschema:"Environment variables for the container. Each variable is a literal value or a reference to a secret by name."`
	// Container command (entrypoint override).
	//  Overrides the image's default ENTRYPOINT.
	Command []string `json:"command,omitempty" jsonschema:"Container command (entrypoint override). Overrides the image's default ENTRYPOINT."`
	// Container arguments.
	//  Overrides the image's default CMD.
	Args []string `json:"args,omitempty" jsonschema:"Container arguments. Overrides the image's default CMD."`
	// Liveness probe. Determines if the container is alive.
	//  If the probe fails, the container is restarted.
	LivenessProbe *AzureContainerAppProbeInput `json:"liveness_probe,omitempty" jsonschema:"Liveness probe. Determines if the container is alive. If the probe fails; the container is restarted."`
	// Readiness probe. Determines if the container is ready to serve traffic.
	//  If the probe fails, the container is removed from load balancing.
	ReadinessProbe *AzureContainerAppProbeInput `json:"readiness_probe,omitempty" jsonschema:"Readiness probe. Determines if the container is ready to serve traffic. If the probe fails; the container is removed from load balancing."`
	// Startup probe. Determines when the container has finished starting.
	//  During startup, liveness and readiness probes are disabled.
	//  Useful for slow-starting applications.
	StartupProbe *AzureContainerAppProbeInput `json:"startup_probe,omitempty" jsonschema:"Startup probe. Determines when the container has finished starting. During startup; liveness and readiness probes are disabled. Useful for slow-starting applications."`
	// Volume mounts for the container. References volumes defined in the
	//  spec's `volumes` field by name.
	VolumeMounts []*AzureContainerAppVolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"Volume mounts for the container. References volumes defined in the spec's 'volumes' field by name."`
}

func (s *AzureContainerAppContainerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	if s.Memory == "" {
		return fmt.Errorf("memory is required")
	}
	for i, v := range s.Env {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("env[%d]: %w", i, err)
			}
		}
	}
	if s.LivenessProbe != nil {
		if err := s.LivenessProbe.validate(); err != nil {
			return fmt.Errorf("liveness_probe: %w", err)
		}
	}
	if s.ReadinessProbe != nil {
		if err := s.ReadinessProbe.validate(); err != nil {
			return fmt.Errorf("readiness_probe: %w", err)
		}
	}
	if s.StartupProbe != nil {
		if err := s.StartupProbe.validate(); err != nil {
			return fmt.Errorf("startup_probe: %w", err)
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppContainerInput) applyDefaults() {
	if s.LivenessProbe != nil {
		s.LivenessProbe.applyDefaults()
	}
	if s.ReadinessProbe != nil {
		s.ReadinessProbe.applyDefaults()
	}
	if s.StartupProbe != nil {
		s.StartupProbe.applyDefaults()
	}
}

func (s *AzureContainerAppContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["image"] = s.Image
	if s.Cpu != 0 {
		m["cpu"] = s.Cpu
	}
	m["memory"] = s.Memory
	if len(s.Env) > 0 {
		items := make([]any, len(s.Env))
		for i, v := range s.Env {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["env"] = items
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	if s.LivenessProbe != nil {
		m["liveness_probe"] = s.LivenessProbe.toMap()
	}
	if s.ReadinessProbe != nil {
		m["readiness_probe"] = s.ReadinessProbe.toMap()
	}
	if s.StartupProbe != nil {
		m["startup_probe"] = s.StartupProbe.toMap()
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	return m
}

// AzureContainerAppCorsPolicy defines Cross-Origin Resource Sharing rules for ingress.
type AzureContainerAppCorsPolicyInput struct {
	// Allowed origins. At least one origin is required.
	//  Use "*" to allow all origins (not recommended for production).
	//  Examples: "https://example.com", "https://*.contoso.com"
	AllowedOrigins []string `json:"allowed_origins,omitempty" jsonschema:"Allowed origins. At least one origin is required. Use '*' to allow all origins (not recommended for production). Examples: 'https://example.com'; 'https://*.contoso.com'"`
	// Allowed HTTP headers.
	//  Examples: "Content-Type", "Authorization", "X-Custom-Header"
	AllowedHeaders []string `json:"allowed_headers,omitempty" jsonschema:"Allowed HTTP headers. Examples: 'Content-Type'; 'Authorization'; 'X-Custom-Header'"`
	// Allowed HTTP methods.
	//  Examples: "GET", "POST", "PUT", "DELETE", "OPTIONS"
	AllowedMethods []string `json:"allowed_methods,omitempty" jsonschema:"Allowed HTTP methods. Examples: 'GET'; 'POST'; 'PUT'; 'DELETE'; 'OPTIONS'"`
	// Headers to expose to the browser.
	ExposedHeaders []string `json:"exposed_headers,omitempty" jsonschema:"Headers to expose to the browser."`
	// Maximum time in seconds that preflight results can be cached.
	MaxAgeInSeconds int32 `json:"max_age_in_seconds,omitempty" jsonschema:"Maximum time in seconds that preflight results can be cached."`
	// Whether to include credentials (cookies, authorization headers)
	//  in CORS requests.
	//
	//  Default: false
	AllowCredentialsEnabled bool `json:"allow_credentials_enabled,omitempty" jsonschema:"Whether to include credentials (cookies; authorization headers) in CORS requests. Default: false"`
}

func (s *AzureContainerAppCorsPolicyInput) validate() error {
	if len(s.AllowedOrigins) < 1 {
		return fmt.Errorf("allowed_origins requires at least 1 items, got %d", len(s.AllowedOrigins))
	}
	return nil
}

func (s *AzureContainerAppCorsPolicyInput) applyDefaults() {
}

func (s *AzureContainerAppCorsPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AllowedOrigins) > 0 {
		m["allowed_origins"] = s.AllowedOrigins
	}
	if len(s.AllowedHeaders) > 0 {
		m["allowed_headers"] = s.AllowedHeaders
	}
	if len(s.AllowedMethods) > 0 {
		m["allowed_methods"] = s.AllowedMethods
	}
	if len(s.ExposedHeaders) > 0 {
		m["exposed_headers"] = s.ExposedHeaders
	}
	if s.MaxAgeInSeconds != 0 {
		m["max_age_in_seconds"] = s.MaxAgeInSeconds
	}
	if s.AllowCredentialsEnabled {
		m["allow_credentials_enabled"] = s.AllowCredentialsEnabled
	}
	return m
}

// AzureContainerAppCustomScaleRule scales the app based on any KEDA-supported scaler.
//
//	KEDA supports dozens of scalers: Kafka, Prometheus, Redis, PostgreSQL, MySQL,
//	cron, cpu, memory, and many more. The `custom_rule_type` identifies the scaler
//	and `metadata` provides scaler-specific configuration.
//
//	See https://keda.sh/docs/scalers/ for the full list of supported scalers.
type AzureContainerAppCustomScaleRuleInput struct {
	// Rule name.
	Name string `json:"name" jsonschema:"required,Rule name."`
	// KEDA scaler type identifier.
	//  Examples: "kafka", "prometheus", "redis", "cron", "cpu", "memory",
	//  "postgresql", "mysql", "rabbitmq", "azure-servicebus"
	CustomRuleType string `json:"custom_rule_type" jsonschema:"required,KEDA scaler type identifier. Examples: 'kafka'; 'prometheus'; 'redis'; 'cron'; 'cpu'; 'memory'; 'postgresql'; 'mysql'; 'rabbitmq'; 'azure-servicebus'"`
	// Scaler-specific metadata. Keys and values depend on the scaler type.
	//
	//  Example for cron: {"timezone": "UTC", "start": "0 8 * * 1-5", "end": "0 18 * * 1-5", "desiredReplicas": "5"}
	//  Example for cpu: {"type": "Utilization", "value": "70"}
	//  Example for kafka: {"bootstrapServers": "kafka:9092", "consume...
	Metadata map[string]string `json:"metadata,omitempty" jsonschema:"Scaler-specific metadata. Keys and values depend on the scaler type. Example for cron: {'timezone': 'UTC'; 'start': '0 8 * * 1-5'; 'end': '0 18 * * 1-5'; 'desiredReplicas': '5'} Example for cpu: {'typ..."`
	// Authentication configuration for the scale rule.
	Authentication []*AzureContainerAppScaleRuleAuthInput `json:"authentication,omitempty" jsonschema:"Authentication configuration for the scale rule."`
}

func (s *AzureContainerAppCustomScaleRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.CustomRuleType == "" {
		return fmt.Errorf("custom_rule_type is required")
	}
	for i, v := range s.Authentication {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("authentication[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppCustomScaleRuleInput) applyDefaults() {
}

func (s *AzureContainerAppCustomScaleRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["custom_rule_type"] = s.CustomRuleType
	if len(s.Metadata) > 0 {
		m["metadata"] = s.Metadata
	}
	if len(s.Authentication) > 0 {
		items := make([]any, len(s.Authentication))
		for i, v := range s.Authentication {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["authentication"] = items
	}
	return m
}

// AzureContainerAppDapr configures the Dapr sidecar for the app.
//
//	When configured, a Dapr sidecar is injected alongside the app container,
//	providing building blocks for distributed applications:
//	- Service-to-service invocation
//	- Pub/sub messaging
//	- State management
//	- Secrets management
//	- Bindings and triggers
type AzureContainerAppDaprInput struct {
	// Dapr application identifier. Used for service discovery and invocation.
	//  Other Dapr-enabled apps invoke this app using this ID.
	AppId string `json:"app_id" jsonschema:"required,Dapr application identifier. Used for service discovery and invocation. Other Dapr-enabled apps invoke this app using this ID."`
	// Application port that the Dapr sidecar communicates with.
	//  This is the port your application listens on.
	AppPort int32 `json:"app_port,omitempty" jsonschema:"Application port that the Dapr sidecar communicates with. This is the port your application listens on."`
	// Protocol used for Dapr-to-app communication.
	//  "http": HTTP/1.1 (default).
	//  "grpc": gRPC (for gRPC-based applications).
	//
	//  Default: "http"
	AppProtocol string `json:"app_protocol,omitempty" jsonschema:"Protocol used for Dapr-to-app communication. 'http': HTTP/1.1 (default). 'grpc': gRPC (for gRPC-based applications). Default: 'http'"`
}

func (s *AzureContainerAppDaprInput) validate() error {
	if s.AppId == "" {
		return fmt.Errorf("app_id is required")
	}
	return nil
}

func (s *AzureContainerAppDaprInput) applyDefaults() {
	if s.AppProtocol == "" {
		s.AppProtocol = "http"
	}
}

func (s *AzureContainerAppDaprInput) toMap() map[string]any {
	m := make(map[string]any)
	m["app_id"] = s.AppId
	if s.AppPort != 0 {
		m["app_port"] = s.AppPort
	}
	if s.AppProtocol != "" {
		m["app_protocol"] = s.AppProtocol
	}
	return m
}

// AzureContainerAppEnvVar defines an environment variable for a container.
//
//	An env var is either a literal value or a reference to a secret by name.
//	When `secret_name` is set, `value` is ignored and the env var's value
//	comes from the named secret in the app's `secrets` list.
type AzureContainerAppEnvVarInput struct {
	// Environment variable name.
	Name string `json:"name" jsonschema:"required,Environment variable name."`
	// Literal value. Ignored when secret_name is set.
	Value string `json:"value,omitempty" jsonschema:"Literal value. Ignored when secret_name is set."`
	// Reference to a secret name defined in the app's `secrets` list.
	//  When set, the env var's value comes from the secret.
	SecretName string `json:"secret_name,omitempty" jsonschema:"Reference to a secret name defined in the app's 'secrets' list. When set; the env var's value comes from the secret."`
}

func (s *AzureContainerAppEnvVarInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureContainerAppEnvVarInput) applyDefaults() {
}

func (s *AzureContainerAppEnvVarInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.SecretName != "" {
		m["secret_name"] = s.SecretName
	}
	return m
}

// AzureContainerAppHttpScaleRule scales the app based on concurrent HTTP requests.
//
//	This is the most common scale rule for web services and APIs.
//	When concurrent requests exceed the threshold, the app scales up.
type AzureContainerAppHttpScaleRuleInput struct {
	// Rule name. Must be unique within the app's scale rules.
	Name string `json:"name" jsonschema:"required,Rule name. Must be unique within the app's scale rules."`
	// Number of concurrent HTTP requests that triggers scaling.
	//  Must be a positive integer as a string (KEDA convention).
	//
	//  Example: "100" means scale up when more than 100 concurrent requests per replica.
	ConcurrentRequests string `json:"concurrent_requests" jsonschema:"required,Number of concurrent HTTP requests that triggers scaling. Must be a positive integer as a string (KEDA convention). Example: '100' means scale up when more than 100 concurrent requests per replica."`
	// Authentication configuration for the scale rule.
	//  References secrets for KEDA scaler authentication.
	Authentication []*AzureContainerAppScaleRuleAuthInput `json:"authentication,omitempty" jsonschema:"Authentication configuration for the scale rule. References secrets for KEDA scaler authentication."`
}

func (s *AzureContainerAppHttpScaleRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ConcurrentRequests == "" {
		return fmt.Errorf("concurrent_requests is required")
	}
	for i, v := range s.Authentication {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("authentication[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppHttpScaleRuleInput) applyDefaults() {
}

func (s *AzureContainerAppHttpScaleRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["concurrent_requests"] = s.ConcurrentRequests
	if len(s.Authentication) > 0 {
		items := make([]any, len(s.Authentication))
		for i, v := range s.Authentication {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["authentication"] = items
	}
	return m
}

// AzureContainerAppIdentity configures managed identity for the app.
//
//	Managed identities allow the app to authenticate with Azure services
//	(Key Vault, ACR, Storage, etc.) without managing credentials.
//
//	Types:
//	- SystemAssigned: Azure creates and manages an identity tied to this app.
//	  Simplest option. The identity is deleted when the app is deleted.
//	- UserAssigned: References pre-created identities. Can be shared across
//	  multiple apps and has an independent lifecycle.
//	- SystemAssigned,UserAssigned: Both types simultaneously.
type AzureContainerAppIdentityInput struct {
	// Identity type.
	//  "SystemAssigned": Azure-managed identity.
	//  "UserAssigned": Pre-created identity.
	//  "SystemAssigned,UserAssigned": Both.
	Type string `json:"type" jsonschema:"required,Identity type. 'SystemAssigned': Azure-managed identity. 'UserAssigned': Pre-created identity. 'SystemAssigned;UserAssigned': Both."`
	// User Assigned Identity Azure resource IDs.
	//  Required when type includes "UserAssigned".
	//
	//  Can be literal ARM resource IDs or references to AzureUserAssignedIdentity outputs.
	IdentityIds []string `json:"identity_ids,omitempty" jsonschema:"User Assigned Identity Azure resource IDs. Required when type includes 'UserAssigned'. Can be literal ARM resource IDs or references to AzureUserAssignedIdentity outputs."`
}

func (s *AzureContainerAppIdentityInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *AzureContainerAppIdentityInput) applyDefaults() {
}

func (s *AzureContainerAppIdentityInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if len(s.IdentityIds) > 0 {
		m["identity_ids"] = s.IdentityIds
	}
	return m
}

// AzureContainerAppIngress defines HTTP/TCP ingress for the app.
//
//	When ingress is configured, the app gets a FQDN and can receive traffic.
//	Without ingress, the app is only accessible from within the environment
//	via service discovery (the app name).
//
//	Features:
//	- External or internal (environment-only) access
//	- HTTP/HTTP2/TCP transport
//	- Traffic splitting across revisions
//	- IP security restrictions (allow/deny)
//	- CORS policy for browser-based clients
//	- Client certificate mode (mTLS)
type AzureContainerAppIngressInput struct {
	// Whether the app is accessible from outside the environment.
	//
	//  true: App is accessible from the internet (or VNet if environment is internal).
	//  false: App is only accessible from within the environment.
	//
	//  Default: false
	ExternalEnabled bool `json:"external_enabled,omitempty" jsonschema:"Whether the app is accessible from outside the environment. true: App is accessible from the internet (or VNet if environment is internal). false: App is only accessible from within the environment. D..."`
	// Target port on the container to route traffic to. Range: 1-65535.
	TargetPort int32 `json:"target_port,omitempty" jsonschema:"Target port on the container to route traffic to. Range: 1-65535."`
	// Exposed port for TCP transport. Range: 1-65535.
	//  Only applicable when transport is "tcp".
	ExposedPort int32 `json:"exposed_port,omitempty" jsonschema:"Exposed port for TCP transport. Range: 1-65535. Only applicable when transport is 'tcp'."`
	// Transport protocol.
	//  "auto": Auto-detect (default, tries HTTP then TCP).
	//  "http": HTTP/1.1.
	//  "http2": HTTP/2 (for gRPC and long-running connections).
	//  "tcp": Raw TCP (requires exposed_port).
	//
	//  Default: "auto"
	Transport string `json:"transport,omitempty" jsonschema:"Transport protocol. 'auto': Auto-detect (default; tries HTTP then TCP). 'http': HTTP/1.1. 'http2': HTTP/2 (for gRPC and long-running connections). 'tcp': Raw TCP (requires exposed_port). Default: 'aut..."`
	// Allow insecure (HTTP) connections. When false, only HTTPS is accepted
	//  and HTTP requests are redirected to HTTPS.
	//
	//  Default: false (HTTPS only)
	AllowInsecureConnections bool `json:"allow_insecure_connections,omitempty" jsonschema:"Allow insecure (HTTP) connections. When false; only HTTPS is accepted and HTTP requests are redirected to HTTPS. Default: false (HTTPS only)"`
	// Client certificate mode for mTLS.
	//  "Accept": Accept client certificates but don't require them.
	//  "Require": Require client certificates for all requests.
	//  "Ignore": Ignore client certificates entirely.
	//
	//  Omit to use Azure's default behavior (no client certificate requirement).
	ClientCertificateMode string `json:"client_certificate_mode,omitempty" jsonschema:"Client certificate mode for mTLS. 'Accept': Accept client certificates but don't require them. 'Require': Require client certificates for all requests. 'Ignore': Ignore client certificates entirely. O..."`
	// Traffic weight distribution across revisions.
	//  At least one traffic weight is required when ingress is configured.
	//
	//  For Single revision mode, typically one weight with latest_revision=true
	//  and percentage=100. For Multiple revision mode, weights split traffic
	//  across named revisions.
	//
	//  Total percen...
	TrafficWeight []*AzureContainerAppTrafficWeightInput `json:"traffic_weight,omitempty" jsonschema:"Traffic weight distribution across revisions. At least one traffic weight is required when ingress is configured. For Single revision mode; typically one weight with latest_revision=true and percentag..."`
	// IP security restrictions. Allow or deny traffic from specific IP ranges.
	//  Rules are evaluated in order.
	IpSecurityRestrictions []*AzureContainerAppIpSecurityRestrictionInput `json:"ip_security_restrictions,omitempty" jsonschema:"IP security restrictions. Allow or deny traffic from specific IP ranges. Rules are evaluated in order."`
	// CORS policy for browser-based clients.
	CorsPolicy *AzureContainerAppCorsPolicyInput `json:"cors_policy,omitempty" jsonschema:"CORS policy for browser-based clients."`
}

func (s *AzureContainerAppIngressInput) validate() error {
	if len(s.TrafficWeight) < 1 {
		return fmt.Errorf("traffic_weight requires at least 1 items, got %d", len(s.TrafficWeight))
	}
	for i, v := range s.TrafficWeight {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("traffic_weight[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.IpSecurityRestrictions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ip_security_restrictions[%d]: %w", i, err)
			}
		}
	}
	if s.CorsPolicy != nil {
		if err := s.CorsPolicy.validate(); err != nil {
			return fmt.Errorf("cors_policy: %w", err)
		}
	}
	return nil
}

func (s *AzureContainerAppIngressInput) applyDefaults() {
	if s.Transport == "" {
		s.Transport = "auto"
	}
	if s.CorsPolicy != nil {
		s.CorsPolicy.applyDefaults()
	}
}

func (s *AzureContainerAppIngressInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ExternalEnabled {
		m["external_enabled"] = s.ExternalEnabled
	}
	if s.TargetPort != 0 {
		m["target_port"] = s.TargetPort
	}
	if s.ExposedPort != 0 {
		m["exposed_port"] = s.ExposedPort
	}
	if s.Transport != "" {
		m["transport"] = s.Transport
	}
	if s.AllowInsecureConnections {
		m["allow_insecure_connections"] = s.AllowInsecureConnections
	}
	if s.ClientCertificateMode != "" {
		m["client_certificate_mode"] = s.ClientCertificateMode
	}
	if len(s.TrafficWeight) > 0 {
		items := make([]any, len(s.TrafficWeight))
		for i, v := range s.TrafficWeight {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["traffic_weight"] = items
	}
	if len(s.IpSecurityRestrictions) > 0 {
		items := make([]any, len(s.IpSecurityRestrictions))
		for i, v := range s.IpSecurityRestrictions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ip_security_restrictions"] = items
	}
	if s.CorsPolicy != nil {
		m["cors_policy"] = s.CorsPolicy.toMap()
	}
	return m
}

// AzureContainerAppInitContainer defines an init container that runs
//
//	to completion before main containers start.
//
//	Use cases: database migrations, configuration generation, downloading
//	assets, waiting for dependencies to become available.
//
//	Init containers share the same volume mounts and secrets as main containers
//	but cannot have health probes. CPU and memory are optional -- when omitted,
//	init containers inherit the resource allocation of the app.
type AzureContainerAppInitContainerInput struct {
	// Container name. Must be unique within the app (across both containers
	//  and init containers).
	Name string `json:"name" jsonschema:"required,Container name. Must be unique within the app (across both containers and init containers)."`
	// Container image in repository:tag format.
	Image string `json:"image" jsonschema:"required,Container image in repository:tag format."`
	// CPU allocation in vCPU cores. Optional for init containers.
	//  When omitted, inherits from the app's overall resource allocation.
	Cpu float64 `json:"cpu,omitempty" jsonschema:"CPU allocation in vCPU cores. Optional for init containers. When omitted; inherits from the app's overall resource allocation."`
	// Memory allocation in Gi format. Optional for init containers.
	//  When omitted, inherits from the app's overall resource allocation.
	Memory string `json:"memory,omitempty" jsonschema:"Memory allocation in Gi format. Optional for init containers. When omitted; inherits from the app's overall resource allocation."`
	// Environment variables for the init container.
	Env []*AzureContainerAppEnvVarInput `json:"env,omitempty" jsonschema:"Environment variables for the init container."`
	// Container command (entrypoint override).
	Command []string `json:"command,omitempty" jsonschema:"Container command (entrypoint override)."`
	// Container arguments.
	Args []string `json:"args,omitempty" jsonschema:"Container arguments."`
	// Volume mounts for the init container.
	VolumeMounts []*AzureContainerAppVolumeMountInput `json:"volume_mounts,omitempty" jsonschema:"Volume mounts for the init container."`
}

func (s *AzureContainerAppInitContainerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	for i, v := range s.Env {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("env[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.VolumeMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("volume_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppInitContainerInput) applyDefaults() {
}

func (s *AzureContainerAppInitContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["image"] = s.Image
	if s.Cpu != 0 {
		m["cpu"] = s.Cpu
	}
	if s.Memory != "" {
		m["memory"] = s.Memory
	}
	if len(s.Env) > 0 {
		items := make([]any, len(s.Env))
		for i, v := range s.Env {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["env"] = items
	}
	if len(s.Command) > 0 {
		m["command"] = s.Command
	}
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	if len(s.VolumeMounts) > 0 {
		items := make([]any, len(s.VolumeMounts))
		for i, v := range s.VolumeMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["volume_mounts"] = items
	}
	return m
}

// AzureContainerAppIpSecurityRestriction defines an IP allow/deny rule for ingress.
type AzureContainerAppIpSecurityRestrictionInput struct {
	// Rule name.
	Name string `json:"name" jsonschema:"required,Rule name."`
	// Action to take for matching traffic.
	//  "Allow": Permit traffic from the IP range.
	//  "Deny": Block traffic from the IP range.
	Action string `json:"action" jsonschema:"required,Action to take for matching traffic. 'Allow': Permit traffic from the IP range. 'Deny': Block traffic from the IP range."`
	// IP address or CIDR range.
	//  Examples: "203.0.113.0/24", "10.0.0.1"
	IpAddressRange string `json:"ip_address_range" jsonschema:"required,IP address or CIDR range. Examples: '203.0.113.0/24'; '10.0.0.1'"`
	// Optional description of the rule.
	Description string `json:"description,omitempty" jsonschema:"Optional description of the rule."`
}

func (s *AzureContainerAppIpSecurityRestrictionInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Action == "" {
		return fmt.Errorf("action is required")
	}
	if s.IpAddressRange == "" {
		return fmt.Errorf("ip_address_range is required")
	}
	return nil
}

func (s *AzureContainerAppIpSecurityRestrictionInput) applyDefaults() {
}

func (s *AzureContainerAppIpSecurityRestrictionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["action"] = s.Action
	m["ip_address_range"] = s.IpAddressRange
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// AzureContainerAppProbe defines a health probe for a container.
//
//	Probes support three transport types:
//	- TCP: Simple port check (container is alive if port accepts connections)
//	- HTTP: GET request to a path (healthy if response is 200-399)
//	- HTTPS: Same as HTTP but over TLS
//
//	This message is shared by liveness, readiness, and startup probes.
//	The `success_count_threshold` field is only applicable to readiness probes.
type AzureContainerAppProbeInput struct {
	// Probe transport type.
	//  "TCP": Port connectivity check.
	//  "HTTP": HTTP GET request.
	//  "HTTPS": HTTPS GET request.
	Transport string `json:"transport" jsonschema:"required,Probe transport type. 'TCP': Port connectivity check. 'HTTP': HTTP GET request. 'HTTPS': HTTPS GET request."`
	// Port to probe. Range: 1-65535.
	Port int32 `json:"port,omitempty" jsonschema:"Port to probe. Range: 1-65535."`
	// URI path for HTTP/HTTPS probes. Ignored for TCP probes.
	//  Example: "/healthz", "/ready"
	Path string `json:"path,omitempty" jsonschema:"URI path for HTTP/HTTPS probes. Ignored for TCP probes. Example: '/healthz'; '/ready'"`
	// Hostname for the probe request. When omitted, defaults to the container IP.
	Host string `json:"host,omitempty" jsonschema:"Hostname for the probe request. When omitted; defaults to the container IP."`
	// HTTP headers to include in probe requests. Only for HTTP/HTTPS probes.
	Headers []*AzureContainerAppProbeHeaderInput `json:"headers,omitempty" jsonschema:"HTTP headers to include in probe requests. Only for HTTP/HTTPS probes."`
	// Seconds to wait before starting probes after container start.
	//
	//  Default: 0 (readiness/startup), 1 (liveness)
	//  Range: 0-60
	InitialDelayInSeconds int32 `json:"initial_delay_in_seconds,omitempty" jsonschema:"Seconds to wait before starting probes after container start. Default: 0 (readiness/startup); 1 (liveness) Range: 0-60"`
	// Seconds between probe executions.
	//
	//  Default: 10
	//  Range: 1-240
	IntervalSeconds int32 `json:"interval_seconds,omitempty" jsonschema:"Seconds between probe executions. Default: 10 Range: 1-240"`
	// Seconds to wait for a probe response before timing out.
	//
	//  Default: 1
	//  Range: 1-240
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Seconds to wait for a probe response before timing out. Default: 1 Range: 1-240"`
	// Number of consecutive failures before the probe is considered failed.
	//
	//  Default: 3
	//  Range: 1-30
	FailureCountThreshold int32 `json:"failure_count_threshold,omitempty" jsonschema:"Number of consecutive failures before the probe is considered failed. Default: 3 Range: 1-30"`
	// Number of consecutive successes before the probe is considered successful.
	//  Only applicable to readiness probes; ignored for liveness and startup.
	//
	//  Default: 3
	//  Range: 1-10
	SuccessCountThreshold int32 `json:"success_count_threshold,omitempty" jsonschema:"Number of consecutive successes before the probe is considered successful. Only applicable to readiness probes; ignored for liveness and startup. Default: 3 Range: 1-10"`
}

func (s *AzureContainerAppProbeInput) validate() error {
	if s.Transport == "" {
		return fmt.Errorf("transport is required")
	}
	for i, v := range s.Headers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("headers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppProbeInput) applyDefaults() {
	if s.InitialDelayInSeconds == 0 {
		s.InitialDelayInSeconds = 0
	}
	if s.IntervalSeconds == 0 {
		s.IntervalSeconds = 10
	}
	if s.TimeoutSeconds == 0 {
		s.TimeoutSeconds = 1
	}
	if s.FailureCountThreshold == 0 {
		s.FailureCountThreshold = 3
	}
	if s.SuccessCountThreshold == 0 {
		s.SuccessCountThreshold = 3
	}
}

func (s *AzureContainerAppProbeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["transport"] = s.Transport
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Host != "" {
		m["host"] = s.Host
	}
	if len(s.Headers) > 0 {
		items := make([]any, len(s.Headers))
		for i, v := range s.Headers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["headers"] = items
	}
	if s.InitialDelayInSeconds != 0 {
		m["initial_delay_in_seconds"] = s.InitialDelayInSeconds
	}
	if s.IntervalSeconds != 0 {
		m["interval_seconds"] = s.IntervalSeconds
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.FailureCountThreshold != 0 {
		m["failure_count_threshold"] = s.FailureCountThreshold
	}
	if s.SuccessCountThreshold != 0 {
		m["success_count_threshold"] = s.SuccessCountThreshold
	}
	return m
}

// AzureContainerAppProbeHeader defines an HTTP header to include in a probe request.
type AzureContainerAppProbeHeaderInput struct {
	// Header name.
	Name string `json:"name" jsonschema:"required,Header name."`
	// Header value.
	Value string `json:"value" jsonschema:"required,Header value."`
}

func (s *AzureContainerAppProbeHeaderInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AzureContainerAppProbeHeaderInput) applyDefaults() {
}

func (s *AzureContainerAppProbeHeaderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	return m
}

// AzureContainerAppRegistry defines credentials for a private container registry.
//
//	Authentication modes (exactly one must be used):
//	1. Username/password: Set `username` and `password_secret_name` (references a secret).
//	2. Managed identity: Set `identity` (system-assigned or user-assigned identity ID).
type AzureContainerAppRegistryInput struct {
	// Registry server hostname.
	//  Examples: "myregistry.azurecr.io", "ghcr.io", "docker.io"
	Server string `json:"server" jsonschema:"required,Registry server hostname. Examples: 'myregistry.azurecr.io'; 'ghcr.io'; 'docker.io'"`
	// Registry username. Required with password_secret_name.
	Username string `json:"username,omitempty" jsonschema:"Registry username. Required with password_secret_name."`
	// Secret name containing the registry password.
	//  Must reference a secret defined in the app's `secrets` list.
	//  Required with username.
	PasswordSecretName string `json:"password_secret_name,omitempty" jsonschema:"Secret name containing the registry password. Must reference a secret defined in the app's 'secrets' list. Required with username."`
	// Managed identity for registry authentication.
	//  Value is either "System" (system-assigned) or a User Assigned Identity
	//  Azure resource ID. Alternative to username/password.
	Identity string `json:"identity,omitempty" jsonschema:"Managed identity for registry authentication. Value is either 'System' (system-assigned) or a User Assigned Identity Azure resource ID. Alternative to username/password."`
}

func (s *AzureContainerAppRegistryInput) validate() error {
	if s.Server == "" {
		return fmt.Errorf("server is required")
	}
	return nil
}

func (s *AzureContainerAppRegistryInput) applyDefaults() {
}

func (s *AzureContainerAppRegistryInput) toMap() map[string]any {
	m := make(map[string]any)
	m["server"] = s.Server
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.PasswordSecretName != "" {
		m["password_secret_name"] = s.PasswordSecretName
	}
	if s.Identity != "" {
		m["identity"] = s.Identity
	}
	return m
}

// AzureContainerAppScaleRuleAuth provides authentication for a scale rule.
//
//	References a secret by name and maps it to a scaler-specific trigger parameter.
type AzureContainerAppScaleRuleAuthInput struct {
	// Name of the secret in the app's `secrets` list.
	SecretName string `json:"secret_name" jsonschema:"required,Name of the secret in the app's 'secrets' list."`
	// Scaler-specific trigger parameter name that this secret maps to.
	//  The parameter name depends on the scale rule type.
	//
	//  Examples:
	//  - Azure Queue: "connection"
	//  - Kafka: "sasl" or "tls"
	//  - Custom: varies by scaler
	TriggerParameter string `json:"trigger_parameter" jsonschema:"required,Scaler-specific trigger parameter name that this secret maps to. The parameter name depends on the scale rule type. Examples: - Azure Queue: 'connection' - Kafka: 'sasl' or 'tls' - Custom: varies by s..."`
}

func (s *AzureContainerAppScaleRuleAuthInput) validate() error {
	if s.SecretName == "" {
		return fmt.Errorf("secret_name is required")
	}
	if s.TriggerParameter == "" {
		return fmt.Errorf("trigger_parameter is required")
	}
	return nil
}

func (s *AzureContainerAppScaleRuleAuthInput) applyDefaults() {
}

func (s *AzureContainerAppScaleRuleAuthInput) toMap() map[string]any {
	m := make(map[string]any)
	m["secret_name"] = s.SecretName
	m["trigger_parameter"] = s.TriggerParameter
	return m
}

// AzureContainerAppSecret defines a secret available to the app.
//
//	Secrets can be:
//	1. Plain-text value: Set `value` directly. Simple but less secure.
//	2. Key Vault reference: Set `key_vault_secret_id` + `identity`.
//	   The identity must have read access to the Key Vault secret.
//
//	Secrets are referenced by name in:
//	- Container env vars (via secret_name)
//	- Registry credentials (via password_secret_name)
//	- Scale rule authentication (via secret_name)
type AzureContainerAppSecretInput struct {
	// Secret name. Lowercase alphanumeric or hyphens, max 253 characters.
	//  This name is used to reference the secret elsewhere in the spec.
	Name string `json:"name" jsonschema:"required,Secret name. Lowercase alphanumeric or hyphens; max 253 characters. This name is used to reference the secret elsewhere in the spec."`
	// Plain-text secret value. Mutually exclusive with key_vault_secret_id.
	Value string `json:"value,omitempty" jsonschema:"Plain-text secret value. Mutually exclusive with key_vault_secret_id."`
	// Key Vault secret URI. Format:
	//  https://{vault-name}.vault.azure.net/secrets/{secret-name}
	//  or with version: https://{vault-name}.vault.azure.net/secrets/{secret-name}/{version}
	//
	//  Requires `identity` to be set for Key Vault access.
	//  Mutually exclusive with `value`.
	KeyVaultSecretId string `json:"key_vault_secret_id,omitempty" jsonschema:"Key Vault secret URI. Format: https://{vault-name}.vault.azure.net/secrets/{secret-name} or with version: https://{vault-name}.vault.azure.net/secrets/{secret-name}/{version} Requires 'identity' to be..."`
	// Identity for Key Vault access. Required when key_vault_secret_id is set.
	//
	//  Value is either:
	//  - "System": Use the app's system-assigned managed identity
	//  - A User Assigned Identity Azure resource ID
	Identity string `json:"identity,omitempty" jsonschema:"Identity for Key Vault access. Required when key_vault_secret_id is set. Value is either: - 'System': Use the app's system-assigned managed identity - A User Assigned Identity Azure resource ID"`
}

func (s *AzureContainerAppSecretInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureContainerAppSecretInput) applyDefaults() {
}

func (s *AzureContainerAppSecretInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.KeyVaultSecretId != "" {
		m["key_vault_secret_id"] = s.KeyVaultSecretId
	}
	if s.Identity != "" {
		m["identity"] = s.Identity
	}
	return m
}

// AzureContainerAppTcpScaleRule scales the app based on concurrent TCP connections.
type AzureContainerAppTcpScaleRuleInput struct {
	// Rule name.
	Name string `json:"name" jsonschema:"required,Rule name."`
	// Number of concurrent TCP connections that triggers scaling.
	//  Must be a positive integer as a string.
	ConcurrentRequests string `json:"concurrent_requests" jsonschema:"required,Number of concurrent TCP connections that triggers scaling. Must be a positive integer as a string."`
	// Authentication configuration for the scale rule.
	Authentication []*AzureContainerAppScaleRuleAuthInput `json:"authentication,omitempty" jsonschema:"Authentication configuration for the scale rule."`
}

func (s *AzureContainerAppTcpScaleRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ConcurrentRequests == "" {
		return fmt.Errorf("concurrent_requests is required")
	}
	for i, v := range s.Authentication {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("authentication[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppTcpScaleRuleInput) applyDefaults() {
}

func (s *AzureContainerAppTcpScaleRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["concurrent_requests"] = s.ConcurrentRequests
	if len(s.Authentication) > 0 {
		items := make([]any, len(s.Authentication))
		for i, v := range s.Authentication {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["authentication"] = items
	}
	return m
}

// AzureContainerAppTrafficWeight defines how traffic is distributed across revisions.
//
//	Either `latest_revision` must be true OR `revision_suffix` must be set.
//	For Single revision mode, use latest_revision=true with percentage=100.
type AzureContainerAppTrafficWeightInput struct {
	// Route traffic to the latest revision.
	//  When true, revision_suffix is ignored and traffic goes to the latest active revision.
	LatestRevision bool `json:"latest_revision,omitempty" jsonschema:"Route traffic to the latest revision. When true; revision_suffix is ignored and traffic goes to the latest active revision."`
	// Target a specific revision by suffix.
	//  The full revision name is "{app-name}--{revision_suffix}".
	//  Required when latest_revision is false.
	RevisionSuffix string `json:"revision_suffix,omitempty" jsonschema:"Target a specific revision by suffix. The full revision name is '{app-name}--{revision_suffix}'. Required when latest_revision is false."`
	// Percentage of traffic to route to this revision.
	//  All weights must sum to 100. Range: 0-100.
	Percentage int32 `json:"percentage,omitempty" jsonschema:"Percentage of traffic to route to this revision. All weights must sum to 100. Range: 0-100."`
	// Optional label prefix for this traffic weight.
	//  When set, the revision gets an additional FQDN: {label}.{app-fqdn}
	Label string `json:"label,omitempty" jsonschema:"Optional label prefix for this traffic weight. When set; the revision gets an additional FQDN: {label}.{app-fqdn}"`
}

func (s *AzureContainerAppTrafficWeightInput) validate() error {
	return nil
}

func (s *AzureContainerAppTrafficWeightInput) applyDefaults() {
}

func (s *AzureContainerAppTrafficWeightInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.LatestRevision {
		m["latest_revision"] = s.LatestRevision
	}
	if s.RevisionSuffix != "" {
		m["revision_suffix"] = s.RevisionSuffix
	}
	if s.Percentage != 0 {
		m["percentage"] = s.Percentage
	}
	if s.Label != "" {
		m["label"] = s.Label
	}
	return m
}

// AzureContainerAppVolume defines a volume available to containers.
//
//	Supported storage types:
//	- EmptyDir (default): Ephemeral storage, fast, lost when the replica terminates.
//	  Good for scratch space, caching, temporary files.
//	- AzureFile: Persistent Azure Files share. Survives replica restarts.
//	  Requires a storage resource configured in the Container App Environment.
type AzureContainerAppVolumeInput struct {
	// Volume name. Referenced by containers in their volume_mounts field.
	Name string `json:"name" jsonschema:"required,Volume name. Referenced by containers in their volume_mounts field."`
	// Storage type. "EmptyDir" for ephemeral storage, "AzureFile" for persistent.
	//
	//  Default: "EmptyDir"
	StorageType string `json:"storage_type,omitempty" jsonschema:"Storage type. 'EmptyDir' for ephemeral storage; 'AzureFile' for persistent. Default: 'EmptyDir'"`
	// Name of the Container App Environment storage resource.
	//  Required when storage_type is "AzureFile".
	//  References a storage resource created via azurerm_container_app_environment_storage.
	StorageName string `json:"storage_name,omitempty" jsonschema:"Name of the Container App Environment storage resource. Required when storage_type is 'AzureFile'. References a storage resource created via azurerm_container_app_environment_storage."`
	// Comma-separated mount options for the volume.
	//  Example: "uid=1000,gid=1000"
	MountOptions string `json:"mount_options,omitempty" jsonschema:"Comma-separated mount options for the volume. Example: 'uid=1000;gid=1000'"`
}

func (s *AzureContainerAppVolumeInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureContainerAppVolumeInput) applyDefaults() {
	if s.StorageType == "" {
		s.StorageType = "EmptyDir"
	}
}

func (s *AzureContainerAppVolumeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.StorageName != "" {
		m["storage_name"] = s.StorageName
	}
	if s.MountOptions != "" {
		m["mount_options"] = s.MountOptions
	}
	return m
}

// AzureContainerAppVolumeMount mounts a volume into a container at a specified path.
type AzureContainerAppVolumeMountInput struct {
	// Name of the volume to mount. Must match a volume name in the spec's `volumes` field.
	Name string `json:"name" jsonschema:"required,Name of the volume to mount. Must match a volume name in the spec's 'volumes' field."`
	// Absolute path inside the container where the volume is mounted.
	//  Example: "/data", "/mnt/config"
	Path string `json:"path" jsonschema:"required,Absolute path inside the container where the volume is mounted. Example: '/data'; '/mnt/config'"`
	// Sub-path within the volume to mount. When omitted, the entire volume is mounted.
	SubPath string `json:"sub_path,omitempty" jsonschema:"Sub-path within the volume to mount. When omitted; the entire volume is mounted."`
}

func (s *AzureContainerAppVolumeMountInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

func (s *AzureContainerAppVolumeMountInput) applyDefaults() {
}

func (s *AzureContainerAppVolumeMountInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["path"] = s.Path
	if s.SubPath != "" {
		m["sub_path"] = s.SubPath
	}
	return m
}

// ParseAzureContainerApp validates and normalizes a AzureContainerApp cloud_object.
func ParseAzureContainerApp(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureContainerApp"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureContainerAppSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
