// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureNetworkSecurityGroup is the top-level API resource for an Azure Network
//
//	Security Group. NSGs provide stateful packet filtering for Azure resources,
//	controlling inbound and outbound traffic with priority-ordered security rules.
type AzureNetworkSecurityGroupSpecInput struct {
	// The Azure region where the NSG will be created.
	//  Must match the region of the resources it will be associated with (subnets, NICs).
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the NSG will be created. Must match the region of the resources it will be associated with (subnets; NICs). Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the NSG will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the NSG will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Network Security Group.
	//  Must be unique within the resource group.
	//  Allowed characters: alphanumeric, underscores, hyphens, and periods.
	//  Must start with alphanumeric. Length: 1 to 80 characters.
	Name string `json:"name" jsonschema:"required,The name of the Network Security Group. Must be unique within the resource group. Allowed characters: alphanumeric; underscores; hyphens; and periods. Must start with alphanumeric. Length: 1 to 80 cha..."`
	// Security rules that define allowed or denied traffic flows.
	//  Each rule specifies a 5-tuple filter (source, destination, port, protocol, direction)
	//  combined with an access decision (Allow/Deny) and a priority for ordering.
	//
	//  Rules are evaluated in priority order (lowest number = highest priority).
	//  ...
	SecurityRules []*AzureSecurityRuleInput `json:"security_rules,omitempty" jsonschema:"Security rules that define allowed or denied traffic flows. Each rule specifies a 5-tuple filter (source; destination; port; protocol; direction) combined with an access decision (Allow/Deny) and a pr..."`
}

func (s *AzureNetworkSecurityGroupSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.SecurityRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("security_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureNetworkSecurityGroupSpecInput) applyDefaults() {
}

func (s *AzureNetworkSecurityGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if len(s.SecurityRules) > 0 {
		items := make([]any, len(s.SecurityRules))
		for i, v := range s.SecurityRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["security_rules"] = items
	}
	return m
}

// AzureSecurityRule defines a single network security rule within the NSG.
//
//	Each rule is a 5-tuple filter combined with an access decision and priority.
//
//	Rules are evaluated in priority order within their direction (Inbound or Outbound).
//	Lower priority numbers are evaluated first. The first matching rule wins.
type AzureSecurityRuleInput struct {
	// A user-chosen name for this rule.
	//  Must be unique within the NSG. Used for identification in Azure Portal, CLI,
	//  and IaC state. Use descriptive names like "allow-https-inbound" or "deny-all-outbound".
	Name string `json:"name" jsonschema:"required,A user-chosen name for this rule. Must be unique within the NSG. Used for identification in Azure Portal; CLI; and IaC state. Use descriptive names like 'allow-https-inbound' or 'deny-all-outbound'."`
	// Optional human-readable description of the rule's purpose.
	//  Useful for documenting intent (e.g., "Allow HTTPS from corporate VPN range").
	//  Maximum 140 characters.
	Description string `json:"description,omitempty" jsonschema:"Optional human-readable description of the rule's purpose. Useful for documenting intent (e.g.; 'Allow HTTPS from corporate VPN range'). Maximum 140 characters."`
	// The evaluation priority of this rule. Lower numbers are evaluated first.
	//  Range: 100 to 4096 (inclusive).
	//  Azure reserves priorities 65000-65500 for implicit default rules.
	//
	//  Best practice: Use increments of 10 or 100 (e.g., 100, 200, 300) to leave
	//  room for inserting rules later without renumbering...
	Priority int32 `json:"priority" jsonschema:"required,The evaluation priority of this rule. Lower numbers are evaluated first. Range: 100 to 4096 (inclusive). Azure reserves priorities 65000-65500 for implicit default rules. Best practice: Use increments..."`
	// The traffic direction this rule applies to.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "Inbound" -- traffic entering the resource (from external to internal)
	//  - "Outbound" -- traffic leaving the resource (from internal to external)
	Direction string `json:"direction" jsonschema:"required,The traffic direction this rule applies to. Uses Azure's exact API values for provider authenticity. Valid values: - 'Inbound' -- traffic entering the resource (from external to internal) - 'Outbound'..."`
	// The access decision when this rule matches.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Allow" -- permit matching traffic
	//  - "Deny" -- block matching traffic
	Access string `json:"access" jsonschema:"required,The access decision when this rule matches. Uses Azure's exact API values. Valid values: - 'Allow' -- permit matching traffic - 'Deny' -- block matching traffic"`
	// The network protocol this rule matches.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Tcp" -- TCP traffic
	//  - "Udp" -- UDP traffic
	//  - "Icmp" -- ICMP traffic (ping, traceroute)
	//  - "*" -- any protocol
	Protocol string `json:"protocol" jsonschema:"required,The network protocol this rule matches. Uses Azure's exact API values. Valid values: - 'Tcp' -- TCP traffic - 'Udp' -- UDP traffic - 'Icmp' -- ICMP traffic (ping; traceroute) - '*' -- any protocol"`
	// The source port or port range for this rule.
	//  Accepts a single port ("443"), a range ("1024-65535"), or "*" for any port.
	//  Most rules use "*" for source port since source ports are typically ephemeral.
	//  Default: "*"
	SourcePortRange string `json:"source_port_range,omitempty" jsonschema:"The source port or port range for this rule. Accepts a single port ('443'); a range ('1024-65535'); or '*' for any port. Most rules use '*' for source port since source ports are typically ephemeral. ..."`
	// The destination port or port range for this rule.
	//  Accepts a single port ("443"), a range ("1024-65535"), or "*" for any port.
	//  This is the field that typically defines what service the rule targets.
	//  Examples: "22" (SSH), "80" (HTTP), "443" (HTTPS), "3306" (MySQL), "5432" (PostgreSQL).
	DestinationPortRange string `json:"destination_port_range" jsonschema:"required,The destination port or port range for this rule. Accepts a single port ('443'); a range ('1024-65535'); or '*' for any port. This is the field that typically defines what service the rule targets. Ex..."`
	// The source address prefix for this rule.
	//  Accepts a CIDR ("10.0.0.0/8"), a single IP ("10.0.0.1"), an Azure service tag
	//  ("VirtualNetwork", "AzureLoadBalancer", "Internet"), or "*" for any source.
	//  Default: "*"
	//
	//  If source_address_prefixes (plural) is also set, the plural field takes precedence
	//  and...
	SourceAddressPrefix string `json:"source_address_prefix,omitempty" jsonschema:"The source address prefix for this rule. Accepts a CIDR ('10.0.0.0/8'); a single IP ('10.0.0.1'); an Azure service tag ('VirtualNetwork'; 'AzureLoadBalancer'; 'Internet'); or '*' for any source. Defau..."`
	// The destination address prefix for this rule.
	//  Accepts a CIDR ("10.0.1.0/24"), a single IP, an Azure service tag
	//  ("VirtualNetwork", "AzureLoadBalancer", "Internet"), or "*" for any destination.
	//  Default: "*"
	//
	//  If destination_address_prefixes (plural) is also set, the plural field takes
	//  precedence ...
	DestinationAddressPrefix string `json:"destination_address_prefix,omitempty" jsonschema:"The destination address prefix for this rule. Accepts a CIDR ('10.0.1.0/24'); a single IP; an Azure service tag ('VirtualNetwork'; 'AzureLoadBalancer'; 'Internet'); or '*' for any destination. Default..."`
	// Optional list of source address prefixes (CIDRs or IPs).
	//  Use this when a rule needs to allow/deny traffic from multiple non-contiguous
	//  source ranges in a single rule (e.g., multiple VPN CIDR blocks).
	//
	//  When set (non-empty), this field takes precedence over source_address_prefix.
	//  Note: Azure servi...
	SourceAddressPrefixes []string `json:"source_address_prefixes,omitempty" jsonschema:"Optional list of source address prefixes (CIDRs or IPs). Use this when a rule needs to allow/deny traffic from multiple non-contiguous source ranges in a single rule (e.g.; multiple VPN CIDR blocks). ..."`
	// Optional list of destination address prefixes (CIDRs or IPs).
	//  Use this when a rule needs to target multiple non-contiguous destination ranges.
	//
	//  When set (non-empty), this field takes precedence over destination_address_prefix.
	//  Note: Azure service tags are only supported in the singular destinatio...
	DestinationAddressPrefixes []string `json:"destination_address_prefixes,omitempty" jsonschema:"Optional list of destination address prefixes (CIDRs or IPs). Use this when a rule needs to target multiple non-contiguous destination ranges. When set (non-empty); this field takes precedence over de..."`
}

func (s *AzureSecurityRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Direction == "" {
		return fmt.Errorf("direction is required")
	}
	if s.Access == "" {
		return fmt.Errorf("access is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if s.DestinationPortRange == "" {
		return fmt.Errorf("destination_port_range is required")
	}
	return nil
}

func (s *AzureSecurityRuleInput) applyDefaults() {
	if s.SourcePortRange == "" {
		s.SourcePortRange = "*"
	}
	if s.SourceAddressPrefix == "" {
		s.SourceAddressPrefix = "*"
	}
	if s.DestinationAddressPrefix == "" {
		s.DestinationAddressPrefix = "*"
	}
}

func (s *AzureSecurityRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Description != "" {
		m["description"] = s.Description
	}
	m["priority"] = s.Priority
	m["direction"] = s.Direction
	m["access"] = s.Access
	m["protocol"] = s.Protocol
	if s.SourcePortRange != "" {
		m["source_port_range"] = s.SourcePortRange
	}
	m["destination_port_range"] = s.DestinationPortRange
	if s.SourceAddressPrefix != "" {
		m["source_address_prefix"] = s.SourceAddressPrefix
	}
	if s.DestinationAddressPrefix != "" {
		m["destination_address_prefix"] = s.DestinationAddressPrefix
	}
	if len(s.SourceAddressPrefixes) > 0 {
		m["source_address_prefixes"] = s.SourceAddressPrefixes
	}
	if len(s.DestinationAddressPrefixes) > 0 {
		m["destination_address_prefixes"] = s.DestinationAddressPrefixes
	}
	return m
}

// ParseAzureNetworkSecurityGroup validates and normalizes a AzureNetworkSecurityGroup cloud_object.
func ParseAzureNetworkSecurityGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureNetworkSecurityGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureNetworkSecurityGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
