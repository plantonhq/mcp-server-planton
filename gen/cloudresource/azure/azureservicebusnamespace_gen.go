// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureServiceBusNamespace is the top-level API resource for an Azure Service
//
//	Bus namespace. Azure Service Bus provides fully managed enterprise message
//	brokering with message queues and publish-subscribe topics for decoupling
//	applications and services.
type AzureServiceBusNamespaceSpecInput struct {
	// The Azure region where the Service Bus namespace will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the Service Bus namespace will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the Service Bus namespace will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Service Bus namespace will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Service Bus namespace.
	//  Must be globally unique across Azure. Used as the endpoint:
	//  `{name}.servicebus.windows.net`
	//
	//  Naming rules (Azure API enforced):
	//  - 6 to 50 characters
	//  - Must start with a letter
	//  - Must end with a letter or number
	//  - Can contain letters, numbers, and hyphens...
	Name string `json:"name" jsonschema:"required,The name of the Service Bus namespace. Must be globally unique across Azure. Used as the endpoint: '{name}.servicebus.windows.net' Naming rules (Azure API enforced): - 6 to 50 characters - Must start ..."`
	// The SKU tier for the Service Bus namespace.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "Basic": Queues only, no topics. Simple messaging scenarios.
	//  - "Standard" (default): Full-featured with queues and topics. Production
	//    recommended. 99.95% SLA.
	//  - "Premium": De...
	Sku string `json:"sku,omitempty" jsonschema:"The SKU tier for the Service Bus namespace. Uses Azure's exact API values for provider authenticity. Valid values: - 'Basic': Queues only; no topics. Simple messaging scenarios. - 'Standard' (default)..."`
	// Messaging units for Premium SKU.
	//  Defines the dedicated processing capacity of the namespace.
	//  Higher capacity means more throughput and lower latency.
	//
	//  Valid values: 1, 2, 4, 8, 16
	//  Only applicable for Premium SKU. Must be omitted for Basic/Standard.
	//
	//  Each messaging unit provides approximately 1 ...
	Capacity int32 `json:"capacity,omitempty" jsonschema:"Messaging units for Premium SKU. Defines the dedicated processing capacity of the namespace. Higher capacity means more throughput and lower latency. Valid values: 1; 2; 4; 8; 16 Only applicable for P..."`
	// Premium messaging partitions for the namespace.
	//  Partitions distribute messages across multiple message stores for
	//  higher throughput and availability within the Premium tier.
	//
	//  Valid values: 1, 2, 4
	//  Only applicable for Premium SKU. Must be omitted for Basic/Standard.
	//
	//  **ForceNew**: Changing this ...
	PremiumMessagingPartitions int32 `json:"premium_messaging_partitions,omitempty" jsonschema:"Premium messaging partitions for the namespace. Partitions distribute messages across multiple message stores for higher throughput and availability within the Premium tier. Valid values: 1; 2; 4 Only..."`
	// Enable zone redundancy for the namespace.
	//  When enabled, the namespace metadata and data are replicated across
	//  availability zones within the region for higher availability.
	//
	//  Only applicable for Premium SKU.
	//
	//  Default: false
	ZoneRedundant bool `json:"zone_redundant,omitempty" jsonschema:"Enable zone redundancy for the namespace. When enabled; the namespace metadata and data are replicated across availability zones within the region for higher availability. Only applicable for Premium ..."`
	// Minimum TLS version for client connections.
	//  Azure enforces this on all AMQP, HTTP, and SBMP connections.
	//
	//  Default: "1.2" (recommended for all production workloads)
	MinimumTlsVersion string `json:"minimum_tls_version,omitempty" jsonschema:"Minimum TLS version for client connections. Azure enforces this on all AMQP; HTTP; and SBMP connections. Default: '1.2' (recommended for all production workloads)"`
	// Whether the namespace is accessible over the public internet.
	//  When false, the namespace can only be accessed via AzurePrivateEndpoint
	//  or VNet service endpoints.
	//
	//  Default: true
	PublicNetworkAccessEnabled bool `json:"public_network_access_enabled,omitempty" jsonschema:"Whether the namespace is accessible over the public internet. When false; the namespace can only be accessed via AzurePrivateEndpoint or VNet service endpoints. Default: true"`
	// Queues within this namespace.
	//  Service Bus queues deliver messages to a single consumer (point-to-point).
	//  Each queue is an independent entity within the namespace.
	//
	//  Available in all SKU tiers (Basic, Standard, Premium).
	Queues []*AzureServiceBusQueueInput `json:"queues,omitempty" jsonschema:"Queues within this namespace. Service Bus queues deliver messages to a single consumer (point-to-point). Each queue is an independent entity within the namespace. Available in all SKU tiers (Basic; St..."`
	// Topics within this namespace.
	//  Service Bus topics deliver messages to multiple independent subscriptions
	//  (publish-subscribe). Each topic can have many subscriptions, each with
	//  its own filter rules.
	//
	//  **Not available in Basic SKU.** Use Standard or Premium for topics.
	Topics []*AzureServiceBusTopicInput `json:"topics,omitempty" jsonschema:"Topics within this namespace. Service Bus topics deliver messages to multiple independent subscriptions (publish-subscribe). Each topic can have many subscriptions; each with its own filter rules. **N..."`
}

func (s *AzureServiceBusNamespaceSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.Queues {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("queues[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Topics {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("topics[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureServiceBusNamespaceSpecInput) applyDefaults() {
	if s.Sku == "" {
		s.Sku = "Standard"
	}
	if s.MinimumTlsVersion == "" {
		s.MinimumTlsVersion = "1.2"
	}
	// default: PublicNetworkAccessEnabled = true (applied at zero-value)
}

func (s *AzureServiceBusNamespaceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.Sku != "" {
		m["sku"] = s.Sku
	}
	if s.Capacity != 0 {
		m["capacity"] = s.Capacity
	}
	if s.PremiumMessagingPartitions != 0 {
		m["premium_messaging_partitions"] = s.PremiumMessagingPartitions
	}
	if s.ZoneRedundant {
		m["zone_redundant"] = s.ZoneRedundant
	}
	if s.MinimumTlsVersion != "" {
		m["minimum_tls_version"] = s.MinimumTlsVersion
	}
	if s.PublicNetworkAccessEnabled {
		m["public_network_access_enabled"] = s.PublicNetworkAccessEnabled
	}
	if len(s.Queues) > 0 {
		items := make([]any, len(s.Queues))
		for i, v := range s.Queues {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["queues"] = items
	}
	if len(s.Topics) > 0 {
		items := make([]any, len(s.Topics))
		for i, v := range s.Topics {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["topics"] = items
	}
	return m
}

// AzureServiceBusQueue defines a queue within the Service Bus namespace.
//
//	Queues provide reliable, ordered (FIFO) message delivery to a single
//	consumer. Messages are stored durably until explicitly received and
//	completed by a consumer.
//
//	Key capabilities:
//	- **Lock duration**: Messages are locked during processing. If not completed
//	  within the lock duration, they become available to other consumers.
//	- **Duplicate detection**: Prevents duplicate messages based on MessageId
//	  within a configurable time window.
//	- **Sessions**: Groups related messages for ordered, stateful processing.
//	- **Dead-letter queue**: Automatically stores messages that cannot be
//	  processed (expired, exceeded max delivery count, filter evaluation errors).
//	- **Message forwarding**: Auto-forwards messages to another queue or topic
//	  within the same namespace (for routing patterns).
//
//	**ForceNew fields**: `name`, `partitioning_enabled`, `requires_duplicate_detection`,
//	`requires_session`.
type AzureServiceBusQueueInput struct {
	// The queue name.
	//  Must be unique within the namespace.
	//
	//  Naming rules: 1-260 characters, starts and ends with a letter or number.
	//  Can contain letters, numbers, periods, hyphens, underscores, tildes,
	//  and forward slashes.
	Name string `json:"name" jsonschema:"required,The queue name. Must be unique within the namespace. Naming rules: 1-260 characters; starts and ends with a letter or number. Can contain letters; numbers; periods; hyphens; underscores; tildes; and f..."`
	// Maximum size of the queue in megabytes.
	//  Determines how much message data the queue can hold before it starts
	//  rejecting new messages.
	//
	//  Valid values: 1024, 2048, 3072, 4096, 5120 (Standard/Basic).
	//  Premium supports up to 81920 MB.
	//  Default: varies by SKU (1024 for Standard, 81920 for Premium).
	//
	//  **...
	MaxSizeInMegabytes int32 `json:"max_size_in_megabytes,omitempty" jsonschema:"Maximum size of the queue in megabytes. Determines how much message data the queue can hold before it starts rejecting new messages. Valid values: 1024; 2048; 3072; 4096; 5120 (Standard/Basic). Premiu..."`
	// Enable queue partitioning.
	//  Partitioned queues distribute messages across multiple message stores
	//  for higher throughput.
	//
	//  For Premium SKU: must match the namespace's `premium_messaging_partitions`
	//  setting. The IaC modules handle this automatically.
	//
	//  **ForceNew**: Changing this destroys and recre...
	PartitioningEnabled bool `json:"partitioning_enabled,omitempty" jsonschema:"Enable queue partitioning. Partitioned queues distribute messages across multiple message stores for higher throughput. For Premium SKU: must match the namespace's 'premium_messaging_partitions' setti..."`
	// Default message time-to-live as an ISO 8601 duration.
	//  Messages older than this duration are automatically dead-lettered or
	//  discarded (depending on `dead_lettering_on_message_expiration`).
	//
	//  Examples: "P14D" (14 days), "PT1H" (1 hour), "PT30M" (30 minutes).
	//  Default: unbounded (messages never expir...
	DefaultMessageTtl string `json:"default_message_ttl,omitempty" jsonschema:"Default message time-to-live as an ISO 8601 duration. Messages older than this duration are automatically dead-lettered or discarded (depending on 'dead_lettering_on_message_expiration'). Examples: 'P..."`
	// How long a message is locked for processing as an ISO 8601 duration.
	//  When a consumer receives a message in PeekLock mode, the message is
	//  locked for this duration. If not completed within the lock duration,
	//  the message becomes available to other consumers.
	//
	//  Range: PT5S (5 seconds) to PT5M (5 minu...
	LockDuration string `json:"lock_duration,omitempty" jsonschema:"How long a message is locked for processing as an ISO 8601 duration. When a consumer receives a message in PeekLock mode; the message is locked for this duration. If not completed within the lock dura..."`
	// Maximum number of delivery attempts before dead-lettering.
	//  After this many failed delivery attempts, the message is moved to
	//  the queue's dead-letter sub-queue.
	//
	//  Minimum: 1. Default: 10.
	//
	//  Lower values detect poison messages faster. Higher values tolerate
	//  transient consumer failures better.
	MaxDeliveryCount int32 `json:"max_delivery_count,omitempty" jsonschema:"Maximum number of delivery attempts before dead-lettering. After this many failed delivery attempts; the message is moved to the queue's dead-letter sub-queue. Minimum: 1. Default: 10. Lower values de..."`
	// Enable duplicate message detection.
	//  When enabled, Service Bus tracks MessageId values for a configurable
	//  time window (default 10 minutes) and silently drops duplicate messages.
	//
	//  Useful for idempotent messaging patterns where producers may retry
	//  sends without knowing if the original message was a...
	RequiresDuplicateDetection bool `json:"requires_duplicate_detection,omitempty" jsonschema:"Enable duplicate message detection. When enabled; Service Bus tracks MessageId values for a configurable time window (default 10 minutes) and silently drops duplicate messages. Useful for idempotent m..."`
	// Enable message sessions for ordered processing.
	//  Sessions group related messages by a SessionId, enabling:
	//  - Strict FIFO ordering within a session
	//  - Stateful processing (session state stored on the broker)
	//  - Exclusive processing (one consumer per session at a time)
	//
	//  All messages in a session are...
	RequiresSession bool `json:"requires_session,omitempty" jsonschema:"Enable message sessions for ordered processing. Sessions group related messages by a SessionId; enabling: - Strict FIFO ordering within a session - Stateful processing (session state stored on the bro..."`
	// Move expired messages to the dead-letter queue.
	//  When true, messages that exceed their TTL are moved to the dead-letter
	//  sub-queue instead of being discarded. This enables inspection and
	//  reprocessing of expired messages.
	//
	//  Default: false
	DeadLetteringOnMessageExpiration bool `json:"dead_lettering_on_message_expiration,omitempty" jsonschema:"Move expired messages to the dead-letter queue. When true; messages that exceed their TTL are moved to the dead-letter sub-queue instead of being discarded. This enables inspection and reprocessing of..."`
	// Auto-forward messages to another queue or topic within the same namespace.
	//  When set, messages arriving in this queue are automatically forwarded
	//  to the specified entity. The value is the name of the target queue or
	//  topic (not the full resource ID).
	//
	//  Useful for routing patterns and message distri...
	ForwardTo string `json:"forward_to,omitempty" jsonschema:"Auto-forward messages to another queue or topic within the same namespace. When set; messages arriving in this queue are automatically forwarded to the specified entity. The value is the name of the t..."`
	// Auto-forward dead-lettered messages to another queue or topic.
	//  When set, messages that are dead-lettered (expired, exceeded max
	//  delivery count) are forwarded to the specified entity instead of
	//  remaining in the dead-letter sub-queue.
	//
	//  The value is the name of the target queue or topic within the ...
	ForwardDeadLetteredMessagesTo string `json:"forward_dead_lettered_messages_to,omitempty" jsonschema:"Auto-forward dead-lettered messages to another queue or topic. When set; messages that are dead-lettered (expired; exceeded max delivery count) are forwarded to the specified entity instead of remaini..."`
}

func (s *AzureServiceBusQueueInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureServiceBusQueueInput) applyDefaults() {
	if s.LockDuration == "" {
		s.LockDuration = "PT1M"
	}
	if s.MaxDeliveryCount == 0 {
		s.MaxDeliveryCount = 10
	}
}

func (s *AzureServiceBusQueueInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.MaxSizeInMegabytes != 0 {
		m["max_size_in_megabytes"] = s.MaxSizeInMegabytes
	}
	if s.PartitioningEnabled {
		m["partitioning_enabled"] = s.PartitioningEnabled
	}
	if s.DefaultMessageTtl != "" {
		m["default_message_ttl"] = s.DefaultMessageTtl
	}
	if s.LockDuration != "" {
		m["lock_duration"] = s.LockDuration
	}
	if s.MaxDeliveryCount != 0 {
		m["max_delivery_count"] = s.MaxDeliveryCount
	}
	if s.RequiresDuplicateDetection {
		m["requires_duplicate_detection"] = s.RequiresDuplicateDetection
	}
	if s.RequiresSession {
		m["requires_session"] = s.RequiresSession
	}
	if s.DeadLetteringOnMessageExpiration {
		m["dead_lettering_on_message_expiration"] = s.DeadLetteringOnMessageExpiration
	}
	if s.ForwardTo != "" {
		m["forward_to"] = s.ForwardTo
	}
	if s.ForwardDeadLetteredMessagesTo != "" {
		m["forward_dead_lettered_messages_to"] = s.ForwardDeadLetteredMessagesTo
	}
	return m
}

// AzureServiceBusTopic defines a topic within the Service Bus namespace.
//
//	Topics implement the publish-subscribe messaging pattern. Publishers send
//	messages to a topic, and multiple subscriptions can independently receive
//	copies of those messages with optional filter rules.
//
//	**Not available in Basic SKU.** Use Standard or Premium.
//
//	Topics do NOT have lock_duration, max_delivery_count, sessions, or
//	dead-lettering -- those are subscription-level concerns. This component
//	deliberately omits subscriptions (see spec comment).
//
//	**ForceNew fields**: `name`, `partitioning_enabled`, `requires_duplicate_detection`.
type AzureServiceBusTopicInput struct {
	// The topic name.
	//  Must be unique within the namespace.
	//
	//  Naming rules: 1-260 characters, starts and ends with a letter or number.
	//  Can contain letters, numbers, periods, hyphens, underscores, tildes,
	//  and forward slashes.
	Name string `json:"name" jsonschema:"required,The topic name. Must be unique within the namespace. Naming rules: 1-260 characters; starts and ends with a letter or number. Can contain letters; numbers; periods; hyphens; underscores; tildes; and f..."`
	// Maximum size of the topic in megabytes.
	//  Determines how much message data the topic can hold across all
	//  subscriptions before it starts rejecting new messages.
	//
	//  Valid values: 1024, 2048, 3072, 4096, 5120 (Standard).
	//  Premium supports up to 81920 MB.
	//  Default: varies by SKU.
	MaxSizeInMegabytes int32 `json:"max_size_in_megabytes,omitempty" jsonschema:"Maximum size of the topic in megabytes. Determines how much message data the topic can hold across all subscriptions before it starts rejecting new messages. Valid values: 1024; 2048; 3072; 4096; 5120..."`
	// Enable topic partitioning.
	//  Partitioned topics distribute messages across multiple message stores
	//  for higher throughput.
	//
	//  For Premium SKU: must match the namespace's `premium_messaging_partitions`
	//  setting. The IaC modules handle this automatically.
	//
	//  **ForceNew**: Changing this destroys and recre...
	PartitioningEnabled bool `json:"partitioning_enabled,omitempty" jsonschema:"Enable topic partitioning. Partitioned topics distribute messages across multiple message stores for higher throughput. For Premium SKU: must match the namespace's 'premium_messaging_partitions' setti..."`
	// Default message time-to-live as an ISO 8601 duration.
	//  Messages older than this duration are automatically removed.
	//
	//  Examples: "P14D" (14 days), "PT1H" (1 hour), "P30D" (30 days).
	//  Default: unbounded (messages never expire).
	DefaultMessageTtl string `json:"default_message_ttl,omitempty" jsonschema:"Default message time-to-live as an ISO 8601 duration. Messages older than this duration are automatically removed. Examples: 'P14D' (14 days); 'PT1H' (1 hour); 'P30D' (30 days). Default: unbounded (me..."`
	// Enable duplicate message detection.
	//  When enabled, Service Bus tracks MessageId values and silently drops
	//  duplicate messages within a configurable time window (default 10 minutes).
	//
	//  **ForceNew**: Changing this destroys and recreates the topic.
	//
	//  Default: false
	RequiresDuplicateDetection bool `json:"requires_duplicate_detection,omitempty" jsonschema:"Enable duplicate message detection. When enabled; Service Bus tracks MessageId values and silently drops duplicate messages within a configurable time window (default 10 minutes). **ForceNew**: Changi..."`
	// Enable message ordering support.
	//  When enabled, the topic preserves the order of messages within a
	//  session. Works with session-enabled subscriptions for ordered
	//  publish-subscribe patterns.
	//
	//  Default: false
	SupportOrdering bool `json:"support_ordering,omitempty" jsonschema:"Enable message ordering support. When enabled; the topic preserves the order of messages within a session. Works with session-enabled subscriptions for ordered publish-subscribe patterns. Default: fal..."`
}

func (s *AzureServiceBusTopicInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureServiceBusTopicInput) applyDefaults() {
}

func (s *AzureServiceBusTopicInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.MaxSizeInMegabytes != 0 {
		m["max_size_in_megabytes"] = s.MaxSizeInMegabytes
	}
	if s.PartitioningEnabled {
		m["partitioning_enabled"] = s.PartitioningEnabled
	}
	if s.DefaultMessageTtl != "" {
		m["default_message_ttl"] = s.DefaultMessageTtl
	}
	if s.RequiresDuplicateDetection {
		m["requires_duplicate_detection"] = s.RequiresDuplicateDetection
	}
	if s.SupportOrdering {
		m["support_ordering"] = s.SupportOrdering
	}
	return m
}

// ParseAzureServiceBusNamespace validates and normalizes a AzureServiceBusNamespace cloud_object.
func ParseAzureServiceBusNamespace(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureServiceBusNamespace"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureServiceBusNamespaceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
