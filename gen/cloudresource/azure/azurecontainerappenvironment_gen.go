// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureContainerAppEnvironment is the top-level API resource for an Azure
//
//	Container Apps Managed Environment. It defines the hosting platform for
//	Azure Container Apps, providing the execution boundary, networking,
//	logging, and compute configuration.
type AzureContainerAppEnvironmentSpecInput struct {
	// The Azure region where the Container App Environment will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	//
	//  **ForceNew**: Changing this destroys and recreates the environment.
	Region string `json:"region" jsonschema:"required,The Azure region where the Container App Environment will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'. **ForceNew**: Changing this destroys and recreates the environment."`
	// The Azure Resource Group where the Container App Environment will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	//
	//  **ForceNew**: Changing this destroys and recreates the environment.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Container App Environment will be created. Can be a literal string or a reference to an AzureResourceGroup output. **ForceNew**: Changing this destroys and recreates..."`
	// The name of the Container App Environment.
	//  Must be lowercase alphanumeric or hyphens, start with a letter, end with
	//  an alphanumeric character, and be between 2 and 60 characters.
	//
	//  This name appears in the Azure portal, CLI, and is part of the default
	//  domain for apps in this environment ({app-nam...
	Name string `json:"name" jsonschema:"required,The name of the Container App Environment. Must be lowercase alphanumeric or hyphens; start with a letter; end with an alphanumeric character; and be between 2 and 60 characters. This name appears in ..."`
	// The existing Subnet to use for the Container Apps Control Plane.
	//  When provided, the environment is VNet-injected, enabling private
	//  connectivity to other VNet resources (databases, storage, etc.).
	//
	//  **Important**: The subnet must have a /21 or larger address space
	//  (minimum 2048 IPs). Container App...
	InfrastructureSubnetId string `json:"infrastructure_subnet_id,omitempty" jsonschema:"The existing Subnet to use for the Container Apps Control Plane. When provided; the environment is VNet-injected; enabling private connectivity to other VNet resources (databases; storage; etc.). **Im..."`
	// The Log Analytics Workspace to link for centralized log collection.
	//  When provided, the IaC modules automatically configure the logging
	//  destination to "log-analytics". When omitted, logs are streaming-only.
	//
	//  Log Analytics enables querying container app logs via KQL, setting up
	//  alerts, and integra...
	LogAnalyticsWorkspaceId string `json:"log_analytics_workspace_id,omitempty" jsonschema:"The Log Analytics Workspace to link for centralized log collection. When provided; the IaC modules automatically configure the logging destination to 'log-analytics'. When omitted; logs are streaming-..."`
	// Enable Internal Load Balancing mode. When true, apps in this environment
	//  are only accessible from within the VNet (no public internet access).
	//
	//  Requires `infrastructure_subnet_id` to be set.
	//
	//  Use this for backend microservices, internal APIs, and workloads that
	//  should not be exposed to the publi...
	InternalLoadBalancerEnabled bool `json:"internal_load_balancer_enabled,omitempty" jsonschema:"Enable Internal Load Balancing mode. When true; apps in this environment are only accessible from within the VNet (no public internet access). Requires 'infrastructure_subnet_id' to be set. Use this f..."`
	// Enable zone redundancy. Distributes the environment's infrastructure
	//  across multiple availability zones for higher resilience.
	//
	//  Requires `infrastructure_subnet_id` to be set.
	//
	//  When enabled, Container Apps infrastructure is spread across all
	//  available zones in the region (typically 3). Recommende...
	ZoneRedundancyEnabled bool `json:"zone_redundancy_enabled,omitempty" jsonschema:"Enable zone redundancy. Distributes the environment's infrastructure across multiple availability zones for higher resilience. Requires 'infrastructure_subnet_id' to be set. When enabled; Container Ap..."`
	// Workload profiles for dedicated compute resources.
	//
	//  By default, all environments include the "Consumption" profile (serverless,
	//  pay-per-use, scales to zero). This field is for adding **dedicated compute
	//  profiles** alongside Consumption. Azure automatically includes the
	//  Consumption profile -- do ...
	WorkloadProfiles []*AzureContainerAppWorkloadProfileInput `json:"workload_profiles,omitempty" jsonschema:"Workload profiles for dedicated compute resources. By default; all environments include the 'Consumption' profile (serverless; pay-per-use; scales to zero). This field is for adding **dedicated comput..."`
}

func (s *AzureContainerAppEnvironmentSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.WorkloadProfiles {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("workload_profiles[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureContainerAppEnvironmentSpecInput) applyDefaults() {
}

func (s *AzureContainerAppEnvironmentSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.InfrastructureSubnetId != "" {
		m["infrastructure_subnet_id"] = s.InfrastructureSubnetId
	}
	if s.LogAnalyticsWorkspaceId != "" {
		m["log_analytics_workspace_id"] = s.LogAnalyticsWorkspaceId
	}
	if s.InternalLoadBalancerEnabled {
		m["internal_load_balancer_enabled"] = s.InternalLoadBalancerEnabled
	}
	if s.ZoneRedundancyEnabled {
		m["zone_redundancy_enabled"] = s.ZoneRedundancyEnabled
	}
	if len(s.WorkloadProfiles) > 0 {
		items := make([]any, len(s.WorkloadProfiles))
		for i, v := range s.WorkloadProfiles {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["workload_profiles"] = items
	}
	return m
}

// AzureContainerAppWorkloadProfile defines a dedicated compute profile
//
//	within a Container App Environment.
//
//	Each profile represents a pool of dedicated VMs that container apps can
//	target. Apps select a workload profile by name in their configuration.
type AzureContainerAppWorkloadProfileInput struct {
	// The name of the workload profile.
	//  This name is referenced by Container Apps when selecting which
	//  profile to run on (e.g., "gpu-pool", "high-memory").
	//
	//  Must be unique within the environment.
	Name string `json:"name" jsonschema:"required,The name of the workload profile. This name is referenced by Container Apps when selecting which profile to run on (e.g.; 'gpu-pool'; 'high-memory'). Must be unique within the environment."`
	// The workload profile type (SKU) that determines the VM size.
	//
	//  General purpose: "D4", "D8", "D16", "D32"
	//  Memory optimized: "E4", "E8", "E16", "E32"
	//  GPU (NVIDIA A100): "NC24-A100", "NC48-A100", "NC96-A100"
	//
	//  Do not use "Consumption" here -- it is always available by default.
	WorkloadProfileType string `json:"workload_profile_type" jsonschema:"required,The workload profile type (SKU) that determines the VM size. General purpose: 'D4'; 'D8'; 'D16'; 'D32' Memory optimized: 'E4'; 'E8'; 'E16'; 'E32' GPU (NVIDIA A100): 'NC24-A100'; 'NC48-A100'; 'NC96-A10..."`
	// Minimum number of instances for this profile.
	//  Set to 0 to allow scale-to-zero (instances are deallocated when idle).
	//  Set to 1+ to keep pre-warmed instances for reduced cold-start latency.
	MinimumCount int32 `json:"minimum_count,omitempty" jsonschema:"Minimum number of instances for this profile. Set to 0 to allow scale-to-zero (instances are deallocated when idle). Set to 1+ to keep pre-warmed instances for reduced cold-start latency."`
	// Maximum number of instances this profile can scale to.
	//  Controls the upper bound on cost and capacity.
	MaximumCount int32 `json:"maximum_count,omitempty" jsonschema:"Maximum number of instances this profile can scale to. Controls the upper bound on cost and capacity."`
}

func (s *AzureContainerAppWorkloadProfileInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.WorkloadProfileType == "" {
		return fmt.Errorf("workload_profile_type is required")
	}
	return nil
}

func (s *AzureContainerAppWorkloadProfileInput) applyDefaults() {
}

func (s *AzureContainerAppWorkloadProfileInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["workload_profile_type"] = s.WorkloadProfileType
	if s.MinimumCount != 0 {
		m["minimum_count"] = s.MinimumCount
	}
	if s.MaximumCount != 0 {
		m["maximum_count"] = s.MaximumCount
	}
	return m
}

// ParseAzureContainerAppEnvironment validates and normalizes a AzureContainerAppEnvironment cloud_object.
func ParseAzureContainerAppEnvironment(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureContainerAppEnvironment"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureContainerAppEnvironmentSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
