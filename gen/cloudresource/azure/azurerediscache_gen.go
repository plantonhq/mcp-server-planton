// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureRedisCache is the top-level API resource for an Azure Cache for Redis.
//
//	Azure Cache for Redis provides a fully managed, in-memory data store based
//	on the open-source Redis engine. It supports caching, session management,
//	real-time analytics, and message brokering with sub-millisecond latency.
type AzureRedisCacheSpecInput struct {
	// The Azure region where the Redis cache will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the Redis cache will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the Redis cache will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Redis cache will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Redis cache.
	//  Must be globally unique across Azure. Used as the cache endpoint:
	//  `{name}.redis.cache.windows.net`
	//  Allowed characters: lowercase letters, numbers, and hyphens.
	//  Must start with a letter, must not end with a hyphen.
	//  Length: 1 to 63 characters.
	//
	//  **ForceNew**: Changing...
	Name string `json:"name" jsonschema:"required,The name of the Redis cache. Must be globally unique across Azure. Used as the cache endpoint: '{name}.redis.cache.windows.net' Allowed characters: lowercase letters; numbers; and hyphens. Must start ..."`
	// The SKU tier for the Redis cache.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "Basic": Single node, no SLA, no replication. Dev/test only.
	//  - "Standard" (default): Primary + replica, 99.9% SLA. Production recommended.
	//  - "Premium": Advanced features -- VNet injection...
	SkuName string `json:"sku_name,omitempty" jsonschema:"The SKU tier for the Redis cache. Uses Azure's exact API values for provider authenticity. Valid values: - 'Basic': Single node; no SLA; no replication. Dev/test only. - 'Standard' (default): Primary ..."`
	// Cache capacity (size) within the chosen SKU tier.
	//  The actual memory size depends on the SKU family:
	//
	//  Basic/Standard (C-family):
	//    0=250MB, 1=1GB, 2=2.5GB, 3=6GB, 4=13GB, 5=26GB, 6=53GB
	//
	//  Premium (P-family):
	//    1=6GB, 2=13GB, 3=26GB, 4=53GB, 5=120GB (per shard)
	//
	//  The `family` field ("C" or "P") is...
	Capacity int32 `json:"capacity,omitempty" jsonschema:"Cache capacity (size) within the chosen SKU tier. The actual memory size depends on the SKU family: Basic/Standard (C-family): 0=250MB; 1=1GB; 2=2.5GB; 3=6GB; 4=13GB; 5=26GB; 6=53GB Premium (P-family)..."`
	// Redis engine version.
	//
	//  Valid values: "4", "6"
	//  Default: "6" (recommended -- Redis 4 is end-of-life).
	//
	//  Note: Azure represents versions as major version only. Version "6" maps
	//  to the latest Redis 6.x release available in the region.
	RedisVersion string `json:"redis_version,omitempty" jsonschema:"Redis engine version. Valid values: '4'; '6' Default: '6' (recommended -- Redis 4 is end-of-life). Note: Azure represents versions as major version only. Version '6' maps to the latest Redis 6.x relea..."`
	// Subnet ID for VNet injection (Premium SKU only).
	//  When set, the cache is deployed inside the specified subnet with private
	//  IP addressing. The subnet must be dedicated to Azure Cache for Redis
	//  (no other resources in the subnet).
	//
	//  **ForceNew**: Changing this destroys and recreates the cache.
	//
	//  Can ...
	SubnetId string `json:"subnet_id,omitempty" jsonschema:"Subnet ID for VNet injection (Premium SKU only). When set; the cache is deployed inside the specified subnet with private IP addressing. The subnet must be dedicated to Azure Cache for Redis (no other..."`
	// Availability zones for the Redis cache.
	//  Distributes cache nodes across specified zones for higher availability.
	//  Requires Standard or Premium SKU.
	//
	//  Examples: ["1"], ["1", "2", "3"]
	Zones []string `json:"zones,omitempty" jsonschema:"Availability zones for the Redis cache. Distributes cache nodes across specified zones for higher availability. Requires Standard or Premium SKU. Examples: ['1']; ['1'; '2'; '3']"`
	// Number of shards for Redis Cluster (Premium SKU only).
	//  Enables data partitioning across multiple Redis nodes for higher
	//  throughput and larger data sets.
	//
	//  Each shard is a primary/replica pair. Total cache memory = capacity * (1 + shard_count).
	//  Range: 1-10 shards.
	ShardCount int32 `json:"shard_count,omitempty" jsonschema:"Number of shards for Redis Cluster (Premium SKU only). Enables data partitioning across multiple Redis nodes for higher throughput and larger data sets. Each shard is a primary/replica pair. Total cac..."`
	// Enable the non-SSL port (6379).
	//  When false (default), only the SSL port (6380) is available.
	//  It is strongly recommended to keep this disabled for production workloads.
	//
	//  Default: false
	NonSslPortEnabled bool `json:"non_ssl_port_enabled,omitempty" jsonschema:"Enable the non-SSL port (6379). When false (default); only the SSL port (6380) is available. It is strongly recommended to keep this disabled for production workloads. Default: false"`
	// Minimum TLS version for client connections.
	//  Azure enforces this on all connections to the SSL port.
	//
	//  Default: "1.2" (only valid value in Azure provider v5.0+)
	MinimumTlsVersion string `json:"minimum_tls_version,omitempty" jsonschema:"Minimum TLS version for client connections. Azure enforces this on all connections to the SSL port. Default: '1.2' (only valid value in Azure provider v5.0+)"`
	// Whether the Redis cache is accessible over the public internet.
	//  When false, the cache can only be accessed via VNet injection or
	//  AzurePrivateEndpoint.
	//
	//  Default: true
	PublicNetworkAccessEnabled bool `json:"public_network_access_enabled,omitempty" jsonschema:"Whether the Redis cache is accessible over the public internet. When false; the cache can only be accessed via VNet injection or AzurePrivateEndpoint. Default: true"`
	// Memory eviction policy when the cache reaches its memory limit.
	//  Uses Redis's exact configuration value names for provider authenticity.
	//
	//  Valid values:
	//  - "volatile-lru" (default): Evict keys with TTL, least-recently-used first
	//  - "allkeys-lru": Evict any key, least-recently-used first (cache-only ...
	MaxmemoryPolicy string `json:"maxmemory_policy,omitempty" jsonschema:"Memory eviction policy when the cache reaches its memory limit. Uses Redis's exact configuration value names for provider authenticity. Valid values: - 'volatile-lru' (default): Evict keys with TTL; l..."`
	// Patch (maintenance) schedules for the Redis cache.
	//  Defines when Azure can apply Redis engine patches and updates.
	//  If not specified, Azure chooses the maintenance window automatically.
	//
	//  For production workloads, specify at least one patch schedule during
	//  a low-traffic window.
	PatchSchedules []*AzureRedisPatchScheduleInput `json:"patch_schedules,omitempty" jsonschema:"Patch (maintenance) schedules for the Redis cache. Defines when Azure can apply Redis engine patches and updates. If not specified; Azure chooses the maintenance window automatically. For production w..."`
	// Firewall rules for IP-based access control.
	//  Only effective when `public_network_access_enabled` is true and the cache
	//  is NOT VNet-injected.
	//
	//  Each rule allows a range of IPv4 addresses to access the cache.
	//  Without firewall rules, all public IP addresses are blocked by default.
	FirewallRules []*AzureRedisFirewallRuleInput `json:"firewall_rules,omitempty" jsonschema:"Firewall rules for IP-based access control. Only effective when 'public_network_access_enabled' is true and the cache is NOT VNet-injected. Each rule allows a range of IPv4 addresses to access the cac..."`
}

func (s *AzureRedisCacheSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.PatchSchedules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("patch_schedules[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.FirewallRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("firewall_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureRedisCacheSpecInput) applyDefaults() {
	if s.SkuName == "" {
		s.SkuName = "Standard"
	}
	if s.RedisVersion == "" {
		s.RedisVersion = "6"
	}
	if s.MinimumTlsVersion == "" {
		s.MinimumTlsVersion = "1.2"
	}
	// default: PublicNetworkAccessEnabled = true (applied at zero-value)
	if s.MaxmemoryPolicy == "" {
		s.MaxmemoryPolicy = "volatile-lru"
	}
}

func (s *AzureRedisCacheSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.SkuName != "" {
		m["sku_name"] = s.SkuName
	}
	if s.Capacity != 0 {
		m["capacity"] = s.Capacity
	}
	if s.RedisVersion != "" {
		m["redis_version"] = s.RedisVersion
	}
	if s.SubnetId != "" {
		m["subnet_id"] = s.SubnetId
	}
	if len(s.Zones) > 0 {
		m["zones"] = s.Zones
	}
	if s.ShardCount != 0 {
		m["shard_count"] = s.ShardCount
	}
	if s.NonSslPortEnabled {
		m["non_ssl_port_enabled"] = s.NonSslPortEnabled
	}
	if s.MinimumTlsVersion != "" {
		m["minimum_tls_version"] = s.MinimumTlsVersion
	}
	if s.PublicNetworkAccessEnabled {
		m["public_network_access_enabled"] = s.PublicNetworkAccessEnabled
	}
	if s.MaxmemoryPolicy != "" {
		m["maxmemory_policy"] = s.MaxmemoryPolicy
	}
	if len(s.PatchSchedules) > 0 {
		items := make([]any, len(s.PatchSchedules))
		for i, v := range s.PatchSchedules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["patch_schedules"] = items
	}
	if len(s.FirewallRules) > 0 {
		items := make([]any, len(s.FirewallRules))
		for i, v := range s.FirewallRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["firewall_rules"] = items
	}
	return m
}

// AzureRedisFirewallRule defines an IP-based access rule for the Redis cache.
//
//	Each rule allows a contiguous range of IPv4 addresses to connect.
//
//	Firewall rules are only effective when:
//	- `public_network_access_enabled` is true
//	- The cache is NOT deployed with VNet injection (`subnet_id` is not set)
//
//	**Note:** Azure requires firewall rule names to contain only alphanumeric
//	characters and underscores (no hyphens).
type AzureRedisFirewallRuleInput struct {
	// Rule name.
	//  Must contain only alphanumeric characters and underscores.
	//  Azure rejects names with hyphens or special characters.
	Name string `json:"name" jsonschema:"required,Rule name. Must contain only alphanumeric characters and underscores. Azure rejects names with hyphens or special characters."`
	// Start of the IP address range (inclusive).
	//  Must be a valid IPv4 address.
	//  Use "0.0.0.0" for both start and end to allow Azure services.
	StartIp string `json:"start_ip" jsonschema:"required,Start of the IP address range (inclusive). Must be a valid IPv4 address. Use '0.0.0.0' for both start and end to allow Azure services."`
	// End of the IP address range (inclusive).
	//  Must be a valid IPv4 address.
	//  Set equal to `start_ip` for a single IP address.
	EndIp string `json:"end_ip" jsonschema:"required,End of the IP address range (inclusive). Must be a valid IPv4 address. Set equal to 'start_ip' for a single IP address."`
}

func (s *AzureRedisFirewallRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.StartIp == "" {
		return fmt.Errorf("start_ip is required")
	}
	if s.EndIp == "" {
		return fmt.Errorf("end_ip is required")
	}
	return nil
}

func (s *AzureRedisFirewallRuleInput) applyDefaults() {
}

func (s *AzureRedisFirewallRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["start_ip"] = s.StartIp
	m["end_ip"] = s.EndIp
	return m
}

// AzureRedisPatchSchedule defines a maintenance window for Redis engine
//
//	patches and updates. Azure uses these windows to apply updates with
//	minimal disruption.
//
//	It is recommended to schedule patches during low-traffic periods.
//	Multiple schedules can be specified (e.g., one per week).
type AzureRedisPatchScheduleInput struct {
	// Day of the week for the maintenance window.
	//  Uses English day names (case-insensitive in the provider, but we
	//  validate for capitalized form for consistency).
	//
	//  Valid values: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
	//  "Saturday", "Sunday", "Everyday", "Weekend"
	DayOfWeek string `json:"day_of_week" jsonschema:"required,Day of the week for the maintenance window. Uses English day names (case-insensitive in the provider; but we validate for capitalized form for consistency). Valid values: 'Monday'; 'Tuesday'; 'Wednesd..."`
	// UTC hour at which the maintenance window starts (0-23).
	//  Default: 0
	StartHourUtc int32 `json:"start_hour_utc,omitempty" jsonschema:"UTC hour at which the maintenance window starts (0-23). Default: 0"`
	// Duration of the maintenance window as an ISO 8601 duration string.
	//  Default: "PT5H" (5 hours)
	//
	//  Examples: "PT5H" (5 hours), "PT3H" (3 hours)
	MaintenanceWindow string `json:"maintenance_window,omitempty" jsonschema:"Duration of the maintenance window as an ISO 8601 duration string. Default: 'PT5H' (5 hours) Examples: 'PT5H' (5 hours); 'PT3H' (3 hours)"`
}

func (s *AzureRedisPatchScheduleInput) validate() error {
	if s.DayOfWeek == "" {
		return fmt.Errorf("day_of_week is required")
	}
	return nil
}

func (s *AzureRedisPatchScheduleInput) applyDefaults() {
	if s.MaintenanceWindow == "" {
		s.MaintenanceWindow = "PT5H"
	}
}

func (s *AzureRedisPatchScheduleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["day_of_week"] = s.DayOfWeek
	if s.StartHourUtc != 0 {
		m["start_hour_utc"] = s.StartHourUtc
	}
	if s.MaintenanceWindow != "" {
		m["maintenance_window"] = s.MaintenanceWindow
	}
	return m
}

// ParseAzureRedisCache validates and normalizes a AzureRedisCache cloud_object.
func ParseAzureRedisCache(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureRedisCache"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureRedisCacheSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
