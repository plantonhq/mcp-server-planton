// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzurePostgresqlFlexibleServer is the top-level API resource for an Azure
//
//	Database for PostgreSQL Flexible Server.
//	Azure Database for PostgreSQL Flexible Server is a fully managed relational
//	database service with granular control over compute, storage, high availability,
//	and networking. Supports PostgreSQL 12 through 17.
type AzurePostgresqlFlexibleServerSpecInput struct {
	// The Azure region where the PostgreSQL Flexible Server will be created.
	//  Must match the region of the VNet/subnet if VNet integration is used.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the PostgreSQL Flexible Server will be created. Must match the region of the VNet/subnet if VNet integration is used. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia..."`
	// The Azure Resource Group where the PostgreSQL Flexible Server will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the PostgreSQL Flexible Server will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the PostgreSQL Flexible Server.
	//  Must be globally unique across Azure. Used as the server hostname:
	//  `{name}.postgres.database.azure.com`
	//  Allowed characters: lowercase letters, numbers, and hyphens.
	//  Must start with a letter. Length: 3 to 63 characters.
	//
	//  **ForceNew**: Changing this des...
	Name string `json:"name" jsonschema:"required,The name of the PostgreSQL Flexible Server. Must be globally unique across Azure. Used as the server hostname: '{name}.postgres.database.azure.com' Allowed characters: lowercase letters; numbers; and ..."`
	// The administrator login name for the server.
	//  Cannot be "azure_superuser", "admin", "administrator", "root", "guest", or "public".
	//  Must start with a letter.
	//
	//  **ForceNew**: Changing this destroys and recreates the server.
	AdministratorLogin string `json:"administrator_login" jsonschema:"required,The administrator login name for the server. Cannot be 'azure_superuser'; 'admin'; 'administrator'; 'root'; 'guest'; or 'public'. Must start with a letter. **ForceNew**: Changing this destroys and rec..."`
	// The administrator password for the server.
	//  Can be a literal value or a reference to another resource's output
	//  (e.g., a generated random password or a Key Vault secret value).
	//
	//  Password requirements: 8-128 characters, must contain characters from
	//  at least three of: uppercase, lowercase, digits, s...
	AdministratorPassword string `json:"administrator_password" jsonschema:"required,The administrator password for the server. Can be a literal value or a reference to another resource's output (e.g.; a generated random password or a Key Vault secret value). Password requirements: 8-..."`
	// The PostgreSQL major version.
	//  Uses Azure's exact version strings for provider authenticity.
	//
	//  Valid values: "12", "13", "14", "15", "16", "17"
	//  Default: "16" (current GA production standard)
	//
	//  - "12": EOL Nov 2024, use only for legacy migration
	//  - "13": EOL Nov 2025, use only for existing workloads...
	Version string `json:"version,omitempty" jsonschema:"The PostgreSQL major version. Uses Azure's exact version strings for provider authenticity. Valid values: '12'; '13'; '14'; '15'; '16'; '17' Default: '16' (current GA production standard) - '12': EOL ..."`
	// The SKU name defining the compute tier and size.
	//  Format: {TIER}_Standard_{SIZE}
	//
	//  Burstable (dev/test):
	//    "B_Standard_B1ms" (1 vCPU, 2 GiB), "B_Standard_B2s" (2 vCPU, 4 GiB),
	//    "B_Standard_B4ms" (4 vCPU, 8 GiB)
	//
	//  General Purpose (production):
	//    "GP_Standard_D2s_v3" (2 vCPU, 8 GiB), "GP_Standard_...
	SkuName string `json:"sku_name" jsonschema:"required,The SKU name defining the compute tier and size. Format: {TIER}_Standard_{SIZE} Burstable (dev/test): 'B_Standard_B1ms' (1 vCPU; 2 GiB); 'B_Standard_B2s' (2 vCPU; 4 GiB); 'B_Standard_B4ms' (4 vCPU; 8 ..."`
	// The storage size in megabytes.
	//  Must be one of the Azure-allowed values:
	//    32768 (32 GB), 65536 (64 GB), 131072 (128 GB), 262144 (256 GB),
	//    524288 (512 GB), 1048576 (1 TB), 2097152 (2 TB), 4194304 (4 TB),
	//    8388608 (8 TB), 16777216 (16 TB), 33553408 (32 TB)
	//
	//  **Cannot be downgraded** -- decreasi...
	StorageMb int32 `json:"storage_mb" jsonschema:"required,The storage size in megabytes. Must be one of the Azure-allowed values: 32768 (32 GB); 65536 (64 GB); 131072 (128 GB); 262144 (256 GB); 524288 (512 GB); 1048576 (1 TB); 2097152 (2 TB); 4194304 (4 TB);..."`
	// Enable storage auto-grow.
	//  When enabled, Azure automatically increases storage when free storage
	//  falls below a threshold. Prevents out-of-storage failures for databases
	//  that grow unpredictably.
	//
	//  Default: false (storage stays at the provisioned size)
	AutoGrowEnabled bool `json:"auto_grow_enabled,omitempty" jsonschema:"Enable storage auto-grow. When enabled; Azure automatically increases storage when free storage falls below a threshold. Prevents out-of-storage failures for databases that grow unpredictably. Default..."`
	// The ID of a subnet delegated to Microsoft.DBforPostgreSQL/flexibleServers.
	//  When set, the server is deployed with **private VNet access** and
	//  public network access is automatically disabled.
	//
	//  The subnet must have the delegation `Microsoft.DBforPostgreSQL/flexibleServers`.
	//  Use the AzureSubnet comp...
	DelegatedSubnetId string `json:"delegated_subnet_id,omitempty" jsonschema:"The ID of a subnet delegated to Microsoft.DBforPostgreSQL/flexibleServers. When set; the server is deployed with **private VNet access** and public network access is automatically disabled. The subnet..."`
	// The ID of a private DNS zone for server name resolution within the VNet.
	//  Typically "privatelink.postgres.database.azure.com" for private access.
	//
	//  When `delegated_subnet_id` is set, providing a private DNS zone enables
	//  VNet-connected clients to resolve the server's FQDN to its private IP.
	PrivateDnsZoneId string `json:"private_dns_zone_id,omitempty" jsonschema:"The ID of a private DNS zone for server name resolution within the VNet. Typically 'privatelink.postgres.database.azure.com' for private access. When 'delegated_subnet_id' is set; providing a private ..."`
	// The availability zone for the primary server.
	//  Valid values: "1", "2", "3". If omitted, Azure selects automatically.
	//
	//  When using ZoneRedundant high availability, the standby is placed in
	//  a different zone from the primary. Set this to control primary placement.
	Zone string `json:"zone,omitempty" jsonschema:"The availability zone for the primary server. Valid values: '1'; '2'; '3'. If omitted; Azure selects automatically. When using ZoneRedundant high availability; the standby is placed in a different zon..."`
	// High availability configuration.
	//  If this message is present, high availability is enabled.
	//  If omitted, the server runs as a single instance (no HA).
	//
	//  Burstable SKUs (B_Standard_*) do NOT support high availability.
	//  General Purpose and Memory Optimized SKUs support both modes.
	HighAvailability *AzurePostgresqlHighAvailabilityInput `json:"high_availability,omitempty" jsonschema:"High availability configuration. If this message is present; high availability is enabled. If omitted; the server runs as a single instance (no HA). Burstable SKUs (B_Standard_*) do NOT support high a..."`
	// The number of days to retain backups.
	//  Azure performs automatic daily backups. This controls how far back
	//  you can restore using point-in-time restore.
	//  Default: 7 days. Range: 7 to 35 days.
	BackupRetentionDays int32 `json:"backup_retention_days,omitempty" jsonschema:"The number of days to retain backups. Azure performs automatic daily backups. This controls how far back you can restore using point-in-time restore. Default: 7 days. Range: 7 to 35 days."`
	// Enable geo-redundant backup storage.
	//  When enabled, backup data is replicated to a paired Azure region,
	//  enabling cross-region restore for disaster recovery.
	//
	//  **ForceNew**: Changing this destroys and recreates the server.
	//  Only available in regions that support geo-redundant storage.
	//  Default: fals...
	GeoRedundantBackupEnabled bool `json:"geo_redundant_backup_enabled,omitempty" jsonschema:"Enable geo-redundant backup storage. When enabled; backup data is replicated to a paired Azure region; enabling cross-region restore for disaster recovery. **ForceNew**: Changing this destroys and rec..."`
	// Databases to create on the server.
	//  Each database is created as a separate `azurerm_postgresql_flexible_server_database`
	//  resource with its own lifecycle.
	//
	//  If omitted, only the default "postgres" database exists (created by Azure
	//  automatically). Most applications create at least one application da...
	Databases []*AzurePostgresqlDatabaseInput `json:"databases,omitempty" jsonschema:"Databases to create on the server. Each database is created as a separate 'azurerm_postgresql_flexible_server_database' resource with its own lifecycle. If omitted; only the default 'postgres' databas..."`
	// Firewall rules for public access mode.
	//  Only effective when `delegated_subnet_id` is NOT set (public access mode).
	//  Each rule allows connections from a range of IP addresses.
	//
	//  To allow all Azure services: start_ip_address = "0.0.0.0", end_ip_address = "0.0.0.0"
	//  To allow a single IP: set both start...
	FirewallRules []*AzurePostgresqlFirewallRuleInput `json:"firewall_rules,omitempty" jsonschema:"Firewall rules for public access mode. Only effective when 'delegated_subnet_id' is NOT set (public access mode). Each rule allows connections from a range of IP addresses. To allow all Azure services..."`
}

func (s *AzurePostgresqlFlexibleServerSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.AdministratorLogin == "" {
		return fmt.Errorf("administrator_login is required")
	}
	if s.AdministratorPassword == "" {
		return fmt.Errorf("administrator_password is required")
	}
	if s.SkuName == "" {
		return fmt.Errorf("sku_name is required")
	}
	if s.HighAvailability != nil {
		if err := s.HighAvailability.validate(); err != nil {
			return fmt.Errorf("high_availability: %w", err)
		}
	}
	for i, v := range s.Databases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("databases[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.FirewallRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("firewall_rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzurePostgresqlFlexibleServerSpecInput) applyDefaults() {
	if s.Version == "" {
		s.Version = "16"
	}
	if s.HighAvailability != nil {
		s.HighAvailability.applyDefaults()
	}
	if s.BackupRetentionDays == 0 {
		s.BackupRetentionDays = 7
	}
}

func (s *AzurePostgresqlFlexibleServerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["administrator_login"] = s.AdministratorLogin
	m["administrator_password"] = s.AdministratorPassword
	if s.Version != "" {
		m["version"] = s.Version
	}
	m["sku_name"] = s.SkuName
	m["storage_mb"] = s.StorageMb
	if s.AutoGrowEnabled {
		m["auto_grow_enabled"] = s.AutoGrowEnabled
	}
	if s.DelegatedSubnetId != "" {
		m["delegated_subnet_id"] = s.DelegatedSubnetId
	}
	if s.PrivateDnsZoneId != "" {
		m["private_dns_zone_id"] = s.PrivateDnsZoneId
	}
	if s.Zone != "" {
		m["zone"] = s.Zone
	}
	if s.HighAvailability != nil {
		m["high_availability"] = s.HighAvailability.toMap()
	}
	if s.BackupRetentionDays != 0 {
		m["backup_retention_days"] = s.BackupRetentionDays
	}
	if s.GeoRedundantBackupEnabled {
		m["geo_redundant_backup_enabled"] = s.GeoRedundantBackupEnabled
	}
	if len(s.Databases) > 0 {
		items := make([]any, len(s.Databases))
		for i, v := range s.Databases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["databases"] = items
	}
	if len(s.FirewallRules) > 0 {
		items := make([]any, len(s.FirewallRules))
		for i, v := range s.FirewallRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["firewall_rules"] = items
	}
	return m
}

// AzurePostgresqlDatabase defines a database to create on the PostgreSQL
//
//	Flexible Server. Each database is a separate Azure resource with its own
//	lifecycle, enabling independent management.
type AzurePostgresqlDatabaseInput struct {
	// The name of the database.
	//  Must be unique within the server.
	//  Allowed characters: letters, numbers, underscores, hyphens.
	Name string `json:"name" jsonschema:"required,The name of the database. Must be unique within the server. Allowed characters: letters; numbers; underscores; hyphens."`
	// The character set for the database.
	//  Default: "UTF8" (recommended for most applications).
	//  Common values: "UTF8", "SQL_ASCII", "LATIN1".
	Charset string `json:"charset,omitempty" jsonschema:"The character set for the database. Default: 'UTF8' (recommended for most applications). Common values: 'UTF8'; 'SQL_ASCII'; 'LATIN1'."`
	// The collation for the database.
	//  Default: "en_US.utf8" (recommended for most applications).
	//  Determines sort order and string comparison behavior.
	Collation string `json:"collation,omitempty" jsonschema:"The collation for the database. Default: 'en_US.utf8' (recommended for most applications). Determines sort order and string comparison behavior."`
}

func (s *AzurePostgresqlDatabaseInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzurePostgresqlDatabaseInput) applyDefaults() {
	if s.Charset == "" {
		s.Charset = "UTF8"
	}
	if s.Collation == "" {
		s.Collation = "en_US.utf8"
	}
}

func (s *AzurePostgresqlDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Charset != "" {
		m["charset"] = s.Charset
	}
	if s.Collation != "" {
		m["collation"] = s.Collation
	}
	return m
}

// AzurePostgresqlFirewallRule defines a firewall rule for public access mode.
//
//	Each rule allows connections from a contiguous range of IPv4 addresses.
type AzurePostgresqlFirewallRuleInput struct {
	// The name of the firewall rule.
	//  Must be unique within the server.
	//  Examples: "allow-office", "allow-azure-services", "allow-dev-machine".
	Name string `json:"name" jsonschema:"required,The name of the firewall rule. Must be unique within the server. Examples: 'allow-office'; 'allow-azure-services'; 'allow-dev-machine'."`
	// The start of the IP address range (inclusive).
	//  Must be a valid IPv4 address.
	//  Use "0.0.0.0" with end "0.0.0.0" to allow all Azure services.
	StartIpAddress string `json:"start_ip_address" jsonschema:"required,The start of the IP address range (inclusive). Must be a valid IPv4 address. Use '0.0.0.0' with end '0.0.0.0' to allow all Azure services."`
	// The end of the IP address range (inclusive).
	//  Must be a valid IPv4 address and >= start_ip_address.
	//  Set equal to start_ip_address for a single IP rule.
	EndIpAddress string `json:"end_ip_address" jsonschema:"required,The end of the IP address range (inclusive). Must be a valid IPv4 address and >= start_ip_address. Set equal to start_ip_address for a single IP rule."`
}

func (s *AzurePostgresqlFirewallRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.StartIpAddress == "" {
		return fmt.Errorf("start_ip_address is required")
	}
	if s.EndIpAddress == "" {
		return fmt.Errorf("end_ip_address is required")
	}
	return nil
}

func (s *AzurePostgresqlFirewallRuleInput) applyDefaults() {
}

func (s *AzurePostgresqlFirewallRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["start_ip_address"] = s.StartIpAddress
	m["end_ip_address"] = s.EndIpAddress
	return m
}

// AzurePostgresqlHighAvailability defines the high availability configuration
//
//	for the PostgreSQL Flexible Server.
//
//	When this message is present on the spec, HA is enabled. Omitting it means
//	the server runs as a single instance.
type AzurePostgresqlHighAvailabilityInput struct {
	// The high availability mode.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "ZoneRedundant" -- Standby in a different availability zone (recommended for production)
	//  - "SameZone" -- Standby in the same zone as primary (lower latency failover)
	//
	//  ZoneRedundant provides pro...
	Mode string `json:"mode" jsonschema:"required,The high availability mode. Uses Azure's exact API values for provider authenticity. Valid values: - 'ZoneRedundant' -- Standby in a different availability zone (recommended for production) - 'SameZon..."`
	// The availability zone for the standby server.
	//  Valid values: "1", "2", "3". If omitted, Azure selects automatically.
	//
	//  Must be different from the primary server's `zone` when using ZoneRedundant mode.
	//  Can only be set during initial creation; updates are not supported.
	StandbyAvailabilityZone string `json:"standby_availability_zone,omitempty" jsonschema:"The availability zone for the standby server. Valid values: '1'; '2'; '3'. If omitted; Azure selects automatically. Must be different from the primary server's 'zone' when using ZoneRedundant mode. Ca..."`
}

func (s *AzurePostgresqlHighAvailabilityInput) validate() error {
	if s.Mode == "" {
		return fmt.Errorf("mode is required")
	}
	return nil
}

func (s *AzurePostgresqlHighAvailabilityInput) applyDefaults() {
}

func (s *AzurePostgresqlHighAvailabilityInput) toMap() map[string]any {
	m := make(map[string]any)
	m["mode"] = s.Mode
	if s.StandbyAvailabilityZone != "" {
		m["standby_availability_zone"] = s.StandbyAvailabilityZone
	}
	return m
}

// ParseAzurePostgresqlFlexibleServer validates and normalizes a AzurePostgresqlFlexibleServer cloud_object.
func ParseAzurePostgresqlFlexibleServer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzurePostgresqlFlexibleServer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzurePostgresqlFlexibleServerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
