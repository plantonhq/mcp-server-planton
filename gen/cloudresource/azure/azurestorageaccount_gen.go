// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// azure-storage-account
type AzureStorageAccountSpecInput struct {
	// The Azure region where the Storage Account will be deployed (e.g., "eastus", "westus2", "westeurope").
	//  This is required as Storage Account is a regional service.
	Region string `json:"region" jsonschema:"required,The Azure region where the Storage Account will be deployed (e.g.; 'eastus'; 'westus2'; 'westeurope'). This is required as Storage Account is a regional service."`
	// The Azure Resource Group where the Storage Account will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Storage Account will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The kind of storage account.
	//  - STORAGE_V2: General-purpose v2 (recommended for most scenarios)
	//  - BLOB_STORAGE: Specialized for blob data (hot/cool/archive tiers)
	//  - BLOCK_BLOB_STORAGE: Premium storage for block blobs and append blobs
	//  - FILE_STORAGE: Premium storage for file shares
	//  Default: STORA...
	AccountKind string `json:"account_kind,omitempty" jsonschema:"enum=STORAGE_V2|BLOB_STORAGE|BLOCK_BLOB_STORAGE|FILE_STORAGE|STORAGE,The kind of storage account. - STORAGE_V2: General-purpose v2 (recommended for most scenarios) - BLOB_STORAGE: Specialized for blob data (hot/cool/archive tiers) - BLOCK_BLOB_STORAGE: Premium storage ..."`
	// The performance tier of the storage account.
	//  - STANDARD: Standard performance backed by HDD
	//  - PREMIUM: Premium performance backed by SSD (only for specific account kinds)
	//  Default: STANDARD
	AccountTier string `json:"account_tier,omitempty" jsonschema:"enum=STANDARD|PREMIUM,The performance tier of the storage account. - STANDARD: Standard performance backed by HDD - PREMIUM: Premium performance backed by SSD (only for specific account kinds) Default: STANDARD"`
	// The replication strategy for the storage account.
	//  - LRS: Locally redundant storage (3 copies in single datacenter)
	//  - ZRS: Zone-redundant storage (3 copies across availability zones)
	//  - GRS: Geo-redundant storage (6 copies: 3 local + 3 in paired region)
	//  - GZRS: Geo-zone-redundant storage (ZRS + ge...
	ReplicationType string `json:"replication_type,omitempty" jsonschema:"enum=LRS|ZRS|GRS|GZRS|RA_GRS|RA_GZRS,The replication strategy for the storage account. - LRS: Locally redundant storage (3 copies in single datacenter) - ZRS: Zone-redundant storage (3 copies across availability zones) - GRS: Geo-redunda..."`
	// The default access tier for blob data.
	//  Only applicable for BlobStorage and StorageV2 account kinds.
	//  - HOT: Optimized for frequently accessed data
	//  - COOL: Optimized for infrequently accessed data (30-day minimum retention)
	//  Default: HOT
	AccessTier string `json:"access_tier,omitempty" jsonschema:"enum=HOT|COOL,The default access tier for blob data. Only applicable for BlobStorage and StorageV2 account kinds. - HOT: Optimized for frequently accessed data - COOL: Optimized for infrequently accessed data (30-d..."`
	// Enable HTTPS traffic only. When true, all requests must use HTTPS.
	//  Strongly recommended for security.
	//  Default: true
	EnableHttpsTrafficOnly bool `json:"enable_https_traffic_only,omitempty" jsonschema:"Enable HTTPS traffic only. When true; all requests must use HTTPS. Strongly recommended for security. Default: true"`
	// Minimum TLS version for incoming requests.
	//  - TLS1_0: TLS 1.0 (not recommended)
	//  - TLS1_1: TLS 1.1 (not recommended)
	//  - TLS1_2: TLS 1.2 (recommended)
	//  Default: TLS1_2
	MinTlsVersion string `json:"min_tls_version,omitempty" jsonschema:"enum=TLS1_0|TLS1_1|TLS1_2,Minimum TLS version for incoming requests. - TLS1_0: TLS 1.0 (not recommended) - TLS1_1: TLS 1.1 (not recommended) - TLS1_2: TLS 1.2 (recommended) Default: TLS1_2"`
	// Network access control configuration for the Storage Account.
	//  Controls who can access the storage from where (public internet, specific IPs, VNets).
	NetworkRules *AzureStorageNetworkRulesInput `json:"network_rules,omitempty" jsonschema:"Network access control configuration for the Storage Account. Controls who can access the storage from where (public internet; specific IPs; VNets)."`
	// Blob service properties configuration.
	BlobProperties *AzureStorageBlobPropertiesInput `json:"blob_properties,omitempty" jsonschema:"Blob service properties configuration."`
	// List of blob containers to create in the storage account.
	Containers []*AzureStorageContainerInput `json:"containers,omitempty" jsonschema:"List of blob containers to create in the storage account."`
}

func (s *AzureStorageAccountSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	switch s.AccountKind {
	case "", "STORAGE_V2", "BLOB_STORAGE", "BLOCK_BLOB_STORAGE", "FILE_STORAGE", "STORAGE":
	default:
		return fmt.Errorf("invalid account_kind: %q", s.AccountKind)
	}
	switch s.AccountTier {
	case "", "STANDARD", "PREMIUM":
	default:
		return fmt.Errorf("invalid account_tier: %q", s.AccountTier)
	}
	switch s.ReplicationType {
	case "", "LRS", "ZRS", "GRS", "GZRS", "RA_GRS", "RA_GZRS":
	default:
		return fmt.Errorf("invalid replication_type: %q", s.ReplicationType)
	}
	switch s.AccessTier {
	case "", "HOT", "COOL":
	default:
		return fmt.Errorf("invalid access_tier: %q", s.AccessTier)
	}
	switch s.MinTlsVersion {
	case "", "TLS1_0", "TLS1_1", "TLS1_2":
	default:
		return fmt.Errorf("invalid min_tls_version: %q", s.MinTlsVersion)
	}
	if s.NetworkRules != nil {
		if err := s.NetworkRules.validate(); err != nil {
			return fmt.Errorf("network_rules: %w", err)
		}
	}
	if s.BlobProperties != nil {
		if err := s.BlobProperties.validate(); err != nil {
			return fmt.Errorf("blob_properties: %w", err)
		}
	}
	for i, v := range s.Containers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("containers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureStorageAccountSpecInput) applyDefaults() {
	if s.AccountKind == "" {
		s.AccountKind = "STORAGE_V2"
	}
	if s.AccountTier == "" {
		s.AccountTier = "STANDARD"
	}
	if s.ReplicationType == "" {
		s.ReplicationType = "LRS"
	}
	if s.AccessTier == "" {
		s.AccessTier = "HOT"
	}
	// default: EnableHttpsTrafficOnly = true (applied at zero-value)
	if s.MinTlsVersion == "" {
		s.MinTlsVersion = "TLS1_2"
	}
	if s.NetworkRules != nil {
		s.NetworkRules.applyDefaults()
	}
	if s.BlobProperties != nil {
		s.BlobProperties.applyDefaults()
	}
}

func (s *AzureStorageAccountSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	if s.AccountKind != "" {
		m["account_kind"] = s.AccountKind
	}
	if s.AccountTier != "" {
		m["account_tier"] = s.AccountTier
	}
	if s.ReplicationType != "" {
		m["replication_type"] = s.ReplicationType
	}
	if s.AccessTier != "" {
		m["access_tier"] = s.AccessTier
	}
	if s.EnableHttpsTrafficOnly {
		m["enable_https_traffic_only"] = s.EnableHttpsTrafficOnly
	}
	if s.MinTlsVersion != "" {
		m["min_tls_version"] = s.MinTlsVersion
	}
	if s.NetworkRules != nil {
		m["network_rules"] = s.NetworkRules.toMap()
	}
	if s.BlobProperties != nil {
		m["blob_properties"] = s.BlobProperties.toMap()
	}
	if len(s.Containers) > 0 {
		items := make([]any, len(s.Containers))
		for i, v := range s.Containers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["containers"] = items
	}
	return m
}

// **AzureStorageBlobProperties** defines blob service properties.
type AzureStorageBlobPropertiesInput struct {
	// Enable versioning for blobs. When enabled, Azure maintains previous versions of blobs.
	//  Useful for data protection and recovery.
	//  Default: false
	EnableVersioning bool `json:"enable_versioning,omitempty" jsonschema:"Enable versioning for blobs. When enabled; Azure maintains previous versions of blobs. Useful for data protection and recovery. Default: false"`
	// Soft delete retention period for blobs in days (1-365 days).
	//  When set, deleted blobs are retained for the specified period and can be recovered.
	//  Set to 0 to disable soft delete.
	//  Default: 7 days
	SoftDeleteRetentionDays int32 `json:"soft_delete_retention_days,omitempty" jsonschema:"Soft delete retention period for blobs in days (1-365 days). When set; deleted blobs are retained for the specified period and can be recovered. Set to 0 to disable soft delete. Default: 7 days"`
	// Soft delete retention period for containers in days (1-365 days).
	//  When set, deleted containers are retained for the specified period and can be recovered.
	//  Set to 0 to disable container soft delete.
	//  Default: 7 days
	ContainerSoftDeleteRetentionDays int32 `json:"container_soft_delete_retention_days,omitempty" jsonschema:"Soft delete retention period for containers in days (1-365 days). When set; deleted containers are retained for the specified period and can be recovered. Set to 0 to disable container soft delete. De..."`
}

func (s *AzureStorageBlobPropertiesInput) validate() error {
	return nil
}

func (s *AzureStorageBlobPropertiesInput) applyDefaults() {
	if s.SoftDeleteRetentionDays == 0 {
		s.SoftDeleteRetentionDays = 7
	}
	if s.ContainerSoftDeleteRetentionDays == 0 {
		s.ContainerSoftDeleteRetentionDays = 7
	}
}

func (s *AzureStorageBlobPropertiesInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EnableVersioning {
		m["enable_versioning"] = s.EnableVersioning
	}
	if s.SoftDeleteRetentionDays != 0 {
		m["soft_delete_retention_days"] = s.SoftDeleteRetentionDays
	}
	if s.ContainerSoftDeleteRetentionDays != 0 {
		m["container_soft_delete_retention_days"] = s.ContainerSoftDeleteRetentionDays
	}
	return m
}

// **AzureStorageContainer** defines a blob container to create.
type AzureStorageContainerInput struct {
	// The name of the container.
	//  Must be lowercase, 3-63 characters, and start with a letter or number.
	Name string `json:"name" jsonschema:"required,The name of the container. Must be lowercase; 3-63 characters; and start with a letter or number."`
	// The access level for the container.
	//  - PRIVATE: No public read access (default, recommended)
	//  - BLOB: Public read access for blobs only
	//  - CONTAINER: Public read access for container and blobs
	//  Default: PRIVATE
	AccessType string `json:"access_type,omitempty" jsonschema:"enum=PRIVATE|BLOB|CONTAINER,The access level for the container. - PRIVATE: No public read access (default; recommended) - BLOB: Public read access for blobs only - CONTAINER: Public read access for container and blobs Default: P..."`
}

func (s *AzureStorageContainerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	switch s.AccessType {
	case "", "PRIVATE", "BLOB", "CONTAINER":
	default:
		return fmt.Errorf("invalid access_type: %q", s.AccessType)
	}
	return nil
}

func (s *AzureStorageContainerInput) applyDefaults() {
	if s.AccessType == "" {
		s.AccessType = "PRIVATE"
	}
}

func (s *AzureStorageContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.AccessType != "" {
		m["access_type"] = s.AccessType
	}
	return m
}

// **AzureStorageNetworkRules** defines network access control rules.
type AzureStorageNetworkRulesInput struct {
	// Default action when no explicit rule matches.
	//  - ALLOW: Permit all traffic (not recommended for production)
	//  - DENY: Block all traffic unless explicitly allowed (recommended)
	//  Default: DENY
	DefaultAction string `json:"default_action,omitempty" jsonschema:"enum=ALLOW|DENY,Default action when no explicit rule matches. - ALLOW: Permit all traffic (not recommended for production) - DENY: Block all traffic unless explicitly allowed (recommended) Default: DENY"`
	// Allow traffic from trusted Azure services even when default_action is DENY.
	//  This includes services like Azure Backup, Azure Monitor, Azure Event Grid, etc.
	//  Default: true
	BypassAzureServices bool `json:"bypass_azure_services,omitempty" jsonschema:"Allow traffic from trusted Azure services even when default_action is DENY. This includes services like Azure Backup; Azure Monitor; Azure Event Grid; etc. Default: true"`
	// List of IP addresses or CIDR ranges allowed to access the storage.
	//  Example: ["203.0.113.0/24", "198.51.100.42"]
	IpRules []string `json:"ip_rules,omitempty" jsonschema:"List of IP addresses or CIDR ranges allowed to access the storage. Example: ['203.0.113.0/24'; '198.51.100.42']"`
	// List of Azure Virtual Network subnet resource IDs allowed to access the storage.
	//  Example: ["/subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/{subnet}"]
	VirtualNetworkSubnetIds []string `json:"virtual_network_subnet_ids,omitempty" jsonschema:"List of Azure Virtual Network subnet resource IDs allowed to access the storage. Example: ['/subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/{subn..."`
}

func (s *AzureStorageNetworkRulesInput) validate() error {
	switch s.DefaultAction {
	case "", "ALLOW", "DENY":
	default:
		return fmt.Errorf("invalid default_action: %q", s.DefaultAction)
	}
	return nil
}

func (s *AzureStorageNetworkRulesInput) applyDefaults() {
	if s.DefaultAction == "" {
		s.DefaultAction = "DENY"
	}
	// default: BypassAzureServices = true (applied at zero-value)
}

func (s *AzureStorageNetworkRulesInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DefaultAction != "" {
		m["default_action"] = s.DefaultAction
	}
	if s.BypassAzureServices {
		m["bypass_azure_services"] = s.BypassAzureServices
	}
	if len(s.IpRules) > 0 {
		m["ip_rules"] = s.IpRules
	}
	if len(s.VirtualNetworkSubnetIds) > 0 {
		m["virtual_network_subnet_ids"] = s.VirtualNetworkSubnetIds
	}
	return m
}

// ParseAzureStorageAccount validates and normalizes a AzureStorageAccount cloud_object.
func ParseAzureStorageAccount(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureStorageAccount"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureStorageAccountSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
