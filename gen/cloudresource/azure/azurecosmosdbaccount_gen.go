// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureCosmosdbAccount is the top-level API resource for an Azure Cosmos DB
//
//	account.
//	Azure Cosmos DB is a globally distributed, multi-model database service
//	supporting SQL/NoSQL and MongoDB APIs with configurable consistency,
//	automatic global distribution, and elastic scalability.
type AzureCosmosdbAccountSpecInput struct {
	// The Azure region where the Cosmos DB account will be created.
	//  This is the primary write region. Additional regions are configured
	//  via `geo_locations`.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the Cosmos DB account will be created. This is the primary write region. Additional regions are configured via 'geo_locations'. Examples: 'eastus'; 'westus2'; 'westeurope'; 'sou..."`
	// The Azure Resource Group where the Cosmos DB account will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Cosmos DB account will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Cosmos DB account.
	//  Must be globally unique across Azure. Used as the account endpoint:
	//  `https://{name}.documents.azure.com:443/`
	//  Allowed characters: lowercase letters, numbers, and hyphens.
	//  Length: 3 to 50 characters.
	//
	//  **ForceNew**: Changing this destroys and recreates the accou...
	Name string `json:"name" jsonschema:"required,The name of the Cosmos DB account. Must be globally unique across Azure. Used as the account endpoint: 'https://{name}.documents.azure.com:443/' Allowed characters: lowercase letters; numbers; and hyp..."`
	// The API kind for the Cosmos DB account.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "GlobalDocumentDB" (default): SQL/NoSQL API -- query JSON documents
	//    with SQL-like syntax. Use `sql_databases` for sub-resources.
	//  - "MongoDB": MongoDB wire-protocol compatible API....
	Kind string `json:"kind,omitempty" jsonschema:"The API kind for the Cosmos DB account. Uses Azure's exact API values for provider authenticity. Valid values: - 'GlobalDocumentDB' (default): SQL/NoSQL API -- query JSON documents with SQL-like synta..."`
	// Consistency policy for the account.
	//  Defines the default consistency level for all reads.
	//  If omitted, defaults to Session consistency (read-your-writes within a
	//  session -- the right default for most applications).
	//
	//  Cosmos DB consistency levels (from strongest to weakest):
	//  1. Strong -- linearizab...
	ConsistencyPolicy *AzureCosmosdbConsistencyPolicyInput `json:"consistency_policy,omitempty" jsonschema:"Consistency policy for the account. Defines the default consistency level for all reads. If omitted; defaults to Session consistency (read-your-writes within a session -- the right default for most ap..."`
	// Geographic locations for the Cosmos DB account.
	//  At least one geo_location is required. The first location with
	//  `failover_priority = 0` is the primary write region and should match
	//  the `region` field.
	//
	//  For single-region deployments, provide one geo_location.
	//  For multi-region, provide multiple wi...
	GeoLocations []*AzureCosmosdbGeoLocationInput `json:"geo_locations,omitempty" jsonschema:"Geographic locations for the Cosmos DB account. At least one geo_location is required. The first location with 'failover_priority = 0' is the primary write region and should match the 'region' field. ..."`
	// Cosmos DB capabilities to enable on the account.
	//  Capabilities customize account behavior and enable specific features.
	//
	//  Common capabilities:
	//  - "EnableServerless" -- serverless mode (pay-per-request, no throughput config)
	//  - "EnableAggregationPipeline" -- MongoDB aggregation pipeline
	//  - "EnableMon...
	Capabilities []string `json:"capabilities,omitempty" jsonschema:"Cosmos DB capabilities to enable on the account. Capabilities customize account behavior and enable specific features. Common capabilities: - 'EnableServerless' -- serverless mode (pay-per-request; no..."`
	// Enable the free tier for this account.
	//  Azure Cosmos DB offers a free tier with 1000 RU/s and 25 GB of storage
	//  per subscription. Only one account per subscription can use the free tier.
	//
	//  **ForceNew**: Changing this destroys and recreates the account.
	//  Default: false
	FreeTierEnabled bool `json:"free_tier_enabled,omitempty" jsonschema:"Enable the free tier for this account. Azure Cosmos DB offers a free tier with 1000 RU/s and 25 GB of storage per subscription. Only one account per subscription can use the free tier. **ForceNew**: C..."`
	// Enable automatic failover when a region goes down.
	//  When enabled, Azure automatically promotes the next region in the
	//  failover priority list to be the write region.
	//
	//  Recommended for any multi-region deployment.
	//  Required when `multiple_write_locations_enabled` is true.
	//
	//  Default: false
	AutomaticFailoverEnabled bool `json:"automatic_failover_enabled,omitempty" jsonschema:"Enable automatic failover when a region goes down. When enabled; Azure automatically promotes the next region in the failover priority list to be the write region. Recommended for any multi-region dep..."`
	// Enable multi-region writes (active-active).
	//  When enabled, all configured regions accept writes. Conflicts are
	//  resolved using the configured conflict resolution policy.
	//
	//  Requires `automatic_failover_enabled` to be true.
	//  Increases cost but enables lowest-latency writes from any region.
	//
	//  Default: ...
	MultipleWriteLocationsEnabled bool `json:"multiple_write_locations_enabled,omitempty" jsonschema:"Enable multi-region writes (active-active). When enabled; all configured regions accept writes. Conflicts are resolved using the configured conflict resolution policy. Requires 'automatic_failover_ena..."`
	// Whether the account is accessible over the public internet.
	//  When false, the account can only be accessed via AzurePrivateEndpoint.
	//
	//  Default: true
	PublicNetworkAccessEnabled bool `json:"public_network_access_enabled,omitempty" jsonschema:"Whether the account is accessible over the public internet. When false; the account can only be accessed via AzurePrivateEndpoint. Default: true"`
	// Enable virtual network filtering.
	//  When enabled, only traffic from allowed virtual networks (defined in
	//  `virtual_network_rules`) can reach the account.
	//
	//  Default: false
	IsVirtualNetworkFilterEnabled bool `json:"is_virtual_network_filter_enabled,omitempty" jsonschema:"Enable virtual network filtering. When enabled; only traffic from allowed virtual networks (defined in 'virtual_network_rules') can reach the account. Default: false"`
	// Virtual network rules for restricting network access.
	//  Only effective when `is_virtual_network_filter_enabled` is true.
	//  Each rule allows traffic from a specific subnet.
	VirtualNetworkRules []*AzureCosmosdbVirtualNetworkRuleInput `json:"virtual_network_rules,omitempty" jsonschema:"Virtual network rules for restricting network access. Only effective when 'is_virtual_network_filter_enabled' is true. Each rule allows traffic from a specific subnet."`
	// IP-based firewall rules.
	//  A set of CIDR ranges or individual IPv4 addresses that are allowed to
	//  access the account. Applied in addition to virtual network rules.
	//
	//  To allow access from the Azure portal, include: "104.42.195.92",
	//  "40.76.54.131", "52.176.6.30", "52.169.50.45", "52.187.184.26"
	//
	//  To a...
	IpRangeFilter []string `json:"ip_range_filter,omitempty" jsonschema:"IP-based firewall rules. A set of CIDR ranges or individual IPv4 addresses that are allowed to access the account. Applied in addition to virtual network rules. To allow access from the Azure portal; ..."`
	// Backup policy configuration.
	//  If omitted, Azure defaults to Periodic backup with geo-redundant storage.
	//
	//  Once set to Continuous, the backup type cannot be changed back to Periodic.
	Backup *AzureCosmosdbBackupPolicyInput `json:"backup,omitempty" jsonschema:"Backup policy configuration. If omitted; Azure defaults to Periodic backup with geo-redundant storage. Once set to Continuous; the backup type cannot be changed back to Periodic."`
	// MongoDB server version.
	//  Only applicable when `kind` is "MongoDB". Ignored for GlobalDocumentDB.
	//
	//  Controls the MongoDB wire protocol version that the account supports.
	//  Applications connecting via MongoDB drivers should use a compatible version.
	//
	//  Valid values: "3.6", "4.0", "4.2", "5.0", "6.0", "7...
	MongoServerVersion string `json:"mongo_server_version,omitempty" jsonschema:"MongoDB server version. Only applicable when 'kind' is 'MongoDB'. Ignored for GlobalDocumentDB. Controls the MongoDB wire protocol version that the account supports. Applications connecting via MongoD..."`
	// SQL API databases and containers.
	//  Only applicable when `kind` is "GlobalDocumentDB" (default).
	//
	//  Each database is a logical namespace for containers. Throughput can be
	//  provisioned at the database level (shared across containers) or at the
	//  container level (dedicated per container).
	//
	//  If omitted, o...
	SqlDatabases []*AzureCosmosdbSqlDatabaseInput `json:"sql_databases,omitempty" jsonschema:"SQL API databases and containers. Only applicable when 'kind' is 'GlobalDocumentDB' (default). Each database is a logical namespace for containers. Throughput can be provisioned at the database level ..."`
	// MongoDB API databases and collections.
	//  Only applicable when `kind` is "MongoDB".
	//
	//  Each database is a logical namespace for collections. Throughput can be
	//  provisioned at the database level (shared across collections) or at the
	//  collection level (dedicated per collection).
	//
	//  If omitted, only the ac...
	MongoDatabases []*AzureCosmosdbMongoDatabaseInput `json:"mongo_databases,omitempty" jsonschema:"MongoDB API databases and collections. Only applicable when 'kind' is 'MongoDB'. Each database is a logical namespace for collections. Throughput can be provisioned at the database level (shared acros..."`
}

func (s *AzureCosmosdbAccountSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ConsistencyPolicy != nil {
		if err := s.ConsistencyPolicy.validate(); err != nil {
			return fmt.Errorf("consistency_policy: %w", err)
		}
	}
	if len(s.GeoLocations) < 1 {
		return fmt.Errorf("geo_locations requires at least 1 items, got %d", len(s.GeoLocations))
	}
	for i, v := range s.GeoLocations {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("geo_locations[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.VirtualNetworkRules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("virtual_network_rules[%d]: %w", i, err)
			}
		}
	}
	if s.Backup != nil {
		if err := s.Backup.validate(); err != nil {
			return fmt.Errorf("backup: %w", err)
		}
	}
	for i, v := range s.SqlDatabases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("sql_databases[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.MongoDatabases {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("mongo_databases[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureCosmosdbAccountSpecInput) applyDefaults() {
	if s.Kind == "" {
		s.Kind = "GlobalDocumentDB"
	}
	if s.ConsistencyPolicy != nil {
		s.ConsistencyPolicy.applyDefaults()
	}
	// default: PublicNetworkAccessEnabled = true (applied at zero-value)
	if s.Backup != nil {
		s.Backup.applyDefaults()
	}
}

func (s *AzureCosmosdbAccountSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.Kind != "" {
		m["kind"] = s.Kind
	}
	if s.ConsistencyPolicy != nil {
		m["consistency_policy"] = s.ConsistencyPolicy.toMap()
	}
	if len(s.GeoLocations) > 0 {
		items := make([]any, len(s.GeoLocations))
		for i, v := range s.GeoLocations {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["geo_locations"] = items
	}
	if len(s.Capabilities) > 0 {
		m["capabilities"] = s.Capabilities
	}
	if s.FreeTierEnabled {
		m["free_tier_enabled"] = s.FreeTierEnabled
	}
	if s.AutomaticFailoverEnabled {
		m["automatic_failover_enabled"] = s.AutomaticFailoverEnabled
	}
	if s.MultipleWriteLocationsEnabled {
		m["multiple_write_locations_enabled"] = s.MultipleWriteLocationsEnabled
	}
	if s.PublicNetworkAccessEnabled {
		m["public_network_access_enabled"] = s.PublicNetworkAccessEnabled
	}
	if s.IsVirtualNetworkFilterEnabled {
		m["is_virtual_network_filter_enabled"] = s.IsVirtualNetworkFilterEnabled
	}
	if len(s.VirtualNetworkRules) > 0 {
		items := make([]any, len(s.VirtualNetworkRules))
		for i, v := range s.VirtualNetworkRules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["virtual_network_rules"] = items
	}
	if len(s.IpRangeFilter) > 0 {
		m["ip_range_filter"] = s.IpRangeFilter
	}
	if s.Backup != nil {
		m["backup"] = s.Backup.toMap()
	}
	if s.MongoServerVersion != "" {
		m["mongo_server_version"] = s.MongoServerVersion
	}
	if len(s.SqlDatabases) > 0 {
		items := make([]any, len(s.SqlDatabases))
		for i, v := range s.SqlDatabases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["sql_databases"] = items
	}
	if len(s.MongoDatabases) > 0 {
		items := make([]any, len(s.MongoDatabases))
		for i, v := range s.MongoDatabases {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["mongo_databases"] = items
	}
	return m
}

// AzureCosmosdbBackupPolicy defines the backup configuration for the account.
//
//	Azure Cosmos DB supports two backup modes:
//	- **Periodic** (default): Backups are taken at regular intervals and retained
//	  for a configurable duration. Storage redundancy can be configured.
//	- **Continuous**: Continuous backups with point-in-time restore capability.
//	  More expensive but allows restoration to any point in time.
//
//	**Important**: Once set to Continuous, the backup type cannot be changed
//	back to Periodic.
type AzureCosmosdbBackupPolicyInput struct {
	// The backup type.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Periodic": Backups at regular intervals (default Azure behavior)
	//  - "Continuous": Continuous backups with point-in-time restore
	Type string `json:"type" jsonschema:"required,The backup type. Uses Azure's exact API values. Valid values: - 'Periodic': Backups at regular intervals (default Azure behavior) - 'Continuous': Continuous backups with point-in-time restore"`
	// Backup interval in minutes.
	//  Only applicable when `type` is "Periodic".
	//  Range: 60 to 1440 (1 hour to 24 hours).
	//
	//  Default: 240 (4 hours) when Periodic
	IntervalInMinutes int32 `json:"interval_in_minutes,omitempty" jsonschema:"Backup interval in minutes. Only applicable when 'type' is 'Periodic'. Range: 60 to 1440 (1 hour to 24 hours). Default: 240 (4 hours) when Periodic"`
	// Backup retention in hours.
	//  Only applicable when `type` is "Periodic".
	//  Range: 8 to 720 (8 hours to 30 days).
	//
	//  Default: 8 when Periodic
	RetentionInHours int32 `json:"retention_in_hours,omitempty" jsonschema:"Backup retention in hours. Only applicable when 'type' is 'Periodic'. Range: 8 to 720 (8 hours to 30 days). Default: 8 when Periodic"`
	// Storage redundancy for backup data.
	//  Only applicable when `type` is "Periodic".
	//
	//  Valid values:
	//  - "Geo": Geo-redundant (default, replicated to paired region)
	//  - "Local": Locally-redundant (stays in same region)
	//  - "Zone": Zone-redundant (across availability zones, same region)
	StorageRedundancy string `json:"storage_redundancy,omitempty" jsonschema:"Storage redundancy for backup data. Only applicable when 'type' is 'Periodic'. Valid values: - 'Geo': Geo-redundant (default; replicated to paired region) - 'Local': Locally-redundant (stays in same r..."`
	// Continuous backup tier.
	//  Only applicable when `type` is "Continuous".
	//
	//  Valid values:
	//  - "Continuous7Days": 7-day point-in-time restore window
	//  - "Continuous30Days": 30-day point-in-time restore window (higher cost)
	Tier string `json:"tier,omitempty" jsonschema:"Continuous backup tier. Only applicable when 'type' is 'Continuous'. Valid values: - 'Continuous7Days': 7-day point-in-time restore window - 'Continuous30Days': 30-day point-in-time restore window (hi..."`
}

func (s *AzureCosmosdbBackupPolicyInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *AzureCosmosdbBackupPolicyInput) applyDefaults() {
}

func (s *AzureCosmosdbBackupPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.IntervalInMinutes != 0 {
		m["interval_in_minutes"] = s.IntervalInMinutes
	}
	if s.RetentionInHours != 0 {
		m["retention_in_hours"] = s.RetentionInHours
	}
	if s.StorageRedundancy != "" {
		m["storage_redundancy"] = s.StorageRedundancy
	}
	if s.Tier != "" {
		m["tier"] = s.Tier
	}
	return m
}

// AzureCosmosdbConsistencyPolicy defines the default consistency policy for
//
//	the Cosmos DB account. Consistency is a per-account setting that applies
//	to all databases and containers.
//
//	The five consistency levels (from strongest to weakest):
//	- "Strong": Linearizable. Reads return the most recent committed write.
//	  Only available in single-region or with single write region.
//	- "BoundedStaleness": Reads lag behind writes by at most K versions or T
//	  seconds. Requires `max_staleness_prefix` and `max_interval_in_seconds`.
//	- "Session": Read-your-writes within a client session. The default and
//	  recommended for most applications.
//	- "ConsistentPrefix": Reads never see out-of-order writes. No staleness
//	  bounds.
//	- "Eventual": No ordering or freshness guarantees. Highest throughput and
//	  lowest latency.
type AzureCosmosdbConsistencyPolicyInput struct {
	// The consistency level.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Default: "Session"
	ConsistencyLevel string `json:"consistency_level,omitempty" jsonschema:"The consistency level. Uses Azure's exact API values for provider authenticity. Default: 'Session'"`
	// Maximum staleness interval in seconds.
	//  Only applicable when `consistency_level` is "BoundedStaleness".
	//  Defines the maximum time lag between writes and reads.
	//
	//  Range: 5 to 86400 (24 hours).
	//  For multi-region accounts with BoundedStaleness, minimum is 300 seconds.
	//
	//  Default: 5
	MaxIntervalInSeconds int32 `json:"max_interval_in_seconds,omitempty" jsonschema:"Maximum staleness interval in seconds. Only applicable when 'consistency_level' is 'BoundedStaleness'. Defines the maximum time lag between writes and reads. Range: 5 to 86400 (24 hours). For multi-re..."`
	// Maximum staleness prefix (number of stale requests tolerated).
	//  Only applicable when `consistency_level` is "BoundedStaleness".
	//  Defines the maximum number of versions (operations) a read can lag behind.
	//
	//  Range: 10 to 2147483647.
	//  For multi-region accounts with BoundedStaleness, minimum is 100000.
	// ...
	MaxStalenessPrefix int32 `json:"max_staleness_prefix,omitempty" jsonschema:"Maximum staleness prefix (number of stale requests tolerated). Only applicable when 'consistency_level' is 'BoundedStaleness'. Defines the maximum number of versions (operations) a read can lag behind..."`
}

func (s *AzureCosmosdbConsistencyPolicyInput) validate() error {
	return nil
}

func (s *AzureCosmosdbConsistencyPolicyInput) applyDefaults() {
	if s.ConsistencyLevel == "" {
		s.ConsistencyLevel = "Session"
	}
	if s.MaxIntervalInSeconds == 0 {
		s.MaxIntervalInSeconds = 5
	}
	if s.MaxStalenessPrefix == 0 {
		s.MaxStalenessPrefix = 100
	}
}

func (s *AzureCosmosdbConsistencyPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ConsistencyLevel != "" {
		m["consistency_level"] = s.ConsistencyLevel
	}
	if s.MaxIntervalInSeconds != 0 {
		m["max_interval_in_seconds"] = s.MaxIntervalInSeconds
	}
	if s.MaxStalenessPrefix != 0 {
		m["max_staleness_prefix"] = s.MaxStalenessPrefix
	}
	return m
}

// AzureCosmosdbGeoLocation defines a geographic region for the Cosmos DB account.
//
//	At least one geo_location with `failover_priority = 0` is required (the
//	primary write region). Additional locations enable reads from closer regions
//	and provide failover capability.
//
//	Failover priorities must be unique and contiguous starting from 0.
//	The maximum failover_priority value must equal the total number of regions
//	minus one.
type AzureCosmosdbGeoLocationInput struct {
	// The Azure region name for this geo-location.
	//  Examples: "eastus", "westeurope", "southeastasia".
	//
	//  The location with `failover_priority = 0` should match the account's
	//  `region` field.
	Location string `json:"location" jsonschema:"required,The Azure region name for this geo-location. Examples: 'eastus'; 'westeurope'; 'southeastasia'. The location with 'failover_priority = 0' should match the account's 'region' field."`
	// The failover priority for this region.
	//  Must be unique across all geo_locations.
	//  `0` = primary write region. Higher numbers = lower priority.
	//
	//  When `automatic_failover_enabled` is true, Azure promotes the next
	//  region in priority order if the current write region fails.
	FailoverPriority int32 `json:"failover_priority,omitempty" jsonschema:"The failover priority for this region. Must be unique across all geo_locations. '0' = primary write region. Higher numbers = lower priority. When 'automatic_failover_enabled' is true; Azure promotes t..."`
	// Enable availability zone redundancy for this region.
	//  When true, data is replicated across availability zones within the region
	//  for higher availability. Not all regions support zone redundancy.
	//
	//  Default: false
	ZoneRedundant bool `json:"zone_redundant,omitempty" jsonschema:"Enable availability zone redundancy for this region. When true; data is replicated across availability zones within the region for higher availability. Not all regions support zone redundancy. Default..."`
}

func (s *AzureCosmosdbGeoLocationInput) validate() error {
	if s.Location == "" {
		return fmt.Errorf("location is required")
	}
	return nil
}

func (s *AzureCosmosdbGeoLocationInput) applyDefaults() {
}

func (s *AzureCosmosdbGeoLocationInput) toMap() map[string]any {
	m := make(map[string]any)
	m["location"] = s.Location
	if s.FailoverPriority != 0 {
		m["failover_priority"] = s.FailoverPriority
	}
	if s.ZoneRedundant {
		m["zone_redundant"] = s.ZoneRedundant
	}
	return m
}

// AzureCosmosdbMongoCollection defines a MongoDB API collection within a
//
//	database. Collections are the MongoDB equivalent of SQL containers.
//
//	The shard key is the MongoDB equivalent of a partition key. It determines
//	how data is distributed across physical partitions. The same design
//	principles apply: high cardinality, even distribution, query alignment.
type AzureCosmosdbMongoCollectionInput struct {
	// The collection name.
	//  Must be unique within the database.
	Name string `json:"name" jsonschema:"required,The collection name. Must be unique within the database."`
	// The shard key for the collection.
	//  Determines how documents are distributed across physical partitions.
	//  This is the MongoDB equivalent of a SQL API partition key.
	//
	//  Examples: "_id", "tenantId", "userId", "region"
	//
	//  Choose a shard key with high cardinality and even distribution.
	ShardKey string `json:"shard_key" jsonschema:"required,The shard key for the collection. Determines how documents are distributed across physical partitions. This is the MongoDB equivalent of a SQL API partition key. Examples: '_id'; 'tenantId'; 'userId';..."`
	// Provisioned throughput in RU/s for this collection (dedicated).
	//  Minimum: 400. Increments of 100.
	Throughput int32 `json:"throughput,omitempty" jsonschema:"Provisioned throughput in RU/s for this collection (dedicated). Minimum: 400. Increments of 100."`
	// Maximum throughput for autoscale in RU/s for this collection.
	//  Minimum: 1000. Increments of 1000.
	AutoscaleMaxThroughput int32 `json:"autoscale_max_throughput,omitempty" jsonschema:"Maximum throughput for autoscale in RU/s for this collection. Minimum: 1000. Increments of 1000."`
	// Default time-to-live in seconds.
	//  When set, documents in this collection automatically expire.
	//  -1 means TTL is enabled but no default expiry (per-document TTL only).
	DefaultTtlSeconds int32 `json:"default_ttl_seconds,omitempty" jsonschema:"Default time-to-live in seconds. When set; documents in this collection automatically expire. -1 means TTL is enabled but no default expiry (per-document TTL only)."`
	// Indexes to create on the collection.
	//  MongoDB automatically creates an index on the `_id` field.
	//  Additional indexes improve query performance for frequently queried fields.
	Indexes []*AzureCosmosdbMongoIndexInput `json:"indexes,omitempty" jsonschema:"Indexes to create on the collection. MongoDB automatically creates an index on the '_id' field. Additional indexes improve query performance for frequently queried fields."`
}

func (s *AzureCosmosdbMongoCollectionInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ShardKey == "" {
		return fmt.Errorf("shard_key is required")
	}
	for i, v := range s.Indexes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("indexes[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureCosmosdbMongoCollectionInput) applyDefaults() {
}

func (s *AzureCosmosdbMongoCollectionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["shard_key"] = s.ShardKey
	if s.Throughput != 0 {
		m["throughput"] = s.Throughput
	}
	if s.AutoscaleMaxThroughput != 0 {
		m["autoscale_max_throughput"] = s.AutoscaleMaxThroughput
	}
	if s.DefaultTtlSeconds != 0 {
		m["default_ttl_seconds"] = s.DefaultTtlSeconds
	}
	if len(s.Indexes) > 0 {
		items := make([]any, len(s.Indexes))
		for i, v := range s.Indexes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["indexes"] = items
	}
	return m
}

// AzureCosmosdbMongoDatabase defines a MongoDB API database within the Cosmos
//
//	DB account. A Mongo database is a logical namespace for collections and a
//	boundary for shared throughput.
//
//	`throughput` and `autoscale_max_throughput` are mutually exclusive.
type AzureCosmosdbMongoDatabaseInput struct {
	// The database name.
	//  Must be unique within the account.
	Name string `json:"name" jsonschema:"required,The database name. Must be unique within the account."`
	// Provisioned throughput in RU/s.
	//  Shared across all collections in this database.
	//  Minimum: 400. Increments of 100.
	Throughput int32 `json:"throughput,omitempty" jsonschema:"Provisioned throughput in RU/s. Shared across all collections in this database. Minimum: 400. Increments of 100."`
	// Maximum throughput for autoscale in RU/s.
	//  Minimum: 1000. Increments of 1000.
	AutoscaleMaxThroughput int32 `json:"autoscale_max_throughput,omitempty" jsonschema:"Maximum throughput for autoscale in RU/s. Minimum: 1000. Increments of 1000."`
	// MongoDB collections within this database.
	Collections []*AzureCosmosdbMongoCollectionInput `json:"collections,omitempty" jsonschema:"MongoDB collections within this database."`
}

func (s *AzureCosmosdbMongoDatabaseInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.Collections {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("collections[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureCosmosdbMongoDatabaseInput) applyDefaults() {
}

func (s *AzureCosmosdbMongoDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Throughput != 0 {
		m["throughput"] = s.Throughput
	}
	if s.AutoscaleMaxThroughput != 0 {
		m["autoscale_max_throughput"] = s.AutoscaleMaxThroughput
	}
	if len(s.Collections) > 0 {
		items := make([]any, len(s.Collections))
		for i, v := range s.Collections {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["collections"] = items
	}
	return m
}

// AzureCosmosdbMongoIndex defines an index on a MongoDB collection.
//
//	Indexes improve query performance by allowing efficient lookups on
//	specific fields.
type AzureCosmosdbMongoIndexInput struct {
	// The field names to include in the index.
	//  For single-field indexes: ["fieldName"]
	//  For compound indexes: ["field1", "field2"]
	Keys []string `json:"keys,omitempty" jsonschema:"The field names to include in the index. For single-field indexes: ['fieldName'] For compound indexes: ['field1'; 'field2']"`
	// Whether the index enforces uniqueness.
	//  When true, the index rejects duplicate values for the indexed fields.
	//
	//  Default: false
	Unique bool `json:"unique,omitempty" jsonschema:"Whether the index enforces uniqueness. When true; the index rejects duplicate values for the indexed fields. Default: false"`
}

func (s *AzureCosmosdbMongoIndexInput) validate() error {
	if len(s.Keys) < 1 {
		return fmt.Errorf("keys requires at least 1 items, got %d", len(s.Keys))
	}
	return nil
}

func (s *AzureCosmosdbMongoIndexInput) applyDefaults() {
}

func (s *AzureCosmosdbMongoIndexInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Keys) > 0 {
		m["keys"] = s.Keys
	}
	if s.Unique {
		m["unique"] = s.Unique
	}
	return m
}

// AzureCosmosdbSqlContainer defines a SQL API container (table) within a
//
//	database. Containers are the fundamental unit of scalability in Cosmos DB.
//
//	The partition key is the single most critical design decision for Cosmos DB
//	performance and cost. Choose a partition key that:
//	- Has high cardinality (many distinct values)
//	- Distributes requests evenly across partitions
//	- Is frequently used in query WHERE clauses
//
//	Common partition key choices: tenantId, userId, deviceId, region.
//	Avoid: timestamp (hot partition), status (low cardinality).
type AzureCosmosdbSqlContainerInput struct {
	// The container name.
	//  Must be unique within the database.
	//  Length: 1 to 255 characters.
	Name string `json:"name" jsonschema:"required,The container name. Must be unique within the database. Length: 1 to 255 characters."`
	// Partition key paths.
	//  At least one path is required. Each path starts with "/" and references
	//  a property in the JSON document.
	//
	//  Single partition key (most common): ["/tenantId"]
	//  Hierarchical partition key (MultiHash): ["/tenantId", "/userId"]
	//
	//  When using multiple paths, set `partition_key_kind` ...
	PartitionKeyPaths []string `json:"partition_key_paths,omitempty" jsonschema:"Partition key paths. At least one path is required. Each path starts with '/' and references a property in the JSON document. Single partition key (most common): ['/tenantId'] Hierarchical partition k..."`
	// Partition key kind.
	//  Determines how the partition key is hashed.
	//
	//  Valid values:
	//  - "Hash" (default): Single partition key path
	//  - "MultiHash": Hierarchical (multi-level) partition key
	//
	//  Use "MultiHash" when `partition_key_paths` has multiple paths.
	PartitionKeyKind string `json:"partition_key_kind,omitempty" jsonschema:"Partition key kind. Determines how the partition key is hashed. Valid values: - 'Hash' (default): Single partition key path - 'MultiHash': Hierarchical (multi-level) partition key Use 'MultiHash' when..."`
	// Provisioned throughput in RU/s for this container (dedicated).
	//  When set, this container uses its own dedicated throughput instead
	//  of sharing the database-level throughput.
	//  Minimum: 400. Increments of 100.
	//
	//  Mutually exclusive with `autoscale_max_throughput`.
	//  Ignored when serverless mode is enabl...
	Throughput int32 `json:"throughput,omitempty" jsonschema:"Provisioned throughput in RU/s for this container (dedicated). When set; this container uses its own dedicated throughput instead of sharing the database-level throughput. Minimum: 400. Increments of ..."`
	// Maximum throughput for autoscale in RU/s for this container.
	//  Minimum: 1000. Increments of 1000.
	//
	//  Mutually exclusive with `throughput`.
	//  Ignored when serverless mode is enabled.
	AutoscaleMaxThroughput int32 `json:"autoscale_max_throughput,omitempty" jsonschema:"Maximum throughput for autoscale in RU/s for this container. Minimum: 1000. Increments of 1000. Mutually exclusive with 'throughput'. Ignored when serverless mode is enabled."`
	// Default time-to-live in seconds.
	//  When set, documents in this container automatically expire after this
	//  duration unless overridden by a per-document TTL.
	//
	//  -1 means TTL is enabled but no default expiry (per-document TTL only).
	//  0 or omitted means TTL is disabled.
	//  Positive value: default expiry in ...
	DefaultTtl int32 `json:"default_ttl,omitempty" jsonschema:"Default time-to-live in seconds. When set; documents in this container automatically expire after this duration unless overridden by a per-document TTL. -1 means TTL is enabled but no default expiry (..."`
}

func (s *AzureCosmosdbSqlContainerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.PartitionKeyPaths) < 1 {
		return fmt.Errorf("partition_key_paths requires at least 1 items, got %d", len(s.PartitionKeyPaths))
	}
	return nil
}

func (s *AzureCosmosdbSqlContainerInput) applyDefaults() {
	if s.PartitionKeyKind == "" {
		s.PartitionKeyKind = "Hash"
	}
}

func (s *AzureCosmosdbSqlContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if len(s.PartitionKeyPaths) > 0 {
		m["partition_key_paths"] = s.PartitionKeyPaths
	}
	if s.PartitionKeyKind != "" {
		m["partition_key_kind"] = s.PartitionKeyKind
	}
	if s.Throughput != 0 {
		m["throughput"] = s.Throughput
	}
	if s.AutoscaleMaxThroughput != 0 {
		m["autoscale_max_throughput"] = s.AutoscaleMaxThroughput
	}
	if s.DefaultTtl != 0 {
		m["default_ttl"] = s.DefaultTtl
	}
	return m
}

// AzureCosmosdbSqlDatabase defines a SQL API database within the Cosmos DB
//
//	account. A SQL database is a logical namespace for containers and a boundary
//	for shared throughput.
//
//	Throughput can be provisioned at the database level (shared across all
//	containers in the database) or at the container level (dedicated). When
//	serverless mode is enabled via capabilities, throughput fields are ignored.
//
//	`throughput` and `autoscale_max_throughput` are mutually exclusive.
type AzureCosmosdbSqlDatabaseInput struct {
	// The database name.
	//  Must be unique within the account.
	//  Length: 1 to 255 characters.
	Name string `json:"name" jsonschema:"required,The database name. Must be unique within the account. Length: 1 to 255 characters."`
	// Provisioned throughput in RU/s (Request Units per second).
	//  Shared across all containers in this database unless a container
	//  has its own dedicated throughput.
	//  Minimum: 400. Increments of 100.
	//
	//  Mutually exclusive with `autoscale_max_throughput`.
	//  Ignored when serverless mode is enabled.
	Throughput int32 `json:"throughput,omitempty" jsonschema:"Provisioned throughput in RU/s (Request Units per second). Shared across all containers in this database unless a container has its own dedicated throughput. Minimum: 400. Increments of 100. Mutually ..."`
	// Maximum throughput for autoscale in RU/s.
	//  Azure automatically scales between 10% of this value and this value.
	//  Minimum: 1000. Increments of 1000.
	//
	//  Mutually exclusive with `throughput`.
	//  Ignored when serverless mode is enabled.
	AutoscaleMaxThroughput int32 `json:"autoscale_max_throughput,omitempty" jsonschema:"Maximum throughput for autoscale in RU/s. Azure automatically scales between 10% of this value and this value. Minimum: 1000. Increments of 1000. Mutually exclusive with 'throughput'. Ignored when ser..."`
	// SQL containers within this database.
	//  Containers are where data is stored. Each container requires a partition
	//  key, which determines how data is distributed across physical partitions.
	Containers []*AzureCosmosdbSqlContainerInput `json:"containers,omitempty" jsonschema:"SQL containers within this database. Containers are where data is stored. Each container requires a partition key; which determines how data is distributed across physical partitions."`
}

func (s *AzureCosmosdbSqlDatabaseInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.Containers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("containers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureCosmosdbSqlDatabaseInput) applyDefaults() {
}

func (s *AzureCosmosdbSqlDatabaseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.Throughput != 0 {
		m["throughput"] = s.Throughput
	}
	if s.AutoscaleMaxThroughput != 0 {
		m["autoscale_max_throughput"] = s.AutoscaleMaxThroughput
	}
	if len(s.Containers) > 0 {
		items := make([]any, len(s.Containers))
		for i, v := range s.Containers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["containers"] = items
	}
	return m
}

// AzureCosmosdbVirtualNetworkRule defines a virtual network rule for
//
//	restricting access to the Cosmos DB account.
type AzureCosmosdbVirtualNetworkRuleInput struct {
	// The subnet ID to allow access from.
	//  The subnet must have the "Microsoft.AzureCosmosDB" service endpoint enabled.
	SubnetId string `json:"subnet_id" jsonschema:"required,The subnet ID to allow access from. The subnet must have the 'Microsoft.AzureCosmosDB' service endpoint enabled."`
}

func (s *AzureCosmosdbVirtualNetworkRuleInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *AzureCosmosdbVirtualNetworkRuleInput) applyDefaults() {
}

func (s *AzureCosmosdbVirtualNetworkRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	return m
}

// ParseAzureCosmosdbAccount validates and normalizes a AzureCosmosdbAccount cloud_object.
func ParseAzureCosmosdbAccount(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureCosmosdbAccount"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureCosmosdbAccountSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
