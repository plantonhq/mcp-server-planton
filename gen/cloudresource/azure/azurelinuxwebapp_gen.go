// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureLinuxWebApp is the top-level API resource for an Azure Linux Web App.
//
//	A web app is a fully managed web hosting platform for running HTTP-based
//	applications, supporting multiple language runtimes (Node.js, Python, .NET,
//	Java, PHP, Ruby, Go) and custom Docker containers.
//
//	It runs on an AzureServicePlan and provides built-in load balancing,
//	auto-scaling, and CI/CD integration.
type AzureLinuxWebAppSpecInput struct {
	// The Azure region where the Web App will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	//
	//  **ForceNew**: Changing this destroys and recreates the web app.
	Region string `json:"region" jsonschema:"required,The Azure region where the Web App will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'. **ForceNew**: Changing this destroys and recreates the web app."`
	// The Azure Resource Group where the Web App will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	//
	//  **ForceNew**: Changing this destroys and recreates the web app.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Web App will be created. Can be a literal string or a reference to an AzureResourceGroup output. **ForceNew**: Changing this destroys and recreates the web app."`
	// The name of the Web App.
	//  Must be globally unique across Azure (it forms the default hostname:
	//  `{name}.azurewebsites.net`).
	//
	//  Allowed characters: alphanumeric and hyphens.
	//  Must start and end with an alphanumeric character.
	//  Length: 2 to 60 characters.
	//
	//  **ForceNew**: Changing this destroys and rec...
	Name string `json:"name" jsonschema:"required,The name of the Web App. Must be globally unique across Azure (it forms the default hostname: '{name}.azurewebsites.net'). Allowed characters: alphanumeric and hyphens. Must start and end with an alph..."`
	// The App Service Plan that provides compute resources for this Web App.
	//  Determines the pricing tier, scale behavior, and available features.
	//
	//  Free/Shared (F1/D1): shared infra, dev/test only
	//  Basic (B1-B3): dedicated compute, manual scaling
	//  Standard (S1-S3): auto-scale, deployment slots
	//  Premium (...
	ServicePlanId string `json:"service_plan_id" jsonschema:"required,The App Service Plan that provides compute resources for this Web App. Determines the pricing tier; scale behavior; and available features. Free/Shared (F1/D1): shared infra; dev/test only Basic (B1-B..."`
	// Site configuration for the Web App.
	//  Contains the application stack (runtime), security settings,
	//  networking behavior, and operational configuration.
	SiteConfig *AzureLinuxWebAppSiteConfigInput `json:"site_config" jsonschema:"required,Site configuration for the Web App. Contains the application stack (runtime); security settings; networking behavior; and operational configuration."`
	// Application settings (environment variables) for the Web App.
	//  Key-value pairs that are available to the application at runtime via
	//  environment variables.
	//
	//  Common use cases: database connection strings, API keys, feature flags,
	//  third-party service configuration.
	AppSettings map[string]string `json:"app_settings,omitempty" jsonschema:"Application settings (environment variables) for the Web App. Key-value pairs that are available to the application at runtime via environment variables. Common use cases: database connection strings;..."`
	// Named connection strings for database and service connections.
	//  Each connection string has a name, type, and value. The type determines
	//  how Azure exposes the connection in the runtime environment.
	//
	//  For most use cases, app_settings is simpler. Use connection_strings when
	//  you need Azure's native co...
	ConnectionStrings []*AzureLinuxWebAppConnectionStringInput `json:"connection_strings,omitempty" jsonschema:"Named connection strings for database and service connections. Each connection string has a name; type; and value. The type determines how Azure exposes the connection in the runtime environment. For ..."`
	// Application Insights connection string for APM telemetry.
	//  When provided, the Web App can be configured to send telemetry
	//  (requests, dependencies, exceptions, traces) to Application Insights.
	//
	//  Uses the connection_string format (not the legacy instrumentation_key).
	ApplicationInsightsConnectionString string `json:"application_insights_connection_string,omitempty" jsonschema:"Application Insights connection string for APM telemetry. When provided; the Web App can be configured to send telemetry (requests; dependencies; exceptions; traces) to Application Insights. Uses the ..."`
	// Enforce HTTPS-only access to the Web App.
	//  When true, all HTTP requests are redirected to HTTPS.
	//
	//  Default: true (secure by default, unlike the Azure API default of false)
	HttpsOnly bool `json:"https_only,omitempty" jsonschema:"Enforce HTTPS-only access to the Web App. When true; all HTTP requests are redirected to HTTPS. Default: true (secure by default; unlike the Azure API default of false)"`
	// Enable or disable public network access to the Web App.
	//  When false, the Web App is only accessible via VNet integration
	//  or Private Endpoints.
	//
	//  Default: true
	PublicNetworkAccessEnabled bool `json:"public_network_access_enabled,omitempty" jsonschema:"Enable or disable public network access to the Web App. When false; the Web App is only accessible via VNet integration or Private Endpoints. Default: true"`
	// Enable or disable the Web App.
	//  When false, the Web App is stopped and does not serve traffic,
	//  but the resource still exists and incurs plan-level costs.
	//  Useful for temporarily disabling an app without deleting it.
	//
	//  Default: true
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable or disable the Web App. When false; the Web App is stopped and does not serve traffic; but the resource still exists and incurs plan-level costs. Useful for temporarily disabling an app without..."`
	// The subnet ID for VNet integration. When provided, the Web App's
	//  outbound traffic routes through this subnet, enabling access to
	//  VNet-connected resources (databases, Redis, etc.) without public endpoints.
	//
	//  The subnet must be delegated to Microsoft.Web/serverFarms.
	//  Not supported on Free (F1) and ...
	VirtualNetworkSubnetId string `json:"virtual_network_subnet_id,omitempty" jsonschema:"The subnet ID for VNet integration. When provided; the Web App's outbound traffic routes through this subnet; enabling access to VNet-connected resources (databases; Redis; etc.) without public endpoi..."`
	// Managed identity configuration for the Web App.
	//  Enables the app to authenticate with Azure services (Key Vault, Storage,
	//  ACR, etc.) without managing credentials.
	//
	//  When identity is configured with SystemAssigned, the web app gets
	//  a system-assigned identity whose principal_id and tenant_id are exp...
	Identity *AzureLinuxWebAppIdentityInput `json:"identity,omitempty" jsonschema:"Managed identity configuration for the Web App. Enables the app to authenticate with Azure services (Key Vault; Storage; ACR; etc.) without managing credentials. When identity is configured with Syste..."`
	// User Assigned Identity ID for accessing Key Vault references.
	//  When the Web App uses Key Vault references in app_settings
	//  (e.g., `@Microsoft.KeyVault(SecretUri=...)`), this identity is used
	//  to authenticate with Key Vault.
	//
	//  If not specified, the system-assigned identity is used.
	KeyVaultReferenceIdentityId string `json:"key_vault_reference_identity_id,omitempty" jsonschema:"User Assigned Identity ID for accessing Key Vault references. When the Web App uses Key Vault references in app_settings (e.g.; '@Microsoft.KeyVault(SecretUri=...)'); this identity is used to authenti..."`
	// Enable client affinity (ARR session affinity) for the Web App.
	//  When true, Azure uses ARR (Application Request Routing) cookies to
	//  route subsequent requests from a client to the same instance. This is
	//  useful for stateful applications that store session data in memory.
	//
	//  For stateless apps (recomme...
	ClientAffinityEnabled bool `json:"client_affinity_enabled,omitempty" jsonschema:"Enable client affinity (ARR session affinity) for the Web App. When true; Azure uses ARR (Application Request Routing) cookies to route subsequent requests from a client to the same instance. This is ..."`
	// Enable client certificate authentication (mutual TLS).
	//  When true, clients must present a valid certificate to access the app.
	//
	//  Default: false
	ClientCertificateEnabled bool `json:"client_certificate_enabled,omitempty" jsonschema:"Enable client certificate authentication (mutual TLS). When true; clients must present a valid certificate to access the app. Default: false"`
	// Client certificate mode when client_certificate_enabled is true.
	//
	//  Valid values:
	//  - "Required": All requests must have a valid client certificate
	//  - "Optional": Certificate is requested but not required
	//  - "OptionalInteractiveUser": Certificate is optional for browser users
	//
	//  Default: "Optional"
	ClientCertificateMode string `json:"client_certificate_mode,omitempty" jsonschema:"Client certificate mode when client_certificate_enabled is true. Valid values: - 'Required': All requests must have a valid client certificate - 'Optional': Certificate is requested but not required -..."`
	// Paths excluded from client certificate validation.
	//  Semicolon-separated list of paths where client certificates are not required.
	//  Example: "/api/health;/api/status"
	ClientCertificateExclusionPaths string `json:"client_certificate_exclusion_paths,omitempty" jsonschema:"Paths excluded from client certificate validation. Semicolon-separated list of paths where client certificates are not required. Example: '/api/health;/api/status'"`
	// Azure Storage Account mounts for the Web App.
	//  Mounts Azure File Shares or Blob containers as directories accessible
	//  to the application code at runtime.
	StorageMounts []*AzureLinuxWebAppStorageMountInput `json:"storage_mounts,omitempty" jsonschema:"Azure Storage Account mounts for the Web App. Mounts Azure File Shares or Blob containers as directories accessible to the application code at runtime."`
	// Logging configuration for the Web App.
	//  Controls application-level logging, HTTP request logging, failed request
	//  tracing, and detailed error messages. Unlike Function Apps where logging
	//  is nested inside site_config, Web App logs are a top-level block.
	Logs *AzureLinuxWebAppLogsInput `json:"logs,omitempty" jsonschema:"Logging configuration for the Web App. Controls application-level logging; HTTP request logging; failed request tracing; and detailed error messages. Unlike Function Apps where logging is nested insid..."`
}

func (s *AzureLinuxWebAppSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ServicePlanId == "" {
		return fmt.Errorf("service_plan_id is required")
	}
	if s.SiteConfig == nil {
		return fmt.Errorf("site_config is required")
	}
	if s.SiteConfig != nil {
		if err := s.SiteConfig.validate(); err != nil {
			return fmt.Errorf("site_config: %w", err)
		}
	}
	for i, v := range s.ConnectionStrings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("connection_strings[%d]: %w", i, err)
			}
		}
	}
	if s.Identity != nil {
		if err := s.Identity.validate(); err != nil {
			return fmt.Errorf("identity: %w", err)
		}
	}
	for i, v := range s.StorageMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("storage_mounts[%d]: %w", i, err)
			}
		}
	}
	if s.Logs != nil {
		if err := s.Logs.validate(); err != nil {
			return fmt.Errorf("logs: %w", err)
		}
	}
	return nil
}

func (s *AzureLinuxWebAppSpecInput) applyDefaults() {
	if s.SiteConfig != nil {
		s.SiteConfig.applyDefaults()
	}
	// default: HttpsOnly = true (applied at zero-value)
	// default: PublicNetworkAccessEnabled = true (applied at zero-value)
	// default: Enabled = true (applied at zero-value)
	if s.Identity != nil {
		s.Identity.applyDefaults()
	}
	if s.ClientCertificateMode == "" {
		s.ClientCertificateMode = "Optional"
	}
	if s.Logs != nil {
		s.Logs.applyDefaults()
	}
}

func (s *AzureLinuxWebAppSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["service_plan_id"] = s.ServicePlanId
	if s.SiteConfig != nil {
		m["site_config"] = s.SiteConfig.toMap()
	}
	if len(s.AppSettings) > 0 {
		m["app_settings"] = s.AppSettings
	}
	if len(s.ConnectionStrings) > 0 {
		items := make([]any, len(s.ConnectionStrings))
		for i, v := range s.ConnectionStrings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["connection_strings"] = items
	}
	if s.ApplicationInsightsConnectionString != "" {
		m["application_insights_connection_string"] = s.ApplicationInsightsConnectionString
	}
	if s.HttpsOnly {
		m["https_only"] = s.HttpsOnly
	}
	if s.PublicNetworkAccessEnabled {
		m["public_network_access_enabled"] = s.PublicNetworkAccessEnabled
	}
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.VirtualNetworkSubnetId != "" {
		m["virtual_network_subnet_id"] = s.VirtualNetworkSubnetId
	}
	if s.Identity != nil {
		m["identity"] = s.Identity.toMap()
	}
	if s.KeyVaultReferenceIdentityId != "" {
		m["key_vault_reference_identity_id"] = s.KeyVaultReferenceIdentityId
	}
	if s.ClientAffinityEnabled {
		m["client_affinity_enabled"] = s.ClientAffinityEnabled
	}
	if s.ClientCertificateEnabled {
		m["client_certificate_enabled"] = s.ClientCertificateEnabled
	}
	if s.ClientCertificateMode != "" {
		m["client_certificate_mode"] = s.ClientCertificateMode
	}
	if s.ClientCertificateExclusionPaths != "" {
		m["client_certificate_exclusion_paths"] = s.ClientCertificateExclusionPaths
	}
	if len(s.StorageMounts) > 0 {
		items := make([]any, len(s.StorageMounts))
		for i, v := range s.StorageMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["storage_mounts"] = items
	}
	if s.Logs != nil {
		m["logs"] = s.Logs.toMap()
	}
	return m
}

// AzureLinuxWebAppApplicationLogs configures application-level logging
//
//	for the Web App. Application logs capture output from the application
//	code (e.g., console.log, logging framework output).
type AzureLinuxWebAppApplicationLogsInput struct {
	// Log level for the file system logger.
	//  Controls which log messages are written to the application log files.
	//
	//  Valid values:
	//  - "Off": No logging
	//  - "Error": Only errors
	//  - "Warning": Errors and warnings
	//  - "Information": Errors, warnings, and informational messages
	//  - "Verbose": All messages includ...
	FileSystemLevel string `json:"file_system_level,omitempty" jsonschema:"Log level for the file system logger. Controls which log messages are written to the application log files. Valid values: - 'Off': No logging - 'Error': Only errors - 'Warning': Errors and warnings - ..."`
}

func (s *AzureLinuxWebAppApplicationLogsInput) validate() error {
	return nil
}

func (s *AzureLinuxWebAppApplicationLogsInput) applyDefaults() {
	if s.FileSystemLevel == "" {
		s.FileSystemLevel = "Error"
	}
}

func (s *AzureLinuxWebAppApplicationLogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.FileSystemLevel != "" {
		m["file_system_level"] = s.FileSystemLevel
	}
	return m
}

// AzureLinuxWebAppApplicationStack defines the runtime for the Web App.
//
//	Exactly one runtime must be specified. This maps to the `application_stack`
//	block within `site_config` in the Terraform provider. The constraint is
//	documented (not enforced via proto) because protobuf lacks native oneOf-with-
//	optional semantics for this pattern.
//
//	Web Apps support a broader set of runtimes compared to Function Apps,
//	including PHP, Ruby, Go, and Java with configurable application servers.
//
//	Runtime options:
//	- .NET: dotnet_version
//	- Node.js: node_version
//	- Python: python_version
//	- PHP: php_version
//	- Ruby: ruby_version (deprecated, limited support)
//	- Go: go_version (deprecated, limited support)
//	- Java: java_version + java_server + java_server_version
//	- Container: docker (registry_url + image_name + image_tag)
type AzureLinuxWebAppApplicationStackInput struct {
	// .NET runtime version.
	//
	//  Valid values: "3.1", "6.0", "7.0", "8.0", "9.0", "10.0"
	DotnetVersion string `json:"dotnet_version,omitempty" jsonschema:".NET runtime version. Valid values: '3.1'; '6.0'; '7.0'; '8.0'; '9.0'; '10.0'"`
	// Node.js runtime version.
	//  Linux Web Apps use the LTS variant identifiers.
	//
	//  Valid values: "12-lts", "14-lts", "16-lts", "18-lts", "20-lts",
	//  "22-lts", "24-lts"
	NodeVersion string `json:"node_version,omitempty" jsonschema:"Node.js runtime version. Linux Web Apps use the LTS variant identifiers. Valid values: '12-lts'; '14-lts'; '16-lts'; '18-lts'; '20-lts'; '22-lts'; '24-lts'"`
	// Python runtime version.
	//
	//  Valid values: "3.7", "3.8", "3.9", "3.10", "3.11", "3.12", "3.13"
	PythonVersion string `json:"python_version,omitempty" jsonschema:"Python runtime version. Valid values: '3.7'; '3.8'; '3.9'; '3.10'; '3.11'; '3.12'; '3.13'"`
	// PHP runtime version.
	//
	//  Valid values: "7.4", "8.0", "8.1", "8.2", "8.3", "8.4"
	PhpVersion string `json:"php_version,omitempty" jsonschema:"PHP runtime version. Valid values: '7.4'; '8.0'; '8.1'; '8.2'; '8.3'; '8.4'"`
	// Ruby runtime version.
	//
	//  **Deprecated**: Ruby support on Azure App Service is limited and
	//  not recommended for new deployments. Consider containerized deployment
	//  via the docker block instead.
	//
	//  Valid values: "2.6", "2.7"
	RubyVersion string `json:"ruby_version,omitempty" jsonschema:"Ruby runtime version. **Deprecated**: Ruby support on Azure App Service is limited and not recommended for new deployments. Consider containerized deployment via the docker block instead. Valid values..."`
	// Go runtime version.
	//
	//  **Deprecated**: Go support on Azure App Service is limited and
	//  not recommended for new deployments. Consider containerized deployment
	//  via the docker block instead.
	//
	//  Valid values: "1.18", "1.19"
	GoVersion string `json:"go_version,omitempty" jsonschema:"Go runtime version. **Deprecated**: Go support on Azure App Service is limited and not recommended for new deployments. Consider containerized deployment via the docker block instead. Valid values: '1..."`
	// Java runtime version.
	//  When using Java, you must also set java_server and java_server_version
	//  to specify the application server.
	//
	//  Valid values: "8", "11", "17", "21"
	//
	//  RequiredWith: java_server, java_server_version
	JavaVersion string `json:"java_version,omitempty" jsonschema:"Java runtime version. When using Java; you must also set java_server and java_server_version to specify the application server. Valid values: '8'; '11'; '17'; '21' RequiredWith: java_server; java_serv..."`
	// Java application server type.
	//  Specifies the servlet container or application server runtime.
	//
	//  Valid values:
	//  - "JAVA": Java SE (embedded server, e.g., Spring Boot executable JAR)
	//  - "TOMCAT": Apache Tomcat servlet container
	//  - "JBOSSEAP": Red Hat JBoss EAP application server
	//
	//  RequiredWith: java_v...
	JavaServer string `json:"java_server,omitempty" jsonschema:"Java application server type. Specifies the servlet container or application server runtime. Valid values: - 'JAVA': Java SE (embedded server; e.g.; Spring Boot executable JAR) - 'TOMCAT': Apache Tomc..."`
	// Java application server version.
	//  The valid values depend on the selected java_server:
	//
	//  JAVA: "8", "11", "17", "21" (SE version, typically matches java_version)
	//  TOMCAT: "8.5", "9.0", "10.0", "10.1" (and minor versions)
	//  JBOSSEAP: "7", "7.4", "8.0" (and minor versions)
	//
	//  No CEL whitelist is applied...
	JavaServerVersion string `json:"java_server_version,omitempty" jsonschema:"Java application server version. The valid values depend on the selected java_server: JAVA: '8'; '11'; '17'; '21' (SE version; typically matches java_version) TOMCAT: '8.5'; '9.0'; '10.0'; '10.1' (and..."`
	// Docker container configuration.
	//  Runs a custom container image as the Web App runtime.
	//  Any web server that listens on the configured port (default 8080)
	//  can be deployed as a containerized Web App.
	Docker *AzureLinuxWebAppDockerConfigInput `json:"docker,omitempty" jsonschema:"Docker container configuration. Runs a custom container image as the Web App runtime. Any web server that listens on the configured port (default 8080) can be deployed as a containerized Web App."`
}

func (s *AzureLinuxWebAppApplicationStackInput) validate() error {
	if s.Docker != nil {
		if err := s.Docker.validate(); err != nil {
			return fmt.Errorf("docker: %w", err)
		}
	}
	return nil
}

func (s *AzureLinuxWebAppApplicationStackInput) applyDefaults() {
	if s.Docker != nil {
		s.Docker.applyDefaults()
	}
}

func (s *AzureLinuxWebAppApplicationStackInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DotnetVersion != "" {
		m["dotnet_version"] = s.DotnetVersion
	}
	if s.NodeVersion != "" {
		m["node_version"] = s.NodeVersion
	}
	if s.PythonVersion != "" {
		m["python_version"] = s.PythonVersion
	}
	if s.PhpVersion != "" {
		m["php_version"] = s.PhpVersion
	}
	if s.RubyVersion != "" {
		m["ruby_version"] = s.RubyVersion
	}
	if s.GoVersion != "" {
		m["go_version"] = s.GoVersion
	}
	if s.JavaVersion != "" {
		m["java_version"] = s.JavaVersion
	}
	if s.JavaServer != "" {
		m["java_server"] = s.JavaServer
	}
	if s.JavaServerVersion != "" {
		m["java_server_version"] = s.JavaServerVersion
	}
	if s.Docker != nil {
		m["docker"] = s.Docker.toMap()
	}
	return m
}

// AzureLinuxWebAppConnectionString defines a named connection string
//
//	for the Web App. Connection strings are exposed to the application via
//	environment variables with a prefix based on the type.
type AzureLinuxWebAppConnectionStringInput struct {
	// The name of the connection string.
	Name string `json:"name" jsonschema:"required,The name of the connection string."`
	// The type of connection string. Determines the environment variable prefix.
	//
	//  Valid values: MySQL, SQLServer, SQLAzure, Custom, NotificationHub,
	//  ServiceBus, EventHub, APIHub, DocDb, RedisCache, PostgreSQL
	Type string `json:"type" jsonschema:"required,The type of connection string. Determines the environment variable prefix. Valid values: MySQL; SQLServer; SQLAzure; Custom; NotificationHub; ServiceBus; EventHub; APIHub; DocDb; RedisCache; PostgreSQ..."`
	// The connection string value. This is a sensitive credential.
	//  Can be a literal value or a reference to a secrets manager.
	Value string `json:"value" jsonschema:"required,The connection string value. This is a sensitive credential. Can be a literal value or a reference to a secrets manager."`
}

func (s *AzureLinuxWebAppConnectionStringInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AzureLinuxWebAppConnectionStringInput) applyDefaults() {
}

func (s *AzureLinuxWebAppConnectionStringInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["type"] = s.Type
	m["value"] = s.Value
	return m
}

// AzureLinuxWebAppCorsSettings configures Cross-Origin Resource Sharing
//
//	for the Web App's HTTP endpoints.
type AzureLinuxWebAppCorsSettingsInput struct {
	// List of origins allowed to make cross-origin requests.
	//  Use "*" to allow all origins (not recommended for production).
	//  Example: ["https://myapp.example.com", "https://admin.example.com"]
	AllowedOrigins []string `json:"allowed_origins,omitempty" jsonschema:"List of origins allowed to make cross-origin requests. Use '*' to allow all origins (not recommended for production). Example: ['https://myapp.example.com'; 'https://admin.example.com']"`
	// Allow credentials (cookies, authorization headers) in cross-origin requests.
	//  Cannot be used with allowed_origins = ["*"].
	//
	//  Default: false
	SupportCredentials bool `json:"support_credentials,omitempty" jsonschema:"Allow credentials (cookies; authorization headers) in cross-origin requests. Cannot be used with allowed_origins = ['*']. Default: false"`
}

func (s *AzureLinuxWebAppCorsSettingsInput) validate() error {
	if len(s.AllowedOrigins) < 1 {
		return fmt.Errorf("allowed_origins requires at least 1 items, got %d", len(s.AllowedOrigins))
	}
	return nil
}

func (s *AzureLinuxWebAppCorsSettingsInput) applyDefaults() {
}

func (s *AzureLinuxWebAppCorsSettingsInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AllowedOrigins) > 0 {
		m["allowed_origins"] = s.AllowedOrigins
	}
	if s.SupportCredentials {
		m["support_credentials"] = s.SupportCredentials
	}
	return m
}

// AzureLinuxWebAppDockerConfig defines the container configuration for
//
//	running the Web App as a custom Docker container.
//
//	The container image must run a web server that listens on the port
//	specified by the WEBSITES_PORT environment variable (default: 8080).
type AzureLinuxWebAppDockerConfigInput struct {
	// The URL of the container registry.
	//  Examples: "https://myregistry.azurecr.io", "https://ghcr.io"
	RegistryUrl string `json:"registry_url" jsonschema:"required,The URL of the container registry. Examples: 'https://myregistry.azurecr.io'; 'https://ghcr.io'"`
	// The container image name (without tag).
	//  Example: "myorg/my-web-app"
	ImageName string `json:"image_name" jsonschema:"required,The container image name (without tag). Example: 'myorg/my-web-app'"`
	// The container image tag.
	//  Example: "latest", "v1.2.3", "sha-abc123"
	ImageTag string `json:"image_tag" jsonschema:"required,The container image tag. Example: 'latest'; 'v1.2.3'; 'sha-abc123'"`
	// Username for authenticating with the container registry.
	//  Not needed when using managed identity for ACR authentication
	//  (set container_registry_use_managed_identity in site_config).
	RegistryUsername string `json:"registry_username,omitempty" jsonschema:"Username for authenticating with the container registry. Not needed when using managed identity for ACR authentication (set container_registry_use_managed_identity in site_config)."`
	// Password for authenticating with the container registry.
	//  This is a sensitive credential. Provide directly or via StringValueOrRef.
	//
	//  Not needed when using managed identity for ACR authentication.
	RegistryPassword string `json:"registry_password,omitempty" jsonschema:"Password for authenticating with the container registry. This is a sensitive credential. Provide directly or via StringValueOrRef. Not needed when using managed identity for ACR authentication."`
}

func (s *AzureLinuxWebAppDockerConfigInput) validate() error {
	if s.RegistryUrl == "" {
		return fmt.Errorf("registry_url is required")
	}
	if s.ImageName == "" {
		return fmt.Errorf("image_name is required")
	}
	if s.ImageTag == "" {
		return fmt.Errorf("image_tag is required")
	}
	return nil
}

func (s *AzureLinuxWebAppDockerConfigInput) applyDefaults() {
}

func (s *AzureLinuxWebAppDockerConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["registry_url"] = s.RegistryUrl
	m["image_name"] = s.ImageName
	m["image_tag"] = s.ImageTag
	if s.RegistryUsername != "" {
		m["registry_username"] = s.RegistryUsername
	}
	if s.RegistryPassword != "" {
		m["registry_password"] = s.RegistryPassword
	}
	return m
}

// AzureLinuxWebAppHttpLogs configures HTTP request/response logging
//
//	for the Web App. HTTP logs capture details about incoming requests
//	and outgoing responses, useful for traffic analysis and debugging.
type AzureLinuxWebAppHttpLogsInput struct {
	// Maximum size of HTTP log files in megabytes.
	//  When the total log size exceeds this limit, the oldest log files
	//  are automatically deleted.
	//
	//  Range: 25 to 100 MB.
	//
	//  Default: 35
	RetentionInMb int32 `json:"retention_in_mb,omitempty" jsonschema:"Maximum size of HTTP log files in megabytes. When the total log size exceeds this limit; the oldest log files are automatically deleted. Range: 25 to 100 MB. Default: 35"`
	// Number of days to retain HTTP log files.
	//  Set to 0 for indefinite retention (limited only by retention_in_mb).
	//
	//  Default: 0 (indefinite, limited by disk quota)
	RetentionInDays int32 `json:"retention_in_days,omitempty" jsonschema:"Number of days to retain HTTP log files. Set to 0 for indefinite retention (limited only by retention_in_mb). Default: 0 (indefinite; limited by disk quota)"`
}

func (s *AzureLinuxWebAppHttpLogsInput) validate() error {
	return nil
}

func (s *AzureLinuxWebAppHttpLogsInput) applyDefaults() {
	if s.RetentionInMb == 0 {
		s.RetentionInMb = 35
	}
	if s.RetentionInDays == 0 {
		s.RetentionInDays = 0
	}
}

func (s *AzureLinuxWebAppHttpLogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RetentionInMb != 0 {
		m["retention_in_mb"] = s.RetentionInMb
	}
	if s.RetentionInDays != 0 {
		m["retention_in_days"] = s.RetentionInDays
	}
	return m
}

// AzureLinuxWebAppIdentity configures managed identity for the Web App.
//
//	Managed identities eliminate the need to manage credentials for
//	authenticating with Azure services. The identity is automatically managed
//	by Azure AD and can be assigned RBAC roles on Azure resources.
//
//	Follows the same pattern as AzureFunctionAppIdentity.
type AzureLinuxWebAppIdentityInput struct {
	// Identity type.
	//  "SystemAssigned": Azure-managed identity tied to the Web App lifecycle.
	//  "UserAssigned": Pre-created identity with independent lifecycle.
	//  "SystemAssigned,UserAssigned": Both identity types.
	Type string `json:"type" jsonschema:"required,Identity type. 'SystemAssigned': Azure-managed identity tied to the Web App lifecycle. 'UserAssigned': Pre-created identity with independent lifecycle. 'SystemAssigned;UserAssigned': Both identity typ..."`
	// User Assigned Identity Azure resource IDs.
	//  Required when type includes "UserAssigned".
	//
	//  Can be literal ARM resource IDs or references to AzureUserAssignedIdentity outputs.
	IdentityIds []string `json:"identity_ids,omitempty" jsonschema:"User Assigned Identity Azure resource IDs. Required when type includes 'UserAssigned'. Can be literal ARM resource IDs or references to AzureUserAssignedIdentity outputs."`
}

func (s *AzureLinuxWebAppIdentityInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *AzureLinuxWebAppIdentityInput) applyDefaults() {
}

func (s *AzureLinuxWebAppIdentityInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if len(s.IdentityIds) > 0 {
		m["identity_ids"] = s.IdentityIds
	}
	return m
}

// AzureLinuxWebAppIpRestriction defines an IP-based access restriction rule.
//
//	Rules are evaluated in priority order (lower number = higher priority).
//
//	Exactly one of ip_address, service_tag, or virtual_network_subnet_id
//	must be specified per rule.
type AzureLinuxWebAppIpRestrictionInput struct {
	// Rule name for identification.
	Name string `json:"name,omitempty" jsonschema:"Rule name for identification."`
	// Rule priority. Lower numbers are evaluated first.
	//  Range: 1 to 65000.
	Priority int32 `json:"priority,omitempty" jsonschema:"Rule priority. Lower numbers are evaluated first. Range: 1 to 65000."`
	// Action to take when the rule matches.
	//
	//  Valid values: "Allow", "Deny"
	//
	//  Default: "Allow"
	Action string `json:"action,omitempty" jsonschema:"Action to take when the rule matches. Valid values: 'Allow'; 'Deny' Default: 'Allow'"`
	// IP address or CIDR range.
	//  Example: "10.0.0.0/24", "203.0.113.50/32"
	IpAddress string `json:"ip_address,omitempty" jsonschema:"IP address or CIDR range. Example: '10.0.0.0/24'; '203.0.113.50/32'"`
	// Azure service tag.
	//  Example: "AzureFrontDoor.Backend", "AzureCloud.WestUS"
	ServiceTag string `json:"service_tag,omitempty" jsonschema:"Azure service tag. Example: 'AzureFrontDoor.Backend'; 'AzureCloud.WestUS'"`
	// Subnet ID for VNet-based access control.
	//  Traffic from this subnet is allowed/denied based on the action.
	VirtualNetworkSubnetId string `json:"virtual_network_subnet_id,omitempty" jsonschema:"Subnet ID for VNet-based access control. Traffic from this subnet is allowed/denied based on the action."`
	// Human-readable description of the rule.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the rule."`
	// HTTP header filters for the rule.
	//  Used with Azure Front Door or other reverse proxies to restrict
	//  access based on request headers.
	Headers *AzureLinuxWebAppIpRestrictionHeadersInput `json:"headers,omitempty" jsonschema:"HTTP header filters for the rule. Used with Azure Front Door or other reverse proxies to restrict access based on request headers."`
}

func (s *AzureLinuxWebAppIpRestrictionInput) validate() error {
	if s.Headers != nil {
		if err := s.Headers.validate(); err != nil {
			return fmt.Errorf("headers: %w", err)
		}
	}
	return nil
}

func (s *AzureLinuxWebAppIpRestrictionInput) applyDefaults() {
	if s.Action == "" {
		s.Action = "Allow"
	}
	if s.Headers != nil {
		s.Headers.applyDefaults()
	}
}

func (s *AzureLinuxWebAppIpRestrictionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.IpAddress != "" {
		m["ip_address"] = s.IpAddress
	}
	if s.ServiceTag != "" {
		m["service_tag"] = s.ServiceTag
	}
	if s.VirtualNetworkSubnetId != "" {
		m["virtual_network_subnet_id"] = s.VirtualNetworkSubnetId
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Headers != nil {
		m["headers"] = s.Headers.toMap()
	}
	return m
}

// AzureLinuxWebAppIpRestrictionHeaders defines header-based filters for
//
//	IP restriction rules. Used primarily with Azure Front Door to ensure
//	traffic comes through the CDN rather than directly to the Web App.
type AzureLinuxWebAppIpRestrictionHeadersInput struct {
	// X-Forwarded-For header values to match.
	//  Up to 8 entries. CIDR ranges are supported.
	XForwardedFor []string `json:"x_forwarded_for,omitempty" jsonschema:"X-Forwarded-For header values to match. Up to 8 entries. CIDR ranges are supported."`
	// X-Forwarded-Host header values to match.
	//  Up to 8 entries.
	XForwardedHost []string `json:"x_forwarded_host,omitempty" jsonschema:"X-Forwarded-Host header values to match. Up to 8 entries."`
	// X-Azure-FDID (Front Door ID) header values to match.
	//  Up to 8 entries. Used to ensure traffic comes from your specific
	//  Front Door instance.
	XAzureFdid []string `json:"x_azure_fdid,omitempty" jsonschema:"X-Azure-FDID (Front Door ID) header values to match. Up to 8 entries. Used to ensure traffic comes from your specific Front Door instance."`
	// X-FD-HealthProbe header values to match.
	//  Used to allow Front Door health probe traffic.
	XFdHealthProbe []string `json:"x_fd_health_probe,omitempty" jsonschema:"X-FD-HealthProbe header values to match. Used to allow Front Door health probe traffic."`
}

func (s *AzureLinuxWebAppIpRestrictionHeadersInput) validate() error {
	return nil
}

func (s *AzureLinuxWebAppIpRestrictionHeadersInput) applyDefaults() {
}

func (s *AzureLinuxWebAppIpRestrictionHeadersInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.XForwardedFor) > 0 {
		m["x_forwarded_for"] = s.XForwardedFor
	}
	if len(s.XForwardedHost) > 0 {
		m["x_forwarded_host"] = s.XForwardedHost
	}
	if len(s.XAzureFdid) > 0 {
		m["x_azure_fdid"] = s.XAzureFdid
	}
	if len(s.XFdHealthProbe) > 0 {
		m["x_fd_health_probe"] = s.XFdHealthProbe
	}
	return m
}

// AzureLinuxWebAppLogs configures the logging behavior for the Web App.
//
//	Unlike Function Apps where logging is nested inside site_config as
//	app_service_logs, Web App logs are a top-level block on the resource
//	with richer configuration options including application logs, HTTP logs,
//	failed request tracing, and detailed error messages.
type AzureLinuxWebAppLogsInput struct {
	// Application-level logging configuration.
	//  Controls the verbosity of application logs written to the file system.
	ApplicationLogs *AzureLinuxWebAppApplicationLogsInput `json:"application_logs,omitempty" jsonschema:"Application-level logging configuration. Controls the verbosity of application logs written to the file system."`
	// HTTP request logging configuration.
	//  Controls retention and storage limits for HTTP request/response logs.
	HttpLogs *AzureLinuxWebAppHttpLogsInput `json:"http_logs,omitempty" jsonschema:"HTTP request logging configuration. Controls retention and storage limits for HTTP request/response logs."`
	// Enable failed request tracing.
	//  When true, Azure captures detailed traces for failed HTTP requests
	//  (status code >= 400), including the request pipeline stages, timing,
	//  and any errors. Useful for diagnosing intermittent failures.
	//
	//  Default: false
	FailedRequestTracing bool `json:"failed_request_tracing,omitempty" jsonschema:"Enable failed request tracing. When true; Azure captures detailed traces for failed HTTP requests (status code >= 400); including the request pipeline stages; timing; and any errors. Useful for diagno..."`
	// Enable detailed error messages in HTTP error responses.
	//  When true, the Web App returns detailed error pages for HTTP errors
	//  instead of generic error pages. Useful for development and debugging.
	//
	//  **Security note**: Disable in production to avoid leaking internal
	//  implementation details in error re...
	DetailedErrorMessages bool `json:"detailed_error_messages,omitempty" jsonschema:"Enable detailed error messages in HTTP error responses. When true; the Web App returns detailed error pages for HTTP errors instead of generic error pages. Useful for development and debugging. **Secu..."`
}

func (s *AzureLinuxWebAppLogsInput) validate() error {
	if s.ApplicationLogs != nil {
		if err := s.ApplicationLogs.validate(); err != nil {
			return fmt.Errorf("application_logs: %w", err)
		}
	}
	if s.HttpLogs != nil {
		if err := s.HttpLogs.validate(); err != nil {
			return fmt.Errorf("http_logs: %w", err)
		}
	}
	return nil
}

func (s *AzureLinuxWebAppLogsInput) applyDefaults() {
	if s.ApplicationLogs != nil {
		s.ApplicationLogs.applyDefaults()
	}
	if s.HttpLogs != nil {
		s.HttpLogs.applyDefaults()
	}
}

func (s *AzureLinuxWebAppLogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ApplicationLogs != nil {
		m["application_logs"] = s.ApplicationLogs.toMap()
	}
	if s.HttpLogs != nil {
		m["http_logs"] = s.HttpLogs.toMap()
	}
	if s.FailedRequestTracing {
		m["failed_request_tracing"] = s.FailedRequestTracing
	}
	if s.DetailedErrorMessages {
		m["detailed_error_messages"] = s.DetailedErrorMessages
	}
	return m
}

// AzureLinuxWebAppSiteConfig defines the site-level configuration for a
//
//	Linux Web App. This maps to the `site_config` block in the Terraform
//	azurerm_linux_web_app resource.
//
//	Contains the application stack (runtime selection), scaling settings,
//	security configuration, networking behavior, and operational controls.
type AzureLinuxWebAppSiteConfigInput struct {
	// The application stack defines the runtime for the Web App.
	//  Exactly one runtime must be specified: dotnet_version, node_version,
	//  python_version, php_version, ruby_version, go_version, java_version
	//  (with java_server + java_server_version), or docker.
	ApplicationStack *AzureLinuxWebAppApplicationStackInput `json:"application_stack,omitempty" jsonschema:"The application stack defines the runtime for the Web App. Exactly one runtime must be specified: dotnet_version; node_version; python_version; php_version; ruby_version; go_version; java_version (wit..."`
	// Keep the Web App always loaded in memory.
	//  When true, the app is never unloaded due to inactivity.
	//
	//  Critical for Standard and Premium plans -- without this, the app
	//  may be unloaded after idle periods, causing cold start latency.
	//
	//  Not supported on Free (F1) tier.
	AlwaysOn bool `json:"always_on,omitempty" jsonschema:"Keep the Web App always loaded in memory. When true; the app is never unloaded due to inactivity. Critical for Standard and Premium plans -- without this; the app may be unloaded after idle periods; c..."`
	// Custom startup command for the Web App.
	//  Overrides the default startup behavior. Useful for custom Docker
	//  containers or runtimes that need specific initialization.
	//  Example: "gunicorn --bind=0.0.0.0 --timeout 600 app:app"
	AppCommandLine string `json:"app_command_line,omitempty" jsonschema:"Custom startup command for the Web App. Overrides the default startup behavior. Useful for custom Docker containers or runtimes that need specific initialization. Example: 'gunicorn --bind=0.0.0.0 --t..."`
	// Health check endpoint path.
	//  Azure periodically sends requests to this path and marks the instance
	//  as unhealthy if it doesn't respond with a 200-299 status code.
	//  Unhealthy instances are removed from the load balancer rotation.
	//
	//  Recommended for production deployments. Common paths: "/health",
	//  "/h...
	HealthCheckPath string `json:"health_check_path,omitempty" jsonschema:"Health check endpoint path. Azure periodically sends requests to this path and marks the instance as unhealthy if it doesn't respond with a 200-299 status code. Unhealthy instances are removed from th..."`
	// Time in minutes after which an unhealthy instance is evicted.
	//  Azure monitors the health check path and removes instances that
	//  have been continuously unhealthy for this duration.
	//
	//  Range: 2 to 10 minutes.
	HealthCheckEvictionTimeInMin int32 `json:"health_check_eviction_time_in_min,omitempty" jsonschema:"Time in minutes after which an unhealthy instance is evicted. Azure monitors the health check path and removes instances that have been continuously unhealthy for this duration. Range: 2 to 10 minutes..."`
	// Minimum TLS version for incoming HTTPS requests.
	//
	//  Valid values: "1.0", "1.1", "1.2", "1.3"
	//
	//  Default: "1.2" (industry standard; "1.3" for maximum security)
	MinimumTlsVersion string `json:"minimum_tls_version,omitempty" jsonschema:"Minimum TLS version for incoming HTTPS requests. Valid values: '1.0'; '1.1'; '1.2'; '1.3' Default: '1.2' (industry standard; '1.3' for maximum security)"`
	// Minimum TLS version for SCM (Kudu) site.
	//
	//  Default: "1.2"
	ScmMinimumTlsVersion string `json:"scm_minimum_tls_version,omitempty" jsonschema:"Minimum TLS version for SCM (Kudu) site. Default: '1.2'"`
	// FTPS state for the Web App.
	//  Controls whether FTP/FTPS file deployment is allowed.
	//
	//  Valid values:
	//  - "AllAllowed": Both FTP and FTPS are enabled
	//  - "FtpsOnly": Only FTPS (encrypted) is enabled
	//  - "Disabled": FTP/FTPS is completely disabled (recommended)
	//
	//  Default: "Disabled" (secure by default)
	FtpsState string `json:"ftps_state,omitempty" jsonschema:"FTPS state for the Web App. Controls whether FTP/FTPS file deployment is allowed. Valid values: - 'AllAllowed': Both FTP and FTPS are enabled - 'FtpsOnly': Only FTPS (encrypted) is enabled - 'Disabled..."`
	// Number of worker instances for the Web App.
	//  Controls how many instances are allocated.
	//
	//  Range: 1-100.
	WorkerCount int32 `json:"worker_count,omitempty" jsonschema:"Number of worker instances for the Web App. Controls how many instances are allocated. Range: 1-100."`
	// Enable HTTP/2 protocol for the Web App.
	//  HTTP/2 provides multiplexing, header compression, and server push
	//  for improved performance.
	//
	//  Default: false
	Http2Enabled bool `json:"http2_enabled,omitempty" jsonschema:"Enable HTTP/2 protocol for the Web App. HTTP/2 provides multiplexing; header compression; and server push for improved performance. Default: false"`
	// Enable WebSocket connections for the Web App.
	//
	//  Default: false
	WebsocketsEnabled bool `json:"websockets_enabled,omitempty" jsonschema:"Enable WebSocket connections for the Web App. Default: false"`
	// Use a 32-bit worker process instead of 64-bit.
	//  Reduces memory footprint but limits addressable memory to ~2 GB.
	//
	//  Note: The Azure provider defaults to true, but OpenMCF overrides
	//  this to false. 64-bit workers are recommended for production.
	//
	//  Default: false (opinionated override; Azure provider de...
	Use32BitWorker bool `json:"use_32_bit_worker,omitempty" jsonschema:"Use a 32-bit worker process instead of 64-bit. Reduces memory footprint but limits addressable memory to ~2 GB. Note: The Azure provider defaults to true; but OpenMCF overrides this to false. 64-bit w..."`
	// Route all outbound traffic from the Web App through the VNet.
	//  Requires virtual_network_subnet_id to be set on the spec.
	//
	//  When false (default), only RFC1918 traffic routes through the VNet.
	//  When true, all outbound traffic (including public internet) routes
	//  through the VNet, enabling inspection vi...
	VnetRouteAllEnabled bool `json:"vnet_route_all_enabled,omitempty" jsonschema:"Route all outbound traffic from the Web App through the VNet. Requires virtual_network_subnet_id to be set on the spec. When false (default); only RFC1918 traffic routes through the VNet. When true; a..."`
	// Load balancing mode for distributing requests across instances.
	//
	//  Valid values: LeastRequests, WeightedRoundRobin, LeastResponseTime,
	//  WeightedTotalTraffic, RequestHash, PerSiteRoundRobin
	//
	//  Default: "LeastRequests"
	LoadBalancingMode string `json:"load_balancing_mode,omitempty" jsonschema:"Load balancing mode for distributing requests across instances. Valid values: LeastRequests; WeightedRoundRobin; LeastResponseTime; WeightedTotalTraffic; RequestHash; PerSiteRoundRobin Default: 'Least..."`
	// CORS (Cross-Origin Resource Sharing) configuration.
	//  Controls which origins are allowed to make cross-origin requests to
	//  the Web App's HTTP endpoints.
	Cors *AzureLinuxWebAppCorsSettingsInput `json:"cors,omitempty" jsonschema:"CORS (Cross-Origin Resource Sharing) configuration. Controls which origins are allowed to make cross-origin requests to the Web App's HTTP endpoints."`
	// IP restriction rules for the main site.
	//  Controls which IP addresses, service tags, or subnets can access
	//  the Web App.
	IpRestrictions []*AzureLinuxWebAppIpRestrictionInput `json:"ip_restrictions,omitempty" jsonschema:"IP restriction rules for the main site. Controls which IP addresses; service tags; or subnets can access the Web App."`
	// Default action for IP restrictions on the main site.
	//  When "Allow", unlisted IPs are allowed (rules are deny-list).
	//  When "Deny", unlisted IPs are denied (rules are allow-list).
	//
	//  Default: "Allow"
	IpRestrictionDefaultAction string `json:"ip_restriction_default_action,omitempty" jsonschema:"Default action for IP restrictions on the main site. When 'Allow'; unlisted IPs are allowed (rules are deny-list). When 'Deny'; unlisted IPs are denied (rules are allow-list). Default: 'Allow'"`
	// Use the main site's IP restrictions for the SCM (Kudu) site.
	//  When true, scm_ip_restrictions are ignored.
	//
	//  Default: false
	ScmUseMainIpRestriction bool `json:"scm_use_main_ip_restriction,omitempty" jsonschema:"Use the main site's IP restrictions for the SCM (Kudu) site. When true; scm_ip_restrictions are ignored. Default: false"`
	// IP restriction rules for the SCM (Kudu) site.
	//  Only used when scm_use_main_ip_restriction is false.
	ScmIpRestrictions []*AzureLinuxWebAppIpRestrictionInput `json:"scm_ip_restrictions,omitempty" jsonschema:"IP restriction rules for the SCM (Kudu) site. Only used when scm_use_main_ip_restriction is false."`
	// Default action for IP restrictions on the SCM site.
	//
	//  Default: "Allow"
	ScmIpRestrictionDefaultAction string `json:"scm_ip_restriction_default_action,omitempty" jsonschema:"Default action for IP restrictions on the SCM site. Default: 'Allow'"`
	// Use managed identity for pulling container images from Azure Container Registry.
	//  Requires the Web App's identity to have AcrPull role on the registry.
	//
	//  Default: false
	ContainerRegistryUseManagedIdentity bool `json:"container_registry_use_managed_identity,omitempty" jsonschema:"Use managed identity for pulling container images from Azure Container Registry. Requires the Web App's identity to have AcrPull role on the registry. Default: false"`
	// Client ID of the managed identity used for ACR image pulls.
	//  Only used when container_registry_use_managed_identity is true and
	//  a user-assigned identity (not system-assigned) should be used.
	ContainerRegistryManagedIdentityClientId string `json:"container_registry_managed_identity_client_id,omitempty" jsonschema:"Client ID of the managed identity used for ACR image pulls. Only used when container_registry_use_managed_identity is true and a user-assigned identity (not system-assigned) should be used."`
}

func (s *AzureLinuxWebAppSiteConfigInput) validate() error {
	if s.ApplicationStack != nil {
		if err := s.ApplicationStack.validate(); err != nil {
			return fmt.Errorf("application_stack: %w", err)
		}
	}
	if s.Cors != nil {
		if err := s.Cors.validate(); err != nil {
			return fmt.Errorf("cors: %w", err)
		}
	}
	for i, v := range s.IpRestrictions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ip_restrictions[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ScmIpRestrictions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("scm_ip_restrictions[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureLinuxWebAppSiteConfigInput) applyDefaults() {
	if s.ApplicationStack != nil {
		s.ApplicationStack.applyDefaults()
	}
	if s.MinimumTlsVersion == "" {
		s.MinimumTlsVersion = "1.2"
	}
	if s.ScmMinimumTlsVersion == "" {
		s.ScmMinimumTlsVersion = "1.2"
	}
	if s.FtpsState == "" {
		s.FtpsState = "Disabled"
	}
	if s.LoadBalancingMode == "" {
		s.LoadBalancingMode = "LeastRequests"
	}
	if s.Cors != nil {
		s.Cors.applyDefaults()
	}
	if s.IpRestrictionDefaultAction == "" {
		s.IpRestrictionDefaultAction = "Allow"
	}
	if s.ScmIpRestrictionDefaultAction == "" {
		s.ScmIpRestrictionDefaultAction = "Allow"
	}
}

func (s *AzureLinuxWebAppSiteConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ApplicationStack != nil {
		m["application_stack"] = s.ApplicationStack.toMap()
	}
	if s.AlwaysOn {
		m["always_on"] = s.AlwaysOn
	}
	if s.AppCommandLine != "" {
		m["app_command_line"] = s.AppCommandLine
	}
	if s.HealthCheckPath != "" {
		m["health_check_path"] = s.HealthCheckPath
	}
	if s.HealthCheckEvictionTimeInMin != 0 {
		m["health_check_eviction_time_in_min"] = s.HealthCheckEvictionTimeInMin
	}
	if s.MinimumTlsVersion != "" {
		m["minimum_tls_version"] = s.MinimumTlsVersion
	}
	if s.ScmMinimumTlsVersion != "" {
		m["scm_minimum_tls_version"] = s.ScmMinimumTlsVersion
	}
	if s.FtpsState != "" {
		m["ftps_state"] = s.FtpsState
	}
	if s.WorkerCount != 0 {
		m["worker_count"] = s.WorkerCount
	}
	if s.Http2Enabled {
		m["http2_enabled"] = s.Http2Enabled
	}
	if s.WebsocketsEnabled {
		m["websockets_enabled"] = s.WebsocketsEnabled
	}
	if s.Use32BitWorker {
		m["use_32_bit_worker"] = s.Use32BitWorker
	}
	if s.VnetRouteAllEnabled {
		m["vnet_route_all_enabled"] = s.VnetRouteAllEnabled
	}
	if s.LoadBalancingMode != "" {
		m["load_balancing_mode"] = s.LoadBalancingMode
	}
	if s.Cors != nil {
		m["cors"] = s.Cors.toMap()
	}
	if len(s.IpRestrictions) > 0 {
		items := make([]any, len(s.IpRestrictions))
		for i, v := range s.IpRestrictions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ip_restrictions"] = items
	}
	if s.IpRestrictionDefaultAction != "" {
		m["ip_restriction_default_action"] = s.IpRestrictionDefaultAction
	}
	if s.ScmUseMainIpRestriction {
		m["scm_use_main_ip_restriction"] = s.ScmUseMainIpRestriction
	}
	if len(s.ScmIpRestrictions) > 0 {
		items := make([]any, len(s.ScmIpRestrictions))
		for i, v := range s.ScmIpRestrictions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["scm_ip_restrictions"] = items
	}
	if s.ScmIpRestrictionDefaultAction != "" {
		m["scm_ip_restriction_default_action"] = s.ScmIpRestrictionDefaultAction
	}
	if s.ContainerRegistryUseManagedIdentity {
		m["container_registry_use_managed_identity"] = s.ContainerRegistryUseManagedIdentity
	}
	if s.ContainerRegistryManagedIdentityClientId != "" {
		m["container_registry_managed_identity_client_id"] = s.ContainerRegistryManagedIdentityClientId
	}
	return m
}

// AzureLinuxWebAppStorageMount defines an Azure Storage mount for
//
//	the Web App. Mounts Azure File Shares or Blob containers as
//	directories accessible to application code at runtime.
type AzureLinuxWebAppStorageMountInput struct {
	// Unique name for this mount within the Web App.
	Name string `json:"name" jsonschema:"required,Unique name for this mount within the Web App."`
	// Storage type.
	//
	//  Valid values:
	//  - "AzureBlob": Mount an Azure Blob container (read-only)
	//  - "AzureFiles": Mount an Azure File Share (read-write)
	Type string `json:"type" jsonschema:"required,Storage type. Valid values: - 'AzureBlob': Mount an Azure Blob container (read-only) - 'AzureFiles': Mount an Azure File Share (read-write)"`
	// Name of the Azure Storage Account that contains the share or container.
	AccountName string `json:"account_name" jsonschema:"required,Name of the Azure Storage Account that contains the share or container."`
	// Name of the file share or blob container to mount.
	ShareName string `json:"share_name" jsonschema:"required,Name of the file share or blob container to mount."`
	// Access key for the storage account.
	//  This is a sensitive credential.
	AccessKey string `json:"access_key" jsonschema:"required,Access key for the storage account. This is a sensitive credential."`
	// Path inside the container where the share is mounted.
	//  Example: "/mnt/data"
	MountPath string `json:"mount_path,omitempty" jsonschema:"Path inside the container where the share is mounted. Example: '/mnt/data'"`
}

func (s *AzureLinuxWebAppStorageMountInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.AccountName == "" {
		return fmt.Errorf("account_name is required")
	}
	if s.ShareName == "" {
		return fmt.Errorf("share_name is required")
	}
	if s.AccessKey == "" {
		return fmt.Errorf("access_key is required")
	}
	return nil
}

func (s *AzureLinuxWebAppStorageMountInput) applyDefaults() {
}

func (s *AzureLinuxWebAppStorageMountInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["type"] = s.Type
	m["account_name"] = s.AccountName
	m["share_name"] = s.ShareName
	m["access_key"] = s.AccessKey
	if s.MountPath != "" {
		m["mount_path"] = s.MountPath
	}
	return m
}

// ParseAzureLinuxWebApp validates and normalizes a AzureLinuxWebApp cloud_object.
func ParseAzureLinuxWebApp(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureLinuxWebApp"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureLinuxWebAppSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
