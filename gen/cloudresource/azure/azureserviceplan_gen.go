// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureServicePlan is the top-level API resource for an Azure App Service Plan.
//
//	An App Service Plan defines the compute resources (region, VM size, instance
//	count, pricing tier) that host Azure Web Apps, Function Apps, and Logic Apps.
type AzureServicePlanSpecInput struct {
	// The Azure region where the Service Plan will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	//
	//  **ForceNew**: Changing this destroys and recreates the plan.
	Region string `json:"region" jsonschema:"required,The Azure region where the Service Plan will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'. **ForceNew**: Changing this destroys and recreates the plan."`
	// The Azure Resource Group where the Service Plan will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	//
	//  **ForceNew**: Changing this destroys and recreates the plan.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Service Plan will be created. Can be a literal string or a reference to an AzureResourceGroup output. **ForceNew**: Changing this destroys and recreates the plan."`
	// The name of the Service Plan.
	//  Allowed characters: alphanumeric, hyphens, and underscores.
	//  Length: 1 to 60 characters.
	//
	//  This name appears in the Azure portal and CLI. It does not need to be
	//  globally unique (uniqueness is scoped to the resource group).
	//
	//  **ForceNew**: Changing this destroys and re...
	Name string `json:"name" jsonschema:"required,The name of the Service Plan. Allowed characters: alphanumeric; hyphens; and underscores. Length: 1 to 60 characters. This name appears in the Azure portal and CLI. It does not need to be globally uni..."`
	// The operating system type for the plan.
	//  Uses Azure's exact API values for provider authenticity.
	//
	//  Valid values:
	//  - "Linux" (default): Runs Linux-based web apps and function apps.
	//    Sets `reserved = true` in the Azure API.
	//  - "Windows": Runs Windows-based web apps and function apps.
	//    Sets `reser...
	OsType string `json:"os_type,omitempty" jsonschema:"The operating system type for the plan. Uses Azure's exact API values for provider authenticity. Valid values: - 'Linux' (default): Runs Linux-based web apps and function apps. Sets 'reserved = true' ..."`
	// The SKU name that determines the pricing tier and compute capacity.
	//
	//  Common SKUs by category:
	//    Free/Shared: "F1", "D1"
	//    Basic:       "B1", "B2", "B3"
	//    Standard:    "S1", "S2", "S3"
	//    Premium v3:  "P1v3", "P2v3", "P3v3"
	//    Consumption: "Y1" (for Azure Functions pay-per-execution)
	//    Elastic: ...
	SkuName string `json:"sku_name" jsonschema:"required,The SKU name that determines the pricing tier and compute capacity. Common SKUs by category: Free/Shared: 'F1'; 'D1' Basic: 'B1'; 'B2'; 'B3' Standard: 'S1'; 'S2'; 'S3' Premium v3: 'P1v3'; 'P2v3'; 'P3v..."`
	// Number of VM instances (workers) allocated to the plan.
	//  Minimum: 1.
	//
	//  If not specified, Azure defaults to the SKU's default capacity (typically 1).
	//  When `zone_balancing_enabled` is true, set this to a multiple of the
	//  number of availability zones in the region (typically 3) for even distribution.
	// ...
	WorkerCount int32 `json:"worker_count,omitempty" jsonschema:"Number of VM instances (workers) allocated to the plan. Minimum: 1. If not specified; Azure defaults to the SKU's default capacity (typically 1). When 'zone_balancing_enabled' is true; set this to a m..."`
	// Enable availability zone balancing for the plan.
	//  Distributes instances across availability zones for higher resilience.
	//
	//  Only supported on: Premium (v2/v3), Elastic Premium (EP*), Isolated v2,
	//  and Workflow (WS*) SKUs.
	//  **Not supported on**: Free (F1), Shared (D1), Basic (B*), Standard (S*).
	//
	//  Whe...
	ZoneBalancingEnabled bool `json:"zone_balancing_enabled,omitempty" jsonschema:"Enable availability zone balancing for the plan. Distributes instances across availability zones for higher resilience. Only supported on: Premium (v2/v3); Elastic Premium (EP*); Isolated v2; and Work..."`
	// Enable per-site scaling, allowing individual apps within the plan
	//  to scale independently of the plan's overall instance count.
	//
	//  Supported on Standard and above SKUs. Not supported on Free, Shared,
	//  Basic, Consumption (Y1), or Elastic Premium (EP*) SKUs.
	//
	//  Default: false
	PerSiteScalingEnabled bool `json:"per_site_scaling_enabled,omitempty" jsonschema:"Enable per-site scaling; allowing individual apps within the plan to scale independently of the plan's overall instance count. Supported on Standard and above SKUs. Not supported on Free; Shared; Basi..."`
	// Maximum number of elastic workers for the plan.
	//
	//  Only applicable to:
	//  - Elastic Premium SKUs (EP1, EP2, EP3): Controls the upper bound on
	//    how many workers the plan can scale to when handling events. This is
	//    the primary cost control lever for serverless Function App workloads.
	//    Default: 20, ...
	MaximumElasticWorkerCount int32 `json:"maximum_elastic_worker_count,omitempty" jsonschema:"Maximum number of elastic workers for the plan. Only applicable to: - Elastic Premium SKUs (EP1; EP2; EP3): Controls the upper bound on how many workers the plan can scale to when handling events. Thi..."`
}

func (s *AzureServicePlanSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.SkuName == "" {
		return fmt.Errorf("sku_name is required")
	}
	return nil
}

func (s *AzureServicePlanSpecInput) applyDefaults() {
	if s.OsType == "" {
		s.OsType = "Linux"
	}
}

func (s *AzureServicePlanSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.OsType != "" {
		m["os_type"] = s.OsType
	}
	m["sku_name"] = s.SkuName
	if s.WorkerCount != 0 {
		m["worker_count"] = s.WorkerCount
	}
	if s.ZoneBalancingEnabled {
		m["zone_balancing_enabled"] = s.ZoneBalancingEnabled
	}
	if s.PerSiteScalingEnabled {
		m["per_site_scaling_enabled"] = s.PerSiteScalingEnabled
	}
	if s.MaximumElasticWorkerCount != 0 {
		m["maximum_elastic_worker_count"] = s.MaximumElasticWorkerCount
	}
	return m
}

// ParseAzureServicePlan validates and normalizes a AzureServicePlan cloud_object.
func ParseAzureServicePlan(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureServicePlan"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureServicePlanSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
