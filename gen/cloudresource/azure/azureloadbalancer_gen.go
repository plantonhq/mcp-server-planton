// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureLoadBalancer is the top-level API resource for an Azure Load Balancer.
//
//	Azure Load Balancer is a Layer 4 (TCP/UDP) load balancer that distributes
//	traffic across healthy backend instances using health probes and configurable
//	routing rules. Supports both public and internal configurations.
type AzureLoadBalancerSpecInput struct {
	// The Azure region where the Load Balancer will be created.
	//  Must match the region of the backend resources (VMs, VMSS, AKS).
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the Load Balancer will be created. Must match the region of the backend resources (VMs; VMSS; AKS). Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the Load Balancer will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Load Balancer will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the Load Balancer.
	//  Must be unique within the resource group.
	//  Allowed characters: alphanumeric, underscores, hyphens, and periods.
	//  Must start with alphanumeric. Length: 1 to 80 characters.
	Name string `json:"name" jsonschema:"required,The name of the Load Balancer. Must be unique within the resource group. Allowed characters: alphanumeric; underscores; hyphens; and periods. Must start with alphanumeric. Length: 1 to 80 characters."`
	// The ID of a public IP address to use for the frontend configuration.
	//  Set this for a **public (internet-facing)** load balancer.
	//  Mutually exclusive with `subnet_id` -- exactly one must be set.
	//
	//  Can be a literal Azure resource ID or a reference to an AzurePublicIp output.
	//  The referenced public IP ...
	PublicIpId string `json:"public_ip_id,omitempty" jsonschema:"The ID of a public IP address to use for the frontend configuration. Set this for a **public (internet-facing)** load balancer. Mutually exclusive with 'subnet_id' -- exactly one must be set. Can be a..."`
	// The ID of a subnet to use for the frontend configuration.
	//  Set this for an **internal (private VNet)** load balancer.
	//  Mutually exclusive with `public_ip_id` -- exactly one must be set.
	//
	//  Can be a literal Azure resource ID or a reference to an AzureSubnet output.
	SubnetId string `json:"subnet_id,omitempty" jsonschema:"The ID of a subnet to use for the frontend configuration. Set this for an **internal (private VNet)** load balancer. Mutually exclusive with 'public_ip_id' -- exactly one must be set. Can be a literal..."`
	// Optional static private IP address for an internal load balancer.
	//  Only valid when `subnet_id` is set. The IP must fall within the subnet's
	//  address range.
	//
	//  If omitted, Azure dynamically allocates a private IP from the subnet.
	//  Use a static IP when DNS resolution, firewall rules, or service discove...
	PrivateIpAddress string `json:"private_ip_address,omitempty" jsonschema:"Optional static private IP address for an internal load balancer. Only valid when 'subnet_id' is set. The IP must fall within the subnet's address range. If omitted; Azure dynamically allocates a priv..."`
	// Backend address pools that receive load-balanced traffic.
	//  At least one pool is required. Each pool is created as a separate
	//  `azurerm_lb_backend_address_pool` resource.
	//
	//  Pool membership (adding VMs, VMSS instances, or NICs) is managed outside
	//  this component -- via AKS node pools, VMSS configurati...
	BackendPools []*AzureBackendPoolInput `json:"backend_pools,omitempty" jsonschema:"Backend address pools that receive load-balanced traffic. At least one pool is required. Each pool is created as a separate 'azurerm_lb_backend_address_pool' resource. Pool membership (adding VMs; VMS..."`
	// Health probes that check backend instance availability.
	//  At least one probe is required. Each probe is created as a separate resource.
	//
	//  Probes run at `interval_in_seconds` intervals. After `number_of_probes`
	//  consecutive failures, the backend is marked unhealthy and removed from
	//  the rotation. Heal...
	HealthProbes []*AzureHealthProbeInput `json:"health_probes,omitempty" jsonschema:"Health probes that check backend instance availability. At least one probe is required. Each probe is created as a separate resource. Probes run at 'interval_in_seconds' intervals. After 'number_of_pr..."`
	// Load balancing rules that define how traffic is routed from the frontend
	//  to backend pools. At least one rule is required.
	//
	//  Each rule maps a frontend port/protocol combination to a backend pool
	//  and health probe. The frontend IP configuration name is auto-derived
	//  from `metadata.name` (as "{name}-f...
	Rules []*AzureLoadBalancingRuleInput `json:"rules,omitempty" jsonschema:"Load balancing rules that define how traffic is routed from the frontend to backend pools. At least one rule is required. Each rule maps a frontend port/protocol combination to a backend pool and heal..."`
}

func (s *AzureLoadBalancerSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(s.BackendPools) < 1 {
		return fmt.Errorf("backend_pools requires at least 1 items, got %d", len(s.BackendPools))
	}
	for i, v := range s.BackendPools {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("backend_pools[%d]: %w", i, err)
			}
		}
	}
	if len(s.HealthProbes) < 1 {
		return fmt.Errorf("health_probes requires at least 1 items, got %d", len(s.HealthProbes))
	}
	for i, v := range s.HealthProbes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("health_probes[%d]: %w", i, err)
			}
		}
	}
	if len(s.Rules) < 1 {
		return fmt.Errorf("rules requires at least 1 items, got %d", len(s.Rules))
	}
	for i, v := range s.Rules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rules[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureLoadBalancerSpecInput) applyDefaults() {
}

func (s *AzureLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if s.PublicIpId != "" {
		m["public_ip_id"] = s.PublicIpId
	}
	if s.SubnetId != "" {
		m["subnet_id"] = s.SubnetId
	}
	if s.PrivateIpAddress != "" {
		m["private_ip_address"] = s.PrivateIpAddress
	}
	if len(s.BackendPools) > 0 {
		items := make([]any, len(s.BackendPools))
		for i, v := range s.BackendPools {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["backend_pools"] = items
	}
	if len(s.HealthProbes) > 0 {
		items := make([]any, len(s.HealthProbes))
		for i, v := range s.HealthProbes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["health_probes"] = items
	}
	if len(s.Rules) > 0 {
		items := make([]any, len(s.Rules))
		for i, v := range s.Rules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rules"] = items
	}
	return m
}

// AzureBackendPool defines a backend address pool on the load balancer.
//
//	Pools are named containers that hold references to backend instances.
//	The actual instance membership is managed externally (via VMSS, AKS, or NIC binding).
type AzureBackendPoolInput struct {
	// The name of the backend pool.
	//  Must be unique within the load balancer. Used by load balancing rules
	//  to target traffic to this pool.
	//  Examples: "default", "web-servers", "api-pool".
	Name string `json:"name" jsonschema:"required,The name of the backend pool. Must be unique within the load balancer. Used by load balancing rules to target traffic to this pool. Examples: 'default'; 'web-servers'; 'api-pool'."`
}

func (s *AzureBackendPoolInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

func (s *AzureBackendPoolInput) applyDefaults() {
}

func (s *AzureBackendPoolInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	return m
}

// AzureLoadBalancingRule defines how traffic arriving at the frontend is
//
//	distributed to a backend pool. Each rule maps a frontend port/protocol
//	to a backend port and references a health probe for backend health checks.
type AzureLoadBalancingRuleInput struct {
	// The name of the load balancing rule.
	//  Must be unique within the load balancer.
	//  Examples: "http-rule", "https-rule", "tcp-3306-rule".
	Name string `json:"name" jsonschema:"required,The name of the load balancing rule. Must be unique within the load balancer. Examples: 'http-rule'; 'https-rule'; 'tcp-3306-rule'."`
	// The transport protocol for the rule.
	//  Uses Azure's exact API values.
	//
	//  Valid values:
	//  - "Tcp" -- TCP traffic
	//  - "Udp" -- UDP traffic
	//  - "All" -- all protocols (HA ports rule, requires frontend_port = 0 and backend_port = 0)
	Protocol string `json:"protocol" jsonschema:"required,The transport protocol for the rule. Uses Azure's exact API values. Valid values: - 'Tcp' -- TCP traffic - 'Udp' -- UDP traffic - 'All' -- all protocols (HA ports rule; requires frontend_port = 0 and ..."`
	// The port on the frontend (public IP or internal IP) that receives traffic.
	//  Range: 0 to 65534. Use 0 for HA ports (protocol "All").
	FrontendPort int32 `json:"frontend_port,omitempty" jsonschema:"The port on the frontend (public IP or internal IP) that receives traffic. Range: 0 to 65534. Use 0 for HA ports (protocol 'All')."`
	// The port on the backend instances that receives forwarded traffic.
	//  Range: 0 to 65535. Use 0 for HA ports (protocol "All").
	BackendPort int32 `json:"backend_port,omitempty" jsonschema:"The port on the backend instances that receives forwarded traffic. Range: 0 to 65535. Use 0 for HA ports (protocol 'All')."`
	// The name of the backend pool to route traffic to.
	//  Must match a pool name defined in `backend_pools`.
	BackendPoolName string `json:"backend_pool_name" jsonschema:"required,The name of the backend pool to route traffic to. Must match a pool name defined in 'backend_pools'."`
	// The name of the health probe to use for backend health checks.
	//  Must match a probe name defined in `health_probes`.
	ProbeName string `json:"probe_name" jsonschema:"required,The name of the health probe to use for backend health checks. Must match a probe name defined in 'health_probes'."`
	// The TCP idle timeout in minutes. Connections idle longer than this are closed.
	//  Default: 4 minutes. Range: 4 to 100 minutes.
	//  Higher values suit long-lived connections (WebSocket, database pools).
	IdleTimeoutInMinutes int32 `json:"idle_timeout_in_minutes,omitempty" jsonschema:"The TCP idle timeout in minutes. Connections idle longer than this are closed. Default: 4 minutes. Range: 4 to 100 minutes. Higher values suit long-lived connections (WebSocket; database pools)."`
	// Enable floating IP (Direct Server Return).
	//  When enabled, Azure does not rewrite the destination IP in packets --
	//  the backend receives the original frontend IP. Required for SQL AlwaysOn
	//  availability groups and some HA clustering scenarios.
	//  Default: false.
	EnableFloatingIp bool `json:"enable_floating_ip,omitempty" jsonschema:"Enable floating IP (Direct Server Return). When enabled; Azure does not rewrite the destination IP in packets -- the backend receives the original frontend IP. Required for SQL AlwaysOn availability g..."`
	// Disable outbound SNAT for this rule's backend pool.
	//  By default, Standard LB provides SNAT for outbound traffic from backends.
	//  Disable this when using explicit outbound rules or a NAT Gateway for
	//  outbound connectivity, to avoid SNAT port exhaustion.
	//  Default: false.
	DisableOutboundSnat bool `json:"disable_outbound_snat,omitempty" jsonschema:"Disable outbound SNAT for this rule's backend pool. By default; Standard LB provides SNAT for outbound traffic from backends. Disable this when using explicit outbound rules or a NAT Gateway for outbo..."`
}

func (s *AzureLoadBalancingRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if s.BackendPoolName == "" {
		return fmt.Errorf("backend_pool_name is required")
	}
	if s.ProbeName == "" {
		return fmt.Errorf("probe_name is required")
	}
	return nil
}

func (s *AzureLoadBalancingRuleInput) applyDefaults() {
	if s.IdleTimeoutInMinutes == 0 {
		s.IdleTimeoutInMinutes = 4
	}
}

func (s *AzureLoadBalancingRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["protocol"] = s.Protocol
	if s.FrontendPort != 0 {
		m["frontend_port"] = s.FrontendPort
	}
	if s.BackendPort != 0 {
		m["backend_port"] = s.BackendPort
	}
	m["backend_pool_name"] = s.BackendPoolName
	m["probe_name"] = s.ProbeName
	if s.IdleTimeoutInMinutes != 0 {
		m["idle_timeout_in_minutes"] = s.IdleTimeoutInMinutes
	}
	if s.EnableFloatingIp {
		m["enable_floating_ip"] = s.EnableFloatingIp
	}
	if s.DisableOutboundSnat {
		m["disable_outbound_snat"] = s.DisableOutboundSnat
	}
	return m
}

// ParseAzureLoadBalancer validates and normalizes a AzureLoadBalancer cloud_object.
func ParseAzureLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
