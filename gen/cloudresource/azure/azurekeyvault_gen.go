// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// azure-key-vault
type AzureKeyVaultSpecInput struct {
	// The Azure region where the Key Vault will be deployed (e.g., "eastus", "westus2", "westeurope").
	//  This is required as Key Vault is a regional service.
	Region string `json:"region" jsonschema:"required,The Azure region where the Key Vault will be deployed (e.g.; 'eastus'; 'westus2'; 'westeurope'). This is required as Key Vault is a regional service."`
	// The Azure Resource Group where the Key Vault will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Key Vault will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The SKU tier for the Key Vault.
	//  - STANDARD: Software-protected keys, suitable for most applications
	//  - PREMIUM: HSM-backed keys, required for compliance (PCI-DSS, FIPS 140-2 Level 3)
	//  Default: STANDARD
	Sku string `json:"sku,omitempty" jsonschema:"enum=STANDARD|PREMIUM,The SKU tier for the Key Vault. - STANDARD: Software-protected keys; suitable for most applications - PREMIUM: HSM-backed keys; required for compliance (PCI-DSS; FIPS 140-2 Level 3) Default: STANDARD"`
	// Enable Azure RBAC for authorization instead of vault access policies.
	//  RBAC is the modern, recommended approach that integrates with Azure AD and PIM.
	//  Default: true (strongly recommended for new deployments)
	EnableRbacAuthorization bool `json:"enable_rbac_authorization,omitempty" jsonschema:"Enable Azure RBAC for authorization instead of vault access policies. RBAC is the modern; recommended approach that integrates with Azure AD and PIM. Default: true (strongly recommended for new deploy..."`
	// Enable purge protection to prevent permanent deletion of the vault and its contents.
	//  When enabled, deleted vaults are retained for the soft delete retention period and cannot be purged.
	//  CRITICAL: Should always be true for production environments.
	//  Default: true
	EnablePurgeProtection bool `json:"enable_purge_protection,omitempty" jsonschema:"Enable purge protection to prevent permanent deletion of the vault and its contents. When enabled; deleted vaults are retained for the soft delete retention period and cannot be purged. CRITICAL: Shou..."`
	// Soft delete retention period in days (7-90 days).
	//  Deleted secrets, keys, and certificates are retained for this period and can be recovered.
	//  Default: 90 days (maximum retention)
	SoftDeleteRetentionDays int32 `json:"soft_delete_retention_days,omitempty" jsonschema:"Soft delete retention period in days (7-90 days). Deleted secrets; keys; and certificates are retained for this period and can be recovered. Default: 90 days (maximum retention)"`
	// Network access control configuration for the Key Vault.
	//  Controls who can access the vault from where (public internet, specific IPs, VNets).
	NetworkAcls *AzureKeyVaultNetworkAclsInput `json:"network_acls,omitempty" jsonschema:"Network access control configuration for the Key Vault. Controls who can access the vault from where (public internet; specific IPs; VNets)."`
	// List of secret names to create in the Key Vault.
	//  The actual secret values should be set separately after vault creation using Azure SDK,
	//  Azure CLI, or the Key Vault API (never hardcoded in IaC).
	SecretNames []string `json:"secret_names,omitempty" jsonschema:"List of secret names to create in the Key Vault. The actual secret values should be set separately after vault creation using Azure SDK; Azure CLI; or the Key Vault API (never hardcoded in IaC)."`
}

func (s *AzureKeyVaultSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	switch s.Sku {
	case "", "STANDARD", "PREMIUM":
	default:
		return fmt.Errorf("invalid sku: %q", s.Sku)
	}
	if s.NetworkAcls != nil {
		if err := s.NetworkAcls.validate(); err != nil {
			return fmt.Errorf("network_acls: %w", err)
		}
	}
	return nil
}

func (s *AzureKeyVaultSpecInput) applyDefaults() {
	if s.Sku == "" {
		s.Sku = "STANDARD"
	}
	// default: EnableRbacAuthorization = true (applied at zero-value)
	// default: EnablePurgeProtection = true (applied at zero-value)
	if s.SoftDeleteRetentionDays == 0 {
		s.SoftDeleteRetentionDays = 90
	}
	if s.NetworkAcls != nil {
		s.NetworkAcls.applyDefaults()
	}
}

func (s *AzureKeyVaultSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	if s.Sku != "" {
		m["sku"] = s.Sku
	}
	if s.EnableRbacAuthorization {
		m["enable_rbac_authorization"] = s.EnableRbacAuthorization
	}
	if s.EnablePurgeProtection {
		m["enable_purge_protection"] = s.EnablePurgeProtection
	}
	if s.SoftDeleteRetentionDays != 0 {
		m["soft_delete_retention_days"] = s.SoftDeleteRetentionDays
	}
	if s.NetworkAcls != nil {
		m["network_acls"] = s.NetworkAcls.toMap()
	}
	if len(s.SecretNames) > 0 {
		m["secret_names"] = s.SecretNames
	}
	return m
}

// **AzureKeyVaultNetworkAcls** defines network access control rules for the Key Vault.
type AzureKeyVaultNetworkAclsInput struct {
	// Default action when no explicit rule matches.
	//  - ALLOW: Permit all traffic (not recommended for production)
	//  - DENY: Block all traffic unless explicitly allowed (recommended)
	//  Default: DENY
	DefaultAction string `json:"default_action,omitempty" jsonschema:"enum=ALLOW|DENY,Default action when no explicit rule matches. - ALLOW: Permit all traffic (not recommended for production) - DENY: Block all traffic unless explicitly allowed (recommended) Default: DENY"`
	// Allow traffic from trusted Azure services even when default_action is DENY.
	//  This includes services like Azure Backup, Azure Site Recovery, Azure Monitor, etc.
	//  Default: true (recommended to allow Azure service integrations)
	BypassAzureServices bool `json:"bypass_azure_services,omitempty" jsonschema:"Allow traffic from trusted Azure services even when default_action is DENY. This includes services like Azure Backup; Azure Site Recovery; Azure Monitor; etc. Default: true (recommended to allow Azure..."`
	// List of IP addresses or CIDR ranges allowed to access the vault.
	//  Example: ["203.0.113.0/24", "198.51.100.42"]
	//  Used for office IPs, VPN gateways, CI/CD runners, etc.
	IpRules []string `json:"ip_rules,omitempty" jsonschema:"List of IP addresses or CIDR ranges allowed to access the vault. Example: ['203.0.113.0/24'; '198.51.100.42'] Used for office IPs; VPN gateways; CI/CD runners; etc."`
	// List of Azure Virtual Network subnet resource IDs allowed to access the vault.
	//  Example: ["/subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/{subnet}"]
	//  Used to restrict access to specific VNets/subnets.
	VirtualNetworkSubnetIds []string `json:"virtual_network_subnet_ids,omitempty" jsonschema:"List of Azure Virtual Network subnet resource IDs allowed to access the vault. Example: ['/subscriptions/{sub-id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/{subnet..."`
}

func (s *AzureKeyVaultNetworkAclsInput) validate() error {
	switch s.DefaultAction {
	case "", "ALLOW", "DENY":
	default:
		return fmt.Errorf("invalid default_action: %q", s.DefaultAction)
	}
	return nil
}

func (s *AzureKeyVaultNetworkAclsInput) applyDefaults() {
	if s.DefaultAction == "" {
		s.DefaultAction = "DENY"
	}
	// default: BypassAzureServices = true (applied at zero-value)
}

func (s *AzureKeyVaultNetworkAclsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DefaultAction != "" {
		m["default_action"] = s.DefaultAction
	}
	if s.BypassAzureServices {
		m["bypass_azure_services"] = s.BypassAzureServices
	}
	if len(s.IpRules) > 0 {
		m["ip_rules"] = s.IpRules
	}
	if len(s.VirtualNetworkSubnetIds) > 0 {
		m["virtual_network_subnet_ids"] = s.VirtualNetworkSubnetIds
	}
	return m
}

// ParseAzureKeyVault validates and normalizes a AzureKeyVault cloud_object.
func ParseAzureKeyVault(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureKeyVault"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureKeyVaultSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
