// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureFunctionApp is the top-level API resource for an Azure Linux Function App.
//
//	A Function App is a serverless compute platform for event-driven workloads,
//	supporting HTTP triggers, queue triggers, timer triggers, and more.
//
//	It runs on an AzureServicePlan (Consumption, Elastic Premium, or Dedicated)
//	and requires an AzureStorageAccount for runtime state management.
type AzureFunctionAppSpecInput struct {
	// The Azure region where the Function App will be created.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	//
	//  **ForceNew**: Changing this destroys and recreates the function app.
	Region string `json:"region" jsonschema:"required,The Azure region where the Function App will be created. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'. **ForceNew**: Changing this destroys and recreates the function app."`
	// The Azure Resource Group where the Function App will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	//
	//  **ForceNew**: Changing this destroys and recreates the function app.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Function App will be created. Can be a literal string or a reference to an AzureResourceGroup output. **ForceNew**: Changing this destroys and recreates the function..."`
	// The name of the Function App.
	//  Must be globally unique across Azure (it forms the default hostname:
	//  `{name}.azurewebsites.net`).
	//
	//  Allowed characters: alphanumeric and hyphens.
	//  Must start and end with an alphanumeric character.
	//  Length: 2 to 60 characters.
	//
	//  **ForceNew**: Changing this destroys an...
	Name string `json:"name" jsonschema:"required,The name of the Function App. Must be globally unique across Azure (it forms the default hostname: '{name}.azurewebsites.net'). Allowed characters: alphanumeric and hyphens. Must start and end with an..."`
	// The App Service Plan that provides compute resources for this Function App.
	//  Determines the pricing tier, scale behavior, and available features.
	//
	//  Consumption (Y1): pay-per-execution, auto-scale to 200 instances
	//  Elastic Premium (EP*): pre-warmed instances, up to 100
	//  Dedicated (B* /S* /P*): fixed ...
	ServicePlanId string `json:"service_plan_id" jsonschema:"required,The App Service Plan that provides compute resources for this Function App. Determines the pricing tier; scale behavior; and available features. Consumption (Y1): pay-per-execution; auto-scale to 200 ..."`
	// The name of the Azure Storage Account used for Function App runtime state.
	//  Azure Functions use storage for trigger management, execution logs, and
	//  internal coordination. The storage account must already exist.
	//
	//  Mutually exclusive with storage_key_vault_secret_id (not exposed in v1).
	StorageAccountName string `json:"storage_account_name" jsonschema:"required,The name of the Azure Storage Account used for Function App runtime state. Azure Functions use storage for trigger management; execution logs; and internal coordination. The storage account must alrea..."`
	// The access key for the storage account.
	//  This is a sensitive credential. Provide it directly as a literal value
	//  or reference it from a secrets manager via StringValueOrRef.
	//
	//  Note: AzureStorageAccount does not export access keys in its status outputs
	//  (by design -- exporting secrets through status ...
	StorageAccountAccessKey string `json:"storage_account_access_key,omitempty" jsonschema:"The access key for the storage account. This is a sensitive credential. Provide it directly as a literal value or reference it from a secrets manager via StringValueOrRef. Note: AzureStorageAccount do..."`
	// Use the Function App's managed identity to access the storage account
	//  instead of an access key. This is the modern, credential-free approach.
	//
	//  When true, the Function App's system-assigned or user-assigned identity
	//  must have Storage Blob Data Owner and Storage Queue Data Contributor
	//  roles on the...
	StorageUsesManagedIdentity bool `json:"storage_uses_managed_identity,omitempty" jsonschema:"Use the Function App's managed identity to access the storage account instead of an access key. This is the modern; credential-free approach. When true; the Function App's system-assigned or user-assi..."`
	// The Azure Functions runtime version.
	//  Controls which version of the Azure Functions host runs the app.
	//
	//  Common values: "~4" (current LTS), "~3" (legacy, EOL).
	//  The "~" prefix enables automatic minor version updates.
	//
	//  Default: "~4"
	FunctionsExtensionVersion string `json:"functions_extension_version,omitempty" jsonschema:"The Azure Functions runtime version. Controls which version of the Azure Functions host runs the app. Common values: '~4' (current LTS); '~3' (legacy; EOL). The '~' prefix enables automatic minor vers..."`
	// Site configuration for the Function App.
	//  Contains the application stack (runtime), scaling settings, security
	//  settings, and operational configuration.
	SiteConfig *AzureFunctionAppSiteConfigInput `json:"site_config" jsonschema:"required,Site configuration for the Function App. Contains the application stack (runtime); scaling settings; security settings; and operational configuration."`
	// Application settings (environment variables) for the Function App.
	//  Key-value pairs that are available to functions at runtime via
	//  environment variables.
	//
	//  Azure automatically manages several settings (AzureWebJobsStorage,
	//  FUNCTIONS_WORKER_RUNTIME, etc.). User-provided settings are merged
	//  with th...
	AppSettings map[string]string `json:"app_settings,omitempty" jsonschema:"Application settings (environment variables) for the Function App. Key-value pairs that are available to functions at runtime via environment variables. Azure automatically manages several settings (A..."`
	// Named connection strings for database and service connections.
	//  Each connection string has a name, type, and value. The type determines
	//  how Azure exposes the connection in the runtime environment.
	//
	//  For most use cases, app_settings is simpler. Use connection_strings when
	//  you need Azure's native co...
	ConnectionStrings []*AzureFunctionAppConnectionStringInput `json:"connection_strings,omitempty" jsonschema:"Named connection strings for database and service connections. Each connection string has a name; type; and value. The type determines how Azure exposes the connection in the runtime environment. For ..."`
	// Application Insights connection string for APM telemetry.
	//  When provided, Azure automatically configures the Function App to send
	//  telemetry (requests, dependencies, exceptions, traces) to Application
	//  Insights. This is the recommended way to monitor Function Apps.
	//
	//  Uses the connection_string forma...
	ApplicationInsightsConnectionString string `json:"application_insights_connection_string,omitempty" jsonschema:"Application Insights connection string for APM telemetry. When provided; Azure automatically configures the Function App to send telemetry (requests; dependencies; exceptions; traces) to Application I..."`
	// Enforce HTTPS-only access to the Function App.
	//  When true, all HTTP requests are redirected to HTTPS.
	//
	//  Default: true (secure by default, unlike the Azure API default of false)
	HttpsOnly bool `json:"https_only,omitempty" jsonschema:"Enforce HTTPS-only access to the Function App. When true; all HTTP requests are redirected to HTTPS. Default: true (secure by default; unlike the Azure API default of false)"`
	// Enable or disable public network access to the Function App.
	//  When false, the Function App is only accessible via VNet integration
	//  or Private Endpoints.
	//
	//  Default: true
	PublicNetworkAccessEnabled bool `json:"public_network_access_enabled,omitempty" jsonschema:"Enable or disable public network access to the Function App. When false; the Function App is only accessible via VNet integration or Private Endpoints. Default: true"`
	// Enable built-in logging via AzureWebJobsDashboard.
	//  When true, Azure configures the AzureWebJobsDashboard storage connection
	//  for the legacy Functions dashboard. When Application Insights is configured,
	//  you may want to disable this to avoid duplicate logging and storage costs.
	//
	//  Default: true
	BuiltinLoggingEnabled bool `json:"builtin_logging_enabled,omitempty" jsonschema:"Enable built-in logging via AzureWebJobsDashboard. When true; Azure configures the AzureWebJobsDashboard storage connection for the legacy Functions dashboard. When Application Insights is configured;..."`
	// The subnet ID for VNet integration. When provided, the Function App's
	//  outbound traffic routes through this subnet, enabling access to
	//  VNet-connected resources (databases, Redis, etc.) without public endpoints.
	//
	//  The subnet must be delegated to Microsoft.Web/serverFarms.
	//  Not supported on Consumpti...
	VirtualNetworkSubnetId string `json:"virtual_network_subnet_id,omitempty" jsonschema:"The subnet ID for VNet integration. When provided; the Function App's outbound traffic routes through this subnet; enabling access to VNet-connected resources (databases; Redis; etc.) without public e..."`
	// Managed identity configuration for the Function App.
	//  Enables the app to authenticate with Azure services (Key Vault, Storage,
	//  ACR, etc.) without managing credentials.
	//
	//  When identity is configured with SystemAssigned, the function app gets
	//  a system-assigned identity whose principal_id and tenant_...
	Identity *AzureFunctionAppIdentityInput `json:"identity,omitempty" jsonschema:"Managed identity configuration for the Function App. Enables the app to authenticate with Azure services (Key Vault; Storage; ACR; etc.) without managing credentials. When identity is configured with ..."`
	// User Assigned Identity ID for accessing Key Vault references.
	//  When the Function App uses Key Vault references in app_settings
	//  (e.g., `@Microsoft.KeyVault(SecretUri=...)`), this identity is used
	//  to authenticate with Key Vault.
	//
	//  If not specified, the system-assigned identity is used.
	KeyVaultReferenceIdentityId string `json:"key_vault_reference_identity_id,omitempty" jsonschema:"User Assigned Identity ID for accessing Key Vault references. When the Function App uses Key Vault references in app_settings (e.g.; '@Microsoft.KeyVault(SecretUri=...)'); this identity is used to aut..."`
	// Enable client certificate authentication (mutual TLS).
	//  When true, clients must present a valid certificate to access the app.
	//
	//  Default: false
	ClientCertificateEnabled bool `json:"client_certificate_enabled,omitempty" jsonschema:"Enable client certificate authentication (mutual TLS). When true; clients must present a valid certificate to access the app. Default: false"`
	// Client certificate mode when client_certificate_enabled is true.
	//
	//  Valid values:
	//  - "Required": All requests must have a valid client certificate
	//  - "Optional": Certificate is requested but not required
	//  - "OptionalInteractiveUser": Certificate is optional for browser users
	//
	//  Default: "Optional"
	ClientCertificateMode string `json:"client_certificate_mode,omitempty" jsonschema:"Client certificate mode when client_certificate_enabled is true. Valid values: - 'Required': All requests must have a valid client certificate - 'Optional': Certificate is requested but not required -..."`
	// Paths excluded from client certificate validation.
	//  Semicolon-separated list of paths where client certificates are not required.
	//  Example: "/api/health;/api/status"
	ClientCertificateExclusionPaths string `json:"client_certificate_exclusion_paths,omitempty" jsonschema:"Paths excluded from client certificate validation. Semicolon-separated list of paths where client certificates are not required. Example: '/api/health;/api/status'"`
	// Force disable the Azure Files content share that Azure Functions
	//  automatically creates. Set to true when using a custom deployment
	//  method and the content share is not needed.
	//
	//  Default: false
	ContentShareForceDisabled bool `json:"content_share_force_disabled,omitempty" jsonschema:"Force disable the Azure Files content share that Azure Functions automatically creates. Set to true when using a custom deployment method and the content share is not needed. Default: false"`
	// Azure Storage Account mounts for the Function App.
	//  Mounts Azure File Shares or Blob containers as directories accessible
	//  to the function code at runtime.
	StorageMounts []*AzureFunctionAppStorageMountInput `json:"storage_mounts,omitempty" jsonschema:"Azure Storage Account mounts for the Function App. Mounts Azure File Shares or Blob containers as directories accessible to the function code at runtime."`
}

func (s *AzureFunctionAppSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ServicePlanId == "" {
		return fmt.Errorf("service_plan_id is required")
	}
	if s.StorageAccountName == "" {
		return fmt.Errorf("storage_account_name is required")
	}
	if s.SiteConfig == nil {
		return fmt.Errorf("site_config is required")
	}
	if s.SiteConfig != nil {
		if err := s.SiteConfig.validate(); err != nil {
			return fmt.Errorf("site_config: %w", err)
		}
	}
	for i, v := range s.ConnectionStrings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("connection_strings[%d]: %w", i, err)
			}
		}
	}
	if s.Identity != nil {
		if err := s.Identity.validate(); err != nil {
			return fmt.Errorf("identity: %w", err)
		}
	}
	for i, v := range s.StorageMounts {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("storage_mounts[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureFunctionAppSpecInput) applyDefaults() {
	if s.FunctionsExtensionVersion == "" {
		s.FunctionsExtensionVersion = "~4"
	}
	if s.SiteConfig != nil {
		s.SiteConfig.applyDefaults()
	}
	// default: HttpsOnly = true (applied at zero-value)
	// default: PublicNetworkAccessEnabled = true (applied at zero-value)
	// default: BuiltinLoggingEnabled = true (applied at zero-value)
	if s.Identity != nil {
		s.Identity.applyDefaults()
	}
	if s.ClientCertificateMode == "" {
		s.ClientCertificateMode = "Optional"
	}
}

func (s *AzureFunctionAppSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	m["service_plan_id"] = s.ServicePlanId
	m["storage_account_name"] = s.StorageAccountName
	if s.StorageAccountAccessKey != "" {
		m["storage_account_access_key"] = s.StorageAccountAccessKey
	}
	if s.StorageUsesManagedIdentity {
		m["storage_uses_managed_identity"] = s.StorageUsesManagedIdentity
	}
	if s.FunctionsExtensionVersion != "" {
		m["functions_extension_version"] = s.FunctionsExtensionVersion
	}
	if s.SiteConfig != nil {
		m["site_config"] = s.SiteConfig.toMap()
	}
	if len(s.AppSettings) > 0 {
		m["app_settings"] = s.AppSettings
	}
	if len(s.ConnectionStrings) > 0 {
		items := make([]any, len(s.ConnectionStrings))
		for i, v := range s.ConnectionStrings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["connection_strings"] = items
	}
	if s.ApplicationInsightsConnectionString != "" {
		m["application_insights_connection_string"] = s.ApplicationInsightsConnectionString
	}
	if s.HttpsOnly {
		m["https_only"] = s.HttpsOnly
	}
	if s.PublicNetworkAccessEnabled {
		m["public_network_access_enabled"] = s.PublicNetworkAccessEnabled
	}
	if s.BuiltinLoggingEnabled {
		m["builtin_logging_enabled"] = s.BuiltinLoggingEnabled
	}
	if s.VirtualNetworkSubnetId != "" {
		m["virtual_network_subnet_id"] = s.VirtualNetworkSubnetId
	}
	if s.Identity != nil {
		m["identity"] = s.Identity.toMap()
	}
	if s.KeyVaultReferenceIdentityId != "" {
		m["key_vault_reference_identity_id"] = s.KeyVaultReferenceIdentityId
	}
	if s.ClientCertificateEnabled {
		m["client_certificate_enabled"] = s.ClientCertificateEnabled
	}
	if s.ClientCertificateMode != "" {
		m["client_certificate_mode"] = s.ClientCertificateMode
	}
	if s.ClientCertificateExclusionPaths != "" {
		m["client_certificate_exclusion_paths"] = s.ClientCertificateExclusionPaths
	}
	if s.ContentShareForceDisabled {
		m["content_share_force_disabled"] = s.ContentShareForceDisabled
	}
	if len(s.StorageMounts) > 0 {
		items := make([]any, len(s.StorageMounts))
		for i, v := range s.StorageMounts {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["storage_mounts"] = items
	}
	return m
}

// AzureFunctionAppAppServiceLogs configures the App Service logging
//
//	for the Function App.
type AzureFunctionAppAppServiceLogsInput struct {
	// Disk quota for app service logs in megabytes.
	//  Range: 25 to 100.
	//
	//  Default: 35
	DiskQuotaMb int32 `json:"disk_quota_mb,omitempty" jsonschema:"Disk quota for app service logs in megabytes. Range: 25 to 100. Default: 35"`
	// Log retention in days. Set to 0 for indefinite retention.
	RetentionPeriodDays int32 `json:"retention_period_days,omitempty" jsonschema:"Log retention in days. Set to 0 for indefinite retention."`
}

func (s *AzureFunctionAppAppServiceLogsInput) validate() error {
	return nil
}

func (s *AzureFunctionAppAppServiceLogsInput) applyDefaults() {
	if s.DiskQuotaMb == 0 {
		s.DiskQuotaMb = 35
	}
}

func (s *AzureFunctionAppAppServiceLogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DiskQuotaMb != 0 {
		m["disk_quota_mb"] = s.DiskQuotaMb
	}
	if s.RetentionPeriodDays != 0 {
		m["retention_period_days"] = s.RetentionPeriodDays
	}
	return m
}

// AzureFunctionAppApplicationStack defines the runtime for the Function App.
//
//	Exactly one runtime must be specified. This maps to the `application_stack`
//	block within `site_config` in the Terraform provider. The constraint is
//	documented (not enforced via proto) because protobuf lacks native oneOf-with-
//	optional semantics for this pattern.
//
//	Runtime options:
//	- .NET: dotnet_version (+ optional use_dotnet_isolated_runtime)
//	- Node.js: node_version
//	- Python: python_version
//	- Java: java_version
//	- PowerShell: powershell_core_version
//	- Container: docker (registry_url + image_name + image_tag)
//	- Custom: use_custom_runtime
type AzureFunctionAppApplicationStackInput struct {
	// .NET runtime version.
	//  Uses the dotnet-isolated worker model by default in Functions v4+.
	//
	//  Valid values: "3.1", "6.0", "7.0", "8.0", "9.0", "10.0"
	//
	//  Note: .NET 6+ uses isolated worker by default. Set
	//  use_dotnet_isolated_runtime = false only for legacy in-process apps.
	DotnetVersion string `json:"dotnet_version,omitempty" jsonschema:".NET runtime version. Uses the dotnet-isolated worker model by default in Functions v4+. Valid values: '3.1'; '6.0'; '7.0'; '8.0'; '9.0'; '10.0' Note: .NET 6+ uses isolated worker by default. Set use_..."`
	// Use the .NET isolated worker runtime model.
	//  The isolated model runs functions in a separate process from the host,
	//  enabling different .NET versions and full dependency control.
	//
	//  Default: false (in-process model for backward compatibility, though
	//  Microsoft recommends isolated for new apps)
	UseDotnetIsolatedRuntime bool `json:"use_dotnet_isolated_runtime,omitempty" jsonschema:"Use the .NET isolated worker runtime model. The isolated model runs functions in a separate process from the host; enabling different .NET versions and full dependency control. Default: false (in-proc..."`
	// Node.js runtime version.
	//
	//  Valid values: "12", "14", "16", "18", "20", "22", "24"
	NodeVersion string `json:"node_version,omitempty" jsonschema:"Node.js runtime version. Valid values: '12'; '14'; '16'; '18'; '20'; '22'; '24'"`
	// Python runtime version.
	//
	//  Valid values: "3.8", "3.9", "3.10", "3.11", "3.12", "3.13", "3.14"
	PythonVersion string `json:"python_version,omitempty" jsonschema:"Python runtime version. Valid values: '3.8'; '3.9'; '3.10'; '3.11'; '3.12'; '3.13'; '3.14'"`
	// Java runtime version.
	//
	//  Valid values: "8", "11", "17", "21"
	JavaVersion string `json:"java_version,omitempty" jsonschema:"Java runtime version. Valid values: '8'; '11'; '17'; '21'"`
	// PowerShell Core runtime version.
	//
	//  Valid values: "7", "7.2", "7.4"
	PowershellCoreVersion string `json:"powershell_core_version,omitempty" jsonschema:"PowerShell Core runtime version. Valid values: '7'; '7.2'; '7.4'"`
	// Docker container configuration.
	//  Runs a custom container image as the Function App runtime.
	//  The image must include the Azure Functions runtime.
	Docker *AzureFunctionAppDockerConfigInput `json:"docker,omitempty" jsonschema:"Docker container configuration. Runs a custom container image as the Function App runtime. The image must include the Azure Functions runtime."`
	// Use a custom handler runtime.
	//  Custom handlers allow any language/runtime to work with Azure Functions
	//  by implementing a lightweight HTTP server that communicates with the
	//  Functions host process.
	UseCustomRuntime bool `json:"use_custom_runtime,omitempty" jsonschema:"Use a custom handler runtime. Custom handlers allow any language/runtime to work with Azure Functions by implementing a lightweight HTTP server that communicates with the Functions host process."`
}

func (s *AzureFunctionAppApplicationStackInput) validate() error {
	if s.Docker != nil {
		if err := s.Docker.validate(); err != nil {
			return fmt.Errorf("docker: %w", err)
		}
	}
	return nil
}

func (s *AzureFunctionAppApplicationStackInput) applyDefaults() {
	if s.Docker != nil {
		s.Docker.applyDefaults()
	}
}

func (s *AzureFunctionAppApplicationStackInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DotnetVersion != "" {
		m["dotnet_version"] = s.DotnetVersion
	}
	if s.UseDotnetIsolatedRuntime {
		m["use_dotnet_isolated_runtime"] = s.UseDotnetIsolatedRuntime
	}
	if s.NodeVersion != "" {
		m["node_version"] = s.NodeVersion
	}
	if s.PythonVersion != "" {
		m["python_version"] = s.PythonVersion
	}
	if s.JavaVersion != "" {
		m["java_version"] = s.JavaVersion
	}
	if s.PowershellCoreVersion != "" {
		m["powershell_core_version"] = s.PowershellCoreVersion
	}
	if s.Docker != nil {
		m["docker"] = s.Docker.toMap()
	}
	if s.UseCustomRuntime {
		m["use_custom_runtime"] = s.UseCustomRuntime
	}
	return m
}

// AzureFunctionAppConnectionString defines a named connection string
//
//	for the Function App. Connection strings are exposed to functions via
//	environment variables with a prefix based on the type.
type AzureFunctionAppConnectionStringInput struct {
	// The name of the connection string.
	Name string `json:"name" jsonschema:"required,The name of the connection string."`
	// The type of connection string. Determines the environment variable prefix.
	//
	//  Valid values: MySQL, SQLServer, SQLAzure, Custom, NotificationHub,
	//  ServiceBus, EventHub, APIHub, DocDb, RedisCache, PostgreSQL
	Type string `json:"type" jsonschema:"required,The type of connection string. Determines the environment variable prefix. Valid values: MySQL; SQLServer; SQLAzure; Custom; NotificationHub; ServiceBus; EventHub; APIHub; DocDb; RedisCache; PostgreSQ..."`
	// The connection string value. This is a sensitive credential.
	//  Can be a literal value or a reference to a secrets manager.
	Value string `json:"value" jsonschema:"required,The connection string value. This is a sensitive credential. Can be a literal value or a reference to a secrets manager."`
}

func (s *AzureFunctionAppConnectionStringInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AzureFunctionAppConnectionStringInput) applyDefaults() {
}

func (s *AzureFunctionAppConnectionStringInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["type"] = s.Type
	m["value"] = s.Value
	return m
}

// AzureFunctionAppCorsSettings configures Cross-Origin Resource Sharing
//
//	for the Function App's HTTP endpoints.
type AzureFunctionAppCorsSettingsInput struct {
	// List of origins allowed to make cross-origin requests.
	//  Use "*" to allow all origins (not recommended for production).
	//  Example: ["https://myapp.example.com", "https://admin.example.com"]
	AllowedOrigins []string `json:"allowed_origins,omitempty" jsonschema:"List of origins allowed to make cross-origin requests. Use '*' to allow all origins (not recommended for production). Example: ['https://myapp.example.com'; 'https://admin.example.com']"`
	// Allow credentials (cookies, authorization headers) in cross-origin requests.
	//  Cannot be used with allowed_origins = ["*"].
	//
	//  Default: false
	SupportCredentials bool `json:"support_credentials,omitempty" jsonschema:"Allow credentials (cookies; authorization headers) in cross-origin requests. Cannot be used with allowed_origins = ['*']. Default: false"`
}

func (s *AzureFunctionAppCorsSettingsInput) validate() error {
	if len(s.AllowedOrigins) < 1 {
		return fmt.Errorf("allowed_origins requires at least 1 items, got %d", len(s.AllowedOrigins))
	}
	return nil
}

func (s *AzureFunctionAppCorsSettingsInput) applyDefaults() {
}

func (s *AzureFunctionAppCorsSettingsInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AllowedOrigins) > 0 {
		m["allowed_origins"] = s.AllowedOrigins
	}
	if s.SupportCredentials {
		m["support_credentials"] = s.SupportCredentials
	}
	return m
}

// AzureFunctionAppDockerConfig defines the container configuration for
//
//	running the Function App as a custom Docker container.
//
//	The container image must include the Azure Functions runtime base image
//	or implement the Functions custom handler protocol.
type AzureFunctionAppDockerConfigInput struct {
	// The URL of the container registry.
	//  Examples: "https://myregistry.azurecr.io", "https://ghcr.io"
	RegistryUrl string `json:"registry_url" jsonschema:"required,The URL of the container registry. Examples: 'https://myregistry.azurecr.io'; 'https://ghcr.io'"`
	// The container image name (without tag).
	//  Example: "myorg/my-function-app"
	ImageName string `json:"image_name" jsonschema:"required,The container image name (without tag). Example: 'myorg/my-function-app'"`
	// The container image tag.
	//  Example: "latest", "v1.2.3", "sha-abc123"
	ImageTag string `json:"image_tag" jsonschema:"required,The container image tag. Example: 'latest'; 'v1.2.3'; 'sha-abc123'"`
	// Username for authenticating with the container registry.
	//  Not needed when using managed identity for ACR authentication
	//  (set container_registry_use_managed_identity in site_config).
	RegistryUsername string `json:"registry_username,omitempty" jsonschema:"Username for authenticating with the container registry. Not needed when using managed identity for ACR authentication (set container_registry_use_managed_identity in site_config)."`
	// Password for authenticating with the container registry.
	//  This is a sensitive credential. Provide directly or via StringValueOrRef.
	//
	//  Not needed when using managed identity for ACR authentication.
	RegistryPassword string `json:"registry_password,omitempty" jsonschema:"Password for authenticating with the container registry. This is a sensitive credential. Provide directly or via StringValueOrRef. Not needed when using managed identity for ACR authentication."`
}

func (s *AzureFunctionAppDockerConfigInput) validate() error {
	if s.RegistryUrl == "" {
		return fmt.Errorf("registry_url is required")
	}
	if s.ImageName == "" {
		return fmt.Errorf("image_name is required")
	}
	if s.ImageTag == "" {
		return fmt.Errorf("image_tag is required")
	}
	return nil
}

func (s *AzureFunctionAppDockerConfigInput) applyDefaults() {
}

func (s *AzureFunctionAppDockerConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["registry_url"] = s.RegistryUrl
	m["image_name"] = s.ImageName
	m["image_tag"] = s.ImageTag
	if s.RegistryUsername != "" {
		m["registry_username"] = s.RegistryUsername
	}
	if s.RegistryPassword != "" {
		m["registry_password"] = s.RegistryPassword
	}
	return m
}

// AzureFunctionAppIdentity configures managed identity for the Function App.
//
//	Managed identities eliminate the need to manage credentials for
//	authenticating with Azure services. The identity is automatically managed
//	by Azure AD and can be assigned RBAC roles on Azure resources.
//
//	Follows the same pattern as AzureContainerAppIdentity.
type AzureFunctionAppIdentityInput struct {
	// Identity type.
	//  "SystemAssigned": Azure-managed identity tied to the Function App lifecycle.
	//  "UserAssigned": Pre-created identity with independent lifecycle.
	//  "SystemAssigned,UserAssigned": Both identity types.
	Type string `json:"type" jsonschema:"required,Identity type. 'SystemAssigned': Azure-managed identity tied to the Function App lifecycle. 'UserAssigned': Pre-created identity with independent lifecycle. 'SystemAssigned;UserAssigned': Both identit..."`
	// User Assigned Identity Azure resource IDs.
	//  Required when type includes "UserAssigned".
	//
	//  Can be literal ARM resource IDs or references to AzureUserAssignedIdentity outputs.
	IdentityIds []string `json:"identity_ids,omitempty" jsonschema:"User Assigned Identity Azure resource IDs. Required when type includes 'UserAssigned'. Can be literal ARM resource IDs or references to AzureUserAssignedIdentity outputs."`
}

func (s *AzureFunctionAppIdentityInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *AzureFunctionAppIdentityInput) applyDefaults() {
}

func (s *AzureFunctionAppIdentityInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if len(s.IdentityIds) > 0 {
		m["identity_ids"] = s.IdentityIds
	}
	return m
}

// AzureFunctionAppIpRestriction defines an IP-based access restriction rule.
//
//	Rules are evaluated in priority order (lower number = higher priority).
//
//	Exactly one of ip_address, service_tag, or virtual_network_subnet_id
//	must be specified per rule.
type AzureFunctionAppIpRestrictionInput struct {
	// Rule name for identification.
	Name string `json:"name,omitempty" jsonschema:"Rule name for identification."`
	// Rule priority. Lower numbers are evaluated first.
	//  Range: 1 to 65000.
	Priority int32 `json:"priority,omitempty" jsonschema:"Rule priority. Lower numbers are evaluated first. Range: 1 to 65000."`
	// Action to take when the rule matches.
	//
	//  Valid values: "Allow", "Deny"
	//
	//  Default: "Allow"
	Action string `json:"action,omitempty" jsonschema:"Action to take when the rule matches. Valid values: 'Allow'; 'Deny' Default: 'Allow'"`
	// IP address or CIDR range.
	//  Example: "10.0.0.0/24", "203.0.113.50/32"
	IpAddress string `json:"ip_address,omitempty" jsonschema:"IP address or CIDR range. Example: '10.0.0.0/24'; '203.0.113.50/32'"`
	// Azure service tag.
	//  Example: "AzureFrontDoor.Backend", "AzureCloud.WestUS"
	ServiceTag string `json:"service_tag,omitempty" jsonschema:"Azure service tag. Example: 'AzureFrontDoor.Backend'; 'AzureCloud.WestUS'"`
	// Subnet ID for VNet-based access control.
	//  Traffic from this subnet is allowed/denied based on the action.
	VirtualNetworkSubnetId string `json:"virtual_network_subnet_id,omitempty" jsonschema:"Subnet ID for VNet-based access control. Traffic from this subnet is allowed/denied based on the action."`
	// Human-readable description of the rule.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the rule."`
	// HTTP header filters for the rule.
	//  Used with Azure Front Door or other reverse proxies to restrict
	//  access based on request headers.
	Headers *AzureFunctionAppIpRestrictionHeadersInput `json:"headers,omitempty" jsonschema:"HTTP header filters for the rule. Used with Azure Front Door or other reverse proxies to restrict access based on request headers."`
}

func (s *AzureFunctionAppIpRestrictionInput) validate() error {
	if s.Headers != nil {
		if err := s.Headers.validate(); err != nil {
			return fmt.Errorf("headers: %w", err)
		}
	}
	return nil
}

func (s *AzureFunctionAppIpRestrictionInput) applyDefaults() {
	if s.Action == "" {
		s.Action = "Allow"
	}
	if s.Headers != nil {
		s.Headers.applyDefaults()
	}
}

func (s *AzureFunctionAppIpRestrictionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Priority != 0 {
		m["priority"] = s.Priority
	}
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.IpAddress != "" {
		m["ip_address"] = s.IpAddress
	}
	if s.ServiceTag != "" {
		m["service_tag"] = s.ServiceTag
	}
	if s.VirtualNetworkSubnetId != "" {
		m["virtual_network_subnet_id"] = s.VirtualNetworkSubnetId
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.Headers != nil {
		m["headers"] = s.Headers.toMap()
	}
	return m
}

// AzureFunctionAppIpRestrictionHeaders defines header-based filters for
//
//	IP restriction rules. Used primarily with Azure Front Door to ensure
//	traffic comes through the CDN rather than directly to the Function App.
type AzureFunctionAppIpRestrictionHeadersInput struct {
	// X-Forwarded-For header values to match.
	//  Up to 8 entries. CIDR ranges are supported.
	XForwardedFor []string `json:"x_forwarded_for,omitempty" jsonschema:"X-Forwarded-For header values to match. Up to 8 entries. CIDR ranges are supported."`
	// X-Forwarded-Host header values to match.
	//  Up to 8 entries.
	XForwardedHost []string `json:"x_forwarded_host,omitempty" jsonschema:"X-Forwarded-Host header values to match. Up to 8 entries."`
	// X-Azure-FDID (Front Door ID) header values to match.
	//  Up to 8 entries. Used to ensure traffic comes from your specific
	//  Front Door instance.
	XAzureFdid []string `json:"x_azure_fdid,omitempty" jsonschema:"X-Azure-FDID (Front Door ID) header values to match. Up to 8 entries. Used to ensure traffic comes from your specific Front Door instance."`
	// X-FD-HealthProbe header values to match.
	//  Used to allow Front Door health probe traffic.
	XFdHealthProbe []string `json:"x_fd_health_probe,omitempty" jsonschema:"X-FD-HealthProbe header values to match. Used to allow Front Door health probe traffic."`
}

func (s *AzureFunctionAppIpRestrictionHeadersInput) validate() error {
	return nil
}

func (s *AzureFunctionAppIpRestrictionHeadersInput) applyDefaults() {
}

func (s *AzureFunctionAppIpRestrictionHeadersInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.XForwardedFor) > 0 {
		m["x_forwarded_for"] = s.XForwardedFor
	}
	if len(s.XForwardedHost) > 0 {
		m["x_forwarded_host"] = s.XForwardedHost
	}
	if len(s.XAzureFdid) > 0 {
		m["x_azure_fdid"] = s.XAzureFdid
	}
	if len(s.XFdHealthProbe) > 0 {
		m["x_fd_health_probe"] = s.XFdHealthProbe
	}
	return m
}

// AzureFunctionAppSiteConfig defines the site-level configuration for a
//
//	Linux Function App. This maps to the `site_config` block in the
//	Terraform azurerm_linux_function_app resource.
//
//	Contains the application stack (runtime selection), scaling settings,
//	security configuration, networking behavior, and operational controls.
type AzureFunctionAppSiteConfigInput struct {
	// The application stack defines the runtime for the Function App.
	//  Exactly one runtime must be specified: dotnet_version, node_version,
	//  python_version, java_version, powershell_core_version, docker, or
	//  use_custom_runtime.
	ApplicationStack *AzureFunctionAppApplicationStackInput `json:"application_stack,omitempty" jsonschema:"The application stack defines the runtime for the Function App. Exactly one runtime must be specified: dotnet_version; node_version; python_version; java_version; powershell_core_version; docker; or u..."`
	// Keep the Function App always loaded in memory.
	//  When true, the app is never unloaded due to inactivity.
	//
	//  Critical for Dedicated plans (B* /S* /P*) -- without this, the app
	//  may be unloaded after idle periods, causing cold start latency.
	//
	//  Automatically managed on Consumption and Elastic Premium pla...
	AlwaysOn bool `json:"always_on,omitempty" jsonschema:"Keep the Function App always loaded in memory. When true; the app is never unloaded due to inactivity. Critical for Dedicated plans (B*/S*/P*) -- without this; the app may be unloaded after idle perio..."`
	// Custom startup command for the Function App.
	//  Overrides the default startup behavior. Useful for custom Docker
	//  containers or runtimes that need specific initialization.
	AppCommandLine string `json:"app_command_line,omitempty" jsonschema:"Custom startup command for the Function App. Overrides the default startup behavior. Useful for custom Docker containers or runtimes that need specific initialization."`
	// Health check endpoint path.
	//  Azure periodically sends requests to this path and marks the instance
	//  as unhealthy if it doesn't respond with a 200-299 status code.
	//  Unhealthy instances are removed from the load balancer rotation.
	//
	//  Recommended for production deployments. Common paths: "/api/health",
	// ...
	HealthCheckPath string `json:"health_check_path,omitempty" jsonschema:"Health check endpoint path. Azure periodically sends requests to this path and marks the instance as unhealthy if it doesn't respond with a 200-299 status code. Unhealthy instances are removed from th..."`
	// Minimum TLS version for incoming HTTPS requests.
	//
	//  Valid values: "1.0", "1.1", "1.2", "1.3"
	//
	//  Default: "1.2" (industry standard; "1.3" for maximum security)
	MinimumTlsVersion string `json:"minimum_tls_version,omitempty" jsonschema:"Minimum TLS version for incoming HTTPS requests. Valid values: '1.0'; '1.1'; '1.2'; '1.3' Default: '1.2' (industry standard; '1.3' for maximum security)"`
	// Minimum TLS version for SCM (Kudu) site.
	//
	//  Default: "1.2"
	ScmMinimumTlsVersion string `json:"scm_minimum_tls_version,omitempty" jsonschema:"Minimum TLS version for SCM (Kudu) site. Default: '1.2'"`
	// Maximum number of workers for scale-out.
	//  Only applicable to Consumption and Elastic Premium plans.
	//
	//  Consumption (Y1): Azure auto-scales up to 200, but this field caps
	//  the maximum to control costs.
	//  Elastic Premium (EP*): Caps the elastic scale-out range.
	//
	//  Ignored on Dedicated plans (use worker_c...
	AppScaleLimit int32 `json:"app_scale_limit,omitempty" jsonschema:"Maximum number of workers for scale-out. Only applicable to Consumption and Elastic Premium plans. Consumption (Y1): Azure auto-scales up to 200; but this field caps the maximum to control costs. Elas..."`
	// Minimum number of pre-warmed instances for Elastic Premium plans.
	//  These instances are always running and ready to handle requests,
	//  eliminating cold start latency.
	//
	//  Only applicable to Elastic Premium (EP*) plans. Ignored on other tiers.
	ElasticInstanceMinimum int32 `json:"elastic_instance_minimum,omitempty" jsonschema:"Minimum number of pre-warmed instances for Elastic Premium plans. These instances are always running and ready to handle requests; eliminating cold start latency. Only applicable to Elastic Premium (E..."`
	// Number of pre-warmed instances beyond the minimum.
	//  Pre-warmed instances sit in a "warm" state and can handle requests
	//  faster than cold-starting new instances.
	//
	//  Only applicable to Elastic Premium (EP*) plans.
	PreWarmedInstanceCount int32 `json:"pre_warmed_instance_count,omitempty" jsonschema:"Number of pre-warmed instances beyond the minimum. Pre-warmed instances sit in a 'warm' state and can handle requests faster than cold-starting new instances. Only applicable to Elastic Premium (EP*) ..."`
	// Number of worker instances for the Function App.
	//  Controls how many instances are allocated on Dedicated plans.
	//
	//  Range: 1-100.
	WorkerCount int32 `json:"worker_count,omitempty" jsonschema:"Number of worker instances for the Function App. Controls how many instances are allocated on Dedicated plans. Range: 1-100."`
	// Enable HTTP/2 protocol for the Function App.
	//  HTTP/2 provides multiplexing, header compression, and server push
	//  for improved performance.
	//
	//  Default: false
	Http2Enabled bool `json:"http2_enabled,omitempty" jsonschema:"Enable HTTP/2 protocol for the Function App. HTTP/2 provides multiplexing; header compression; and server push for improved performance. Default: false"`
	// Enable WebSocket connections for the Function App.
	//
	//  Default: false
	WebsocketsEnabled bool `json:"websockets_enabled,omitempty" jsonschema:"Enable WebSocket connections for the Function App. Default: false"`
	// Use a 32-bit worker process instead of 64-bit.
	//  Reduces memory footprint but limits addressable memory to ~2 GB.
	//
	//  Default: false
	Use32BitWorker bool `json:"use_32_bit_worker,omitempty" jsonschema:"Use a 32-bit worker process instead of 64-bit. Reduces memory footprint but limits addressable memory to ~2 GB. Default: false"`
	// Route all outbound traffic from the Function App through the VNet.
	//  Requires virtual_network_subnet_id to be set on the spec.
	//
	//  When false (default), only RFC1918 traffic routes through the VNet.
	//  When true, all outbound traffic (including public internet) routes
	//  through the VNet, enabling inspecti...
	VnetRouteAllEnabled bool `json:"vnet_route_all_enabled,omitempty" jsonschema:"Route all outbound traffic from the Function App through the VNet. Requires virtual_network_subnet_id to be set on the spec. When false (default); only RFC1918 traffic routes through the VNet. When tr..."`
	// FTPS state for the Function App.
	//  Controls whether FTP/FTPS file deployment is allowed.
	//
	//  Valid values:
	//  - "AllAllowed": Both FTP and FTPS are enabled
	//  - "FtpsOnly": Only FTPS (encrypted) is enabled
	//  - "Disabled": FTP/FTPS is completely disabled (recommended)
	//
	//  Default: "Disabled" (secure by default...
	FtpsState string `json:"ftps_state,omitempty" jsonschema:"FTPS state for the Function App. Controls whether FTP/FTPS file deployment is allowed. Valid values: - 'AllAllowed': Both FTP and FTPS are enabled - 'FtpsOnly': Only FTPS (encrypted) is enabled - 'Dis..."`
	// Load balancing mode for distributing requests across instances.
	//
	//  Valid values: LeastRequests, WeightedRoundRobin, LeastResponseTime,
	//  WeightedTotalTraffic, RequestHash, PerSiteRoundRobin
	//
	//  Default: "LeastRequests"
	LoadBalancingMode string `json:"load_balancing_mode,omitempty" jsonschema:"Load balancing mode for distributing requests across instances. Valid values: LeastRequests; WeightedRoundRobin; LeastResponseTime; WeightedTotalTraffic; RequestHash; PerSiteRoundRobin Default: 'Least..."`
	// Enable runtime scale monitoring for KEDA-based triggers.
	//  When enabled, the Functions runtime can directly monitor event sources
	//  to make more accurate scaling decisions.
	//
	//  Supported on Elastic Premium and Dedicated plans with Functions v4+.
	RuntimeScaleMonitoringEnabled bool `json:"runtime_scale_monitoring_enabled,omitempty" jsonschema:"Enable runtime scale monitoring for KEDA-based triggers. When enabled; the Functions runtime can directly monitor event sources to make more accurate scaling decisions. Supported on Elastic Premium an..."`
	// CORS (Cross-Origin Resource Sharing) configuration.
	//  Controls which origins are allowed to make cross-origin requests to
	//  the Function App's HTTP endpoints.
	Cors *AzureFunctionAppCorsSettingsInput `json:"cors,omitempty" jsonschema:"CORS (Cross-Origin Resource Sharing) configuration. Controls which origins are allowed to make cross-origin requests to the Function App's HTTP endpoints."`
	// IP restriction rules for the main site.
	//  Controls which IP addresses, service tags, or subnets can access
	//  the Function App.
	IpRestrictions []*AzureFunctionAppIpRestrictionInput `json:"ip_restrictions,omitempty" jsonschema:"IP restriction rules for the main site. Controls which IP addresses; service tags; or subnets can access the Function App."`
	// Default action for IP restrictions on the main site.
	//  When "Allow", unlisted IPs are allowed (rules are deny-list).
	//  When "Deny", unlisted IPs are denied (rules are allow-list).
	//
	//  Default: "Allow"
	IpRestrictionDefaultAction string `json:"ip_restriction_default_action,omitempty" jsonschema:"Default action for IP restrictions on the main site. When 'Allow'; unlisted IPs are allowed (rules are deny-list). When 'Deny'; unlisted IPs are denied (rules are allow-list). Default: 'Allow'"`
	// Use the main site's IP restrictions for the SCM (Kudu) site.
	//  When true, scm_ip_restrictions are ignored.
	//
	//  Default: false
	ScmUseMainIpRestriction bool `json:"scm_use_main_ip_restriction,omitempty" jsonschema:"Use the main site's IP restrictions for the SCM (Kudu) site. When true; scm_ip_restrictions are ignored. Default: false"`
	// IP restriction rules for the SCM (Kudu) site.
	//  Only used when scm_use_main_ip_restriction is false.
	ScmIpRestrictions []*AzureFunctionAppIpRestrictionInput `json:"scm_ip_restrictions,omitempty" jsonschema:"IP restriction rules for the SCM (Kudu) site. Only used when scm_use_main_ip_restriction is false."`
	// Default action for IP restrictions on the SCM site.
	//
	//  Default: "Allow"
	ScmIpRestrictionDefaultAction string `json:"scm_ip_restriction_default_action,omitempty" jsonschema:"Default action for IP restrictions on the SCM site. Default: 'Allow'"`
	// App Service logging configuration.
	AppServiceLogs *AzureFunctionAppAppServiceLogsInput `json:"app_service_logs,omitempty" jsonschema:"App Service logging configuration."`
	// Default documents list for the web server.
	//  Defines which files are served when a request hits the root path.
	DefaultDocuments []string `json:"default_documents,omitempty" jsonschema:"Default documents list for the web server. Defines which files are served when a request hits the root path."`
	// Use managed identity for pulling container images from Azure Container Registry.
	//  Requires the Function App's identity to have AcrPull role on the registry.
	//
	//  Default: false
	ContainerRegistryUseManagedIdentity bool `json:"container_registry_use_managed_identity,omitempty" jsonschema:"Use managed identity for pulling container images from Azure Container Registry. Requires the Function App's identity to have AcrPull role on the registry. Default: false"`
	// Client ID of the managed identity used for ACR image pulls.
	//  Only used when container_registry_use_managed_identity is true and
	//  a user-assigned identity (not system-assigned) should be used.
	ContainerRegistryManagedIdentityClientId string `json:"container_registry_managed_identity_client_id,omitempty" jsonschema:"Client ID of the managed identity used for ACR image pulls. Only used when container_registry_use_managed_identity is true and a user-assigned identity (not system-assigned) should be used."`
	// Application Insights instrumentation key (classic).
	//  Prefer application_insights_connection_string on the parent spec
	//  for new deployments. This field is for backward compatibility with
	//  apps already using the instrumentation key.
	ApplicationInsightsKey string `json:"application_insights_key,omitempty" jsonschema:"Application Insights instrumentation key (classic). Prefer application_insights_connection_string on the parent spec for new deployments. This field is for backward compatibility with apps already usi..."`
}

func (s *AzureFunctionAppSiteConfigInput) validate() error {
	if s.ApplicationStack != nil {
		if err := s.ApplicationStack.validate(); err != nil {
			return fmt.Errorf("application_stack: %w", err)
		}
	}
	if s.Cors != nil {
		if err := s.Cors.validate(); err != nil {
			return fmt.Errorf("cors: %w", err)
		}
	}
	for i, v := range s.IpRestrictions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ip_restrictions[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.ScmIpRestrictions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("scm_ip_restrictions[%d]: %w", i, err)
			}
		}
	}
	if s.AppServiceLogs != nil {
		if err := s.AppServiceLogs.validate(); err != nil {
			return fmt.Errorf("app_service_logs: %w", err)
		}
	}
	return nil
}

func (s *AzureFunctionAppSiteConfigInput) applyDefaults() {
	if s.ApplicationStack != nil {
		s.ApplicationStack.applyDefaults()
	}
	if s.MinimumTlsVersion == "" {
		s.MinimumTlsVersion = "1.2"
	}
	if s.ScmMinimumTlsVersion == "" {
		s.ScmMinimumTlsVersion = "1.2"
	}
	if s.FtpsState == "" {
		s.FtpsState = "Disabled"
	}
	if s.LoadBalancingMode == "" {
		s.LoadBalancingMode = "LeastRequests"
	}
	if s.Cors != nil {
		s.Cors.applyDefaults()
	}
	if s.IpRestrictionDefaultAction == "" {
		s.IpRestrictionDefaultAction = "Allow"
	}
	if s.ScmIpRestrictionDefaultAction == "" {
		s.ScmIpRestrictionDefaultAction = "Allow"
	}
	if s.AppServiceLogs != nil {
		s.AppServiceLogs.applyDefaults()
	}
}

func (s *AzureFunctionAppSiteConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ApplicationStack != nil {
		m["application_stack"] = s.ApplicationStack.toMap()
	}
	if s.AlwaysOn {
		m["always_on"] = s.AlwaysOn
	}
	if s.AppCommandLine != "" {
		m["app_command_line"] = s.AppCommandLine
	}
	if s.HealthCheckPath != "" {
		m["health_check_path"] = s.HealthCheckPath
	}
	if s.MinimumTlsVersion != "" {
		m["minimum_tls_version"] = s.MinimumTlsVersion
	}
	if s.ScmMinimumTlsVersion != "" {
		m["scm_minimum_tls_version"] = s.ScmMinimumTlsVersion
	}
	if s.AppScaleLimit != 0 {
		m["app_scale_limit"] = s.AppScaleLimit
	}
	if s.ElasticInstanceMinimum != 0 {
		m["elastic_instance_minimum"] = s.ElasticInstanceMinimum
	}
	if s.PreWarmedInstanceCount != 0 {
		m["pre_warmed_instance_count"] = s.PreWarmedInstanceCount
	}
	if s.WorkerCount != 0 {
		m["worker_count"] = s.WorkerCount
	}
	if s.Http2Enabled {
		m["http2_enabled"] = s.Http2Enabled
	}
	if s.WebsocketsEnabled {
		m["websockets_enabled"] = s.WebsocketsEnabled
	}
	if s.Use32BitWorker {
		m["use_32_bit_worker"] = s.Use32BitWorker
	}
	if s.VnetRouteAllEnabled {
		m["vnet_route_all_enabled"] = s.VnetRouteAllEnabled
	}
	if s.FtpsState != "" {
		m["ftps_state"] = s.FtpsState
	}
	if s.LoadBalancingMode != "" {
		m["load_balancing_mode"] = s.LoadBalancingMode
	}
	if s.RuntimeScaleMonitoringEnabled {
		m["runtime_scale_monitoring_enabled"] = s.RuntimeScaleMonitoringEnabled
	}
	if s.Cors != nil {
		m["cors"] = s.Cors.toMap()
	}
	if len(s.IpRestrictions) > 0 {
		items := make([]any, len(s.IpRestrictions))
		for i, v := range s.IpRestrictions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ip_restrictions"] = items
	}
	if s.IpRestrictionDefaultAction != "" {
		m["ip_restriction_default_action"] = s.IpRestrictionDefaultAction
	}
	if s.ScmUseMainIpRestriction {
		m["scm_use_main_ip_restriction"] = s.ScmUseMainIpRestriction
	}
	if len(s.ScmIpRestrictions) > 0 {
		items := make([]any, len(s.ScmIpRestrictions))
		for i, v := range s.ScmIpRestrictions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["scm_ip_restrictions"] = items
	}
	if s.ScmIpRestrictionDefaultAction != "" {
		m["scm_ip_restriction_default_action"] = s.ScmIpRestrictionDefaultAction
	}
	if s.AppServiceLogs != nil {
		m["app_service_logs"] = s.AppServiceLogs.toMap()
	}
	if len(s.DefaultDocuments) > 0 {
		m["default_documents"] = s.DefaultDocuments
	}
	if s.ContainerRegistryUseManagedIdentity {
		m["container_registry_use_managed_identity"] = s.ContainerRegistryUseManagedIdentity
	}
	if s.ContainerRegistryManagedIdentityClientId != "" {
		m["container_registry_managed_identity_client_id"] = s.ContainerRegistryManagedIdentityClientId
	}
	if s.ApplicationInsightsKey != "" {
		m["application_insights_key"] = s.ApplicationInsightsKey
	}
	return m
}

// AzureFunctionAppStorageMount defines an Azure Storage mount for
//
//	the Function App. Mounts Azure File Shares or Blob containers as
//	directories accessible to function code at runtime.
type AzureFunctionAppStorageMountInput struct {
	// Unique name for this mount within the Function App.
	Name string `json:"name" jsonschema:"required,Unique name for this mount within the Function App."`
	// Storage type.
	//
	//  Valid values:
	//  - "AzureBlob": Mount an Azure Blob container (read-only)
	//  - "AzureFiles": Mount an Azure File Share (read-write)
	Type string `json:"type" jsonschema:"required,Storage type. Valid values: - 'AzureBlob': Mount an Azure Blob container (read-only) - 'AzureFiles': Mount an Azure File Share (read-write)"`
	// Name of the Azure Storage Account that contains the share or container.
	AccountName string `json:"account_name" jsonschema:"required,Name of the Azure Storage Account that contains the share or container."`
	// Name of the file share or blob container to mount.
	ShareName string `json:"share_name" jsonschema:"required,Name of the file share or blob container to mount."`
	// Access key for the storage account.
	//  This is a sensitive credential.
	AccessKey string `json:"access_key" jsonschema:"required,Access key for the storage account. This is a sensitive credential."`
	// Path inside the container where the share is mounted.
	//  Example: "/mnt/data"
	MountPath string `json:"mount_path,omitempty" jsonschema:"Path inside the container where the share is mounted. Example: '/mnt/data'"`
}

func (s *AzureFunctionAppStorageMountInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.AccountName == "" {
		return fmt.Errorf("account_name is required")
	}
	if s.ShareName == "" {
		return fmt.Errorf("share_name is required")
	}
	if s.AccessKey == "" {
		return fmt.Errorf("access_key is required")
	}
	return nil
}

func (s *AzureFunctionAppStorageMountInput) applyDefaults() {
}

func (s *AzureFunctionAppStorageMountInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["type"] = s.Type
	m["account_name"] = s.AccountName
	m["share_name"] = s.ShareName
	m["access_key"] = s.AccessKey
	if s.MountPath != "" {
		m["mount_path"] = s.MountPath
	}
	return m
}

// ParseAzureFunctionApp validates and normalizes a AzureFunctionApp cloud_object.
func ParseAzureFunctionApp(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureFunctionApp"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureFunctionAppSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
