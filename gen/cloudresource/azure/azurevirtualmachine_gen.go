// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// azure-virtual-machine
type AzureVirtualMachineSpecInput struct {
	// Azure region where the Virtual Machine will be deployed (e.g., "eastus", "westus2", "westeurope").
	//  This is required as VMs are regional resources.
	Region string `json:"region" jsonschema:"required,Azure region where the Virtual Machine will be deployed (e.g.; 'eastus'; 'westus2'; 'westeurope'). This is required as VMs are regional resources."`
	// The Azure Resource Group where the Virtual Machine will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Virtual Machine will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The Azure VM size determining vCPU count, memory, and capabilities.
	//  Examples: "Standard_D2s_v3" (2 vCPUs, 8 GiB RAM), "Standard_D4s_v5" (4 vCPUs, 16 GiB RAM).
	VmSize string `json:"vm_size,omitempty" jsonschema:"The Azure VM size determining vCPU count; memory; and capabilities. Examples: 'Standard_D2s_v3' (2 vCPUs; 8 GiB RAM); 'Standard_D4s_v5' (4 vCPUs; 16 GiB RAM)."`
	// The Azure resource ID of the subnet where this VM will be attached.
	//  This should reference a subnet within an existing Virtual Network (VNet).
	//  Can be a literal value or a reference to an AzureVpc resource's subnet output.
	SubnetId string `json:"subnet_id" jsonschema:"required,The Azure resource ID of the subnet where this VM will be attached. This should reference a subnet within an existing Virtual Network (VNet). Can be a literal value or a reference to an AzureVpc resou..."`
	// Operating system image configuration for the VM.
	Image *AzureVirtualMachineImageInput `json:"image" jsonschema:"required,Operating system image configuration for the VM."`
	// OS disk configuration for the VM.
	OsDisk *AzureVirtualMachineOsDiskInput `json:"os_disk,omitempty" jsonschema:"OS disk configuration for the VM."`
	// Additional data disks to attach to the VM.
	DataDisks []*AzureVirtualMachineDataDiskInput `json:"data_disks,omitempty" jsonschema:"Additional data disks to attach to the VM."`
	// Admin username for the VM (Linux: SSH user, Windows: Administrator name).
	//  Must be a valid username according to Azure requirements.
	AdminUsername string `json:"admin_username,omitempty" jsonschema:"Admin username for the VM (Linux: SSH user; Windows: Administrator name). Must be a valid username according to Azure requirements."`
	// SSH public key for Linux VMs. Required for Linux VMs when password authentication is disabled.
	//  Format: "ssh-rsa AAAAB3NzaC1yc2E... user@host"
	SshPublicKey string `json:"ssh_public_key,omitempty" jsonschema:"SSH public key for Linux VMs. Required for Linux VMs when password authentication is disabled. Format: 'ssh-rsa AAAAB3NzaC1yc2E... user@host'"`
	// Admin password for Windows VMs or Linux VMs with password authentication enabled.
	//  For production, prefer SSH keys for Linux VMs.
	//  Can be a literal value or a reference to an AzureKeyVault secret.
	AdminPassword string `json:"admin_password,omitempty" jsonschema:"Admin password for Windows VMs or Linux VMs with password authentication enabled. For production; prefer SSH keys for Linux VMs. Can be a literal value or a reference to an AzureKeyVault secret."`
	// Network interface configuration for the VM.
	Network *AzureVirtualMachineNetworkConfigInput `json:"network,omitempty" jsonschema:"Network interface configuration for the VM."`
	// Availability zone for the VM (e.g., "1", "2", "3").
	//  Leave empty for no zone (regional placement).
	//  For production workloads, deploy VMs across multiple zones.
	AvailabilityZone string `json:"availability_zone,omitempty" jsonschema:"Availability zone for the VM (e.g.; '1'; '2'; '3'). Leave empty for no zone (regional placement). For production workloads; deploy VMs across multiple zones."`
	// Enable boot diagnostics for the VM.
	//  Boot diagnostics captures serial console output and screenshots to help diagnose boot issues.
	EnableBootDiagnostics bool `json:"enable_boot_diagnostics,omitempty" jsonschema:"Enable boot diagnostics for the VM. Boot diagnostics captures serial console output and screenshots to help diagnose boot issues."`
	// Enable system-assigned managed identity for the VM.
	//  Managed identities allow the VM to authenticate to Azure services without storing credentials.
	EnableSystemAssignedIdentity bool `json:"enable_system_assigned_identity,omitempty" jsonschema:"Enable system-assigned managed identity for the VM. Managed identities allow the VM to authenticate to Azure services without storing credentials."`
	// User-assigned managed identity resource IDs to attach to the VM.
	//  These are pre-created managed identities that can be shared across multiple resources.
	UserAssignedIdentityIds []string `json:"user_assigned_identity_ids,omitempty" jsonschema:"User-assigned managed identity resource IDs to attach to the VM. These are pre-created managed identities that can be shared across multiple resources."`
	// Custom data (cloud-init) script to execute on first boot.
	//  For Linux VMs, this is typically a cloud-init script.
	//  For Windows VMs, this can be a PowerShell script.
	//  Maximum size: 64 KB (base64 encoded).
	CustomData string `json:"custom_data,omitempty" jsonschema:"Custom data (cloud-init) script to execute on first boot. For Linux VMs; this is typically a cloud-init script. For Windows VMs; this can be a PowerShell script. Maximum size: 64 KB (base64 encoded)."`
	// Tags to apply to the VM and related resources.
	//  Tags are key-value pairs for Azure resource organization and cost tracking.
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Tags to apply to the VM and related resources. Tags are key-value pairs for Azure resource organization and cost tracking."`
	// Enable spot pricing for the VM (significantly reduced cost, can be evicted).
	//  Spot VMs are suitable for fault-tolerant, interruptible workloads.
	IsSpotInstance bool `json:"is_spot_instance,omitempty" jsonschema:"Enable spot pricing for the VM (significantly reduced cost; can be evicted). Spot VMs are suitable for fault-tolerant; interruptible workloads."`
	// Maximum price per hour for Spot VMs (in USD).
	//  Set to -1 to use the on-demand price as the maximum.
	//  Only applicable when is_spot_instance is true.
	SpotMaxPrice float64 `json:"spot_max_price,omitempty" jsonschema:"Maximum price per hour for Spot VMs (in USD). Set to -1 to use the on-demand price as the maximum. Only applicable when is_spot_instance is true."`
}

func (s *AzureVirtualMachineSpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if s.Image == nil {
		return fmt.Errorf("image is required")
	}
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.OsDisk != nil {
		if err := s.OsDisk.validate(); err != nil {
			return fmt.Errorf("os_disk: %w", err)
		}
	}
	for i, v := range s.DataDisks {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("data_disks[%d]: %w", i, err)
			}
		}
	}
	if s.Network != nil {
		if err := s.Network.validate(); err != nil {
			return fmt.Errorf("network: %w", err)
		}
	}
	return nil
}

func (s *AzureVirtualMachineSpecInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.OsDisk != nil {
		s.OsDisk.applyDefaults()
	}
	if s.AdminUsername == "" {
		s.AdminUsername = "azureuser"
	}
	if s.Network != nil {
		s.Network.applyDefaults()
	}
	// default: EnableBootDiagnostics = true (applied at zero-value)
}

func (s *AzureVirtualMachineSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	if s.VmSize != "" {
		m["vm_size"] = s.VmSize
	}
	m["subnet_id"] = s.SubnetId
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.OsDisk != nil {
		m["os_disk"] = s.OsDisk.toMap()
	}
	if len(s.DataDisks) > 0 {
		items := make([]any, len(s.DataDisks))
		for i, v := range s.DataDisks {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["data_disks"] = items
	}
	if s.AdminUsername != "" {
		m["admin_username"] = s.AdminUsername
	}
	if s.SshPublicKey != "" {
		m["ssh_public_key"] = s.SshPublicKey
	}
	if s.AdminPassword != "" {
		m["admin_password"] = s.AdminPassword
	}
	if s.Network != nil {
		m["network"] = s.Network.toMap()
	}
	if s.AvailabilityZone != "" {
		m["availability_zone"] = s.AvailabilityZone
	}
	if s.EnableBootDiagnostics {
		m["enable_boot_diagnostics"] = s.EnableBootDiagnostics
	}
	if s.EnableSystemAssignedIdentity {
		m["enable_system_assigned_identity"] = s.EnableSystemAssignedIdentity
	}
	if len(s.UserAssignedIdentityIds) > 0 {
		m["user_assigned_identity_ids"] = s.UserAssignedIdentityIds
	}
	if s.CustomData != "" {
		m["custom_data"] = s.CustomData
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.IsSpotInstance {
		m["is_spot_instance"] = s.IsSpotInstance
	}
	if s.SpotMaxPrice != 0 {
		m["spot_max_price"] = s.SpotMaxPrice
	}
	return m
}

// AzureVirtualMachineDataDisk defines an additional data disk configuration.
type AzureVirtualMachineDataDiskInput struct {
	// Name of the data disk.
	Name string `json:"name" jsonschema:"required,Name of the data disk."`
	// Size of the data disk in GB.
	SizeGb int32 `json:"size_gb" jsonschema:"required,Size of the data disk in GB."`
	// Storage account type for the data disk.
	StorageType string `json:"storage_type,omitempty" jsonschema:"enum=standard_lrs|standard_ssd_lrs|premium_lrs|premium_zrs,Storage account type for the data disk."`
	// Caching mode for the data disk.
	Caching string `json:"caching,omitempty" jsonschema:"enum=none|read_only|read_write,Caching mode for the data disk."`
	// Logical Unit Number (LUN) for the data disk.
	//  Each data disk must have a unique LUN (0-63).
	Lun int32 `json:"lun,omitempty" jsonschema:"Logical Unit Number (LUN) for the data disk. Each data disk must have a unique LUN (0-63)."`
	// Whether to delete the data disk when the VM is deleted.
	DeleteWithVm bool `json:"delete_with_vm,omitempty" jsonschema:"Whether to delete the data disk when the VM is deleted."`
}

func (s *AzureVirtualMachineDataDiskInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	switch s.StorageType {
	case "", "standard_lrs", "standard_ssd_lrs", "premium_lrs", "premium_zrs":
	default:
		return fmt.Errorf("invalid storage_type: %q", s.StorageType)
	}
	switch s.Caching {
	case "", "none", "read_only", "read_write":
	default:
		return fmt.Errorf("invalid caching: %q", s.Caching)
	}
	return nil
}

func (s *AzureVirtualMachineDataDiskInput) applyDefaults() {
	if s.StorageType == "" {
		s.StorageType = "premium_lrs"
	}
	if s.Caching == "" {
		s.Caching = "read_only"
	}
	// default: DeleteWithVm = true (applied at zero-value)
}

func (s *AzureVirtualMachineDataDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["size_gb"] = s.SizeGb
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.Caching != "" {
		m["caching"] = s.Caching
	}
	if s.Lun != 0 {
		m["lun"] = s.Lun
	}
	if s.DeleteWithVm {
		m["delete_with_vm"] = s.DeleteWithVm
	}
	return m
}

// AzureVirtualMachineImage defines the OS image configuration for the VM.
type AzureVirtualMachineImageInput struct {
	// Image publisher (e.g., "Canonical", "MicrosoftWindowsServer", "RedHat").
	//  Required when using marketplace images, not needed for custom images.
	Publisher string `json:"publisher,omitempty" jsonschema:"Image publisher (e.g.; 'Canonical'; 'MicrosoftWindowsServer'; 'RedHat'). Required when using marketplace images; not needed for custom images."`
	// Image offer (e.g., "0001-com-ubuntu-server-jammy", "WindowsServer", "RHEL").
	//  Required when using marketplace images, not needed for custom images.
	Offer string `json:"offer,omitempty" jsonschema:"Image offer (e.g.; '0001-com-ubuntu-server-jammy'; 'WindowsServer'; 'RHEL'). Required when using marketplace images; not needed for custom images."`
	// Image SKU (e.g., "22_04-lts-gen2", "2022-datacenter-g2", "8-lvm-gen2").
	//  Required when using marketplace images, not needed for custom images.
	Sku string `json:"sku,omitempty" jsonschema:"Image SKU (e.g.; '22_04-lts-gen2'; '2022-datacenter-g2'; '8-lvm-gen2'). Required when using marketplace images; not needed for custom images."`
	// Image version (e.g., "latest", "22.04.202301100").
	//  Use "latest" for auto-updates or a specific version for stability.
	Version string `json:"version,omitempty" jsonschema:"Image version (e.g.; 'latest'; '22.04.202301100'). Use 'latest' for auto-updates or a specific version for stability."`
	// Custom image ID (Azure resource ID of a custom or shared image).
	//  If specified, publisher/offer/sku/version are ignored.
	CustomImageId string `json:"custom_image_id,omitempty" jsonschema:"Custom image ID (Azure resource ID of a custom or shared image). If specified; publisher/offer/sku/version are ignored."`
}

func (s *AzureVirtualMachineImageInput) validate() error {
	return nil
}

func (s *AzureVirtualMachineImageInput) applyDefaults() {
	if s.Version == "" {
		s.Version = "latest"
	}
}

func (s *AzureVirtualMachineImageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Publisher != "" {
		m["publisher"] = s.Publisher
	}
	if s.Offer != "" {
		m["offer"] = s.Offer
	}
	if s.Sku != "" {
		m["sku"] = s.Sku
	}
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.CustomImageId != "" {
		m["custom_image_id"] = s.CustomImageId
	}
	return m
}

// AzureVirtualMachineNetworkConfig defines network-related settings.
type AzureVirtualMachineNetworkConfigInput struct {
	// Enable a public IP address for the VM.
	//  Set to true for VMs that need direct internet access.
	//  For production, prefer private IPs with NAT Gateway or Azure Bastion.
	EnablePublicIp bool `json:"enable_public_ip,omitempty" jsonschema:"Enable a public IP address for the VM. Set to true for VMs that need direct internet access. For production; prefer private IPs with NAT Gateway or Azure Bastion."`
	// SKU for the public IP (if enabled).
	//  Standard is required for availability zones.
	PublicIpSku string `json:"public_ip_sku,omitempty" jsonschema:"enum=basic|standard,SKU for the public IP (if enabled). Standard is required for availability zones."`
	// Allocation method for the public IP.
	PublicIpAllocation string `json:"public_ip_allocation,omitempty" jsonschema:"enum=public_dynamic|public_static,Allocation method for the public IP."`
	// Network Security Group (NSG) ID to associate with the VM's network interface.
	//  Can be a literal Azure resource ID or a reference to another resource.
	NetworkSecurityGroupId string `json:"network_security_group_id,omitempty" jsonschema:"Network Security Group (NSG) ID to associate with the VM's network interface. Can be a literal Azure resource ID or a reference to another resource."`
	// Enable accelerated networking for improved network performance.
	//  Requires a compatible VM size (most D-series and above support this).
	EnableAcceleratedNetworking bool `json:"enable_accelerated_networking,omitempty" jsonschema:"Enable accelerated networking for improved network performance. Requires a compatible VM size (most D-series and above support this)."`
	// Allocation method for the private IP.
	PrivateIpAllocation string `json:"private_ip_allocation,omitempty" jsonschema:"enum=private_dynamic|private_static,Allocation method for the private IP."`
	// Static private IP address (required when private_ip_allocation is static).
	//  Must be within the subnet's address range.
	PrivateIpAddress string `json:"private_ip_address,omitempty" jsonschema:"Static private IP address (required when private_ip_allocation is static). Must be within the subnet's address range."`
}

func (s *AzureVirtualMachineNetworkConfigInput) validate() error {
	switch s.PublicIpSku {
	case "", "basic", "standard":
	default:
		return fmt.Errorf("invalid public_ip_sku: %q", s.PublicIpSku)
	}
	switch s.PublicIpAllocation {
	case "", "public_dynamic", "public_static":
	default:
		return fmt.Errorf("invalid public_ip_allocation: %q", s.PublicIpAllocation)
	}
	switch s.PrivateIpAllocation {
	case "", "private_dynamic", "private_static":
	default:
		return fmt.Errorf("invalid private_ip_allocation: %q", s.PrivateIpAllocation)
	}
	return nil
}

func (s *AzureVirtualMachineNetworkConfigInput) applyDefaults() {
	if s.PublicIpSku == "" {
		s.PublicIpSku = "standard"
	}
	if s.PublicIpAllocation == "" {
		s.PublicIpAllocation = "public_static"
	}
	// default: EnableAcceleratedNetworking = true (applied at zero-value)
	if s.PrivateIpAllocation == "" {
		s.PrivateIpAllocation = "private_dynamic"
	}
}

func (s *AzureVirtualMachineNetworkConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EnablePublicIp {
		m["enable_public_ip"] = s.EnablePublicIp
	}
	if s.PublicIpSku != "" {
		m["public_ip_sku"] = s.PublicIpSku
	}
	if s.PublicIpAllocation != "" {
		m["public_ip_allocation"] = s.PublicIpAllocation
	}
	if s.NetworkSecurityGroupId != "" {
		m["network_security_group_id"] = s.NetworkSecurityGroupId
	}
	if s.EnableAcceleratedNetworking {
		m["enable_accelerated_networking"] = s.EnableAcceleratedNetworking
	}
	if s.PrivateIpAllocation != "" {
		m["private_ip_allocation"] = s.PrivateIpAllocation
	}
	if s.PrivateIpAddress != "" {
		m["private_ip_address"] = s.PrivateIpAddress
	}
	return m
}

// AzureVirtualMachineOsDisk defines the OS disk configuration.
type AzureVirtualMachineOsDiskInput struct {
	// Size of the OS disk in GB.
	//  If not specified, uses the default size from the image.
	SizeGb int32 `json:"size_gb,omitempty" jsonschema:"Size of the OS disk in GB. If not specified; uses the default size from the image."`
	// Storage account type for the OS disk.
	StorageType string `json:"storage_type,omitempty" jsonschema:"enum=standard_lrs|standard_ssd_lrs|premium_lrs|premium_zrs,Storage account type for the OS disk."`
	// Caching mode for the OS disk.
	Caching string `json:"caching,omitempty" jsonschema:"enum=none|read_only|read_write,Caching mode for the OS disk."`
	// Whether to delete the OS disk when the VM is deleted.
	DeleteWithVm bool `json:"delete_with_vm,omitempty" jsonschema:"Whether to delete the OS disk when the VM is deleted."`
	// Azure Key Vault disk encryption set ID for customer-managed key encryption.
	//  Can be a literal value or a reference to an AzureKeyVault resource.
	DiskEncryptionSetId string `json:"disk_encryption_set_id,omitempty" jsonschema:"Azure Key Vault disk encryption set ID for customer-managed key encryption. Can be a literal value or a reference to an AzureKeyVault resource."`
}

func (s *AzureVirtualMachineOsDiskInput) validate() error {
	switch s.StorageType {
	case "", "standard_lrs", "standard_ssd_lrs", "premium_lrs", "premium_zrs":
	default:
		return fmt.Errorf("invalid storage_type: %q", s.StorageType)
	}
	switch s.Caching {
	case "", "none", "read_only", "read_write":
	default:
		return fmt.Errorf("invalid caching: %q", s.Caching)
	}
	return nil
}

func (s *AzureVirtualMachineOsDiskInput) applyDefaults() {
	if s.StorageType == "" {
		s.StorageType = "premium_lrs"
	}
	if s.Caching == "" {
		s.Caching = "read_write"
	}
	// default: DeleteWithVm = true (applied at zero-value)
}

func (s *AzureVirtualMachineOsDiskInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SizeGb != 0 {
		m["size_gb"] = s.SizeGb
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.Caching != "" {
		m["caching"] = s.Caching
	}
	if s.DeleteWithVm {
		m["delete_with_vm"] = s.DeleteWithVm
	}
	if s.DiskEncryptionSetId != "" {
		m["disk_encryption_set_id"] = s.DiskEncryptionSetId
	}
	return m
}

// ParseAzureVirtualMachine validates and normalizes a AzureVirtualMachine cloud_object.
func ParseAzureVirtualMachine(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureVirtualMachine"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureVirtualMachineSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
