// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package azure

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AzureUserAssignedIdentity is the top-level resource definition for an Azure
//
//	User-Assigned Managed Identity with RBAC role assignments. It follows the KRM
//	(Kubernetes Resource Model) pattern with apiVersion, kind, metadata, spec, and status.
//
//	User-Assigned Managed Identities provide a secure, credential-free way for Azure
//	resources to authenticate to Azure services. Unlike system-assigned identities,
//	user-assigned identities have an independent lifecycle and can be shared across
//	multiple resources.
type AzureUserAssignedIdentitySpecInput struct {
	// The Azure region where the Managed Identity will be created.
	//  Must match the region of the resource group.
	//  Examples: "eastus", "westus2", "westeurope", "southeastasia".
	Region string `json:"region" jsonschema:"required,The Azure region where the Managed Identity will be created. Must match the region of the resource group. Examples: 'eastus'; 'westus2'; 'westeurope'; 'southeastasia'."`
	// The Azure Resource Group where the Managed Identity will be created.
	//  Can be a literal string or a reference to an AzureResourceGroup output.
	ResourceGroup string `json:"resource_group" jsonschema:"required,The Azure Resource Group where the Managed Identity will be created. Can be a literal string or a reference to an AzureResourceGroup output."`
	// The name of the User-Assigned Managed Identity.
	//  Must be unique within the resource group.
	//  Azure allows 3-128 characters: alphanumeric, hyphens, and underscores.
	Name string `json:"name" jsonschema:"required,The name of the User-Assigned Managed Identity. Must be unique within the resource group. Azure allows 3-128 characters: alphanumeric; hyphens; and underscores."`
	// RBAC role assignments to grant this identity permissions on Azure resources.
	//  Each assignment binds a role definition to a specific Azure resource scope.
	//  An identity without role assignments has no permissions and cannot access
	//  any Azure resources.
	//
	//  Common patterns:
	//  - Key Vault access: scope = K...
	RoleAssignments []*RoleAssignmentInput `json:"role_assignments,omitempty" jsonschema:"RBAC role assignments to grant this identity permissions on Azure resources. Each assignment binds a role definition to a specific Azure resource scope. An identity without role assignments has no per..."`
}

func (s *AzureUserAssignedIdentitySpecInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.ResourceGroup == "" {
		return fmt.Errorf("resource_group is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.RoleAssignments {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("role_assignments[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AzureUserAssignedIdentitySpecInput) applyDefaults() {
}

func (s *AzureUserAssignedIdentitySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	m["resource_group"] = s.ResourceGroup
	m["name"] = s.Name
	if len(s.RoleAssignments) > 0 {
		items := make([]any, len(s.RoleAssignments))
		for i, v := range s.RoleAssignments {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["role_assignments"] = items
	}
	return m
}

// RoleAssignment defines a single Azure RBAC role binding for the managed identity.
//
//	Each assignment grants the identity a specific role on a specific Azure resource.
type RoleAssignmentInput struct {
	// The Azure resource ID to scope this role assignment to.
	//  Can be a subscription, resource group, or individual resource ID.
	//  Can be a literal Azure resource ID or a reference to another resource's output.
	//
	//  Examples of literal scopes:
	//  - Subscription: "/subscriptions/00000000-0000-0000-0000-000000000...
	Scope string `json:"scope" jsonschema:"required,The Azure resource ID to scope this role assignment to. Can be a subscription; resource group; or individual resource ID. Can be a literal Azure resource ID or a reference to another resource's output..."`
	// The name of a built-in or custom Azure RBAC role to assign.
	//  Uses Azure's exact role definition names for clarity and direct API mapping.
	//
	//  Common built-in roles:
	//  - "Contributor" -- full resource management except RBAC
	//  - "Reader" -- read-only access
	//  - "Key Vault Secrets User" -- read Key Vault se...
	RoleDefinitionName string `json:"role_definition_name" jsonschema:"required,The name of a built-in or custom Azure RBAC role to assign. Uses Azure's exact role definition names for clarity and direct API mapping. Common built-in roles: - 'Contributor' -- full resource managem..."`
}

func (s *RoleAssignmentInput) validate() error {
	if s.Scope == "" {
		return fmt.Errorf("scope is required")
	}
	if s.RoleDefinitionName == "" {
		return fmt.Errorf("role_definition_name is required")
	}
	return nil
}

func (s *RoleAssignmentInput) applyDefaults() {
}

func (s *RoleAssignmentInput) toMap() map[string]any {
	m := make(map[string]any)
	m["scope"] = s.Scope
	m["role_definition_name"] = s.RoleDefinitionName
	return m
}

// ParseAzureUserAssignedIdentity validates and normalizes a AzureUserAssignedIdentity cloud_object.
func ParseAzureUserAssignedIdentity(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "azure.openmcf.org/v1", "AzureUserAssignedIdentity"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AzureUserAssignedIdentitySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
