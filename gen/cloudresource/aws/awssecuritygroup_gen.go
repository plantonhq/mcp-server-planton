// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-security-group
type AwsSecurityGroupSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// vpc_id is the ID of the VPC where this Security Group will be created.
	//  Example: "vpc-12345abcde"
	//  This field is required because every Security Group must belong to one VPC.
	VpcId string `json:"vpc_id" jsonschema:"required,vpc_id is the ID of the VPC where this Security Group will be created. Example: 'vpc-12345abcde' This field is required because every Security Group must belong to one VPC."`
	// description provides a short explanation of this Security Group’s purpose.
	//  This field is required by AWS and cannot be modified once created without a replacement.
	//  Example: "Allows inbound HTTP and SSH for web tier"
	Description string `json:"description" jsonschema:"required,description provides a short explanation of this Security Group’s purpose. This field is required by AWS and cannot be modified once created without a replacement. Example: 'Allows inbound HTTP and ..."`
	// ingress_rules define the inbound traffic rules for this Security Group.
	//  If empty, inbound traffic is fully restricted (deny all).
	Ingress []*SecurityGroupRuleInput `json:"ingress,omitempty" jsonschema:"ingress_rules define the inbound traffic rules for this Security Group. If empty; inbound traffic is fully restricted (deny all)."`
	// egress_rules define the outbound traffic rules for this Security Group.
	//  If empty, AWS defaults to allow all outbound traffic unless configured otherwise.
	Egress []*SecurityGroupRuleInput `json:"egress,omitempty" jsonschema:"egress_rules define the outbound traffic rules for this Security Group. If empty; AWS defaults to allow all outbound traffic unless configured otherwise."`
}

func (s *AwsSecurityGroupSpecInput) validate() error {
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if s.Description == "" {
		return fmt.Errorf("description is required")
	}
	for i, v := range s.Ingress {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("ingress[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Egress {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("egress[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsSecurityGroupSpecInput) applyDefaults() {
}

func (s *AwsSecurityGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["vpc_id"] = s.VpcId
	m["description"] = s.Description
	if len(s.Ingress) > 0 {
		items := make([]any, len(s.Ingress))
		for i, v := range s.Ingress {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["ingress"] = items
	}
	if len(s.Egress) > 0 {
		items := make([]any, len(s.Egress))
		for i, v := range s.Egress {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["egress"] = items
	}
	return m
}

// SecurityGroupRule represents a single inbound or outbound rule in the Security Group.
//
//	For ingress, fill in sources (cidrs or source_security_group_ids).
//	For egress, fill in destinations (cidrs or destination_security_group_ids).
type SecurityGroupRuleInput struct {
	// protocol indicates the protocol for the rule.
	//  Common values: "tcp", "udp", "icmp", or "-1" (all protocols).
	Protocol string `json:"protocol" jsonschema:"required,protocol indicates the protocol for the rule. Common values: 'tcp'; 'udp'; 'icmp'; or '-1' (all protocols)."`
	// from_port is the starting port in the range.
	//  For single-port rules, from_port == to_port.
	//  Use 0 when specifying all ports (with protocol = -1) or for ICMP types.
	FromPort int32 `json:"from_port,omitempty" jsonschema:"from_port is the starting port in the range. For single-port rules; from_port == to_port. Use 0 when specifying all ports (with protocol = -1) or for ICMP types."`
	// to_port is the ending port in the range.
	//  For single-port rules, to_port == from_port.
	//  Use 0 when specifying all ports (with protocol = -1) or for ICMP codes.
	ToPort int32 `json:"to_port,omitempty" jsonschema:"to_port is the ending port in the range. For single-port rules; to_port == from_port. Use 0 when specifying all ports (with protocol = -1) or for ICMP codes."`
	// ipv4_cidrs is the list of IPv4 CIDR blocks allowed (ingress) or targeted (egress).
	//  Examples: "10.0.0.0/16", "0.0.0.0/0"
	//  If empty, no IPv4 CIDRs are included in this rule.
	Ipv4Cidrs []string `json:"ipv4_cidrs,omitempty" jsonschema:"ipv4_cidrs is the list of IPv4 CIDR blocks allowed (ingress) or targeted (egress). Examples: '10.0.0.0/16'; '0.0.0.0/0' If empty; no IPv4 CIDRs are included in this rule."`
	// ipv6_cidrs is the list of IPv6 CIDR blocks allowed or targeted.
	//  Example: "::/0"
	//  If empty, no IPv6 CIDRs are included in this rule.
	Ipv6Cidrs []string `json:"ipv6_cidrs,omitempty" jsonschema:"ipv6_cidrs is the list of IPv6 CIDR blocks allowed or targeted. Example: '::/0' If empty; no IPv6 CIDRs are included in this rule."`
	// source_security_group_ids is the list of Security Group IDs that can send traffic (for ingress).
	//  Typically used for internal traffic between resources. Can reference other AwsSecurityGroup resources.
	SourceSecurityGroupIds []string `json:"source_security_group_ids,omitempty" jsonschema:"source_security_group_ids is the list of Security Group IDs that can send traffic (for ingress). Typically used for internal traffic between resources. Can reference other AwsSecurityGroup resources."`
	// destination_security_group_ids is the list of Security Group IDs that receive traffic (for egress).
	//  Useful for restricting outbound traffic to specific groups. Can reference other AwsSecurityGroup resources.
	DestinationSecurityGroupIds []string `json:"destination_security_group_ids,omitempty" jsonschema:"destination_security_group_ids is the list of Security Group IDs that receive traffic (for egress). Useful for restricting outbound traffic to specific groups. Can reference other AwsSecurityGroup res..."`
	// self_reference indicates whether to allow traffic from/to the same Security Group.
	//  This is equivalent to referencing the group’s own ID.
	SelfReference bool `json:"self_reference,omitempty" jsonschema:"self_reference indicates whether to allow traffic from/to the same Security Group. This is equivalent to referencing the group’s own ID."`
	// rule_description is an optional explanation of this specific rule,
	//  aiding in clarity and maintenance. Max 255 chars recommended.
	Description string `json:"description,omitempty" jsonschema:"rule_description is an optional explanation of this specific rule; aiding in clarity and maintenance. Max 255 chars recommended."`
}

func (s *SecurityGroupRuleInput) validate() error {
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	return nil
}

func (s *SecurityGroupRuleInput) applyDefaults() {
}

func (s *SecurityGroupRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["protocol"] = s.Protocol
	if s.FromPort != 0 {
		m["from_port"] = s.FromPort
	}
	if s.ToPort != 0 {
		m["to_port"] = s.ToPort
	}
	if len(s.Ipv4Cidrs) > 0 {
		m["ipv4_cidrs"] = s.Ipv4Cidrs
	}
	if len(s.Ipv6Cidrs) > 0 {
		m["ipv6_cidrs"] = s.Ipv6Cidrs
	}
	if len(s.SourceSecurityGroupIds) > 0 {
		m["source_security_group_ids"] = s.SourceSecurityGroupIds
	}
	if len(s.DestinationSecurityGroupIds) > 0 {
		m["destination_security_group_ids"] = s.DestinationSecurityGroupIds
	}
	if s.SelfReference {
		m["self_reference"] = s.SelfReference
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	return m
}

// ParseAwsSecurityGroup validates and normalizes a AwsSecurityGroup cloud_object.
func ParseAwsSecurityGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsSecurityGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsSecurityGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
