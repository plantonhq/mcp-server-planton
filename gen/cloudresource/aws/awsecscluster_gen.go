// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsEcsCluster represents a containerized application deployed on AWS ECS.
//
//	This resource manages ECS services that can run on either Fargate or EC2.
type AwsEcsClusterSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// enable_container_insights determines whether to enable CloudWatch
	//  Container Insights for this cluster. This is highly recommended
	//  for production monitoring, though it incurs CloudWatch costs.
	//  If omitted, it is recommended to be "true".
	EnableContainerInsights bool `json:"enable_container_insights,omitempty" jsonschema:"enable_container_insights determines whether to enable CloudWatch Container Insights for this cluster. This is highly recommended for production monitoring; though it incurs CloudWatch costs. If omitt..."`
	// capacity_providers is a list of capacity providers attached
	//  to this cluster. For a Fargate-only cluster, typically ["FARGATE"]
	//  or ["FARGATE", "FARGATE_SPOT"] for cost-optimized Spot usage.
	CapacityProviders []string `json:"capacity_providers,omitempty" jsonschema:"capacity_providers is a list of capacity providers attached to this cluster. For a Fargate-only cluster; typically ['FARGATE'] or ['FARGATE'; 'FARGATE_SPOT'] for cost-optimized Spot usage."`
	// default_capacity_provider_strategy defines the base/weight
	//  distribution for tasks across capacity providers. This is the
	//  primary cost-optimization lever for Fargate workloads.
	//  Example: FARGATE (base: 1, weight: 1) + FARGATE_SPOT (weight: 4)
	//  results in 20% on-demand, 80% Spot for scaled tasks.
	DefaultCapacityProviderStrategy []*CapacityProviderStrategyInput `json:"default_capacity_provider_strategy,omitempty" jsonschema:"default_capacity_provider_strategy defines the base/weight distribution for tasks across capacity providers. This is the primary cost-optimization lever for Fargate workloads. Example: FARGATE (base: ..."`
	// execute_command_configuration defines cluster-level auditing
	//  settings for ECS Exec. This controls logging and encryption
	//  for exec sessions. If not specified, exec is disabled.
	ExecuteCommandConfiguration *ExecConfigurationInput `json:"execute_command_configuration,omitempty" jsonschema:"execute_command_configuration defines cluster-level auditing settings for ECS Exec. This controls logging and encryption for exec sessions. If not specified; exec is disabled."`
}

func (s *AwsEcsClusterSpecInput) validate() error {
	for i, v := range s.DefaultCapacityProviderStrategy {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("default_capacity_provider_strategy[%d]: %w", i, err)
			}
		}
	}
	if s.ExecuteCommandConfiguration != nil {
		if err := s.ExecuteCommandConfiguration.validate(); err != nil {
			return fmt.Errorf("execute_command_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsEcsClusterSpecInput) applyDefaults() {
	if s.ExecuteCommandConfiguration != nil {
		s.ExecuteCommandConfiguration.applyDefaults()
	}
}

func (s *AwsEcsClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.EnableContainerInsights {
		m["enable_container_insights"] = s.EnableContainerInsights
	}
	if len(s.CapacityProviders) > 0 {
		m["capacity_providers"] = s.CapacityProviders
	}
	if len(s.DefaultCapacityProviderStrategy) > 0 {
		items := make([]any, len(s.DefaultCapacityProviderStrategy))
		for i, v := range s.DefaultCapacityProviderStrategy {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["default_capacity_provider_strategy"] = items
	}
	if s.ExecuteCommandConfiguration != nil {
		m["execute_command_configuration"] = s.ExecuteCommandConfiguration.toMap()
	}
	return m
}

// CapacityProviderStrategy defines the base/weight model for
//
//	distributing tasks across capacity providers, enabling production
//	cost optimization patterns (e.g., guaranteed on-demand base + Spot scaling).
type CapacityProviderStrategyInput struct {
	// capacity_provider is the name of the capacity provider
	//  (e.g., "FARGATE" or "FARGATE_SPOT").
	CapacityProvider string `json:"capacity_provider,omitempty" jsonschema:"capacity_provider is the name of the capacity provider (e.g.; 'FARGATE' or 'FARGATE_SPOT')."`
	// base is the minimum number of tasks to run on this provider.
	//  Typically used with FARGATE to guarantee stability.
	//  Must be 0 or greater.
	Base int32 `json:"base,omitempty" jsonschema:"base is the minimum number of tasks to run on this provider. Typically used with FARGATE to guarantee stability. Must be 0 or greater."`
	// weight is the relative weight for scaling tasks beyond the base.
	//  Example: FARGATE (weight: 1) + FARGATE_SPOT (weight: 4)
	//  results in 20% on-demand, 80% Spot for scaled tasks.
	//  Must be greater than 0 if this strategy is used.
	Weight int32 `json:"weight,omitempty" jsonschema:"weight is the relative weight for scaling tasks beyond the base. Example: FARGATE (weight: 1) + FARGATE_SPOT (weight: 4) results in 20% on-demand; 80% Spot for scaled tasks. Must be greater than 0 if ..."`
}

func (s *CapacityProviderStrategyInput) validate() error {
	return nil
}

func (s *CapacityProviderStrategyInput) applyDefaults() {
}

func (s *CapacityProviderStrategyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CapacityProvider != "" {
		m["capacity_provider"] = s.CapacityProvider
	}
	if s.Base != 0 {
		m["base"] = s.Base
	}
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	return m
}

// ExecConfiguration defines cluster-level auditing for ECS Exec,
//
//	controlling how exec session commands and output are logged.
type ExecConfigurationInput struct {
	// logging controls the logging behavior for Exec sessions.
	//  UNSPECIFIED (default) means exec is disabled.
	//  DEFAULT enables exec with AWS-managed logging.
	//  NONE enables exec but disables audit logging.
	//  OVERRIDE uses custom log_configuration.
	Logging string `json:"logging,omitempty" jsonschema:"enum=DEFAULT|NONE|OVERRIDE,logging controls the logging behavior for Exec sessions. UNSPECIFIED (default) means exec is disabled. DEFAULT enables exec with AWS-managed logging. NONE enables exec but disables audit logging. OVER..."`
	// log_configuration specifies custom destinations for Exec audit logs.
	//  Only used if logging is OVERRIDE.
	LogConfiguration *ExecLogConfigurationInput `json:"log_configuration,omitempty" jsonschema:"log_configuration specifies custom destinations for Exec audit logs. Only used if logging is OVERRIDE."`
	// kms_key_id is an optional KMS key ID for encrypting exec session data.
	//  Applies to both CloudWatch Logs and S3 if specified.
	//  Can reference an AwsKmsKey resource.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"kms_key_id is an optional KMS key ID for encrypting exec session data. Applies to both CloudWatch Logs and S3 if specified. Can reference an AwsKmsKey resource."`
}

func (s *ExecConfigurationInput) validate() error {
	switch s.Logging {
	case "", "DEFAULT", "NONE", "OVERRIDE":
	default:
		return fmt.Errorf("invalid logging: %q", s.Logging)
	}
	if s.LogConfiguration != nil {
		if err := s.LogConfiguration.validate(); err != nil {
			return fmt.Errorf("log_configuration: %w", err)
		}
	}
	return nil
}

func (s *ExecConfigurationInput) applyDefaults() {
	if s.LogConfiguration != nil {
		s.LogConfiguration.applyDefaults()
	}
}

func (s *ExecConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Logging != "" {
		m["logging"] = s.Logging
	}
	if s.LogConfiguration != nil {
		m["log_configuration"] = s.LogConfiguration.toMap()
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	return m
}

// ExecLogConfiguration specifies custom destinations for Exec audit logs,
//
//	enabling compliance and security monitoring of container exec sessions.
type ExecLogConfigurationInput struct {
	// cloud_watch_log_group_name is the CloudWatch log group to send logs to.
	//  If specified, exec session logs will be sent to this log group.
	CloudWatchLogGroupName string `json:"cloud_watch_log_group_name,omitempty" jsonschema:"cloud_watch_log_group_name is the CloudWatch log group to send logs to. If specified; exec session logs will be sent to this log group."`
	// cloud_watch_encryption_enabled controls whether CloudWatch logs are encrypted.
	//  If true, uses the kms_key_id from ExecConfiguration.
	CloudWatchEncryptionEnabled bool `json:"cloud_watch_encryption_enabled,omitempty" jsonschema:"cloud_watch_encryption_enabled controls whether CloudWatch logs are encrypted. If true; uses the kms_key_id from ExecConfiguration."`
	// s3_bucket_name is the S3 bucket to send logs to.
	//  If specified, exec session logs will be stored in this bucket.
	S3BucketName string `json:"s3_bucket_name,omitempty" jsonschema:"s3_bucket_name is the S3 bucket to send logs to. If specified; exec session logs will be stored in this bucket."`
	// s3_key_prefix is the S3 key prefix for log files.
	//  Used to organize logs within the S3 bucket.
	S3KeyPrefix string `json:"s3_key_prefix,omitempty" jsonschema:"s3_key_prefix is the S3 key prefix for log files. Used to organize logs within the S3 bucket."`
	// s3_encryption_enabled controls whether S3 logs are encrypted.
	//  If true, uses the kms_key_id from ExecConfiguration.
	S3EncryptionEnabled bool `json:"s3_encryption_enabled,omitempty" jsonschema:"s3_encryption_enabled controls whether S3 logs are encrypted. If true; uses the kms_key_id from ExecConfiguration."`
}

func (s *ExecLogConfigurationInput) validate() error {
	return nil
}

func (s *ExecLogConfigurationInput) applyDefaults() {
}

func (s *ExecLogConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CloudWatchLogGroupName != "" {
		m["cloud_watch_log_group_name"] = s.CloudWatchLogGroupName
	}
	if s.CloudWatchEncryptionEnabled {
		m["cloud_watch_encryption_enabled"] = s.CloudWatchEncryptionEnabled
	}
	if s.S3BucketName != "" {
		m["s3_bucket_name"] = s.S3BucketName
	}
	if s.S3KeyPrefix != "" {
		m["s3_key_prefix"] = s.S3KeyPrefix
	}
	if s.S3EncryptionEnabled {
		m["s3_encryption_enabled"] = s.S3EncryptionEnabled
	}
	return m
}

// ParseAwsEcsCluster validates and normalizes a AwsEcsCluster cloud_object.
func ParseAwsEcsCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEcsCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEcsClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
