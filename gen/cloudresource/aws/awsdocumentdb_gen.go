// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsDocumentDb is a deployment component for creating and managing
//
//	AWS DocumentDB clusters - a fully managed MongoDB-compatible document database service.
type AwsDocumentDbSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// subnets is the list of subnet IDs for the DB subnet group.
	//  Provide at least two subnets in distinct Availability Zones for high availability.
	Subnets []string `json:"subnets,omitempty" jsonschema:"subnets is the list of subnet IDs for the DB subnet group. Provide at least two subnets in distinct Availability Zones for high availability."`
	// db_subnet_group is an optional name of an existing DB subnet group to use
	//  instead of creating one from subnets.
	DbSubnetGroup string `json:"db_subnet_group,omitempty" jsonschema:"db_subnet_group is an optional name of an existing DB subnet group to use instead of creating one from subnets."`
	// security_groups are the VPC security groups to associate with the cluster.
	SecurityGroups []string `json:"security_groups,omitempty" jsonschema:"security_groups are the VPC security groups to associate with the cluster."`
	// allowed_cidrs are IPv4 CIDRs to allow ingress to the cluster security group.
	AllowedCidrs []string `json:"allowed_cidrs,omitempty" jsonschema:"allowed_cidrs are IPv4 CIDRs to allow ingress to the cluster security group."`
	// vpc is the VPC where the cluster will be deployed.
	Vpc string `json:"vpc,omitempty" jsonschema:"vpc is the VPC where the cluster will be deployed."`
	// engine_version is the DocumentDB engine version.
	//  Examples: "4.0.0", "5.0.0"
	EngineVersion string `json:"engine_version,omitempty" jsonschema:"engine_version is the DocumentDB engine version. Examples: '4.0.0'; '5.0.0'"`
	// port is the TCP port on which the cluster accepts connections.
	Port int32 `json:"port,omitempty" jsonschema:"port is the TCP port on which the cluster accepts connections."`
	// master_username is the master user name for the cluster.
	MasterUsername string `json:"master_username,omitempty" jsonschema:"master_username is the master user name for the cluster."`
	// master_password is the master user password. Required unless using Secrets Manager.
	MasterPassword string `json:"master_password" jsonschema:"required,master_password is the master user password. Required unless using Secrets Manager."`
	// instance_count is the number of instances to create in the cluster.
	InstanceCount int32 `json:"instance_count,omitempty" jsonschema:"instance_count is the number of instances to create in the cluster."`
	// instance_class is the compute and memory capacity of the DB instances.
	//  Examples: "db.r5.large", "db.r5.xlarge", "db.r6g.large"
	InstanceClass string `json:"instance_class,omitempty" jsonschema:"instance_class is the compute and memory capacity of the DB instances. Examples: 'db.r5.large'; 'db.r5.xlarge'; 'db.r6g.large'"`
	// storage_encrypted indicates whether to encrypt the cluster storage at rest.
	StorageEncrypted bool `json:"storage_encrypted,omitempty" jsonschema:"storage_encrypted indicates whether to encrypt the cluster storage at rest."`
	// kms_key is the ARN of the KMS key for storage encryption.
	KmsKey string `json:"kms_key,omitempty" jsonschema:"kms_key is the ARN of the KMS key for storage encryption."`
	// backup_retention_period is the number of days to retain automated backups (1-35).
	BackupRetentionPeriod int32 `json:"backup_retention_period,omitempty" jsonschema:"backup_retention_period is the number of days to retain automated backups (1-35)."`
	// preferred_backup_window is the daily time range for automated backups in UTC.
	//  Format: "hh24:mi-hh24:mi" (e.g., "03:00-04:00")
	PreferredBackupWindow string `json:"preferred_backup_window,omitempty" jsonschema:"preferred_backup_window is the daily time range for automated backups in UTC. Format: 'hh24:mi-hh24:mi' (e.g.; '03:00-04:00')"`
	// preferred_maintenance_window is the weekly time range for maintenance in UTC.
	//  Format: "ddd:hh24:mi-ddd:hh24:mi" (e.g., "sun:05:00-sun:06:00")
	PreferredMaintenanceWindow string `json:"preferred_maintenance_window,omitempty" jsonschema:"preferred_maintenance_window is the weekly time range for maintenance in UTC. Format: 'ddd:hh24:mi-ddd:hh24:mi' (e.g.; 'sun:05:00-sun:06:00')"`
	// deletion_protection prevents accidental cluster deletion when enabled.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"deletion_protection prevents accidental cluster deletion when enabled."`
	// skip_final_snapshot controls whether a final snapshot is created on deletion.
	SkipFinalSnapshot bool `json:"skip_final_snapshot,omitempty" jsonschema:"skip_final_snapshot controls whether a final snapshot is created on deletion."`
	// final_snapshot_identifier is the identifier for the final snapshot when
	//  skip_final_snapshot is false.
	FinalSnapshotIdentifier string `json:"final_snapshot_identifier,omitempty" jsonschema:"final_snapshot_identifier is the identifier for the final snapshot when skip_final_snapshot is false."`
	// enabled_cloudwatch_logs_exports lists log types to export to CloudWatch.
	//  Valid values: "audit", "profiler"
	EnabledCloudwatchLogsExports []string `json:"enabled_cloudwatch_logs_exports,omitempty" jsonschema:"enabled_cloudwatch_logs_exports lists log types to export to CloudWatch. Valid values: 'audit'; 'profiler'"`
	// apply_immediately specifies whether modifications are applied immediately
	//  or during the next maintenance window.
	ApplyImmediately bool `json:"apply_immediately,omitempty" jsonschema:"apply_immediately specifies whether modifications are applied immediately or during the next maintenance window."`
	// auto_minor_version_upgrade enables automatic minor engine version upgrades.
	AutoMinorVersionUpgrade bool `json:"auto_minor_version_upgrade,omitempty" jsonschema:"auto_minor_version_upgrade enables automatic minor engine version upgrades."`
	// cluster_parameter_group_name is the name of the cluster parameter group.
	ClusterParameterGroupName string `json:"cluster_parameter_group_name,omitempty" jsonschema:"cluster_parameter_group_name is the name of the cluster parameter group."`
	// cluster_parameters are custom parameters for the cluster parameter group.
	ClusterParameters []*AwsDocumentDbParameterInput `json:"cluster_parameters,omitempty" jsonschema:"cluster_parameters are custom parameters for the cluster parameter group."`
}

func (s *AwsDocumentDbSpecInput) validate() error {
	if s.MasterPassword == "" {
		return fmt.Errorf("master_password is required")
	}
	for i, v := range s.ClusterParameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("cluster_parameters[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsDocumentDbSpecInput) applyDefaults() {
	if s.EngineVersion == "" {
		s.EngineVersion = "5.0.0"
	}
	if s.Port == 0 {
		s.Port = 27017
	}
	if s.MasterUsername == "" {
		s.MasterUsername = "docdbadmin"
	}
	if s.InstanceCount == 0 {
		s.InstanceCount = 1
	}
	if s.InstanceClass == "" {
		s.InstanceClass = "db.r6g.large"
	}
	// default: StorageEncrypted = true (applied at zero-value)
	if s.BackupRetentionPeriod == 0 {
		s.BackupRetentionPeriod = 7
	}
	// default: AutoMinorVersionUpgrade = true (applied at zero-value)
}

func (s *AwsDocumentDbSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if len(s.Subnets) > 0 {
		m["subnets"] = s.Subnets
	}
	if s.DbSubnetGroup != "" {
		m["db_subnet_group"] = s.DbSubnetGroup
	}
	if len(s.SecurityGroups) > 0 {
		m["security_groups"] = s.SecurityGroups
	}
	if len(s.AllowedCidrs) > 0 {
		m["allowed_cidrs"] = s.AllowedCidrs
	}
	if s.Vpc != "" {
		m["vpc"] = s.Vpc
	}
	if s.EngineVersion != "" {
		m["engine_version"] = s.EngineVersion
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.MasterUsername != "" {
		m["master_username"] = s.MasterUsername
	}
	m["master_password"] = s.MasterPassword
	if s.InstanceCount != 0 {
		m["instance_count"] = s.InstanceCount
	}
	if s.InstanceClass != "" {
		m["instance_class"] = s.InstanceClass
	}
	if s.StorageEncrypted {
		m["storage_encrypted"] = s.StorageEncrypted
	}
	if s.KmsKey != "" {
		m["kms_key"] = s.KmsKey
	}
	if s.BackupRetentionPeriod != 0 {
		m["backup_retention_period"] = s.BackupRetentionPeriod
	}
	if s.PreferredBackupWindow != "" {
		m["preferred_backup_window"] = s.PreferredBackupWindow
	}
	if s.PreferredMaintenanceWindow != "" {
		m["preferred_maintenance_window"] = s.PreferredMaintenanceWindow
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if s.SkipFinalSnapshot {
		m["skip_final_snapshot"] = s.SkipFinalSnapshot
	}
	if s.FinalSnapshotIdentifier != "" {
		m["final_snapshot_identifier"] = s.FinalSnapshotIdentifier
	}
	if len(s.EnabledCloudwatchLogsExports) > 0 {
		m["enabled_cloudwatch_logs_exports"] = s.EnabledCloudwatchLogsExports
	}
	if s.ApplyImmediately {
		m["apply_immediately"] = s.ApplyImmediately
	}
	if s.AutoMinorVersionUpgrade {
		m["auto_minor_version_upgrade"] = s.AutoMinorVersionUpgrade
	}
	if s.ClusterParameterGroupName != "" {
		m["cluster_parameter_group_name"] = s.ClusterParameterGroupName
	}
	if len(s.ClusterParameters) > 0 {
		items := make([]any, len(s.ClusterParameters))
		for i, v := range s.ClusterParameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["cluster_parameters"] = items
	}
	return m
}

// AwsDocumentDbParameter represents a parameter for the cluster parameter group.
type AwsDocumentDbParameterInput struct {
	// name is the parameter name.
	Name string `json:"name,omitempty" jsonschema:"name is the parameter name."`
	// value is the parameter value.
	Value string `json:"value,omitempty" jsonschema:"value is the parameter value."`
	// apply_method specifies when the parameter is applied: "immediate" or "pending-reboot".
	ApplyMethod string `json:"apply_method,omitempty" jsonschema:"apply_method specifies when the parameter is applied: 'immediate' or 'pending-reboot'."`
}

func (s *AwsDocumentDbParameterInput) validate() error {
	return nil
}

func (s *AwsDocumentDbParameterInput) applyDefaults() {
}

func (s *AwsDocumentDbParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.ApplyMethod != "" {
		m["apply_method"] = s.ApplyMethod
	}
	return m
}

// ParseAwsDocumentDb validates and normalizes a AwsDocumentDb cloud_object.
func ParseAwsDocumentDb(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsDocumentDb"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsDocumentDbSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
