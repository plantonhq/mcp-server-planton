// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsAlb represents a containerized application deployed on AWS ECS.
//
//	This resource manages ECS services that can run on either Fargate or EC2.
type AwsAlbSpecInput struct {
	// The AWS region where the ALB will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the ALB will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// list of subnet IDs in which to create the ALB. AWS requires at least two subnets
	//  for ALBs, which also ensures high availability across multiple Availability Zones.
	//  Typically use private subnets for internal ALBs or public subnets for internet-facing ALBs.
	Subnets []string `json:"subnets" jsonschema:"required,list of subnet IDs in which to create the ALB. AWS requires at least two subnets for ALBs; which also ensures high availability across multiple Availability Zones. Typically use private subnets for in..."`
	// list of security group IDs to attach to the ALB.
	SecurityGroups []string `json:"security_groups,omitempty" jsonschema:"list of security group IDs to attach to the ALB."`
	// indicates whether the ALB is internal or internet-facing.
	//  If true, the ALB is internal; if false (or not set), it is internet-facing.
	Internal bool `json:"internal,omitempty" jsonschema:"indicates whether the ALB is internal or internet-facing. If true; the ALB is internal; if false (or not set); it is internet-facing."`
	// indicates whether the ALB should have deletion protection enabled.
	//  This prevents accidental deletion.
	DeleteProtectionEnabled bool `json:"delete_protection_enabled,omitempty" jsonschema:"indicates whether the ALB should have deletion protection enabled. This prevents accidental deletion."`
	// sets the idle timeout in seconds for connections to the ALB.
	//  If omitted, AWS default is 60 seconds.
	IdleTimeoutSeconds int32 `json:"idle_timeout_seconds,omitempty" jsonschema:"sets the idle timeout in seconds for connections to the ALB. If omitted; AWS default is 60 seconds."`
	// dns configuration allows the resource to manage Route53 DNS if enabled.
	Dns *AwsAlbDnsInput `json:"dns,omitempty" jsonschema:"dns configuration allows the resource to manage Route53 DNS if enabled."`
	// ssl configuration allows a single toggle for SSL, plus a certificate ARN if enabled.
	Ssl *AwsAlbSslInput `json:"ssl,omitempty" jsonschema:"ssl configuration allows a single toggle for SSL; plus a certificate ARN if enabled."`
}

func (s *AwsAlbSpecInput) validate() error {
	if len(s.Subnets) == 0 {
		return fmt.Errorf("subnets is required")
	}
	if len(s.Subnets) < 2 {
		return fmt.Errorf("subnets requires at least 2 items, got %d", len(s.Subnets))
	}
	if s.Dns != nil {
		if err := s.Dns.validate(); err != nil {
			return fmt.Errorf("dns: %w", err)
		}
	}
	if s.Ssl != nil {
		if err := s.Ssl.validate(); err != nil {
			return fmt.Errorf("ssl: %w", err)
		}
	}
	return nil
}

func (s *AwsAlbSpecInput) applyDefaults() {
	if s.Dns != nil {
		s.Dns.applyDefaults()
	}
	if s.Ssl != nil {
		s.Ssl.applyDefaults()
	}
}

func (s *AwsAlbSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["subnets"] = s.Subnets
	if len(s.SecurityGroups) > 0 {
		m["security_groups"] = s.SecurityGroups
	}
	if s.Internal {
		m["internal"] = s.Internal
	}
	if s.DeleteProtectionEnabled {
		m["delete_protection_enabled"] = s.DeleteProtectionEnabled
	}
	if s.IdleTimeoutSeconds != 0 {
		m["idle_timeout_seconds"] = s.IdleTimeoutSeconds
	}
	if s.Dns != nil {
		m["dns"] = s.Dns.toMap()
	}
	if s.Ssl != nil {
		m["ssl"] = s.Ssl.toMap()
	}
	return m
}

// AwsAlbDns defines the Route53 DNS configuration for the ALB.
type AwsAlbDnsInput struct {
	// enabled, when set to true, indicates that the ALB resource
	//  should create DNS records in Route53 .
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled; when set to true; indicates that the ALB resource should create DNS records in Route53 ."`
	// route53_zone_id is the Route53 Hosted Zone ID where DNS records
	//  will be created.
	Route53ZoneId string `json:"route53_zone_id,omitempty" jsonschema:"route53_zone_id is the Route53 Hosted Zone ID where DNS records will be created."`
	// hostnames is a list of domain names (e.g., ["app.example.com"])
	//  that will point to this ALB.
	Hostnames []string `json:"hostnames,omitempty" jsonschema:"hostnames is a list of domain names (e.g.; ['app.example.com']) that will point to this ALB."`
}

func (s *AwsAlbDnsInput) validate() error {
	return nil
}

func (s *AwsAlbDnsInput) applyDefaults() {
}

func (s *AwsAlbDnsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Route53ZoneId != "" {
		m["route53_zone_id"] = s.Route53ZoneId
	}
	if len(s.Hostnames) > 0 {
		m["hostnames"] = s.Hostnames
	}
	return m
}

// AwsAlbSsl defines a toggle for SSL, plus a certificate ARN required if enabled is true.
type AwsAlbSslInput struct {
	Enabled bool `json:"enabled,omitempty" jsonschema:""`
	// Validation Removed: "certificate_arn must be set if ssl.enabled is true"
	//
	//  Previously, we enforced a message-level CEL expression on AwsAlbSsl:
	//    "!this.enabled || (has(this.certificate_arn.value) || has(this.certificate_arn.value_from))"
	//  to require a certificate ARN whenever SSL is enabled.
	//
	//  How...
	CertificateArn string `json:"certificate_arn,omitempty" jsonschema:"Validation Removed: 'certificate_arn must be set if ssl.enabled is true' Previously; we enforced a message-level CEL expression on AwsAlbSsl: '!this.enabled || (has(this.certificate_arn.value) || has(..."`
}

func (s *AwsAlbSslInput) validate() error {
	return nil
}

func (s *AwsAlbSslInput) applyDefaults() {
}

func (s *AwsAlbSslInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.CertificateArn != "" {
		m["certificate_arn"] = s.CertificateArn
	}
	return m
}

// ParseAwsAlb validates and normalizes a AwsAlb cloud_object.
func ParseAwsAlb(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsAlb"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsAlbSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
