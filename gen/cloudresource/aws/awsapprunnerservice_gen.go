// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-app-runner-service
type AwsAppRunnerServiceSpecInput struct {
	// The AWS region where the App Runner service will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the App Runner service will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Image-based deployment source. Use this to deploy from a container image
	//  stored in Amazon ECR (private) or ECR Public Gallery.
	ImageSource *AwsAppRunnerServiceImageSourceInput `json:"image_source,omitempty" jsonschema:"Image-based deployment source. Use this to deploy from a container image stored in Amazon ECR (private) or ECR Public Gallery."`
	// Code-based deployment source. Use this to deploy from a GitHub repository.
	//  App Runner clones the repo, builds the application using the specified runtime,
	//  and deploys the resulting container.
	CodeSource *AwsAppRunnerServiceCodeSourceInput `json:"code_source,omitempty" jsonschema:"Code-based deployment source. Use this to deploy from a GitHub repository. App Runner clones the repo; builds the application using the specified runtime; and deploys the resulting container."`
	// Port that the application listens on inside the container. App Runner routes
	//  incoming HTTPS traffic on port 443 to this port.
	Port string `json:"port,omitempty" jsonschema:"Port that the application listens on inside the container. App Runner routes incoming HTTPS traffic on port 443 to this port."`
	// Override the container start command. For image source, this overrides the
	//  image ENTRYPOINT/CMD. For code source with configuration_source="API",
	//  this is the command that starts the application.
	StartCommand string `json:"start_command,omitempty" jsonschema:"Override the container start command. For image source; this overrides the image ENTRYPOINT/CMD. For code source with configuration_source='API'; this is the command that starts the application."`
	// Environment variables injected into every instance at runtime. Keys are
	//  variable names, values are plaintext strings. Avoid embedding secrets
	//  here; use environment_secrets for sensitive values.
	//  Keys prefixed with "AWSAPPRUNNER" are reserved by the service.
	EnvironmentVariables map[string]string `json:"environment_variables,omitempty" jsonschema:"Environment variables injected into every instance at runtime. Keys are variable names; values are plaintext strings. Avoid embedding secrets here; use environment_secrets for sensitive values. Keys p..."`
	// Environment secrets injected at runtime. Keys are variable names, values
	//  are full ARNs of AWS Secrets Manager secrets or SSM Parameter Store parameters.
	//  App Runner retrieves the secret value at deploy time and injects it as a
	//  plaintext environment variable. The instance_role_arn must have permiss...
	EnvironmentSecrets map[string]string `json:"environment_secrets,omitempty" jsonschema:"Environment secrets injected at runtime. Keys are variable names; values are full ARNs of AWS Secrets Manager secrets or SSM Parameter Store parameters. App Runner retrieves the secret value at deploy..."`
	// CPU allocation per instance. Accepts numeric millicore strings or human-readable vCPU format.
	//  Numeric: "256", "512", "1024", "2048", "4096"
	//  Human-readable: "0.25 vCPU", "0.5 vCPU", "1 vCPU", "2 vCPU", "4 vCPU"
	Cpu string `json:"cpu,omitempty" jsonschema:"CPU allocation per instance. Accepts numeric millicore strings or human-readable vCPU format. Numeric: '256'; '512'; '1024'; '2048'; '4096' Human-readable: '0.25 vCPU'; '0.5 vCPU'; '1 vCPU'; '2 vCPU';..."`
	// Memory allocation per instance. Accepts numeric megabyte strings or human-readable GB format.
	//  Numeric: "512", "1024", "2048", "3072", "4096", "6144", "8192", "10240", "12288"
	//  Human-readable: "0.5 GB", "1 GB", "2 GB", "3 GB", "4 GB", "6 GB", "8 GB", "10 GB", "12 GB"
	//  Note: Not all CPU/memory combin...
	Memory string `json:"memory,omitempty" jsonschema:"Memory allocation per instance. Accepts numeric megabyte strings or human-readable GB format. Numeric: '512'; '1024'; '2048'; '3072'; '4096'; '6144'; '8192'; '10240'; '12288' Human-readable: '0.5 GB';..."`
	// IAM role that service instances assume at runtime to call AWS APIs.
	//  This is the role your application code uses (e.g., to read from S3, write to DynamoDB).
	//  This is NOT the role used to pull images from ECR (that is access_role_arn in image_source).
	InstanceRoleArn string `json:"instance_role_arn,omitempty" jsonschema:"IAM role that service instances assume at runtime to call AWS APIs. This is the role your application code uses (e.g.; to read from S3; write to DynamoDB). This is NOT the role used to pull images fro..."`
	// Health check configuration. App Runner uses health checks to monitor instance
	//  readiness. If not provided, App Runner uses default TCP health checks on the
	//  configured port.
	HealthCheck *AwsAppRunnerServiceHealthCheckInput `json:"health_check,omitempty" jsonschema:"Health check configuration. App Runner uses health checks to monitor instance readiness. If not provided; App Runner uses default TCP health checks on the configured port."`
	// Auto scaling configuration controls how App Runner scales the number of
	//  instances based on incoming request concurrency. If not provided, App Runner
	//  uses defaults: 1 min, 25 max, 100 max concurrency per instance.
	AutoScaling *AwsAppRunnerServiceAutoScalingInput `json:"auto_scaling,omitempty" jsonschema:"Auto scaling configuration controls how App Runner scales the number of instances based on incoming request concurrency. If not provided; App Runner uses defaults: 1 min; 25 max; 100 max concurrency p..."`
	// ARN of an existing VPC Connector for outbound VPC access. Use this when
	//  you want to share a single VPC Connector across multiple App Runner services.
	//  Mutually exclusive with subnet_ids/security_group_ids (which create an inline connector).
	VpcConnectorArn string `json:"vpc_connector_arn,omitempty" jsonschema:"ARN of an existing VPC Connector for outbound VPC access. Use this when you want to share a single VPC Connector across multiple App Runner services. Mutually exclusive with subnet_ids/security_group_..."`
	// VPC subnet IDs for creating an inline VPC Connector. When provided, the module
	//  automatically creates a VPC Connector so the service can reach resources in
	//  your VPC (databases, caches, internal APIs). Provide subnets in at least two
	//  Availability Zones for high availability. Mutually exclusive with...
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"VPC subnet IDs for creating an inline VPC Connector. When provided; the module automatically creates a VPC Connector so the service can reach resources in your VPC (databases; caches; internal APIs). ..."`
	// Security group IDs for the inline VPC Connector. Controls what VPC resources
	//  the service can reach. Only used when subnet_ids is provided (ignored otherwise).
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security group IDs for the inline VPC Connector. Controls what VPC resources the service can reach. Only used when subnet_ids is provided (ignored otherwise)."`
	// Whether the service endpoint is publicly accessible from the internet.
	//  When true (default), the service gets a public HTTPS URL. When false,
	//  the service is only reachable via a VPC Ingress Connection (a separate
	//  resource not managed by this component).
	IsPubliclyAccessible bool `json:"is_publicly_accessible,omitempty" jsonschema:"Whether the service endpoint is publicly accessible from the internet. When true (default); the service gets a public HTTPS URL. When false; the service is only reachable via a VPC Ingress Connection ..."`
	// IP address type for the service endpoint.
	//  "IPV4": IPv4-only (default). "DUAL_STACK": IPv4 + IPv6.
	IpAddressType string `json:"ip_address_type,omitempty" jsonschema:"IP address type for the service endpoint. 'IPV4': IPv4-only (default). 'DUAL_STACK': IPv4 + IPv6."`
	// Customer-managed KMS key ARN for encrypting the service's stored copy of
	//  the container image and data logs. If omitted, App Runner uses an AWS-managed key.
	//  ForceNew: changing this value requires replacing the service.
	KmsKeyArn string `json:"kms_key_arn,omitempty" jsonschema:"Customer-managed KMS key ARN for encrypting the service's stored copy of the container image and data logs. If omitted; App Runner uses an AWS-managed key. ForceNew: changing this value requires repla..."`
	// Whether to enable observability (AWS X-Ray tracing) for the service.
	//  When true, observability_configuration_arn must also be provided.
	ObservabilityEnabled bool `json:"observability_enabled,omitempty" jsonschema:"Whether to enable observability (AWS X-Ray tracing) for the service. When true; observability_configuration_arn must also be provided."`
	// ARN of an App Runner Observability Configuration resource. Required when
	//  observability_enabled is true. Observability configurations are created
	//  separately (via AWS Console or CLI) and can be shared across services.
	ObservabilityConfigurationArn string `json:"observability_configuration_arn,omitempty" jsonschema:"ARN of an App Runner Observability Configuration resource. Required when observability_enabled is true. Observability configurations are created separately (via AWS Console or CLI) and can be shared a..."`
	// Whether App Runner automatically triggers a new deployment when the source changes.
	//  For image source: redeploys when a new image is pushed to the same tag.
	//  For code source: redeploys when a new commit is pushed to the configured branch.
	AutoDeploymentsEnabled bool `json:"auto_deployments_enabled,omitempty" jsonschema:"Whether App Runner automatically triggers a new deployment when the source changes. For image source: redeploys when a new image is pushed to the same tag. For code source: redeploys when a new commit..."`
}

func (s *AwsAppRunnerServiceSpecInput) validate() error {
	if s.ImageSource != nil {
		if err := s.ImageSource.validate(); err != nil {
			return fmt.Errorf("image_source: %w", err)
		}
	}
	if s.CodeSource != nil {
		if err := s.CodeSource.validate(); err != nil {
			return fmt.Errorf("code_source: %w", err)
		}
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	if s.AutoScaling != nil {
		if err := s.AutoScaling.validate(); err != nil {
			return fmt.Errorf("auto_scaling: %w", err)
		}
	}
	return nil
}

func (s *AwsAppRunnerServiceSpecInput) applyDefaults() {
	if s.ImageSource != nil {
		s.ImageSource.applyDefaults()
	}
	if s.CodeSource != nil {
		s.CodeSource.applyDefaults()
	}
	if s.Port == "" {
		s.Port = "8080"
	}
	if s.Cpu == "" {
		s.Cpu = "1024"
	}
	if s.Memory == "" {
		s.Memory = "2048"
	}
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
	if s.AutoScaling != nil {
		s.AutoScaling.applyDefaults()
	}
	// default: IsPubliclyAccessible = true (applied at zero-value)
	if s.IpAddressType == "" {
		s.IpAddressType = "IPV4"
	}
	// default: AutoDeploymentsEnabled = true (applied at zero-value)
}

func (s *AwsAppRunnerServiceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.ImageSource != nil {
		m["image_source"] = s.ImageSource.toMap()
	}
	if s.CodeSource != nil {
		m["code_source"] = s.CodeSource.toMap()
	}
	if s.Port != "" {
		m["port"] = s.Port
	}
	if s.StartCommand != "" {
		m["start_command"] = s.StartCommand
	}
	if len(s.EnvironmentVariables) > 0 {
		m["environment_variables"] = s.EnvironmentVariables
	}
	if len(s.EnvironmentSecrets) > 0 {
		m["environment_secrets"] = s.EnvironmentSecrets
	}
	if s.Cpu != "" {
		m["cpu"] = s.Cpu
	}
	if s.Memory != "" {
		m["memory"] = s.Memory
	}
	if s.InstanceRoleArn != "" {
		m["instance_role_arn"] = s.InstanceRoleArn
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	if s.AutoScaling != nil {
		m["auto_scaling"] = s.AutoScaling.toMap()
	}
	if s.VpcConnectorArn != "" {
		m["vpc_connector_arn"] = s.VpcConnectorArn
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.IsPubliclyAccessible {
		m["is_publicly_accessible"] = s.IsPubliclyAccessible
	}
	if s.IpAddressType != "" {
		m["ip_address_type"] = s.IpAddressType
	}
	if s.KmsKeyArn != "" {
		m["kms_key_arn"] = s.KmsKeyArn
	}
	if s.ObservabilityEnabled {
		m["observability_enabled"] = s.ObservabilityEnabled
	}
	if s.ObservabilityConfigurationArn != "" {
		m["observability_configuration_arn"] = s.ObservabilityConfigurationArn
	}
	if s.AutoDeploymentsEnabled {
		m["auto_deployments_enabled"] = s.AutoDeploymentsEnabled
	}
	return m
}

// AwsAppRunnerServiceAutoScaling configures how App Runner scales the number of
//
//	running instances in response to incoming traffic. App Runner uses a concurrency-based
//	model: when the number of concurrent requests per instance exceeds max_concurrency,
//	a new instance is launched (up to max_size). When traffic decreases, instances are
//	removed (down to min_size).
type AwsAppRunnerServiceAutoScalingInput struct {
	// Minimum number of instances that App Runner keeps running at all times.
	//  These instances are always warm and ready to serve traffic. Setting this
	//  above 1 reduces cold-start latency at the cost of increased baseline charges.
	MinSize int32 `json:"min_size,omitempty" jsonschema:"Minimum number of instances that App Runner keeps running at all times. These instances are always warm and ready to serve traffic. Setting this above 1 reduces cold-start latency at the cost of incre..."`
	// Maximum number of instances that App Runner scales out to during traffic spikes.
	MaxSize int32 `json:"max_size,omitempty" jsonschema:"Maximum number of instances that App Runner scales out to during traffic spikes."`
	// Maximum number of concurrent requests routed to a single instance before
	//  App Runner launches additional instances. Lower values provide more headroom
	//  per instance but cost more (more instances for the same traffic).
	MaxConcurrency int32 `json:"max_concurrency,omitempty" jsonschema:"Maximum number of concurrent requests routed to a single instance before App Runner launches additional instances. Lower values provide more headroom per instance but cost more (more instances for the..."`
}

func (s *AwsAppRunnerServiceAutoScalingInput) validate() error {
	return nil
}

func (s *AwsAppRunnerServiceAutoScalingInput) applyDefaults() {
	if s.MinSize == 0 {
		s.MinSize = 1
	}
	if s.MaxSize == 0 {
		s.MaxSize = 25
	}
	if s.MaxConcurrency == 0 {
		s.MaxConcurrency = 100
	}
}

func (s *AwsAppRunnerServiceAutoScalingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinSize != 0 {
		m["min_size"] = s.MinSize
	}
	if s.MaxSize != 0 {
		m["max_size"] = s.MaxSize
	}
	if s.MaxConcurrency != 0 {
		m["max_concurrency"] = s.MaxConcurrency
	}
	return m
}

// AwsAppRunnerServiceCodeSource configures deployment from a GitHub code repository.
//
//	App Runner clones the repository, builds the application using the specified runtime
//	and build command, then deploys the resulting container.
//
//	Requires an App Runner Connection resource that authorizes GitHub access. Connections
//	are created out-of-band via the AWS Console or AWS CLI and can be shared across services.
type AwsAppRunnerServiceCodeSourceInput struct {
	// GitHub repository URL (e.g., "https://github.com/owner/repo").
	RepositoryUrl string `json:"repository_url,omitempty" jsonschema:"GitHub repository URL (e.g.; 'https://github.com/owner/repo')."`
	// Branch name to deploy from (e.g., "main", "production").
	Branch string `json:"branch,omitempty" jsonschema:"Branch name to deploy from (e.g.; 'main'; 'production')."`
	// Subdirectory within the repository containing the application source code.
	//  Defaults to the repository root when not specified. Useful for monorepos
	//  where the App Runner service lives in a subfolder.
	SourceDirectory string `json:"source_directory,omitempty" jsonschema:"Subdirectory within the repository containing the application source code. Defaults to the repository root when not specified. Useful for monorepos where the App Runner service lives in a subfolder."`
	// ARN of an App Runner Connection that provides GitHub access. Connections are
	//  created via the AWS Console or CLI (they require an OAuth handshake) and can
	//  be shared across multiple services.
	ConnectionArn string `json:"connection_arn" jsonschema:"required,ARN of an App Runner Connection that provides GitHub access. Connections are created via the AWS Console or CLI (they require an OAuth handshake) and can be shared across multiple services."`
	// Where App Runner reads the build/runtime configuration from.
	//  "API": Configuration is provided in this spec (runtime, build_command, port, start_command).
	//  "REPOSITORY": Configuration is read from an apprunner.yaml file in the repository root
	//    (or source_directory). In this mode, runtime and build...
	ConfigurationSource string `json:"configuration_source,omitempty" jsonschema:"Where App Runner reads the build/runtime configuration from. 'API': Configuration is provided in this spec (runtime; build_command; port; start_command). 'REPOSITORY': Configuration is read from an ap..."`
	// Runtime identifier for building and running the application. Required when
	//  configuration_source is "API", ignored when "REPOSITORY".
	//  Valid values: "PYTHON_3", "NODEJS_12", "NODEJS_14", "NODEJS_16", "NODEJS_18",
	//  "CORRETTO_8", "CORRETTO_11", "GO_1", "DOTNET_6", "PHP_81", "RUBY_31".
	Runtime string `json:"runtime,omitempty" jsonschema:"Runtime identifier for building and running the application. Required when configuration_source is 'API'; ignored when 'REPOSITORY'. Valid values: 'PYTHON_3'; 'NODEJS_12'; 'NODEJS_14'; 'NODEJS_16'; 'N..."`
	// Shell command to build/compile the application. Only used when configuration_source
	//  is "API". Example: "npm ci && npm run build" or "pip install -r requirements.txt".
	BuildCommand string `json:"build_command,omitempty" jsonschema:"Shell command to build/compile the application. Only used when configuration_source is 'API'. Example: 'npm ci && npm run build' or 'pip install -r requirements.txt'."`
}

func (s *AwsAppRunnerServiceCodeSourceInput) validate() error {
	if s.ConnectionArn == "" {
		return fmt.Errorf("connection_arn is required")
	}
	return nil
}

func (s *AwsAppRunnerServiceCodeSourceInput) applyDefaults() {
}

func (s *AwsAppRunnerServiceCodeSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RepositoryUrl != "" {
		m["repository_url"] = s.RepositoryUrl
	}
	if s.Branch != "" {
		m["branch"] = s.Branch
	}
	if s.SourceDirectory != "" {
		m["source_directory"] = s.SourceDirectory
	}
	m["connection_arn"] = s.ConnectionArn
	if s.ConfigurationSource != "" {
		m["configuration_source"] = s.ConfigurationSource
	}
	if s.Runtime != "" {
		m["runtime"] = s.Runtime
	}
	if s.BuildCommand != "" {
		m["build_command"] = s.BuildCommand
	}
	return m
}

// AwsAppRunnerServiceHealthCheck configures health monitoring for the service.
//
//	App Runner periodically probes each instance to determine if it is healthy.
//	Unhealthy instances are replaced automatically.
type AwsAppRunnerServiceHealthCheckInput struct {
	// Protocol used for health checks.
	//  "TCP": Checks that the port is open and accepting connections (default).
	//  "HTTP": Sends an HTTP GET request to the specified path and expects a 200 response.
	Protocol string `json:"protocol,omitempty" jsonschema:"Protocol used for health checks. 'TCP': Checks that the port is open and accepting connections (default). 'HTTP': Sends an HTTP GET request to the specified path and expects a 200 response."`
	// URL path for HTTP health checks (e.g., "/health", "/readyz").
	//  Ignored when protocol is "TCP".
	Path string `json:"path,omitempty" jsonschema:"URL path for HTTP health checks (e.g.; '/health'; '/readyz'). Ignored when protocol is 'TCP'."`
	// Time in seconds between consecutive health checks.
	IntervalSeconds int32 `json:"interval_seconds,omitempty" jsonschema:"Time in seconds between consecutive health checks."`
	// Maximum time in seconds to wait for a health check response before
	//  considering the check failed.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Maximum time in seconds to wait for a health check response before considering the check failed."`
	// Number of consecutive successful health checks required before marking
	//  an instance as healthy.
	HealthyThreshold int32 `json:"healthy_threshold,omitempty" jsonschema:"Number of consecutive successful health checks required before marking an instance as healthy."`
	// Number of consecutive failed health checks before marking an instance
	//  as unhealthy and triggering replacement.
	UnhealthyThreshold int32 `json:"unhealthy_threshold,omitempty" jsonschema:"Number of consecutive failed health checks before marking an instance as unhealthy and triggering replacement."`
}

func (s *AwsAppRunnerServiceHealthCheckInput) validate() error {
	return nil
}

func (s *AwsAppRunnerServiceHealthCheckInput) applyDefaults() {
	if s.Protocol == "" {
		s.Protocol = "TCP"
	}
	if s.Path == "" {
		s.Path = "/"
	}
	if s.IntervalSeconds == 0 {
		s.IntervalSeconds = 5
	}
	if s.TimeoutSeconds == 0 {
		s.TimeoutSeconds = 2
	}
	if s.HealthyThreshold == 0 {
		s.HealthyThreshold = 1
	}
	if s.UnhealthyThreshold == 0 {
		s.UnhealthyThreshold = 5
	}
}

func (s *AwsAppRunnerServiceHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.IntervalSeconds != 0 {
		m["interval_seconds"] = s.IntervalSeconds
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.HealthyThreshold != 0 {
		m["healthy_threshold"] = s.HealthyThreshold
	}
	if s.UnhealthyThreshold != 0 {
		m["unhealthy_threshold"] = s.UnhealthyThreshold
	}
	return m
}

// AwsAppRunnerServiceImageSource configures deployment from a container image
//
//	stored in Amazon ECR (private registry) or ECR Public Gallery.
type AwsAppRunnerServiceImageSourceInput struct {
	// Full container image identifier including tag or digest.
	//  ECR format: "ACCOUNT_ID.dkr.ecr.REGION.amazonaws.com/REPO:TAG"
	//  ECR Public format: "public.ecr.aws/ALIAS/REPO:TAG"
	ImageIdentifier string `json:"image_identifier,omitempty" jsonschema:"Full container image identifier including tag or digest. ECR format: 'ACCOUNT_ID.dkr.ecr.REGION.amazonaws.com/REPO:TAG' ECR Public format: 'public.ecr.aws/ALIAS/REPO:TAG'"`
	// Type of image repository.
	//  "ECR": Private Amazon ECR registry (requires access_role_arn for pull access).
	//  "ECR_PUBLIC": Public ECR Gallery (no authentication required for pulling).
	ImageRepositoryType string `json:"image_repository_type,omitempty" jsonschema:"Type of image repository. 'ECR': Private Amazon ECR registry (requires access_role_arn for pull access). 'ECR_PUBLIC': Public ECR Gallery (no authentication required for pulling)."`
	// IAM role ARN that grants App Runner permission to pull images from private ECR.
	//  Required when image_repository_type is "ECR". Not needed for "ECR_PUBLIC".
	//  This role must have the ecr:GetDownloadUrlForLayer, ecr:BatchGetImage, and
	//  ecr:GetAuthorizationToken permissions.
	AccessRoleArn string `json:"access_role_arn,omitempty" jsonschema:"IAM role ARN that grants App Runner permission to pull images from private ECR. Required when image_repository_type is 'ECR'. Not needed for 'ECR_PUBLIC'. This role must have the ecr:GetDownloadUrlFor..."`
}

func (s *AwsAppRunnerServiceImageSourceInput) validate() error {
	return nil
}

func (s *AwsAppRunnerServiceImageSourceInput) applyDefaults() {
}

func (s *AwsAppRunnerServiceImageSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ImageIdentifier != "" {
		m["image_identifier"] = s.ImageIdentifier
	}
	if s.ImageRepositoryType != "" {
		m["image_repository_type"] = s.ImageRepositoryType
	}
	if s.AccessRoleArn != "" {
		m["access_role_arn"] = s.AccessRoleArn
	}
	return m
}

// ParseAwsAppRunnerService validates and normalizes a AwsAppRunnerService cloud_object.
func ParseAwsAppRunnerService(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsAppRunnerService"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsAppRunnerServiceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
