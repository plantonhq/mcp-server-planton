// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsMemorydbCluster is a deployment component for creating and managing
//
//	Amazon MemoryDB clusters — a fully managed, Redis-compatible, durable
//	in-memory database with microsecond reads and single-digit millisecond writes.
type AwsMemorydbClusterSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Cache engine to use. Redis is the standard choice; Valkey is the
	//  open-source Redis-compatible alternative. Values: "redis", "valkey".
	Engine string `json:"engine" jsonschema:"required,Cache engine to use. Redis is the standard choice; Valkey is the open-source Redis-compatible alternative. Values: 'redis'; 'valkey'."`
	// Engine version to deploy. Examples: "7.1", "7.0", "6.2" for Redis;
	//  "7.2" for Valkey. Leave empty to use the provider default.
	EngineVersion string `json:"engine_version,omitempty" jsonschema:"Engine version to deploy. Examples: '7.1'; '7.0'; '6.2' for Redis; '7.2' for Valkey. Leave empty to use the provider default."`
	// Human-readable description for the cluster.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description for the cluster."`
	// MemoryDB node type. Determines CPU, memory, and network capacity.
	//  Examples: "db.t4g.small" (dev), "db.r7g.large" (production),
	//  "db.r6gd.xlarge" (data tiering).
	NodeType string `json:"node_type" jsonschema:"required,MemoryDB node type. Determines CPU; memory; and network capacity. Examples: 'db.t4g.small' (dev); 'db.r7g.large' (production); 'db.r6gd.xlarge' (data tiering)."`
	// Port on which the cluster accepts connections. Default: 6379.
	//  ForceNew — changing it destroys and recreates the cluster.
	Port int32 `json:"port,omitempty" jsonschema:"Port on which the cluster accepts connections. Default: 6379. ForceNew — changing it destroys and recreates the cluster."`
	// Number of shards (data partitions) in the cluster. Each shard holds a
	//  portion of the keyspace. Default: 1.
	NumShards int32 `json:"num_shards,omitempty" jsonschema:"Number of shards (data partitions) in the cluster. Each shard holds a portion of the keyspace. Default: 1."`
	// Number of read replicas per shard. Range: 0–5. Default: 1 (i.e., each
	//  shard has 1 primary + 1 replica = 2 nodes).
	NumReplicasPerShard int32 `json:"num_replicas_per_shard,omitempty" jsonschema:"Number of read replicas per shard. Range: 0–5. Default: 1 (i.e.; each shard has 1 primary + 1 replica = 2 nodes)."`
	// Name of the MemoryDB Access Control List (ACL) to associate with the cluster.
	//  The ACL defines which users can access the cluster and what commands they can
	//  execute. Use "open-access" for development (no authentication required when
	//  TLS is enabled) or reference a custom ACL for production.
	//  When t...
	AclName string `json:"acl_name,omitempty" jsonschema:"Name of the MemoryDB Access Control List (ACL) to associate with the cluster. The ACL defines which users can access the cluster and what commands they can execute. Use 'open-access' for development (..."`
	// Subnet IDs for the MemoryDB subnet group. Provide subnets in at least two
	//  AZs for multi-AZ resilience. A subnet group is created automatically from
	//  these subnets.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs for the MemoryDB subnet group. Provide subnets in at least two AZs for multi-AZ resilience. A subnet group is created automatically from these subnets."`
	// VPC security groups to attach to the cluster nodes. Controls network-level
	//  access to the MemoryDB endpoint.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"VPC security groups to attach to the cluster nodes. Controls network-level access to the MemoryDB endpoint."`
	// Enable TLS for in-transit encryption on all client connections. When false,
	//  acl_name must be "open-access". ForceNew — changing it destroys and
	//  recreates the cluster.
	TlsEnabled bool `json:"tls_enabled,omitempty" jsonschema:"Enable TLS for in-transit encryption on all client connections. When false; acl_name must be 'open-access'. ForceNew — changing it destroys and recreates the cluster."`
	// Customer-managed KMS key ARN for at-rest encryption. MemoryDB always encrypts
	//  data at rest; this field optionally specifies your own key instead of the
	//  AWS-managed key. ForceNew — changing it destroys and recreates the cluster.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key ARN for at-rest encryption. MemoryDB always encrypts data at rest; this field optionally specifies your own key instead of the AWS-managed key. ForceNew — changing it destro..."`
	// Weekly maintenance window in UTC. Format: "ddd:hh24:mi-ddd:hh24:mi".
	//  Example: "sun:05:00-sun:06:00". Leave empty for AWS-assigned default.
	MaintenanceWindow string `json:"maintenance_window,omitempty" jsonschema:"Weekly maintenance window in UTC. Format: 'ddd:hh24:mi-ddd:hh24:mi'. Example: 'sun:05:00-sun:06:00'. Leave empty for AWS-assigned default."`
	// Number of days to retain automatic snapshots. 0 disables automatic snapshots.
	//  Range: 0–35.
	SnapshotRetentionLimit int32 `json:"snapshot_retention_limit,omitempty" jsonschema:"Number of days to retain automatic snapshots. 0 disables automatic snapshots. Range: 0–35."`
	// Daily snapshot window in UTC. Format: "hh24:mi-hh24:mi".
	//  Example: "05:00-09:00". Leave empty for AWS-assigned default.
	SnapshotWindow string `json:"snapshot_window,omitempty" jsonschema:"Daily snapshot window in UTC. Format: 'hh24:mi-hh24:mi'. Example: '05:00-09:00'. Leave empty for AWS-assigned default."`
	// Name of the final snapshot to create when the cluster is deleted. If not
	//  provided, no final snapshot is created.
	FinalSnapshotName string `json:"final_snapshot_name,omitempty" jsonschema:"Name of the final snapshot to create when the cluster is deleted. If not provided; no final snapshot is created."`
	// ARN(s) of RDB snapshot files stored in S3 to restore data from.
	//  ForceNew — only used at cluster creation time. Mutually exclusive with
	//  snapshot_name.
	SnapshotArns []string `json:"snapshot_arns,omitempty" jsonschema:"ARN(s) of RDB snapshot files stored in S3 to restore data from. ForceNew — only used at cluster creation time. Mutually exclusive with snapshot_name."`
	// Name of a MemoryDB snapshot to restore from. ForceNew — only used at
	//  cluster creation time. Mutually exclusive with snapshot_arns.
	SnapshotName string `json:"snapshot_name,omitempty" jsonschema:"Name of a MemoryDB snapshot to restore from. ForceNew — only used at cluster creation time. Mutually exclusive with snapshot_arns."`
	// Parameter group family. Required when `parameters` is provided.
	//  Examples: "memorydb_redis7", "memorydb_redis6".
	ParameterGroupFamily string `json:"parameter_group_family,omitempty" jsonschema:"Parameter group family. Required when 'parameters' is provided. Examples: 'memorydb_redis7'; 'memorydb_redis6'."`
	// Custom MemoryDB parameters to apply via a managed parameter group.
	//  Common examples: activedefrag, maxmemory-policy.
	Parameters []*AwsMemorydbClusterParameterInput `json:"parameters,omitempty" jsonschema:"Custom MemoryDB parameters to apply via a managed parameter group. Common examples: activedefrag; maxmemory-policy."`
	// SNS topic ARN for cluster event notifications (failover, maintenance,
	//  configuration changes, etc.).
	SnsTopicArn string `json:"sns_topic_arn,omitempty" jsonschema:"SNS topic ARN for cluster event notifications (failover; maintenance; configuration changes; etc.)."`
	// Automatically apply minor engine version upgrades during maintenance windows.
	//  Default: true.
	AutoMinorVersionUpgrade bool `json:"auto_minor_version_upgrade,omitempty" jsonschema:"Automatically apply minor engine version upgrades during maintenance windows. Default: true."`
	// Enable data tiering — automatically moves less-frequently-accessed data to
	//  SSD storage for cost efficiency with large datasets. Only available on
	//  specific node types (db.r6gd.*). ForceNew — cannot be changed after creation.
	DataTiering bool `json:"data_tiering,omitempty" jsonschema:"Enable data tiering — automatically moves less-frequently-accessed data to SSD storage for cost efficiency with large datasets. Only available on specific node types (db.r6gd.*). ForceNew — cannot..."`
}

func (s *AwsMemorydbClusterSpecInput) validate() error {
	if s.Engine == "" {
		return fmt.Errorf("engine is required")
	}
	if s.NodeType == "" {
		return fmt.Errorf("node_type is required")
	}
	for i, v := range s.Parameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("parameters[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsMemorydbClusterSpecInput) applyDefaults() {
	if s.Port == 0 {
		s.Port = 6379
	}
	if s.NumShards == 0 {
		s.NumShards = 1
	}
	if s.NumReplicasPerShard == 0 {
		s.NumReplicasPerShard = 1
	}
	if s.AclName == "" {
		s.AclName = "open-access"
	}
	// default: TlsEnabled = true (applied at zero-value)
	// default: AutoMinorVersionUpgrade = true (applied at zero-value)
}

func (s *AwsMemorydbClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["engine"] = s.Engine
	if s.EngineVersion != "" {
		m["engine_version"] = s.EngineVersion
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	m["node_type"] = s.NodeType
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.NumShards != 0 {
		m["num_shards"] = s.NumShards
	}
	if s.NumReplicasPerShard != 0 {
		m["num_replicas_per_shard"] = s.NumReplicasPerShard
	}
	if s.AclName != "" {
		m["acl_name"] = s.AclName
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.TlsEnabled {
		m["tls_enabled"] = s.TlsEnabled
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.MaintenanceWindow != "" {
		m["maintenance_window"] = s.MaintenanceWindow
	}
	if s.SnapshotRetentionLimit != 0 {
		m["snapshot_retention_limit"] = s.SnapshotRetentionLimit
	}
	if s.SnapshotWindow != "" {
		m["snapshot_window"] = s.SnapshotWindow
	}
	if s.FinalSnapshotName != "" {
		m["final_snapshot_name"] = s.FinalSnapshotName
	}
	if len(s.SnapshotArns) > 0 {
		m["snapshot_arns"] = s.SnapshotArns
	}
	if s.SnapshotName != "" {
		m["snapshot_name"] = s.SnapshotName
	}
	if s.ParameterGroupFamily != "" {
		m["parameter_group_family"] = s.ParameterGroupFamily
	}
	if len(s.Parameters) > 0 {
		items := make([]any, len(s.Parameters))
		for i, v := range s.Parameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["parameters"] = items
	}
	if s.SnsTopicArn != "" {
		m["sns_topic_arn"] = s.SnsTopicArn
	}
	if s.AutoMinorVersionUpgrade {
		m["auto_minor_version_upgrade"] = s.AutoMinorVersionUpgrade
	}
	if s.DataTiering {
		m["data_tiering"] = s.DataTiering
	}
	return m
}

// AwsMemorydbClusterParameter defines a single parameter override for the
//
//	managed parameter group. Parameters tune Redis/Valkey engine behavior
//	(e.g., activedefrag, maxmemory-policy).
type AwsMemorydbClusterParameterInput struct {
	// Parameter name (e.g., "activedefrag", "maxmemory-policy").
	Name string `json:"name" jsonschema:"required,Parameter name (e.g.; 'activedefrag'; 'maxmemory-policy')."`
	// Parameter value (e.g., "yes", "volatile-lru").
	Value string `json:"value" jsonschema:"required,Parameter value (e.g.; 'yes'; 'volatile-lru')."`
}

func (s *AwsMemorydbClusterParameterInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AwsMemorydbClusterParameterInput) applyDefaults() {
}

func (s *AwsMemorydbClusterParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	return m
}

// ParseAwsMemorydbCluster validates and normalizes a AwsMemorydbCluster cloud_object.
func ParseAwsMemorydbCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsMemorydbCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsMemorydbClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
