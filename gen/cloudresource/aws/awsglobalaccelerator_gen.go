// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsGlobalAccelerator is a deployment component for creating and managing
//
//	AWS Global Accelerator resources — a networking service that improves
//	availability and performance by routing traffic through the AWS global
//	network to optimal regional endpoints.
type AwsGlobalAcceleratorSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Whether the accelerator is enabled and accepting traffic. When disabled,
	//  the accelerator's DNS name stops resolving and no traffic is routed.
	//  Useful for temporarily disabling an accelerator during maintenance without
	//  destroying it.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether the accelerator is enabled and accepting traffic. When disabled; the accelerator's DNS name stops resolving and no traffic is routed. Useful for temporarily disabling an accelerator during mai..."`
	// IP address type for the accelerator.
	//  - "IPV4": Two static IPv4 anycast addresses (default).
	//  - "DUAL_STACK": IPv4 + IPv6 anycast addresses for clients on IPv6 networks.
	IpAddressType string `json:"ip_address_type,omitempty" jsonschema:"IP address type for the accelerator. - 'IPV4': Two static IPv4 anycast addresses (default). - 'DUAL_STACK': IPv4 + IPv6 anycast addresses for clients on IPv6 networks."`
	// Bring-Your-Own-IP (BYOIP) addresses to assign to the accelerator instead
	//  of AWS-allocated anycast IPs. Provide exactly 1 or 2 IPv4 addresses from
	//  a BYOIP address pool registered with AWS.
	//
	//  ForceNew — changing this destroys and recreates the accelerator.
	//  Leave empty to use AWS-allocated IPs (th...
	IpAddresses []string `json:"ip_addresses,omitempty" jsonschema:"Bring-Your-Own-IP (BYOIP) addresses to assign to the accelerator instead of AWS-allocated anycast IPs. Provide exactly 1 or 2 IPv4 addresses from a BYOIP address pool registered with AWS. ForceNew —..."`
	// Optional flow log configuration for traffic analysis. When enabled,
	//  Global Accelerator publishes flow logs to the specified S3 bucket.
	FlowLogs *AwsGlobalAcceleratorFlowLogsInput `json:"flow_logs,omitempty" jsonschema:"Optional flow log configuration for traffic analysis. When enabled; Global Accelerator publishes flow logs to the specified S3 bucket."`
	// Listeners define the ports and protocols the accelerator accepts traffic on.
	//  Each listener routes traffic to one or more regional endpoint groups.
	//
	//  At least one listener is required — an accelerator without listeners
	//  serves no purpose beyond reserving static IPs.
	Listeners []*AwsGlobalAcceleratorListenerInput `json:"listeners" jsonschema:"required,Listeners define the ports and protocols the accelerator accepts traffic on. Each listener routes traffic to one or more regional endpoint groups. At least one listener is required — an accelerator ..."`
}

func (s *AwsGlobalAcceleratorSpecInput) validate() error {
	if s.FlowLogs != nil {
		if err := s.FlowLogs.validate(); err != nil {
			return fmt.Errorf("flow_logs: %w", err)
		}
	}
	if len(s.Listeners) == 0 {
		return fmt.Errorf("listeners is required")
	}
	if len(s.Listeners) < 1 {
		return fmt.Errorf("listeners requires at least 1 items, got %d", len(s.Listeners))
	}
	for i, v := range s.Listeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("listeners[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsGlobalAcceleratorSpecInput) applyDefaults() {
	// default: Enabled = true (applied at zero-value)
	if s.IpAddressType == "" {
		s.IpAddressType = "IPV4"
	}
	if s.FlowLogs != nil {
		s.FlowLogs.applyDefaults()
	}
}

func (s *AwsGlobalAcceleratorSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.IpAddressType != "" {
		m["ip_address_type"] = s.IpAddressType
	}
	if len(s.IpAddresses) > 0 {
		m["ip_addresses"] = s.IpAddresses
	}
	if s.FlowLogs != nil {
		m["flow_logs"] = s.FlowLogs.toMap()
	}
	if len(s.Listeners) > 0 {
		items := make([]any, len(s.Listeners))
		for i, v := range s.Listeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["listeners"] = items
	}
	return m
}

// AwsGlobalAcceleratorEndpoint defines a single endpoint within an endpoint
//
//	group. Endpoints are the actual resources that receive traffic.
//
//	Supported endpoint types:
//	- Application Load Balancer (ALB ARN)
//	- Network Load Balancer (NLB ARN)
//	- Elastic IP (allocation ID)
//	- EC2 instance (instance ID)
//
//	The endpoint_id field is polymorphic — Global Accelerator determines the
//	endpoint type from the identifier format.
type AwsGlobalAcceleratorEndpointInput struct {
	// Resource identifier for the endpoint. Accepts:
	//  - ALB ARN: "arn:aws:elasticloadbalancing:..."
	//  - NLB ARN: "arn:aws:elasticloadbalancing:..."
	//  - EIP allocation ID: "eipalloc-..."
	//  - EC2 instance ID: "i-..."
	//
	//  Uses StringValueOrRef for cross-resource referencing (e.g., reference an
	//  AwsAlb's load_bala...
	EndpointId string `json:"endpoint_id" jsonschema:"required,Resource identifier for the endpoint. Accepts: - ALB ARN: 'arn:aws:elasticloadbalancing:...' - NLB ARN: 'arn:aws:elasticloadbalancing:...' - EIP allocation ID: 'eipalloc-...' - EC2 instance ID: 'i-......"`
	// Relative weight for this endpoint. Range: 0-255. Default: 128.
	//  Higher weight means more traffic. Set to 0 to temporarily stop routing
	//  traffic to this endpoint without removing it.
	Weight int32 `json:"weight,omitempty" jsonschema:"Relative weight for this endpoint. Range: 0-255. Default: 128. Higher weight means more traffic. Set to 0 to temporarily stop routing traffic to this endpoint without removing it."`
	// Preserve the client's source IP address in requests forwarded to the
	//  endpoint. When enabled, the endpoint sees the original client IP instead
	//  of the Global Accelerator IP.
	//
	//  Supported for ALB and EC2 instance endpoints only. For NLB and EIP
	//  endpoints, client IP is always preserved regardless of t...
	ClientIpPreservationEnabled bool `json:"client_ip_preservation_enabled,omitempty" jsonschema:"Preserve the client's source IP address in requests forwarded to the endpoint. When enabled; the endpoint sees the original client IP instead of the Global Accelerator IP. Supported for ALB and EC2 in..."`
}

func (s *AwsGlobalAcceleratorEndpointInput) validate() error {
	if s.EndpointId == "" {
		return fmt.Errorf("endpoint_id is required")
	}
	return nil
}

func (s *AwsGlobalAcceleratorEndpointInput) applyDefaults() {
}

func (s *AwsGlobalAcceleratorEndpointInput) toMap() map[string]any {
	m := make(map[string]any)
	m["endpoint_id"] = s.EndpointId
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	if s.ClientIpPreservationEnabled {
		m["client_ip_preservation_enabled"] = s.ClientIpPreservationEnabled
	}
	return m
}

// AwsGlobalAcceleratorEndpointGroup defines a regional set of endpoints that
//
//	receive traffic from a listener. Each endpoint group maps to one
//	`aws_globalaccelerator_endpoint_group` resource.
//
//	Endpoint groups enable multi-region architectures: place groups in different
//	AWS regions and Global Accelerator routes users to the nearest healthy region.
//	Use traffic_dial_percentage for gradual regional traffic shifting (blue/green,
//	canary deployments across regions).
type AwsGlobalAcceleratorEndpointGroupInput struct {
	// User-assigned name for this endpoint group. Used as part of the composite
	//  key in the endpoint_group_arns output map (format: "listener_name/group_name").
	//
	//  Must be unique within the parent listener's endpoint groups. Lowercase
	//  alphanumeric and hyphens only, starting with a letter (max 63 character...
	Name string `json:"name" jsonschema:"required,User-assigned name for this endpoint group. Used as part of the composite key in the endpoint_group_arns output map (format: 'listener_name/group_name'). Must be unique within the parent listener's en..."`
	// AWS region for this endpoint group (e.g., "us-east-1", "eu-west-1").
	//  When omitted, defaults to the AWS provider region. ForceNew — changing
	//  the region requires replacing the endpoint group.
	EndpointGroupRegion string `json:"endpoint_group_region,omitempty" jsonschema:"AWS region for this endpoint group (e.g.; 'us-east-1'; 'eu-west-1'). When omitted; defaults to the AWS provider region. ForceNew — changing the region requires replacing the endpoint group."`
	// Port to use for health checks. When omitted, uses the listener port.
	//  Use this to check health on a dedicated health-check port separate from
	//  the traffic port.
	HealthCheckPort int32 `json:"health_check_port,omitempty" jsonschema:"Port to use for health checks. When omitted; uses the listener port. Use this to check health on a dedicated health-check port separate from the traffic port."`
	// Protocol for health checks.
	//  - "TCP" (default): Verifies port reachability only.
	//  - "HTTP": Sends GET request to health_check_path, expects 200 response.
	//  - "HTTPS": Same as HTTP but over TLS.
	HealthCheckProtocol string `json:"health_check_protocol,omitempty" jsonschema:"Protocol for health checks. - 'TCP' (default): Verifies port reachability only. - 'HTTP': Sends GET request to health_check_path; expects 200 response. - 'HTTPS': Same as HTTP but over TLS."`
	// Path for HTTP/HTTPS health checks. The accelerator sends a GET request
	//  to this path. Required when health_check_protocol is HTTP or HTTPS.
	//  Ignored for TCP health checks. Example: "/health" or "/api/status".
	HealthCheckPath string `json:"health_check_path,omitempty" jsonschema:"Path for HTTP/HTTPS health checks. The accelerator sends a GET request to this path. Required when health_check_protocol is HTTP or HTTPS. Ignored for TCP health checks. Example: '/health' or '/api/st..."`
	// Seconds between health checks for each endpoint. AWS only supports
	//  two values: 10 or 30 seconds. This is NOT a continuous range — any
	//  other value will be rejected by the API.
	HealthCheckIntervalSeconds int32 `json:"health_check_interval_seconds,omitempty" jsonschema:"Seconds between health checks for each endpoint. AWS only supports two values: 10 or 30 seconds. This is NOT a continuous range — any other value will be rejected by the API."`
	// Number of consecutive health checks that must succeed (or fail) to
	//  change an endpoint's health status. Range: 1-10.
	ThresholdCount int32 `json:"threshold_count,omitempty" jsonschema:"Number of consecutive health checks that must succeed (or fail) to change an endpoint's health status. Range: 1-10."`
	// Percentage of traffic to route to this endpoint group. Range: 0.0-100.0.
	//  Default: 100.0 (all traffic). Use values below 100 for gradual traffic
	//  shifting between regions (blue/green, canary deployments).
	//
	//  Set to 0 to temporarily drain a region without removing its endpoints.
	TrafficDialPercentage float64 `json:"traffic_dial_percentage,omitempty" jsonschema:"Percentage of traffic to route to this endpoint group. Range: 0.0-100.0. Default: 100.0 (all traffic). Use values below 100 for gradual traffic shifting between regions (blue/green; canary deployments..."`
	// Endpoints within this regional group. Each endpoint is a resource that
	//  receives traffic — an ALB, NLB, Elastic IP, or EC2 instance.
	//
	//  Endpoints are optional. You may create the endpoint group first and
	//  register endpoints later (e.g., when the ALB or NLB is deployed).
	Endpoints []*AwsGlobalAcceleratorEndpointInput `json:"endpoints,omitempty" jsonschema:"Endpoints within this regional group. Each endpoint is a resource that receives traffic — an ALB; NLB; Elastic IP; or EC2 instance. Endpoints are optional. You may create the endpoint group first an..."`
	// Port overrides remap listener ports to different endpoint ports. Useful
	//  when the listener accepts traffic on one port but the endpoint serves
	//  on a different port. Maximum 10 overrides per endpoint group.
	//
	//  Example: listener on port 443, endpoint on port 8443.
	PortOverrides []*AwsGlobalAcceleratorPortOverrideInput `json:"port_overrides,omitempty" jsonschema:"Port overrides remap listener ports to different endpoint ports. Useful when the listener accepts traffic on one port but the endpoint serves on a different port. Maximum 10 overrides per endpoint gro..."`
}

func (s *AwsGlobalAcceleratorEndpointGroupInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	for i, v := range s.Endpoints {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("endpoints[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.PortOverrides {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("port_overrides[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsGlobalAcceleratorEndpointGroupInput) applyDefaults() {
	if s.HealthCheckProtocol == "" {
		s.HealthCheckProtocol = "TCP"
	}
	if s.HealthCheckIntervalSeconds == 0 {
		s.HealthCheckIntervalSeconds = 30
	}
	if s.ThresholdCount == 0 {
		s.ThresholdCount = 3
	}
}

func (s *AwsGlobalAcceleratorEndpointGroupInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.EndpointGroupRegion != "" {
		m["endpoint_group_region"] = s.EndpointGroupRegion
	}
	if s.HealthCheckPort != 0 {
		m["health_check_port"] = s.HealthCheckPort
	}
	if s.HealthCheckProtocol != "" {
		m["health_check_protocol"] = s.HealthCheckProtocol
	}
	if s.HealthCheckPath != "" {
		m["health_check_path"] = s.HealthCheckPath
	}
	if s.HealthCheckIntervalSeconds != 0 {
		m["health_check_interval_seconds"] = s.HealthCheckIntervalSeconds
	}
	if s.ThresholdCount != 0 {
		m["threshold_count"] = s.ThresholdCount
	}
	if s.TrafficDialPercentage != 0 {
		m["traffic_dial_percentage"] = s.TrafficDialPercentage
	}
	if len(s.Endpoints) > 0 {
		items := make([]any, len(s.Endpoints))
		for i, v := range s.Endpoints {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["endpoints"] = items
	}
	if len(s.PortOverrides) > 0 {
		items := make([]any, len(s.PortOverrides))
		for i, v := range s.PortOverrides {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["port_overrides"] = items
	}
	return m
}

// AwsGlobalAcceleratorFlowLogs configures flow log delivery to S3 for traffic
//
//	analysis. Flow logs capture information about the IP address traffic flowing
//	to and from network interfaces in Global Accelerator.
type AwsGlobalAcceleratorFlowLogsInput struct {
	// Enable flow log delivery.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable flow log delivery."`
	// S3 bucket name for flow log storage. Required when enabled is true.
	S3Bucket string `json:"s3_bucket,omitempty" jsonschema:"S3 bucket name for flow log storage. Required when enabled is true."`
	// S3 key prefix for flow logs. Useful for organizing logs when multiple
	//  accelerators share a bucket. Example: "ga-logs/prod-accelerator/".
	S3Prefix string `json:"s3_prefix,omitempty" jsonschema:"S3 key prefix for flow logs. Useful for organizing logs when multiple accelerators share a bucket. Example: 'ga-logs/prod-accelerator/'."`
}

func (s *AwsGlobalAcceleratorFlowLogsInput) validate() error {
	return nil
}

func (s *AwsGlobalAcceleratorFlowLogsInput) applyDefaults() {
}

func (s *AwsGlobalAcceleratorFlowLogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.S3Bucket != "" {
		m["s3_bucket"] = s.S3Bucket
	}
	if s.S3Prefix != "" {
		m["s3_prefix"] = s.S3Prefix
	}
	return m
}

// AwsGlobalAcceleratorListener defines a port/protocol combination that the
//
//	accelerator accepts traffic on, along with the endpoint groups that receive
//	the routed traffic.
//
//	Each listener maps to one `aws_globalaccelerator_listener` resource.
//	Listeners are ForceNew on accelerator_arn (handled automatically by the
//	module) but can have port ranges and endpoint groups updated in place.
type AwsGlobalAcceleratorListenerInput struct {
	// User-assigned name for this listener. Used as a key in the output maps
	//  (listener_arns, endpoint_group_arns) so downstream resources can reference
	//  specific listener or endpoint group ARNs via valueFrom.
	//
	//  Must be unique within the accelerator's listeners. Lowercase alphanumeric
	//  and hyphens only, s...
	Name string `json:"name" jsonschema:"required,User-assigned name for this listener. Used as a key in the output maps (listener_arns; endpoint_group_arns) so downstream resources can reference specific listener or endpoint group ARNs via valueFrom..."`
	// Protocol for this listener. Global Accelerator operates at Layer 4.
	//  - "TCP": For HTTP, HTTPS, WebSocket, gRPC, and other TCP workloads.
	//  - "UDP": For DNS, gaming, IoT, and real-time media workloads.
	Protocol string `json:"protocol" jsonschema:"required,Protocol for this listener. Global Accelerator operates at Layer 4. - 'TCP': For HTTP; HTTPS; WebSocket; gRPC; and other TCP workloads. - 'UDP': For DNS; gaming; IoT; and real-time media workloads."`
	// Client affinity setting for this listener.
	//  - "NONE" (default): Requests from the same client may be routed to
	//    different endpoints. Best for stateless workloads.
	//  - "SOURCE_IP": All requests from the same source IP address are routed
	//    to the same endpoint within an endpoint group. Required for ...
	ClientAffinity string `json:"client_affinity,omitempty" jsonschema:"Client affinity setting for this listener. - 'NONE' (default): Requests from the same client may be routed to different endpoints. Best for stateless workloads. - 'SOURCE_IP': All requests from the sa..."`
	// Port ranges that this listener accepts traffic on. Each range defines
	//  a from_port and to_port (inclusive). Use a single port range for most
	//  workloads, or multiple ranges for services on different ports.
	//
	//  At least one port range is required. Maximum 10 ranges per listener.
	PortRanges []*AwsGlobalAcceleratorPortRangeInput `json:"port_ranges" jsonschema:"required,Port ranges that this listener accepts traffic on. Each range defines a from_port and to_port (inclusive). Use a single port range for most workloads; or multiple ranges for services on different port..."`
	// Endpoint groups define regional destinations for this listener's traffic.
	//  Each endpoint group represents a set of endpoints in one AWS region.
	//
	//  At least one endpoint group is required — a listener without endpoint
	//  groups drops all traffic.
	EndpointGroups []*AwsGlobalAcceleratorEndpointGroupInput `json:"endpoint_groups" jsonschema:"required,Endpoint groups define regional destinations for this listener's traffic. Each endpoint group represents a set of endpoints in one AWS region. At least one endpoint group is required — a listener wi..."`
}

func (s *AwsGlobalAcceleratorListenerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if len(s.PortRanges) == 0 {
		return fmt.Errorf("port_ranges is required")
	}
	if len(s.PortRanges) < 1 {
		return fmt.Errorf("port_ranges requires at least 1 items, got %d", len(s.PortRanges))
	}
	for i, v := range s.PortRanges {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("port_ranges[%d]: %w", i, err)
			}
		}
	}
	if len(s.EndpointGroups) == 0 {
		return fmt.Errorf("endpoint_groups is required")
	}
	if len(s.EndpointGroups) < 1 {
		return fmt.Errorf("endpoint_groups requires at least 1 items, got %d", len(s.EndpointGroups))
	}
	for i, v := range s.EndpointGroups {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("endpoint_groups[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsGlobalAcceleratorListenerInput) applyDefaults() {
	if s.ClientAffinity == "" {
		s.ClientAffinity = "NONE"
	}
}

func (s *AwsGlobalAcceleratorListenerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["protocol"] = s.Protocol
	if s.ClientAffinity != "" {
		m["client_affinity"] = s.ClientAffinity
	}
	if len(s.PortRanges) > 0 {
		items := make([]any, len(s.PortRanges))
		for i, v := range s.PortRanges {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["port_ranges"] = items
	}
	if len(s.EndpointGroups) > 0 {
		items := make([]any, len(s.EndpointGroups))
		for i, v := range s.EndpointGroups {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["endpoint_groups"] = items
	}
	return m
}

// AwsGlobalAcceleratorPortOverride remaps a listener port to a different
//
//	endpoint port. This allows endpoints to serve on a port different from
//	what the listener advertises.
type AwsGlobalAcceleratorPortOverrideInput struct {
	// The listener port that is remapped. Must match a port within one of the
	//  listener's port ranges.
	ListenerPort int32 `json:"listener_port" jsonschema:"required,The listener port that is remapped. Must match a port within one of the listener's port ranges."`
	// The endpoint port that traffic is forwarded to.
	EndpointPort int32 `json:"endpoint_port" jsonschema:"required,The endpoint port that traffic is forwarded to."`
}

func (s *AwsGlobalAcceleratorPortOverrideInput) validate() error {
	return nil
}

func (s *AwsGlobalAcceleratorPortOverrideInput) applyDefaults() {
}

func (s *AwsGlobalAcceleratorPortOverrideInput) toMap() map[string]any {
	m := make(map[string]any)
	m["listener_port"] = s.ListenerPort
	m["endpoint_port"] = s.EndpointPort
	return m
}

// AwsGlobalAcceleratorPortRange defines an inclusive port range for a listener.
type AwsGlobalAcceleratorPortRangeInput struct {
	// First port in the range (inclusive). Range: 1-65535.
	FromPort int32 `json:"from_port" jsonschema:"required,First port in the range (inclusive). Range: 1-65535."`
	// Last port in the range (inclusive). Must be >= from_port. Range: 1-65535.
	ToPort int32 `json:"to_port" jsonschema:"required,Last port in the range (inclusive). Must be >= from_port. Range: 1-65535."`
}

func (s *AwsGlobalAcceleratorPortRangeInput) validate() error {
	return nil
}

func (s *AwsGlobalAcceleratorPortRangeInput) applyDefaults() {
}

func (s *AwsGlobalAcceleratorPortRangeInput) toMap() map[string]any {
	m := make(map[string]any)
	m["from_port"] = s.FromPort
	m["to_port"] = s.ToPort
	return m
}

// ParseAwsGlobalAccelerator validates and normalizes a AwsGlobalAccelerator cloud_object.
func ParseAwsGlobalAccelerator(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsGlobalAccelerator"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsGlobalAcceleratorSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
