// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsNetworkLoadBalancer represents a managed AWS Network Load Balancer
//
//	deployed via OpenMCF. This resource provisions a Layer 4 load balancer
//	with listeners, target groups, and optional Route53 DNS records.
type AwsNetworkLoadBalancerSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Subnet mappings define where NLB nodes are placed and optionally assign
	//  static IP addresses. Each mapping corresponds to one Availability Zone.
	//
	//  For internet-facing NLBs, provide an allocation_id (Elastic IP) per subnet
	//  to get static public IPs -- a primary reason to choose NLB over ALB.
	//
	//  For in...
	SubnetMappings []*AwsNetworkLoadBalancerSubnetMappingInput `json:"subnet_mappings" jsonschema:"required,Subnet mappings define where NLB nodes are placed and optionally assign static IP addresses. Each mapping corresponds to one Availability Zone. For internet-facing NLBs; provide an allocation_id (Elas..."`
	// Security group IDs to attach to the NLB. Unlike ALB, security groups are
	//  optional for NLB. When omitted, the NLB accepts all traffic on configured
	//  listener ports. When provided, security group rules filter inbound traffic.
	//
	//  Important: once security groups are attached to an NLB, they cannot be
	//  f...
	SecurityGroups []string `json:"security_groups,omitempty" jsonschema:"Security group IDs to attach to the NLB. Unlike ALB; security groups are optional for NLB. When omitted; the NLB accepts all traffic on configured listener ports. When provided; security group rules f..."`
	// When true, creates an internal NLB accessible only within the VPC.
	//  When false (default), creates an internet-facing NLB with public DNS.
	Internal bool `json:"internal,omitempty" jsonschema:"When true; creates an internal NLB accessible only within the VPC. When false (default); creates an internet-facing NLB with public DNS."`
	// Prevents accidental deletion of the NLB when enabled. Recommended for
	//  production workloads.
	DeleteProtectionEnabled bool `json:"delete_protection_enabled,omitempty" jsonschema:"Prevents accidental deletion of the NLB when enabled. Recommended for production workloads."`
	// Distribute traffic evenly across all registered targets in all enabled
	//  Availability Zones. Default is false for NLB (unlike ALB where cross-zone
	//  is always enabled). Enable this when target distribution across AZs is
	//  uneven or when you need consistent per-target traffic distribution.
	CrossZoneLoadBalancingEnabled bool `json:"cross_zone_load_balancing_enabled,omitempty" jsonschema:"Distribute traffic evenly across all registered targets in all enabled Availability Zones. Default is false for NLB (unlike ALB where cross-zone is always enabled). Enable this when target distributio..."`
	// IP address type for the NLB. Controls whether the NLB uses IPv4 only or
	//  dual-stack (IPv4 + IPv6).
	//  Valid values: "ipv4" (default), "dualstack".
	IpAddressType string `json:"ip_address_type,omitempty" jsonschema:"IP address type for the NLB. Controls whether the NLB uses IPv4 only or dual-stack (IPv4 + IPv6). Valid values: 'ipv4' (default); 'dualstack'."`
	// Controls how DNS queries from clients are routed to NLB nodes across
	//  Availability Zones. Affects latency and cross-zone traffic costs.
	//
	//  Valid values:
	//  - "any_availability_zone" (default): Clients may be routed to any AZ.
	//  - "availability_zone_affinity": Clients are routed to the AZ of the
	//    resol...
	DnsRecordClientRoutingPolicy string `json:"dns_record_client_routing_policy,omitempty" jsonschema:"Controls how DNS queries from clients are routed to NLB nodes across Availability Zones. Affects latency and cross-zone traffic costs. Valid values: - 'any_availability_zone' (default): Clients may be..."`
	// Listeners define the ports and protocols the NLB accepts traffic on.
	//  Each listener includes an inline target group that receives forwarded
	//  connections.
	//
	//  At least one listener is required. A common pattern is a single TLS
	//  listener on port 443 forwarding to TCP targets on an application port.
	Listeners []*AwsNetworkLoadBalancerListenerInput `json:"listeners" jsonschema:"required,Listeners define the ports and protocols the NLB accepts traffic on. Each listener includes an inline target group that receives forwarded connections. At least one listener is required. A common patt..."`
	// Optional Route53 DNS configuration. When enabled, creates alias A records
	//  pointing the specified hostnames to the NLB's DNS name.
	Dns *AwsNetworkLoadBalancerDnsInput `json:"dns,omitempty" jsonschema:"Optional Route53 DNS configuration. When enabled; creates alias A records pointing the specified hostnames to the NLB's DNS name."`
}

func (s *AwsNetworkLoadBalancerSpecInput) validate() error {
	if len(s.SubnetMappings) == 0 {
		return fmt.Errorf("subnet_mappings is required")
	}
	if len(s.SubnetMappings) < 1 {
		return fmt.Errorf("subnet_mappings requires at least 1 items, got %d", len(s.SubnetMappings))
	}
	for i, v := range s.SubnetMappings {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("subnet_mappings[%d]: %w", i, err)
			}
		}
	}
	if len(s.Listeners) == 0 {
		return fmt.Errorf("listeners is required")
	}
	if len(s.Listeners) < 1 {
		return fmt.Errorf("listeners requires at least 1 items, got %d", len(s.Listeners))
	}
	for i, v := range s.Listeners {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("listeners[%d]: %w", i, err)
			}
		}
	}
	if s.Dns != nil {
		if err := s.Dns.validate(); err != nil {
			return fmt.Errorf("dns: %w", err)
		}
	}
	return nil
}

func (s *AwsNetworkLoadBalancerSpecInput) applyDefaults() {
	if s.Dns != nil {
		s.Dns.applyDefaults()
	}
}

func (s *AwsNetworkLoadBalancerSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if len(s.SubnetMappings) > 0 {
		items := make([]any, len(s.SubnetMappings))
		for i, v := range s.SubnetMappings {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["subnet_mappings"] = items
	}
	if len(s.SecurityGroups) > 0 {
		m["security_groups"] = s.SecurityGroups
	}
	if s.Internal {
		m["internal"] = s.Internal
	}
	if s.DeleteProtectionEnabled {
		m["delete_protection_enabled"] = s.DeleteProtectionEnabled
	}
	if s.CrossZoneLoadBalancingEnabled {
		m["cross_zone_load_balancing_enabled"] = s.CrossZoneLoadBalancingEnabled
	}
	if s.IpAddressType != "" {
		m["ip_address_type"] = s.IpAddressType
	}
	if s.DnsRecordClientRoutingPolicy != "" {
		m["dns_record_client_routing_policy"] = s.DnsRecordClientRoutingPolicy
	}
	if len(s.Listeners) > 0 {
		items := make([]any, len(s.Listeners))
		for i, v := range s.Listeners {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["listeners"] = items
	}
	if s.Dns != nil {
		m["dns"] = s.Dns.toMap()
	}
	return m
}

// AwsNetworkLoadBalancerDns defines optional Route53 DNS configuration for
//
//	the NLB. When enabled, creates alias A records that point the specified
//	hostnames to the NLB's DNS name.
//
//	This is the same pattern used by AwsAlb. Alias records are preferred over
//	CNAME records because they work at the zone apex, have no charge for
//	alias queries, and inherit the NLB's health check status.
type AwsNetworkLoadBalancerDnsInput struct {
	// When true, creates Route53 alias records for the NLB.
	Enabled bool `json:"enabled,omitempty" jsonschema:"When true; creates Route53 alias records for the NLB."`
	// Route53 hosted zone ID where alias records are created.
	//  Required when enabled is true.
	Route53ZoneId string `json:"route53_zone_id,omitempty" jsonschema:"Route53 hosted zone ID where alias records are created. Required when enabled is true."`
	// Domain names that will point to the NLB via Route53 alias records.
	//  Each hostname gets its own A record aliased to the NLB's DNS name.
	Hostnames []string `json:"hostnames,omitempty" jsonschema:"Domain names that will point to the NLB via Route53 alias records. Each hostname gets its own A record aliased to the NLB's DNS name."`
}

func (s *AwsNetworkLoadBalancerDnsInput) validate() error {
	return nil
}

func (s *AwsNetworkLoadBalancerDnsInput) applyDefaults() {
}

func (s *AwsNetworkLoadBalancerDnsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Route53ZoneId != "" {
		m["route53_zone_id"] = s.Route53ZoneId
	}
	if len(s.Hostnames) > 0 {
		m["hostnames"] = s.Hostnames
	}
	return m
}

// AwsNetworkLoadBalancerHealthCheck defines how the NLB determines whether
//
//	targets in a target group are healthy enough to receive traffic.
//
//	NLB health checks differ from ALB in important ways:
//	- TCP health checks (default) only verify port reachability, not content
//	- HTTP/HTTPS health checks can verify application readiness via a path
//	- Health check intervals, thresholds, and timeouts have different defaults
//	  and ranges than ALB
type AwsNetworkLoadBalancerHealthCheckInput struct {
	// Protocol used for health checks.
	//  Valid values: "TCP" (default), "HTTP", "HTTPS".
	//
	//  TCP health checks verify that the target port is reachable. HTTP/HTTPS
	//  health checks send a GET request to the specified path and verify the
	//  response status code.
	Protocol string `json:"protocol,omitempty" jsonschema:"Protocol used for health checks. Valid values: 'TCP' (default); 'HTTP'; 'HTTPS'. TCP health checks verify that the target port is reachable. HTTP/HTTPS health checks send a GET request to the specifie..."`
	// Port used for health checks. Specify "traffic-port" to use the target
	//  group's traffic port, or a specific port number (1-65535).
	//  Default: "traffic-port".
	Port string `json:"port,omitempty" jsonschema:"Port used for health checks. Specify 'traffic-port' to use the target group's traffic port; or a specific port number (1-65535). Default: 'traffic-port'."`
	// Path for HTTP/HTTPS health checks. The NLB sends a GET request to this
	//  path and checks the response status code against the matcher.
	//  Required when health check protocol is HTTP or HTTPS.
	//  Default: "/" when protocol is HTTP or HTTPS.
	Path string `json:"path,omitempty" jsonschema:"Path for HTTP/HTTPS health checks. The NLB sends a GET request to this path and checks the response status code against the matcher. Required when health check protocol is HTTP or HTTPS. Default: '/' ..."`
	// Number of consecutive successful health checks required to consider an
	//  unhealthy target healthy. Range: 2-10. Default: 3.
	HealthyThreshold int32 `json:"healthy_threshold,omitempty" jsonschema:"Number of consecutive successful health checks required to consider an unhealthy target healthy. Range: 2-10. Default: 3."`
	// Number of consecutive failed health checks required to consider a healthy
	//  target unhealthy. Range: 2-10. Default: 3.
	//
	//  For NLB, this must equal healthy_threshold (unlike ALB where they can
	//  differ). The IaC modules enforce this by setting both to healthy_threshold.
	UnhealthyThreshold int32 `json:"unhealthy_threshold,omitempty" jsonschema:"Number of consecutive failed health checks required to consider a healthy target unhealthy. Range: 2-10. Default: 3. For NLB; this must equal healthy_threshold (unlike ALB where they can differ). The ..."`
	// Time in seconds between health checks for an individual target.
	//  Range: 5-300. Default: 30 seconds.
	IntervalSeconds int32 `json:"interval_seconds,omitempty" jsonschema:"Time in seconds between health checks for an individual target. Range: 5-300. Default: 30 seconds."`
	// Time in seconds to wait for a health check response before considering
	//  it failed. Must be less than interval_seconds.
	//  Range: 2-120. Default: 10 seconds for TCP, 6 seconds for HTTP/HTTPS.
	TimeoutSeconds int32 `json:"timeout_seconds,omitempty" jsonschema:"Time in seconds to wait for a health check response before considering it failed. Must be less than interval_seconds. Range: 2-120. Default: 10 seconds for TCP; 6 seconds for HTTP/HTTPS."`
	// HTTP response codes that indicate a healthy target. Only valid when
	//  health check protocol is HTTP or HTTPS.
	//  Format: single code ("200"), range ("200-399"), or comma-separated
	//  ("200,202"). Default: "200-399".
	Matcher string `json:"matcher,omitempty" jsonschema:"HTTP response codes that indicate a healthy target. Only valid when health check protocol is HTTP or HTTPS. Format: single code ('200'); range ('200-399'); or comma-separated ('200;202'). Default: '20..."`
}

func (s *AwsNetworkLoadBalancerHealthCheckInput) validate() error {
	return nil
}

func (s *AwsNetworkLoadBalancerHealthCheckInput) applyDefaults() {
}

func (s *AwsNetworkLoadBalancerHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Port != "" {
		m["port"] = s.Port
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.HealthyThreshold != 0 {
		m["healthy_threshold"] = s.HealthyThreshold
	}
	if s.UnhealthyThreshold != 0 {
		m["unhealthy_threshold"] = s.UnhealthyThreshold
	}
	if s.IntervalSeconds != 0 {
		m["interval_seconds"] = s.IntervalSeconds
	}
	if s.TimeoutSeconds != 0 {
		m["timeout_seconds"] = s.TimeoutSeconds
	}
	if s.Matcher != "" {
		m["matcher"] = s.Matcher
	}
	return m
}

// AwsNetworkLoadBalancerListener defines a port/protocol combination that the
//
//	NLB accepts connections on, along with the target group that receives the
//	forwarded traffic.
//
//	NLB listeners only support forward actions (no redirect, fixed-response, or
//	authentication actions like ALB). Therefore, every listener must have an
//	associated target group.
type AwsNetworkLoadBalancerListenerInput struct {
	// User-assigned name for this listener. Used as a key in the output maps
	//  (listener_arns, target_group_arns) so downstream resources can reference
	//  specific listener or target group ARNs via valueFrom.
	//
	//  Must be unique within the NLB's listeners. Lowercase alphanumeric and
	//  hyphens only, starting with...
	Name string `json:"name" jsonschema:"required,User-assigned name for this listener. Used as a key in the output maps (listener_arns; target_group_arns) so downstream resources can reference specific listener or target group ARNs via valueFrom. Mu..."`
	// Port number the listener accepts traffic on. Range: 1-65535.
	Port int32 `json:"port" jsonschema:"required,Port number the listener accepts traffic on. Range: 1-65535."`
	// Protocol for this listener.
	//  Valid values: "TCP", "UDP", "TLS", "TCP_UDP".
	//
	//  Choose TLS for TLS termination at the NLB (requires tls configuration).
	//  Choose TCP for pass-through to targets that handle their own TLS.
	//  Choose UDP for UDP workloads (DNS, gaming, IoT).
	//  Choose TCP_UDP for dual-protocol ...
	Protocol string `json:"protocol" jsonschema:"required,Protocol for this listener. Valid values: 'TCP'; 'UDP'; 'TLS'; 'TCP_UDP'. Choose TLS for TLS termination at the NLB (requires tls configuration). Choose TCP for pass-through to targets that handle the..."`
	// TLS configuration for TLS protocol listeners. Required when protocol is
	//  "TLS". Specifies the ACM certificate for TLS termination and optionally
	//  the security policy.
	Tls *AwsNetworkLoadBalancerTlsConfigInput `json:"tls,omitempty" jsonschema:"TLS configuration for TLS protocol listeners. Required when protocol is 'TLS'. Specifies the ACM certificate for TLS termination and optionally the security policy."`
	// TCP idle timeout in seconds. Controls how long the NLB keeps an idle TCP
	//  connection open before closing it. Only valid for TCP protocol listeners.
	//  Range: 60-6000 seconds. Default: 350 seconds (AWS default).
	TcpIdleTimeoutSeconds int32 `json:"tcp_idle_timeout_seconds,omitempty" jsonschema:"TCP idle timeout in seconds. Controls how long the NLB keeps an idle TCP connection open before closing it. Only valid for TCP protocol listeners. Range: 60-6000 seconds. Default: 350 seconds (AWS def..."`
	// ALPN policy for TLS listeners. Controls which Application-Layer Protocol
	//  Negotiation protocols are advertised during the TLS handshake.
	//
	//  Only valid when protocol is "TLS".
	//  Valid values: "HTTP1Only", "HTTP2Only", "HTTP2Optional", "HTTP2Preferred", "None".
	AlpnPolicy string `json:"alpn_policy,omitempty" jsonschema:"ALPN policy for TLS listeners. Controls which Application-Layer Protocol Negotiation protocols are advertised during the TLS handshake. Only valid when protocol is 'TLS'. Valid values: 'HTTP1Only'; 'H..."`
	// Target group configuration for this listener. Defines how the listener
	//  forwards connections to backend targets.
	//
	//  Every listener must have a target group because NLB only supports forward
	//  actions.
	TargetGroup *AwsNetworkLoadBalancerTargetGroupInput `json:"target_group" jsonschema:"required,Target group configuration for this listener. Defines how the listener forwards connections to backend targets. Every listener must have a target group because NLB only supports forward actions."`
}

func (s *AwsNetworkLoadBalancerListenerInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if s.Tls != nil {
		if err := s.Tls.validate(); err != nil {
			return fmt.Errorf("tls: %w", err)
		}
	}
	if s.TargetGroup == nil {
		return fmt.Errorf("target_group is required")
	}
	if s.TargetGroup != nil {
		if err := s.TargetGroup.validate(); err != nil {
			return fmt.Errorf("target_group: %w", err)
		}
	}
	return nil
}

func (s *AwsNetworkLoadBalancerListenerInput) applyDefaults() {
	if s.Tls != nil {
		s.Tls.applyDefaults()
	}
	if s.TargetGroup != nil {
		s.TargetGroup.applyDefaults()
	}
}

func (s *AwsNetworkLoadBalancerListenerInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["port"] = s.Port
	m["protocol"] = s.Protocol
	if s.Tls != nil {
		m["tls"] = s.Tls.toMap()
	}
	if s.TcpIdleTimeoutSeconds != 0 {
		m["tcp_idle_timeout_seconds"] = s.TcpIdleTimeoutSeconds
	}
	if s.AlpnPolicy != "" {
		m["alpn_policy"] = s.AlpnPolicy
	}
	if s.TargetGroup != nil {
		m["target_group"] = s.TargetGroup.toMap()
	}
	return m
}

// AwsNetworkLoadBalancerSubnetMapping maps an NLB node to a specific subnet
//
//	and optionally assigns a static IP address.
//
//	For internet-facing NLBs, assign an Elastic IP via allocation_id to get a
//	static public IP that does not change across NLB scaling events. This is
//	critical for allowlisting, DNS pinning, and firewall rules.
//
//	For internal NLBs, use private_ipv4_address to pin the NLB node to a
//	specific private IP within the subnet.
type AwsNetworkLoadBalancerSubnetMappingInput struct {
	// Subnet ID where the NLB node is placed. Must be in a VPC that supports
	//  the NLB's scheme (public subnet for internet-facing, private for internal).
	SubnetId string `json:"subnet_id" jsonschema:"required,Subnet ID where the NLB node is placed. Must be in a VPC that supports the NLB's scheme (public subnet for internet-facing; private for internal)."`
	// Elastic IP allocation ID for a static public IP address on this NLB node.
	//  Only valid for internet-facing NLBs. Each subnet mapping can have at most
	//  one Elastic IP.
	AllocationId string `json:"allocation_id,omitempty" jsonschema:"Elastic IP allocation ID for a static public IP address on this NLB node. Only valid for internet-facing NLBs. Each subnet mapping can have at most one Elastic IP."`
	// Specific private IPv4 address for the NLB node in this subnet. Only valid
	//  for internal NLBs. The address must belong to the subnet's CIDR range.
	//  When omitted, AWS assigns a private IP automatically.
	PrivateIpv4Address string `json:"private_ipv4_address,omitempty" jsonschema:"Specific private IPv4 address for the NLB node in this subnet. Only valid for internal NLBs. The address must belong to the subnet's CIDR range. When omitted; AWS assigns a private IP automatically."`
}

func (s *AwsNetworkLoadBalancerSubnetMappingInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	return nil
}

func (s *AwsNetworkLoadBalancerSubnetMappingInput) applyDefaults() {
}

func (s *AwsNetworkLoadBalancerSubnetMappingInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnet_id"] = s.SubnetId
	if s.AllocationId != "" {
		m["allocation_id"] = s.AllocationId
	}
	if s.PrivateIpv4Address != "" {
		m["private_ipv4_address"] = s.PrivateIpv4Address
	}
	return m
}

// AwsNetworkLoadBalancerTargetGroup defines how a listener forwards connections
//
//	to backend targets.
//
//	The target group itself is created by OpenMCF. Actual targets (EC2 instances,
//	IP addresses, or ALBs) are registered separately -- typically by ECS services,
//	EKS ingress controllers, or auto-scaling group attachments. This separation
//	allows the NLB infrastructure to be provisioned independently from the
//	application workloads it fronts.
type AwsNetworkLoadBalancerTargetGroupInput struct {
	// Port to route traffic to on registered targets. Range: 1-65535.
	Port int32 `json:"port" jsonschema:"required,Port to route traffic to on registered targets. Range: 1-65535."`
	// Protocol for communication with targets.
	//  Valid values: "TCP", "UDP", "TLS", "TCP_UDP".
	//
	//  This is the protocol used between the NLB and targets, which may differ
	//  from the listener protocol. For example, a TLS listener can forward to
	//  TCP targets (NLB terminates TLS).
	Protocol string `json:"protocol" jsonschema:"required,Protocol for communication with targets. Valid values: 'TCP'; 'UDP'; 'TLS'; 'TCP_UDP'. This is the protocol used between the NLB and targets; which may differ from the listener protocol. For example; ..."`
	// Target type determines how targets are specified when registered.
	//  - "instance": Targets are EC2 instance IDs. Health checks use the
	//    instance's primary private IP.
	//  - "ip": Targets are IP addresses. Supports IPs within the VPC CIDR
	//    or peered VPC CIDRs.
	//  - "alb": Target is an Application Load B...
	TargetType string `json:"target_type,omitempty" jsonschema:"Target type determines how targets are specified when registered. - 'instance': Targets are EC2 instance IDs. Health checks use the instance's primary private IP. - 'ip': Targets are IP addresses. Sup..."`
	// Health check configuration for targets in this group. When omitted,
	//  AWS applies default health check settings (TCP on the traffic port,
	//  30-second interval, 3 healthy/unhealthy thresholds).
	HealthCheck *AwsNetworkLoadBalancerHealthCheckInput `json:"health_check,omitempty" jsonschema:"Health check configuration for targets in this group. When omitted; AWS applies default health check settings (TCP on the traffic port; 30-second interval; 3 healthy/unhealthy thresholds)."`
	// Time in seconds the NLB waits before deregistering a draining target.
	//  During this period, in-flight connections are allowed to complete.
	//  Range: 0-3600. Default: 300 seconds.
	DeregistrationDelaySeconds int32 `json:"deregistration_delay_seconds,omitempty" jsonschema:"Time in seconds the NLB waits before deregistering a draining target. During this period; in-flight connections are allowed to complete. Range: 0-3600. Default: 300 seconds."`
	// When enabled, targets see the original client IP address in the IP
	//  header. When disabled, targets see the NLB's private IP.
	//
	//  Enabled by default for instance targets, disabled for IP targets.
	//  Use with proxy_protocol_v2 for full client metadata (port, VPC endpoint).
	PreserveClientIp bool `json:"preserve_client_ip,omitempty" jsonschema:"When enabled; targets see the original client IP address in the IP header. When disabled; targets see the NLB's private IP. Enabled by default for instance targets; disabled for IP targets. Use with p..."`
	// Enable Proxy Protocol v2 header on connections forwarded to targets.
	//  The header carries client connection metadata (source IP/port, destination
	//  IP/port, VPC endpoint ID). Targets must be configured to parse the
	//  Proxy Protocol v2 header.
	ProxyProtocolV2 bool `json:"proxy_protocol_v2,omitempty" jsonschema:"Enable Proxy Protocol v2 header on connections forwarded to targets. The header carries client connection metadata (source IP/port; destination IP/port; VPC endpoint ID). Targets must be configured to..."`
	// When enabled, the NLB terminates connections to deregistered targets
	//  immediately when the deregistration delay expires, instead of waiting
	//  for the client to close them. Recommended for long-lived connections
	//  (WebSocket, gRPC streams, database connections).
	ConnectionTermination bool `json:"connection_termination,omitempty" jsonschema:"When enabled; the NLB terminates connections to deregistered targets immediately when the deregistration delay expires; instead of waiting for the client to close them. Recommended for long-lived conn..."`
	// Enable source-IP-based sticky sessions. When enabled, the NLB routes
	//  requests from the same client IP to the same target for the duration
	//  of the connection. This is the only stickiness type supported by NLB
	//  (cookie-based stickiness is ALB-only).
	StickinessEnabled bool `json:"stickiness_enabled,omitempty" jsonschema:"Enable source-IP-based sticky sessions. When enabled; the NLB routes requests from the same client IP to the same target for the duration of the connection. This is the only stickiness type supported ..."`
}

func (s *AwsNetworkLoadBalancerTargetGroupInput) validate() error {
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	return nil
}

func (s *AwsNetworkLoadBalancerTargetGroupInput) applyDefaults() {
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *AwsNetworkLoadBalancerTargetGroupInput) toMap() map[string]any {
	m := make(map[string]any)
	m["port"] = s.Port
	m["protocol"] = s.Protocol
	if s.TargetType != "" {
		m["target_type"] = s.TargetType
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	if s.DeregistrationDelaySeconds != 0 {
		m["deregistration_delay_seconds"] = s.DeregistrationDelaySeconds
	}
	if s.PreserveClientIp {
		m["preserve_client_ip"] = s.PreserveClientIp
	}
	if s.ProxyProtocolV2 {
		m["proxy_protocol_v2"] = s.ProxyProtocolV2
	}
	if s.ConnectionTermination {
		m["connection_termination"] = s.ConnectionTermination
	}
	if s.StickinessEnabled {
		m["stickiness_enabled"] = s.StickinessEnabled
	}
	return m
}

// AwsNetworkLoadBalancerTlsConfig defines TLS termination settings for a
//
//	TLS protocol listener.
//
//	When TLS termination is configured on the NLB, the NLB decrypts incoming
//	TLS connections and forwards plaintext TCP to targets. This offloads
//	certificate management and TLS processing from application servers.
type AwsNetworkLoadBalancerTlsConfigInput struct {
	// ACM certificate ARN for TLS termination. The certificate must cover the
	//  domain names that clients use to connect to the NLB.
	CertificateArn string `json:"certificate_arn" jsonschema:"required,ACM certificate ARN for TLS termination. The certificate must cover the domain names that clients use to connect to the NLB."`
	// TLS security policy that defines the supported ciphers and protocols.
	//  When omitted, AWS uses the default policy.
	//  Recommended: "ELBSecurityPolicy-TLS13-1-2-2021-06" for modern TLS 1.3+1.2.
	SslPolicy string `json:"ssl_policy,omitempty" jsonschema:"TLS security policy that defines the supported ciphers and protocols. When omitted; AWS uses the default policy. Recommended: 'ELBSecurityPolicy-TLS13-1-2-2021-06' for modern TLS 1.3+1.2."`
}

func (s *AwsNetworkLoadBalancerTlsConfigInput) validate() error {
	if s.CertificateArn == "" {
		return fmt.Errorf("certificate_arn is required")
	}
	return nil
}

func (s *AwsNetworkLoadBalancerTlsConfigInput) applyDefaults() {
}

func (s *AwsNetworkLoadBalancerTlsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["certificate_arn"] = s.CertificateArn
	if s.SslPolicy != "" {
		m["ssl_policy"] = s.SslPolicy
	}
	return m
}

// ParseAwsNetworkLoadBalancer validates and normalizes a AwsNetworkLoadBalancer cloud_object.
func ParseAwsNetworkLoadBalancer(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsNetworkLoadBalancer"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsNetworkLoadBalancerSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
