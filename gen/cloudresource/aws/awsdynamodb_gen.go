// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsDynamodb is the Kubernetes-style resource envelope for a DynamoDB table.
type AwsDynamodbSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Billing configuration for the table.
	BillingMode string `json:"billing_mode,omitempty" jsonschema:"enum=PROVISIONED|PAY_PER_REQUEST,Billing configuration for the table."`
	// Provisioned throughput for the table (used when billing_mode is PROVISIONED).
	ProvisionedThroughput *ProvisionedThroughputInput `json:"provisioned_throughput,omitempty" jsonschema:"Provisioned throughput for the table (used when billing_mode is PROVISIONED)."`
	// Attribute definitions referenced by the primary key and indexes.
	AttributeDefinitions []*AttributeDefinitionInput `json:"attribute_definitions,omitempty" jsonschema:"Attribute definitions referenced by the primary key and indexes."`
	// Primary key schema for the table: includes HASH and optional RANGE.
	KeySchema []*KeySchemaElementInput `json:"key_schema,omitempty" jsonschema:"Primary key schema for the table: includes HASH and optional RANGE."`
	// Global secondary indexes.
	GlobalSecondaryIndexes []*GlobalSecondaryIndexInput `json:"global_secondary_indexes,omitempty" jsonschema:"Global secondary indexes."`
	// Local secondary indexes.
	LocalSecondaryIndexes []*LocalSecondaryIndexInput `json:"local_secondary_indexes,omitempty" jsonschema:"Local secondary indexes."`
	// Time-to-live configuration.
	Ttl *TimeToLiveInput `json:"ttl,omitempty" jsonschema:"Time-to-live configuration."`
	// DynamoDB Streams configuration.
	StreamEnabled  bool   `json:"stream_enabled,omitempty" jsonschema:"DynamoDB Streams configuration."`
	StreamViewType string `json:"stream_view_type,omitempty" jsonschema:"enum=KEYS_ONLY|NEW_IMAGE|OLD_IMAGE|NEW_AND_OLD_IMAGES"`
	// Point-in-time recovery (PITR) setting.
	PointInTimeRecoveryEnabled bool `json:"point_in_time_recovery_enabled,omitempty" jsonschema:"Point-in-time recovery (PITR) setting."`
	// Server-side encryption settings.
	ServerSideEncryption *ServerSideEncryptionInput `json:"server_side_encryption,omitempty" jsonschema:"Server-side encryption settings."`
	// Table storage class.
	TableClass string `json:"table_class,omitempty" jsonschema:"enum=STANDARD|STANDARD_INFREQUENT_ACCESS,Table storage class."`
	// Deletion protection setting.
	DeletionProtectionEnabled bool `json:"deletion_protection_enabled,omitempty" jsonschema:"Deletion protection setting."`
	// Contributor Insights setting.
	ContributorInsightsEnabled bool `json:"contributor_insights_enabled,omitempty" jsonschema:"Contributor Insights setting."`
}

func (s *AwsDynamodbSpecInput) validate() error {
	switch s.BillingMode {
	case "", "PROVISIONED", "PAY_PER_REQUEST":
	default:
		return fmt.Errorf("invalid billing_mode: %q", s.BillingMode)
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.validate(); err != nil {
			return fmt.Errorf("provisioned_throughput: %w", err)
		}
	}
	if len(s.AttributeDefinitions) < 1 {
		return fmt.Errorf("attribute_definitions requires at least 1 items, got %d", len(s.AttributeDefinitions))
	}
	for i, v := range s.AttributeDefinitions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("attribute_definitions[%d]: %w", i, err)
			}
		}
	}
	if len(s.KeySchema) < 1 {
		return fmt.Errorf("key_schema requires at least 1 items, got %d", len(s.KeySchema))
	}
	for i, v := range s.KeySchema {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("key_schema[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.GlobalSecondaryIndexes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("global_secondary_indexes[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.LocalSecondaryIndexes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("local_secondary_indexes[%d]: %w", i, err)
			}
		}
	}
	if s.Ttl != nil {
		if err := s.Ttl.validate(); err != nil {
			return fmt.Errorf("ttl: %w", err)
		}
	}
	switch s.StreamViewType {
	case "", "KEYS_ONLY", "NEW_IMAGE", "OLD_IMAGE", "NEW_AND_OLD_IMAGES":
	default:
		return fmt.Errorf("invalid stream_view_type: %q", s.StreamViewType)
	}
	if s.ServerSideEncryption != nil {
		if err := s.ServerSideEncryption.validate(); err != nil {
			return fmt.Errorf("server_side_encryption: %w", err)
		}
	}
	switch s.TableClass {
	case "", "STANDARD", "STANDARD_INFREQUENT_ACCESS":
	default:
		return fmt.Errorf("invalid table_class: %q", s.TableClass)
	}
	return nil
}

func (s *AwsDynamodbSpecInput) applyDefaults() {
	if s.ProvisionedThroughput != nil {
		s.ProvisionedThroughput.applyDefaults()
	}
	if s.Ttl != nil {
		s.Ttl.applyDefaults()
	}
	if s.ServerSideEncryption != nil {
		s.ServerSideEncryption.applyDefaults()
	}
}

func (s *AwsDynamodbSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.BillingMode != "" {
		m["billing_mode"] = s.BillingMode
	}
	if s.ProvisionedThroughput != nil {
		m["provisioned_throughput"] = s.ProvisionedThroughput.toMap()
	}
	if len(s.AttributeDefinitions) > 0 {
		items := make([]any, len(s.AttributeDefinitions))
		for i, v := range s.AttributeDefinitions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["attribute_definitions"] = items
	}
	if len(s.KeySchema) > 0 {
		items := make([]any, len(s.KeySchema))
		for i, v := range s.KeySchema {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["key_schema"] = items
	}
	if len(s.GlobalSecondaryIndexes) > 0 {
		items := make([]any, len(s.GlobalSecondaryIndexes))
		for i, v := range s.GlobalSecondaryIndexes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["global_secondary_indexes"] = items
	}
	if len(s.LocalSecondaryIndexes) > 0 {
		items := make([]any, len(s.LocalSecondaryIndexes))
		for i, v := range s.LocalSecondaryIndexes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["local_secondary_indexes"] = items
	}
	if s.Ttl != nil {
		m["ttl"] = s.Ttl.toMap()
	}
	if s.StreamEnabled {
		m["stream_enabled"] = s.StreamEnabled
	}
	if s.StreamViewType != "" {
		m["stream_view_type"] = s.StreamViewType
	}
	if s.PointInTimeRecoveryEnabled {
		m["point_in_time_recovery_enabled"] = s.PointInTimeRecoveryEnabled
	}
	if s.ServerSideEncryption != nil {
		m["server_side_encryption"] = s.ServerSideEncryption.toMap()
	}
	if s.TableClass != "" {
		m["table_class"] = s.TableClass
	}
	if s.DeletionProtectionEnabled {
		m["deletion_protection_enabled"] = s.DeletionProtectionEnabled
	}
	if s.ContributorInsightsEnabled {
		m["contributor_insights_enabled"] = s.ContributorInsightsEnabled
	}
	return m
}

// Defines an attribute name and type.
type AttributeDefinitionInput struct {
	Name string `json:"name,omitempty" jsonschema:""`
	Type string `json:"type,omitempty" jsonschema:"enum=S|N|B"`
}

func (s *AttributeDefinitionInput) validate() error {
	switch s.Type {
	case "", "S", "N", "B":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *AttributeDefinitionInput) applyDefaults() {
}

func (s *AttributeDefinitionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	return m
}

// Global secondary index definition.
type GlobalSecondaryIndexInput struct {
	Name                  string                      `json:"name,omitempty" jsonschema:""`
	KeySchema             []*KeySchemaElementInput    `json:"key_schema,omitempty" jsonschema:""`
	Projection            *ProjectionInput            `json:"projection,omitempty" jsonschema:""`
	ProvisionedThroughput *ProvisionedThroughputInput `json:"provisioned_throughput,omitempty" jsonschema:""`
}

func (s *GlobalSecondaryIndexInput) validate() error {
	if len(s.KeySchema) < 1 {
		return fmt.Errorf("key_schema requires at least 1 items, got %d", len(s.KeySchema))
	}
	for i, v := range s.KeySchema {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("key_schema[%d]: %w", i, err)
			}
		}
	}
	if s.Projection != nil {
		if err := s.Projection.validate(); err != nil {
			return fmt.Errorf("projection: %w", err)
		}
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.validate(); err != nil {
			return fmt.Errorf("provisioned_throughput: %w", err)
		}
	}
	return nil
}

func (s *GlobalSecondaryIndexInput) applyDefaults() {
	if s.Projection != nil {
		s.Projection.applyDefaults()
	}
	if s.ProvisionedThroughput != nil {
		s.ProvisionedThroughput.applyDefaults()
	}
}

func (s *GlobalSecondaryIndexInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.KeySchema) > 0 {
		items := make([]any, len(s.KeySchema))
		for i, v := range s.KeySchema {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["key_schema"] = items
	}
	if s.Projection != nil {
		m["projection"] = s.Projection.toMap()
	}
	if s.ProvisionedThroughput != nil {
		m["provisioned_throughput"] = s.ProvisionedThroughput.toMap()
	}
	return m
}

// Element of the key schema.
type KeySchemaElementInput struct {
	AttributeName string `json:"attribute_name,omitempty" jsonschema:""`
	KeyType       string `json:"key_type,omitempty" jsonschema:"enum=HASH|RANGE"`
}

func (s *KeySchemaElementInput) validate() error {
	switch s.KeyType {
	case "", "HASH", "RANGE":
	default:
		return fmt.Errorf("invalid key_type: %q", s.KeyType)
	}
	return nil
}

func (s *KeySchemaElementInput) applyDefaults() {
}

func (s *KeySchemaElementInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.AttributeName != "" {
		m["attribute_name"] = s.AttributeName
	}
	if s.KeyType != "" {
		m["key_type"] = s.KeyType
	}
	return m
}

// Local secondary index definition.
type LocalSecondaryIndexInput struct {
	Name       string                   `json:"name,omitempty" jsonschema:""`
	KeySchema  []*KeySchemaElementInput `json:"key_schema,omitempty" jsonschema:""`
	Projection *ProjectionInput         `json:"projection,omitempty" jsonschema:""`
}

func (s *LocalSecondaryIndexInput) validate() error {
	if len(s.KeySchema) < 2 {
		return fmt.Errorf("key_schema requires at least 2 items, got %d", len(s.KeySchema))
	}
	for i, v := range s.KeySchema {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("key_schema[%d]: %w", i, err)
			}
		}
	}
	if s.Projection != nil {
		if err := s.Projection.validate(); err != nil {
			return fmt.Errorf("projection: %w", err)
		}
	}
	return nil
}

func (s *LocalSecondaryIndexInput) applyDefaults() {
	if s.Projection != nil {
		s.Projection.applyDefaults()
	}
}

func (s *LocalSecondaryIndexInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.KeySchema) > 0 {
		items := make([]any, len(s.KeySchema))
		for i, v := range s.KeySchema {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["key_schema"] = items
	}
	if s.Projection != nil {
		m["projection"] = s.Projection.toMap()
	}
	return m
}

// Index projection configuration.
type ProjectionInput struct {
	Type             string   `json:"type,omitempty" jsonschema:"enum=ALL|KEYS_ONLY_PROJECTION|INCLUDE"`
	NonKeyAttributes []string `json:"non_key_attributes,omitempty" jsonschema:""`
}

func (s *ProjectionInput) validate() error {
	switch s.Type {
	case "", "ALL", "KEYS_ONLY_PROJECTION", "INCLUDE":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	return nil
}

func (s *ProjectionInput) applyDefaults() {
}

func (s *ProjectionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if len(s.NonKeyAttributes) > 0 {
		m["non_key_attributes"] = s.NonKeyAttributes
	}
	return m
}

// Provisioned capacity settings.
type ProvisionedThroughputInput struct {
	ReadCapacityUnits  int64 `json:"read_capacity_units,omitempty" jsonschema:""`
	WriteCapacityUnits int64 `json:"write_capacity_units,omitempty" jsonschema:""`
}

func (s *ProvisionedThroughputInput) validate() error {
	return nil
}

func (s *ProvisionedThroughputInput) applyDefaults() {
}

func (s *ProvisionedThroughputInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ReadCapacityUnits != 0 {
		m["read_capacity_units"] = s.ReadCapacityUnits
	}
	if s.WriteCapacityUnits != 0 {
		m["write_capacity_units"] = s.WriteCapacityUnits
	}
	return m
}

// Server-side encryption settings.
type ServerSideEncryptionInput struct {
	Enabled   bool   `json:"enabled,omitempty" jsonschema:""`
	KmsKeyArn string `json:"kms_key_arn,omitempty" jsonschema:""`
}

func (s *ServerSideEncryptionInput) validate() error {
	return nil
}

func (s *ServerSideEncryptionInput) applyDefaults() {
}

func (s *ServerSideEncryptionInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.KmsKeyArn != "" {
		m["kms_key_arn"] = s.KmsKeyArn
	}
	return m
}

// Time-to-live (TTL) configuration.
type TimeToLiveInput struct {
	Enabled       bool   `json:"enabled,omitempty" jsonschema:""`
	AttributeName string `json:"attribute_name,omitempty" jsonschema:""`
}

func (s *TimeToLiveInput) validate() error {
	return nil
}

func (s *TimeToLiveInput) applyDefaults() {
}

func (s *TimeToLiveInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.AttributeName != "" {
		m["attribute_name"] = s.AttributeName
	}
	return m
}

// ParseAwsDynamodb validates and normalizes a AwsDynamodb cloud_object.
func ParseAwsDynamodb(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsDynamodb"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsDynamodbSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
