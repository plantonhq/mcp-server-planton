// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-fsx-lustre-file-system
type AwsFsxLustreFileSystemSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Deployment type controlling data durability and performance characteristics.
	//  ForceNew — cannot be changed after creation.
	//
	//  - "SCRATCH_1": temporary storage, no data replication. Lowest cost. Legacy.
	//  - "SCRATCH_2": temporary storage, no data replication. Higher burst throughput
	//    than SCRATCH_1...
	DeploymentType string `json:"deployment_type,omitempty" jsonschema:"Deployment type controlling data durability and performance characteristics. ForceNew — cannot be changed after creation. - 'SCRATCH_1': temporary storage; no data replication. Lowest cost. Legacy. ..."`
	// Storage capacity in GiB. Minimum 1200 GiB. Exact valid values depend on
	//  deployment type and storage type:
	//
	//  - SCRATCH_2 and PERSISTENT_2 (SSD): 1200, then increments of 2400.
	//  - PERSISTENT_1 (SSD): 1200, then increments of 2400.
	//  - PERSISTENT_1 (HDD): 6000, then increments of 6000.
	//  - SCRATCH_1: 12...
	StorageCapacityGib int32 `json:"storage_capacity_gib,omitempty" jsonschema:"Storage capacity in GiB. Minimum 1200 GiB. Exact valid values depend on deployment type and storage type: - SCRATCH_2 and PERSISTENT_2 (SSD): 1200; then increments of 2400. - PERSISTENT_1 (SSD): 1200;..."`
	// Storage media type. ForceNew — cannot be changed after creation.
	//
	//  - "SSD": solid-state drives. Sub-millisecond latency. Required for SCRATCH_2,
	//    PERSISTENT_2, and recommended for most workloads.
	//  - "HDD": hard disk drives. Lower cost, higher latency. Only available for
	//    PERSISTENT_1 deploymen...
	StorageType string `json:"storage_type,omitempty" jsonschema:"Storage media type. ForceNew — cannot be changed after creation. - 'SSD': solid-state drives. Sub-millisecond latency. Required for SCRATCH_2; PERSISTENT_2; and recommended for most workloads. - 'HD..."`
	// Throughput per unit of storage in MB/s/TiB. Required for PERSISTENT_1 and
	//  PERSISTENT_2 deployments. Invalid for SCRATCH types.
	//
	//  Valid values depend on deployment type and storage type:
	//  - PERSISTENT_1 + SSD: 50, 100, 200
	//  - PERSISTENT_1 + HDD: 12, 40
	//  - PERSISTENT_2 + SSD: 125, 250, 500, 1000
	PerUnitStorageThroughput int32 `json:"per_unit_storage_throughput,omitempty" jsonschema:"Throughput per unit of storage in MB/s/TiB. Required for PERSISTENT_1 and PERSISTENT_2 deployments. Invalid for SCRATCH types. Valid values depend on deployment type and storage type: - PERSISTENT_1 +..."`
	// Enable LZ4 data compression for all data on the file system. Reduces storage
	//  consumption and can improve throughput for compressible data. Can be changed
	//  after creation. Compression does not affect file system performance for
	//  Lustre operations.
	//
	//  Default: NONE
	DataCompressionType string `json:"data_compression_type,omitempty" jsonschema:"Enable LZ4 data compression for all data on the file system. Reduces storage consumption and can improve throughput for compressible data. Can be changed after creation. Compression does not affect fi..."`
	// Lustre file system type version. ForceNew — cannot be changed after creation.
	//  Format: "x.y" (e.g., "2.12", "2.15").
	//
	//  Leave empty to use the latest version supported by the deployment type.
	//  Explicitly set only if workload compatibility requires a specific version.
	FileSystemTypeVersion string `json:"file_system_type_version,omitempty" jsonschema:"Lustre file system type version. ForceNew — cannot be changed after creation. Format: 'x.y' (e.g.; '2.12'; '2.15'). Leave empty to use the latest version supported by the deployment type. Explicitly..."`
	// Subnet ID for the file system's network interface. Required. ForceNew.
	//
	//  Lustre file systems are single-AZ — exactly one subnet is supported. The
	//  file system's ENI is created in this subnet. All compute resources mounting
	//  this file system must have network connectivity to this subnet.
	SubnetId string `json:"subnet_id" jsonschema:"required,Subnet ID for the file system's network interface. Required. ForceNew. Lustre file systems are single-AZ — exactly one subnet is supported. The file system's ENI is created in this subnet. All compu..."`
	// Security groups for the file system's network interface. ForceNew.
	//
	//  Must allow Lustre traffic between the file system and its clients:
	//  - TCP port 988 (Lustre protocol)
	//  - TCP ports 1018-1023 (Lustre data channels)
	//
	//  Up to 50 security groups.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security groups for the file system's network interface. ForceNew. Must allow Lustre traffic between the file system and its clients: - TCP port 988 (Lustre protocol) - TCP ports 1018-1023 (Lustre dat..."`
	// Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key
	//  cannot be changed after creation. When omitted, the file system uses the
	//  AWS-managed FSx key. All Lustre file systems are encrypted at rest by default
	//  using AWS-managed keys; this field upgrades to a customer-managed ke...
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key cannot be changed after creation. When omitted; the file system uses the AWS-managed FSx key. All Lustre file systems are ..."`
	// S3 URI to import data from (e.g., "s3://my-bucket" or "s3://my-bucket/prefix").
	//  ForceNew. Only supported on SCRATCH_1 and SCRATCH_2 deployments.
	//
	//  When set, the file system automatically imports file metadata from S3. File
	//  data is lazy-loaded on first access. For more flexible S3 integration on
	//  P...
	ImportPath string `json:"import_path,omitempty" jsonschema:"S3 URI to import data from (e.g.; 's3://my-bucket' or 's3://my-bucket/prefix'). ForceNew. Only supported on SCRATCH_1 and SCRATCH_2 deployments. When set; the file system automatically imports file me..."`
	// S3 URI for exporting data back to S3 (e.g., "s3://my-bucket/output/").
	//  ForceNew. Requires `import_path` to be set.
	//
	//  When set, changes made on the file system are automatically exported to S3.
	ExportPath string `json:"export_path,omitempty" jsonschema:"S3 URI for exporting data back to S3 (e.g.; 's3://my-bucket/output/'). ForceNew. Requires 'import_path' to be set. When set; changes made on the file system are automatically exported to S3."`
	// CloudWatch logging configuration for Lustre audit events (file access,
	//  file creation, deletion). Useful for compliance and debugging.
	LogConfiguration *AwsFsxLustreFileSystemLogConfigurationInput `json:"log_configuration,omitempty" jsonschema:"CloudWatch logging configuration for Lustre audit events (file access; file creation; deletion). Useful for compliance and debugging."`
	// Number of days to retain automatic backups. Range: 0-90. Set to 0 to disable
	//  automatic backups.
	//
	//  Default: 0 (no automatic backups)
	AutomaticBackupRetentionDays int32 `json:"automatic_backup_retention_days,omitempty" jsonschema:"Number of days to retain automatic backups. Range: 0-90. Set to 0 to disable automatic backups. Default: 0 (no automatic backups)"`
	// Daily UTC time to start automatic backups, in HH:MM format (e.g., "05:00").
	//  If not specified and backups are enabled, AWS chooses a default window.
	DailyAutomaticBackupStartTime string `json:"daily_automatic_backup_start_time,omitempty" jsonschema:"Daily UTC time to start automatic backups; in HH:MM format (e.g.; '05:00'). If not specified and backups are enabled; AWS chooses a default window."`
	// Copy tags from the file system to backups. ForceNew.
	CopyTagsToBackups bool `json:"copy_tags_to_backups,omitempty" jsonschema:"Copy tags from the file system to backups. ForceNew."`
	// Skip creating a final backup when the file system is deleted. Applies only to
	//  PERSISTENT deployments with backup support.
	//
	//  Default: true
	SkipFinalBackup bool `json:"skip_final_backup,omitempty" jsonschema:"Skip creating a final backup when the file system is deleted. Applies only to PERSISTENT deployments with backup support. Default: true"`
	// Weekly UTC maintenance window in the format "d:HH:MM" where d is the day of
	//  the week (1=Monday, 7=Sunday). Example: "1:05:00" for Monday at 05:00 UTC.
	WeeklyMaintenanceStartTime string `json:"weekly_maintenance_start_time,omitempty" jsonschema:"Weekly UTC maintenance window in the format 'd:HH:MM' where d is the day of the week (1=Monday; 7=Sunday). Example: '1:05:00' for Monday at 05:00 UTC."`
	// Metadata performance configuration. Only supported on PERSISTENT_2 deployments.
	//  Controls the metadata IOPS available for file creation, listing, and similar
	//  operations. Most workloads perform well with AUTOMATIC mode.
	MetadataConfiguration *AwsFsxLustreFileSystemMetadataConfigurationInput `json:"metadata_configuration,omitempty" jsonschema:"Metadata performance configuration. Only supported on PERSISTENT_2 deployments. Controls the metadata IOPS available for file creation; listing; and similar operations. Most workloads perform well wit..."`
}

func (s *AwsFsxLustreFileSystemSpecInput) validate() error {
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if s.LogConfiguration != nil {
		if err := s.LogConfiguration.validate(); err != nil {
			return fmt.Errorf("log_configuration: %w", err)
		}
	}
	if s.MetadataConfiguration != nil {
		if err := s.MetadataConfiguration.validate(); err != nil {
			return fmt.Errorf("metadata_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxLustreFileSystemSpecInput) applyDefaults() {
	if s.DeploymentType == "" {
		s.DeploymentType = "SCRATCH_2"
	}
	if s.StorageType == "" {
		s.StorageType = "SSD"
	}
	if s.DataCompressionType == "" {
		s.DataCompressionType = "NONE"
	}
	if s.LogConfiguration != nil {
		s.LogConfiguration.applyDefaults()
	}
	if s.AutomaticBackupRetentionDays == 0 {
		s.AutomaticBackupRetentionDays = 0
	}
	// default: SkipFinalBackup = true (applied at zero-value)
	if s.MetadataConfiguration != nil {
		s.MetadataConfiguration.applyDefaults()
	}
}

func (s *AwsFsxLustreFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.DeploymentType != "" {
		m["deployment_type"] = s.DeploymentType
	}
	if s.StorageCapacityGib != 0 {
		m["storage_capacity_gib"] = s.StorageCapacityGib
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.PerUnitStorageThroughput != 0 {
		m["per_unit_storage_throughput"] = s.PerUnitStorageThroughput
	}
	if s.DataCompressionType != "" {
		m["data_compression_type"] = s.DataCompressionType
	}
	if s.FileSystemTypeVersion != "" {
		m["file_system_type_version"] = s.FileSystemTypeVersion
	}
	m["subnet_id"] = s.SubnetId
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.ImportPath != "" {
		m["import_path"] = s.ImportPath
	}
	if s.ExportPath != "" {
		m["export_path"] = s.ExportPath
	}
	if s.LogConfiguration != nil {
		m["log_configuration"] = s.LogConfiguration.toMap()
	}
	if s.AutomaticBackupRetentionDays != 0 {
		m["automatic_backup_retention_days"] = s.AutomaticBackupRetentionDays
	}
	if s.DailyAutomaticBackupStartTime != "" {
		m["daily_automatic_backup_start_time"] = s.DailyAutomaticBackupStartTime
	}
	if s.CopyTagsToBackups {
		m["copy_tags_to_backups"] = s.CopyTagsToBackups
	}
	if s.SkipFinalBackup {
		m["skip_final_backup"] = s.SkipFinalBackup
	}
	if s.WeeklyMaintenanceStartTime != "" {
		m["weekly_maintenance_start_time"] = s.WeeklyMaintenanceStartTime
	}
	if s.MetadataConfiguration != nil {
		m["metadata_configuration"] = s.MetadataConfiguration.toMap()
	}
	return m
}

// AwsFsxLustreFileSystemLogConfiguration configures CloudWatch logging for Lustre
//
//	file system audit events. Events include file access, creation, deletion, and
//	permission changes.
type AwsFsxLustreFileSystemLogConfigurationInput struct {
	// CloudWatch Logs log group ARN to receive audit events. The log group must
	//  exist and have a resource policy allowing FSx to write to it. If not set,
	//  logging is disabled regardless of the level setting.
	Destination string `json:"destination,omitempty" jsonschema:"CloudWatch Logs log group ARN to receive audit events. The log group must exist and have a resource policy allowing FSx to write to it. If not set; logging is disabled regardless of the level setting."`
	// Audit log level controlling which events are logged.
	//
	//  - "DISABLED": no logging (default when log_configuration is omitted).
	//  - "WARN_ONLY": log warning-level events only.
	//  - "ERROR_ONLY": log error-level events only.
	//  - "WARN_ERROR": log both warning and error events.
	//
	//  Default: WARN_ERROR
	Level string `json:"level,omitempty" jsonschema:"Audit log level controlling which events are logged. - 'DISABLED': no logging (default when log_configuration is omitted). - 'WARN_ONLY': log warning-level events only. - 'ERROR_ONLY': log error-level..."`
}

func (s *AwsFsxLustreFileSystemLogConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxLustreFileSystemLogConfigurationInput) applyDefaults() {
	if s.Level == "" {
		s.Level = "WARN_ERROR"
	}
}

func (s *AwsFsxLustreFileSystemLogConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Destination != "" {
		m["destination"] = s.Destination
	}
	if s.Level != "" {
		m["level"] = s.Level
	}
	return m
}

// AwsFsxLustreFileSystemMetadataConfiguration controls the metadata performance
//
//	of PERSISTENT_2 Lustre file systems. Metadata operations include file creation,
//	listing, stat, rename, and deletion.
type AwsFsxLustreFileSystemMetadataConfigurationInput struct {
	// Metadata IOPS mode.
	//
	//  - "AUTOMATIC": FSx scales metadata IOPS based on file system storage capacity.
	//    Provides 1500-192000 IOPS depending on provisioned storage.
	//  - "USER_PROVISIONED": you specify the exact metadata IOPS. Allows higher
	//    performance independent of storage size but at additional c...
	Mode string `json:"mode,omitempty" jsonschema:"Metadata IOPS mode. - 'AUTOMATIC': FSx scales metadata IOPS based on file system storage capacity. Provides 1500-192000 IOPS depending on provisioned storage. - 'USER_PROVISIONED': you specify the exa..."`
	// Metadata IOPS when mode is "USER_PROVISIONED". Ignored in AUTOMATIC mode.
	//
	//  Valid values: 1500, 3000, 6000, 12000, 24000, 36000, 48000, 60000, 72000,
	//  84000, 96000, 108000, 120000, 132000, 144000, 156000, 168000, 180000, 192000.
	Iops int32 `json:"iops,omitempty" jsonschema:"Metadata IOPS when mode is 'USER_PROVISIONED'. Ignored in AUTOMATIC mode. Valid values: 1500; 3000; 6000; 12000; 24000; 36000; 48000; 60000; 72000; 84000; 96000; 108000; 120000; 132000; 144000; 156000..."`
}

func (s *AwsFsxLustreFileSystemMetadataConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxLustreFileSystemMetadataConfigurationInput) applyDefaults() {
	if s.Mode == "" {
		s.Mode = "AUTOMATIC"
	}
}

func (s *AwsFsxLustreFileSystemMetadataConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Mode != "" {
		m["mode"] = s.Mode
	}
	if s.Iops != 0 {
		m["iops"] = s.Iops
	}
	return m
}

// ParseAwsFsxLustreFileSystem validates and normalizes a AwsFsxLustreFileSystem cloud_object.
func ParseAwsFsxLustreFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsFsxLustreFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsFsxLustreFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
