// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsSqsQueue is the Kubernetes-style resource envelope for an AWS SQS queue.
type AwsSqsQueueSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Whether to create a FIFO queue. Standard queues are created when false.
	//  FIFO queues guarantee exactly-once processing and strict ordering within
	//  each message group. This setting cannot be changed after queue creation.
	FifoQueue bool `json:"fifo_queue,omitempty" jsonschema:"Whether to create a FIFO queue. Standard queues are created when false. FIFO queues guarantee exactly-once processing and strict ordering within each message group. This setting cannot be changed afte..."`
	// Time in seconds that a received message is hidden from subsequent receive
	//  requests. After the timeout expires the message becomes visible again unless
	//  it was deleted. Range: 0–43200 (0s to 12h). AWS default: 30.
	VisibilityTimeoutSeconds int32 `json:"visibility_timeout_seconds,omitempty" jsonschema:"Time in seconds that a received message is hidden from subsequent receive requests. After the timeout expires the message becomes visible again unless it was deleted. Range: 0–43200 (0s to 12h). AWS..."`
	// Duration in seconds that SQS retains a message. After the retention period
	//  expires SQS deletes the message regardless of whether it was consumed.
	//  Range: 60–1209600 (1 min to 14 days). AWS default: 345600 (4 days).
	//  Leave at 0 to use the AWS default.
	MessageRetentionSeconds int32 `json:"message_retention_seconds,omitempty" jsonschema:"Duration in seconds that SQS retains a message. After the retention period expires SQS deletes the message regardless of whether it was consumed. Range: 60–1209600 (1 min to 14 days). AWS default: 3..."`
	// Maximum size of a message body in bytes. Messages exceeding this limit are
	//  rejected by SQS. Range: 1024–1048576 (1 KB to 1 MB). AWS default: 262144 (256 KB).
	//  Leave at 0 to use the AWS default.
	MaxMessageSizeBytes int32 `json:"max_message_size_bytes,omitempty" jsonschema:"Maximum size of a message body in bytes. Messages exceeding this limit are rejected by SQS. Range: 1024–1048576 (1 KB to 1 MB). AWS default: 262144 (256 KB). Leave at 0 to use the AWS default."`
	// Delay in seconds before a newly sent message becomes visible in the queue.
	//  Useful for implementing delayed processing patterns.
	//  Range: 0–900 (0s to 15 min). AWS default: 0.
	DelaySeconds int32 `json:"delay_seconds,omitempty" jsonschema:"Delay in seconds before a newly sent message becomes visible in the queue. Useful for implementing delayed processing patterns. Range: 0–900 (0s to 15 min). AWS default: 0."`
	// Wait time in seconds for the ReceiveMessage API call. A value greater than
	//  0 enables long polling, which reduces the number of empty responses and
	//  lowers cost. Range: 0–20. AWS default: 0 (short polling).
	ReceiveWaitTimeSeconds int32 `json:"receive_wait_time_seconds,omitempty" jsonschema:"Wait time in seconds for the ReceiveMessage API call. A value greater than 0 enables long polling; which reduces the number of empty responses and lowers cost. Range: 0–20. AWS default: 0 (short pol..."`
	// Enable content-based deduplication for FIFO queues. When enabled SQS uses
	//  a SHA-256 hash of the message body as the deduplication ID, removing the
	//  need for the producer to supply an explicit deduplication ID.
	//  Only valid when `fifo_queue` is true.
	ContentBasedDeduplication bool `json:"content_based_deduplication,omitempty" jsonschema:"Enable content-based deduplication for FIFO queues. When enabled SQS uses a SHA-256 hash of the message body as the deduplication ID; removing the need for the producer to supply an explicit deduplica..."`
	// Deduplication scope for FIFO queues. Controls whether deduplication is
	//  applied per message group or across the entire queue.
	//  Valid values: "messageGroup", "queue". Only valid when `fifo_queue` is true.
	DeduplicationScope string `json:"deduplication_scope,omitempty" jsonschema:"Deduplication scope for FIFO queues. Controls whether deduplication is applied per message group or across the entire queue. Valid values: 'messageGroup'; 'queue'. Only valid when 'fifo_queue' is true..."`
	// Throughput limit for FIFO queues. Controls whether throughput quota applies
	//  per message group ID or per queue. Set to "perMessageGroupId" to enable
	//  high throughput mode for FIFO queues.
	//  Valid values: "perMessageGroupId", "perQueue". Only valid when `fifo_queue` is true.
	FifoThroughputLimit string `json:"fifo_throughput_limit,omitempty" jsonschema:"Throughput limit for FIFO queues. Controls whether throughput quota applies per message group ID or per queue. Set to 'perMessageGroupId' to enable high throughput mode for FIFO queues. Valid values: ..."`
	// Dead letter queue configuration. When a message is received more than
	//  `max_receive_count` times without being deleted, SQS moves it to the
	//  specified target queue for investigation and reprocessing.
	DeadLetterConfig *AwsSqsQueueDeadLetterConfigInput `json:"dead_letter_config,omitempty" jsonschema:"Dead letter queue configuration. When a message is received more than 'max_receive_count' times without being deleted; SQS moves it to the specified target queue for investigation and reprocessing."`
	// Customer-managed KMS key for server-side encryption. When set SQS encrypts
	//  message bodies using this key. Accepts a direct KMS key ID/ARN or a
	//  reference to an AwsKmsKey resource. Mutually exclusive with
	//  `sqs_managed_sse_enabled`.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key for server-side encryption. When set SQS encrypts message bodies using this key. Accepts a direct KMS key ID/ARN or a reference to an AwsKmsKey resource. Mutually exclusive wi..."`
	// Duration in seconds that SQS reuses a data encryption key before calling
	//  KMS again. Higher values reduce KMS costs but increase the window for key
	//  reuse. Range: 60–86400 (1 min to 24h). AWS default: 300 (5 min).
	//  Only relevant when `kms_key_id` is set.
	KmsDataKeyReusePeriodSeconds int32 `json:"kms_data_key_reuse_period_seconds,omitempty" jsonschema:"Duration in seconds that SQS reuses a data encryption key before calling KMS again. Higher values reduce KMS costs but increase the window for key reuse. Range: 60–86400 (1 min to 24h). AWS default:..."`
	// Enable SQS-managed server-side encryption (SSE-SQS). SQS manages the
	//  encryption key automatically with no additional cost. Mutually exclusive
	//  with `kms_key_id`.
	SqsManagedSseEnabled bool `json:"sqs_managed_sse_enabled,omitempty" jsonschema:"Enable SQS-managed server-side encryption (SSE-SQS). SQS manages the encryption key automatically with no additional cost. Mutually exclusive with 'kms_key_id'."`
	// IAM access policy for the queue. Controls which AWS principals can perform
	//  actions on this queue (e.g., SendMessage, ReceiveMessage). Expressed as a
	//  standard IAM policy document structure. Common use cases include granting
	//  SNS topics permission to publish to this queue or allowing cross-account
	//  ...
	Policy any `json:"policy,omitempty" jsonschema:"IAM access policy for the queue. Controls which AWS principals can perform actions on this queue (e.g.; SendMessage; ReceiveMessage). Expressed as a standard IAM policy document structure. Common use ..."`
}

func (s *AwsSqsQueueSpecInput) validate() error {
	if s.DeadLetterConfig != nil {
		if err := s.DeadLetterConfig.validate(); err != nil {
			return fmt.Errorf("dead_letter_config: %w", err)
		}
	}
	return nil
}

func (s *AwsSqsQueueSpecInput) applyDefaults() {
	if s.DeadLetterConfig != nil {
		s.DeadLetterConfig.applyDefaults()
	}
}

func (s *AwsSqsQueueSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.FifoQueue {
		m["fifo_queue"] = s.FifoQueue
	}
	if s.VisibilityTimeoutSeconds != 0 {
		m["visibility_timeout_seconds"] = s.VisibilityTimeoutSeconds
	}
	if s.MessageRetentionSeconds != 0 {
		m["message_retention_seconds"] = s.MessageRetentionSeconds
	}
	if s.MaxMessageSizeBytes != 0 {
		m["max_message_size_bytes"] = s.MaxMessageSizeBytes
	}
	if s.DelaySeconds != 0 {
		m["delay_seconds"] = s.DelaySeconds
	}
	if s.ReceiveWaitTimeSeconds != 0 {
		m["receive_wait_time_seconds"] = s.ReceiveWaitTimeSeconds
	}
	if s.ContentBasedDeduplication {
		m["content_based_deduplication"] = s.ContentBasedDeduplication
	}
	if s.DeduplicationScope != "" {
		m["deduplication_scope"] = s.DeduplicationScope
	}
	if s.FifoThroughputLimit != "" {
		m["fifo_throughput_limit"] = s.FifoThroughputLimit
	}
	if s.DeadLetterConfig != nil {
		m["dead_letter_config"] = s.DeadLetterConfig.toMap()
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.KmsDataKeyReusePeriodSeconds != 0 {
		m["kms_data_key_reuse_period_seconds"] = s.KmsDataKeyReusePeriodSeconds
	}
	if s.SqsManagedSseEnabled {
		m["sqs_managed_sse_enabled"] = s.SqsManagedSseEnabled
	}
	// unsupported type "object" for field Policy
	return m
}

// AwsSqsQueueDeadLetterConfig configures the dead letter queue for failed message routing.
//
//	When a consumer receives a message more than `max_receive_count` times without
//	deleting it, SQS automatically moves the message to the specified target queue.
type AwsSqsQueueDeadLetterConfigInput struct {
	// ARN of the target dead letter queue. Accepts a direct ARN or a reference
	//  to another AwsSqsQueue resource. Both queues must be the same type
	//  (both Standard or both FIFO) and reside in the same AWS account and region.
	TargetArn string `json:"target_arn" jsonschema:"required,ARN of the target dead letter queue. Accepts a direct ARN or a reference to another AwsSqsQueue resource. Both queues must be the same type (both Standard or both FIFO) and reside in the same AWS acco..."`
	// Number of times a message can be received before being moved to the dead
	//  letter queue. Must be at least 1. Common values: 3–5 for transient errors,
	//  1 for poison pill detection. Range: 1–1000.
	MaxReceiveCount int32 `json:"max_receive_count,omitempty" jsonschema:"Number of times a message can be received before being moved to the dead letter queue. Must be at least 1. Common values: 3–5 for transient errors; 1 for poison pill detection. Range: 1–1000."`
}

func (s *AwsSqsQueueDeadLetterConfigInput) validate() error {
	if s.TargetArn == "" {
		return fmt.Errorf("target_arn is required")
	}
	return nil
}

func (s *AwsSqsQueueDeadLetterConfigInput) applyDefaults() {
}

func (s *AwsSqsQueueDeadLetterConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["target_arn"] = s.TargetArn
	if s.MaxReceiveCount != 0 {
		m["max_receive_count"] = s.MaxReceiveCount
	}
	return m
}

// ParseAwsSqsQueue validates and normalizes a AwsSqsQueue cloud_object.
func ParseAwsSqsQueue(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsSqsQueue"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsSqsQueueSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
