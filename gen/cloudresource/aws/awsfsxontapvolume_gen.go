// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-fsx-ontap-volume
type AwsFsxOntapVolumeSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// The ID of the Storage Virtual Machine that this volume belongs to. Required.
	//  ForceNew — the volume cannot be moved to a different SVM after creation.
	//
	//  The SVM provides the network endpoints, protocol configuration, and Active
	//  Directory integration. All volumes within an SVM share its protocol s...
	StorageVirtualMachineId string `json:"storage_virtual_machine_id" jsonschema:"required,The ID of the Storage Virtual Machine that this volume belongs to. Required. ForceNew — the volume cannot be moved to a different SVM after creation. The SVM provides the network endpoints; protocol..."`
	// The name of the volume within the ONTAP file system. Required. ForceNew.
	//
	//  This is the ONTAP volume name (not the OpenMCF metadata name). ONTAP volume
	//  names must be alphanumeric plus underscores — hyphens are not allowed. This
	//  name appears in junction paths, SnapMirror relationships, and ONTAP C...
	Name string `json:"name,omitempty" jsonschema:"The name of the volume within the ONTAP file system. Required. ForceNew. This is the ONTAP volume name (not the OpenMCF metadata name). ONTAP volume names must be alphanumeric plus underscores — hyp..."`
	// The size of the volume in megabytes. Required.
	//
	//  Minimum 20 MB. Maximum is constrained by the file system's total storage
	//  capacity. ONTAP volumes support thin provisioning, so the logical size can
	//  exceed the physical capacity available — ONTAP handles overcommit at the
	//  aggregate level.
	//
	//  Covers...
	SizeInMegabytes int32 `json:"size_in_megabytes,omitempty" jsonschema:"The size of the volume in megabytes. Required. Minimum 20 MB. Maximum is constrained by the file system's total storage capacity. ONTAP volumes support thin provisioning; so the logical size can excee..."`
	// The location in the SVM namespace where this volume is mounted. Clients
	//  access the volume at this path (e.g., mount nfs.svm.example.com:/vol1).
	//
	//  If omitted, the volume is created but not mounted — it exists in ONTAP
	//  but is not accessible via NFS/SMB until a junction path is set.
	//
	//  Must start wi...
	JunctionPath string `json:"junction_path,omitempty" jsonschema:"The location in the SVM namespace where this volume is mounted. Clients access the volume at this path (e.g.; mount nfs.svm.example.com:/vol1). If omitted; the volume is created but not mounted — it..."`
	// The ONTAP volume type. ForceNew.
	//
	//  - "RW": Read-write volume. The standard type for serving data to clients.
	//  - "DP": Data protection volume. A read-only destination for SnapMirror
	//    replication. DP volumes cannot be mounted until the SnapMirror
	//    relationship is broken or the volume is converted....
	OntapVolumeType string `json:"ontap_volume_type,omitempty" jsonschema:"The ONTAP volume type. ForceNew. - 'RW': Read-write volume. The standard type for serving data to clients. - 'DP': Data protection volume. A read-only destination for SnapMirror replication. DP volume..."`
	// The volume style. ForceNew.
	//
	//  - "FLEXVOL": Traditional ONTAP volume on a single aggregate. Suitable for
	//    most workloads. Simpler operations and faster metadata performance.
	//  - "FLEXGROUP": A volume distributed across multiple aggregates for high
	//    throughput and large-scale workloads (hundreds of...
	VolumeStyle string `json:"volume_style,omitempty" jsonschema:"The volume style. ForceNew. - 'FLEXVOL': Traditional ONTAP volume on a single aggregate. Suitable for most workloads. Simpler operations and faster metadata performance. - 'FLEXGROUP': A volume distri..."`
	// The security style for this volume's root directory. Controls how file
	//  permissions are evaluated.
	//
	//  - "UNIX": UNIX permissions (mode bits, uid/gid). Best for Linux/NFS.
	//  - "NTFS": Windows ACLs. Best for Windows/SMB with Active Directory.
	//  - "MIXED": Both permission systems coexist. The effective se...
	SecurityStyle string `json:"security_style,omitempty" jsonschema:"The security style for this volume's root directory. Controls how file permissions are evaluated. - 'UNIX': UNIX permissions (mode bits; uid/gid). Best for Linux/NFS. - 'NTFS': Windows ACLs. Best for ..."`
	// The name of the ONTAP snapshot policy to apply to this volume. Snapshot
	//  policies control automatic snapshot creation and retention.
	//
	//  Common policies: "default" (6 hourly + 2 daily + 2 weekly), "none"
	//  (no automatic snapshots). Custom policies can be created via the ONTAP CLI.
	//
	//  Constraints: 1-255 ...
	SnapshotPolicy string `json:"snapshot_policy,omitempty" jsonschema:"The name of the ONTAP snapshot policy to apply to this volume. Snapshot policies control automatic snapshot creation and retention. Common policies: 'default' (6 hourly + 2 daily + 2 weekly); 'none' (..."`
	// Enable ONTAP storage efficiency features: deduplication, compression, and
	//  compaction. These features reduce physical storage consumption by
	//  identifying and eliminating redundant data blocks.
	//
	//  Recommended for most workloads. Disable only for workloads that are
	//  already compressed or deduplicated (...
	StorageEfficiencyEnabled bool `json:"storage_efficiency_enabled,omitempty" jsonschema:"Enable ONTAP storage efficiency features: deduplication; compression; and compaction. These features reduce physical storage consumption by identifying and eliminating redundant data blocks. Recommend..."`
	// Whether to copy resource tags to automatic volume backups.
	//
	//  Default: false
	CopyTagsToBackups bool `json:"copy_tags_to_backups,omitempty" jsonschema:"Whether to copy resource tags to automatic volume backups. Default: false"`
	// Whether to skip the automatic backup that AWS takes when the volume is
	//  deleted. Set to true for development/test volumes where the backup is
	//  unnecessary.
	//
	//  Default: false (a final backup is taken)
	SkipFinalBackup bool `json:"skip_final_backup,omitempty" jsonschema:"Whether to skip the automatic backup that AWS takes when the volume is deleted. Set to true for development/test volumes where the backup is unnecessary. Default: false (a final backup is taken)"`
	// Whether to allow deletion of a SnapLock Enterprise volume that contains
	//  WORM files with unexpired retention periods. Only relevant for SnapLock
	//  Enterprise volumes — Compliance volumes can never bypass retention.
	//
	//  Default: false
	BypassSnaplockEnterpriseRetention bool `json:"bypass_snaplock_enterprise_retention,omitempty" jsonschema:"Whether to allow deletion of a SnapLock Enterprise volume that contains WORM files with unexpired retention periods. Only relevant for SnapLock Enterprise volumes — Compliance volumes can never bypa..."`
	// Data tiering policy that controls when and how data moves from primary
	//  SSD storage to lower-cost capacity pool storage. If omitted, the volume
	//  uses the default tiering policy (SNAPSHOT_ONLY).
	TieringPolicy *AwsFsxOntapVolumeTieringPolicyInput `json:"tiering_policy,omitempty" jsonschema:"Data tiering policy that controls when and how data moves from primary SSD storage to lower-cost capacity pool storage. If omitted; the volume uses the default tiering policy (SNAPSHOT_ONLY)."`
	// SnapLock configuration for WORM (Write Once Read Many) compliance storage.
	//  When configured, files committed to this volume become immutable for their
	//  retention period. ForceNew for snaplock_type.
	//
	//  SnapLock has two modes:
	//  - ENTERPRISE: Admins can delete WORM files before retention expiry (if
	//    p...
	SnaplockConfiguration *AwsFsxOntapVolumeSnaplockConfigurationInput `json:"snaplock_configuration,omitempty" jsonschema:"SnapLock configuration for WORM (Write Once Read Many) compliance storage. When configured; files committed to this volume become immutable for their retention period. ForceNew for snaplock_type. Snap..."`
	// Aggregate configuration for FLEXGROUP volumes. Controls how the volume is
	//  distributed across the file system's aggregates. Ignored for FLEXVOL
	//  volumes.
	//
	//  All fields in this block are ForceNew — changing the aggregate layout
	//  requires recreating the volume.
	AggregateConfiguration *AwsFsxOntapVolumeAggregateConfigurationInput `json:"aggregate_configuration,omitempty" jsonschema:"Aggregate configuration for FLEXGROUP volumes. Controls how the volume is distributed across the file system's aggregates. Ignored for FLEXVOL volumes. All fields in this block are ForceNew — changi..."`
}

func (s *AwsFsxOntapVolumeSpecInput) validate() error {
	if s.StorageVirtualMachineId == "" {
		return fmt.Errorf("storage_virtual_machine_id is required")
	}
	if s.TieringPolicy != nil {
		if err := s.TieringPolicy.validate(); err != nil {
			return fmt.Errorf("tiering_policy: %w", err)
		}
	}
	if s.SnaplockConfiguration != nil {
		if err := s.SnaplockConfiguration.validate(); err != nil {
			return fmt.Errorf("snaplock_configuration: %w", err)
		}
	}
	if s.AggregateConfiguration != nil {
		if err := s.AggregateConfiguration.validate(); err != nil {
			return fmt.Errorf("aggregate_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxOntapVolumeSpecInput) applyDefaults() {
	if s.OntapVolumeType == "" {
		s.OntapVolumeType = "RW"
	}
	if s.VolumeStyle == "" {
		s.VolumeStyle = "FLEXVOL"
	}
	if s.TieringPolicy != nil {
		s.TieringPolicy.applyDefaults()
	}
	if s.SnaplockConfiguration != nil {
		s.SnaplockConfiguration.applyDefaults()
	}
	if s.AggregateConfiguration != nil {
		s.AggregateConfiguration.applyDefaults()
	}
}

func (s *AwsFsxOntapVolumeSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["storage_virtual_machine_id"] = s.StorageVirtualMachineId
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.SizeInMegabytes != 0 {
		m["size_in_megabytes"] = s.SizeInMegabytes
	}
	if s.JunctionPath != "" {
		m["junction_path"] = s.JunctionPath
	}
	if s.OntapVolumeType != "" {
		m["ontap_volume_type"] = s.OntapVolumeType
	}
	if s.VolumeStyle != "" {
		m["volume_style"] = s.VolumeStyle
	}
	if s.SecurityStyle != "" {
		m["security_style"] = s.SecurityStyle
	}
	if s.SnapshotPolicy != "" {
		m["snapshot_policy"] = s.SnapshotPolicy
	}
	if s.StorageEfficiencyEnabled {
		m["storage_efficiency_enabled"] = s.StorageEfficiencyEnabled
	}
	if s.CopyTagsToBackups {
		m["copy_tags_to_backups"] = s.CopyTagsToBackups
	}
	if s.SkipFinalBackup {
		m["skip_final_backup"] = s.SkipFinalBackup
	}
	if s.BypassSnaplockEnterpriseRetention {
		m["bypass_snaplock_enterprise_retention"] = s.BypassSnaplockEnterpriseRetention
	}
	if s.TieringPolicy != nil {
		m["tiering_policy"] = s.TieringPolicy.toMap()
	}
	if s.SnaplockConfiguration != nil {
		m["snaplock_configuration"] = s.SnaplockConfiguration.toMap()
	}
	if s.AggregateConfiguration != nil {
		m["aggregate_configuration"] = s.AggregateConfiguration.toMap()
	}
	return m
}

// AwsFsxOntapVolumeAggregateConfiguration controls how a FLEXGROUP volume is
//
//	distributed across the file system's aggregates. All fields are ForceNew —
//	changing the aggregate layout requires recreating the volume.
//
//	Aggregates are the physical storage pools within an ONTAP file system. Each
//	HA pair has its own set of aggregates (named aggr1, aggr2, etc.). FlexGroup
//	volumes spread data across aggregates for parallel throughput.
type AwsFsxOntapVolumeAggregateConfigurationInput struct {
	// The list of aggregate names to use for the FlexGroup volume. Each name
	//  must match the pattern "aggr" followed by 1-2 digits (e.g., "aggr1",
	//  "aggr2"). Maximum 12 aggregates.
	//
	//  ForceNew — changing this requires volume recreation.
	Aggregates []string `json:"aggregates,omitempty" jsonschema:"The list of aggregate names to use for the FlexGroup volume. Each name must match the pattern 'aggr' followed by 1-2 digits (e.g.; 'aggr1'; 'aggr2'). Maximum 12 aggregates. ForceNew — changing this ..."`
	// The number of FlexGroup constituents (member volumes) to create per
	//  aggregate. The total number of constituents equals
	//  constituents_per_aggregate * len(aggregates).
	//
	//  Higher values increase parallelism but also metadata overhead. Default
	//  in AWS is typically 8.
	//
	//  Range: 1-200. ForceNew.
	ConstituentsPerAggregate int32 `json:"constituents_per_aggregate,omitempty" jsonschema:"The number of FlexGroup constituents (member volumes) to create per aggregate. The total number of constituents equals constituents_per_aggregate * len(aggregates). Higher values increase parallelism ..."`
}

func (s *AwsFsxOntapVolumeAggregateConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxOntapVolumeAggregateConfigurationInput) applyDefaults() {
}

func (s *AwsFsxOntapVolumeAggregateConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Aggregates) > 0 {
		m["aggregates"] = s.Aggregates
	}
	if s.ConstituentsPerAggregate != 0 {
		m["constituents_per_aggregate"] = s.ConstituentsPerAggregate
	}
	return m
}

// AwsFsxOntapVolumeAutocommitPeriod configures automatic transition of files to
//
//	WORM state after a period of inactivity.
type AwsFsxOntapVolumeAutocommitPeriodInput struct {
	// The unit of time for the autocommit period.
	//
	//  - "NONE": Autocommit is disabled.
	//  - "MINUTES", "HOURS", "DAYS", "MONTHS", "YEARS": The time unit for the
	//    value field.
	Type string `json:"type,omitempty" jsonschema:"The unit of time for the autocommit period. - 'NONE': Autocommit is disabled. - 'MINUTES'; 'HOURS'; 'DAYS'; 'MONTHS'; 'YEARS': The time unit for the value field."`
	// The number of time units before an unmodified file is auto-committed to
	//  WORM state. Required when type is not "NONE".
	//
	//  Range: 1-65535.
	Value int32 `json:"value,omitempty" jsonschema:"The number of time units before an unmodified file is auto-committed to WORM state. Required when type is not 'NONE'. Range: 1-65535."`
}

func (s *AwsFsxOntapVolumeAutocommitPeriodInput) validate() error {
	return nil
}

func (s *AwsFsxOntapVolumeAutocommitPeriodInput) applyDefaults() {
}

func (s *AwsFsxOntapVolumeAutocommitPeriodInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Value != 0 {
		m["value"] = s.Value
	}
	return m
}

// AwsFsxOntapVolumeRetentionDuration specifies a time duration for SnapLock
//
//	retention periods. Used for default, minimum, and maximum retention.
type AwsFsxOntapVolumeRetentionDurationInput struct {
	// The unit of time for the retention duration.
	//
	//  - "SECONDS", "MINUTES", "HOURS", "DAYS", "MONTHS", "YEARS": Standard
	//    time units. The value field specifies the count.
	//  - "INFINITE": Files are retained forever. The value field is ignored.
	//  - "UNSPECIFIED": No retention period is set. The value field...
	Type string `json:"type,omitempty" jsonschema:"The unit of time for the retention duration. - 'SECONDS'; 'MINUTES'; 'HOURS'; 'DAYS'; 'MONTHS'; 'YEARS': Standard time units. The value field specifies the count. - 'INFINITE': Files are retained fore..."`
	// The number of time units for the retention duration. Ignored when type is
	//  "INFINITE" or "UNSPECIFIED".
	//
	//  Range: 0-65535.
	Value int32 `json:"value,omitempty" jsonschema:"The number of time units for the retention duration. Ignored when type is 'INFINITE' or 'UNSPECIFIED'. Range: 0-65535."`
}

func (s *AwsFsxOntapVolumeRetentionDurationInput) validate() error {
	return nil
}

func (s *AwsFsxOntapVolumeRetentionDurationInput) applyDefaults() {
}

func (s *AwsFsxOntapVolumeRetentionDurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Value != 0 {
		m["value"] = s.Value
	}
	return m
}

// AwsFsxOntapVolumeRetentionPeriod defines the default, minimum, and maximum
//
//	retention bounds for WORM files on a SnapLock volume.
//
//	- default_retention: Applied to files committed without an explicit retention
//	  period.
//	- minimum_retention: The shortest retention any file can have. Prevents
//	  accidental setting of too-short retention.
//	- maximum_retention: The longest retention any file can have. Prevents
//	  accidental setting of very long retention that would lock data indefinitely.
type AwsFsxOntapVolumeRetentionPeriodInput struct {
	// The default retention period applied to files committed to WORM state
	//  without an explicit retention period.
	DefaultRetention *AwsFsxOntapVolumeRetentionDurationInput `json:"default_retention,omitempty" jsonschema:"The default retention period applied to files committed to WORM state without an explicit retention period."`
	// The minimum retention period. Files cannot have retention periods shorter
	//  than this value.
	MinimumRetention *AwsFsxOntapVolumeRetentionDurationInput `json:"minimum_retention,omitempty" jsonschema:"The minimum retention period. Files cannot have retention periods shorter than this value."`
	// The maximum retention period. Files cannot have retention periods longer
	//  than this value.
	MaximumRetention *AwsFsxOntapVolumeRetentionDurationInput `json:"maximum_retention,omitempty" jsonschema:"The maximum retention period. Files cannot have retention periods longer than this value."`
}

func (s *AwsFsxOntapVolumeRetentionPeriodInput) validate() error {
	if s.DefaultRetention != nil {
		if err := s.DefaultRetention.validate(); err != nil {
			return fmt.Errorf("default_retention: %w", err)
		}
	}
	if s.MinimumRetention != nil {
		if err := s.MinimumRetention.validate(); err != nil {
			return fmt.Errorf("minimum_retention: %w", err)
		}
	}
	if s.MaximumRetention != nil {
		if err := s.MaximumRetention.validate(); err != nil {
			return fmt.Errorf("maximum_retention: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxOntapVolumeRetentionPeriodInput) applyDefaults() {
	if s.DefaultRetention != nil {
		s.DefaultRetention.applyDefaults()
	}
	if s.MinimumRetention != nil {
		s.MinimumRetention.applyDefaults()
	}
	if s.MaximumRetention != nil {
		s.MaximumRetention.applyDefaults()
	}
}

func (s *AwsFsxOntapVolumeRetentionPeriodInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DefaultRetention != nil {
		m["default_retention"] = s.DefaultRetention.toMap()
	}
	if s.MinimumRetention != nil {
		m["minimum_retention"] = s.MinimumRetention.toMap()
	}
	if s.MaximumRetention != nil {
		m["maximum_retention"] = s.MaximumRetention.toMap()
	}
	return m
}

// AwsFsxOntapVolumeSnaplockConfiguration configures WORM (Write Once Read Many)
//
//	storage for regulatory compliance. Once a file is committed to WORM state on
//	a SnapLock volume, it cannot be modified or deleted until its retention period
//	expires.
//
//	SnapLock is used by organizations subject to SEC 17a-4(f), CFTC Rule 1.31,
//	HIPAA, FINRA, and similar regulations that require immutable record retention.
type AwsFsxOntapVolumeSnaplockConfigurationInput struct {
	// The SnapLock retention mode. Required. ForceNew — cannot be changed after
	//  volume creation.
	//
	//  - "ENTERPRISE": Administrative deletion of WORM files is possible (if
	//    privileged_delete is enabled). Suitable for internal governance policies
	//    where an escape hatch is acceptable.
	//  - "COMPLIANCE": I...
	SnaplockType string `json:"snaplock_type,omitempty" jsonschema:"The SnapLock retention mode. Required. ForceNew — cannot be changed after volume creation. - 'ENTERPRISE': Administrative deletion of WORM files is possible (if privileged_delete is enabled). Suitab..."`
	// Whether this volume is designated as the SnapLock audit log volume.
	//  A single audit log volume per SVM records all SnapLock operations
	//  (file commits, retention changes, privileged deletions).
	//
	//  Default: false
	AuditLogVolume bool `json:"audit_log_volume,omitempty" jsonschema:"Whether this volume is designated as the SnapLock audit log volume. A single audit log volume per SVM records all SnapLock operations (file commits; retention changes; privileged deletions). Default: ..."`
	// Controls whether privileged deletion of WORM files is allowed before their
	//  retention period expires. Only meaningful for ENTERPRISE SnapLock.
	//
	//  - "DISABLED": Privileged delete is not allowed (default).
	//  - "ENABLED": Administrators can delete WORM files early.
	//  - "PERMANENTLY_DISABLED": Privileged d...
	PrivilegedDelete string `json:"privileged_delete,omitempty" jsonschema:"Controls whether privileged deletion of WORM files is allowed before their retention period expires. Only meaningful for ENTERPRISE SnapLock. - 'DISABLED': Privileged delete is not allowed (default). ..."`
	// Whether volume-append mode is enabled. When enabled, files can be appended
	//  to (new data added at the end) even after being committed to WORM state.
	//  The existing content remains immutable. Useful for log files and audit
	//  trails that need continuous appending.
	//
	//  Default: false
	VolumeAppendModeEnabled bool `json:"volume_append_mode_enabled,omitempty" jsonschema:"Whether volume-append mode is enabled. When enabled; files can be appended to (new data added at the end) even after being committed to WORM state. The existing content remains immutable. Useful for l..."`
	// Configures automatic commitment of files to WORM state after a period of
	//  inactivity. When autocommit is configured, files that have not been modified
	//  for the specified duration are automatically transitioned to WORM state.
	//
	//  This eliminates the need for applications to explicitly commit files.
	AutocommitPeriod *AwsFsxOntapVolumeAutocommitPeriodInput `json:"autocommit_period,omitempty" jsonschema:"Configures automatic commitment of files to WORM state after a period of inactivity. When autocommit is configured; files that have not been modified for the specified duration are automatically trans..."`
	// Configures the default, minimum, and maximum retention periods for WORM
	//  files on this volume. These bounds constrain how long files must be retained
	//  and provide guardrails for retention policy enforcement.
	RetentionPeriod *AwsFsxOntapVolumeRetentionPeriodInput `json:"retention_period,omitempty" jsonschema:"Configures the default; minimum; and maximum retention periods for WORM files on this volume. These bounds constrain how long files must be retained and provide guardrails for retention policy enforce..."`
}

func (s *AwsFsxOntapVolumeSnaplockConfigurationInput) validate() error {
	if s.AutocommitPeriod != nil {
		if err := s.AutocommitPeriod.validate(); err != nil {
			return fmt.Errorf("autocommit_period: %w", err)
		}
	}
	if s.RetentionPeriod != nil {
		if err := s.RetentionPeriod.validate(); err != nil {
			return fmt.Errorf("retention_period: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxOntapVolumeSnaplockConfigurationInput) applyDefaults() {
	if s.PrivilegedDelete == "" {
		s.PrivilegedDelete = "DISABLED"
	}
	if s.AutocommitPeriod != nil {
		s.AutocommitPeriod.applyDefaults()
	}
	if s.RetentionPeriod != nil {
		s.RetentionPeriod.applyDefaults()
	}
}

func (s *AwsFsxOntapVolumeSnaplockConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SnaplockType != "" {
		m["snaplock_type"] = s.SnaplockType
	}
	if s.AuditLogVolume {
		m["audit_log_volume"] = s.AuditLogVolume
	}
	if s.PrivilegedDelete != "" {
		m["privileged_delete"] = s.PrivilegedDelete
	}
	if s.VolumeAppendModeEnabled {
		m["volume_append_mode_enabled"] = s.VolumeAppendModeEnabled
	}
	if s.AutocommitPeriod != nil {
		m["autocommit_period"] = s.AutocommitPeriod.toMap()
	}
	if s.RetentionPeriod != nil {
		m["retention_period"] = s.RetentionPeriod.toMap()
	}
	return m
}

// AwsFsxOntapVolumeTieringPolicy controls the movement of data between primary
//
//	SSD storage and lower-cost capacity pool (HDD) storage. Tiering reduces costs
//	by automatically migrating infrequently accessed data.
type AwsFsxOntapVolumeTieringPolicyInput struct {
	// The tiering policy name.
	//
	//  - "NONE": All data remains on primary SSD storage. No tiering. Use for
	//    latency-sensitive workloads where all data must be instantly accessible.
	//  - "SNAPSHOT_ONLY": Only snapshot data (point-in-time copies) is tiered.
	//    Active file system data stays on SSD. The safest t...
	Name string `json:"name,omitempty" jsonschema:"The tiering policy name. - 'NONE': All data remains on primary SSD storage. No tiering. Use for latency-sensitive workloads where all data must be instantly accessible. - 'SNAPSHOT_ONLY': Only snapsho..."`
	// The number of days before data is considered "cold" and eligible for
	//  tiering to capacity pool storage. Only applicable when name is "AUTO" or
	//  "SNAPSHOT_ONLY".
	//
	//  Range: 2-183 days. Lower values tier data more aggressively (lower cost,
	//  potentially higher latency for recently accessed data).
	CoolingPeriod int32 `json:"cooling_period,omitempty" jsonschema:"The number of days before data is considered 'cold' and eligible for tiering to capacity pool storage. Only applicable when name is 'AUTO' or 'SNAPSHOT_ONLY'. Range: 2-183 days. Lower values tier data..."`
}

func (s *AwsFsxOntapVolumeTieringPolicyInput) validate() error {
	return nil
}

func (s *AwsFsxOntapVolumeTieringPolicyInput) applyDefaults() {
}

func (s *AwsFsxOntapVolumeTieringPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.CoolingPeriod != 0 {
		m["cooling_period"] = s.CoolingPeriod
	}
	return m
}

// ParseAwsFsxOntapVolume validates and normalizes a AwsFsxOntapVolume cloud_object.
func ParseAwsFsxOntapVolume(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsFsxOntapVolume"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsFsxOntapVolumeSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
