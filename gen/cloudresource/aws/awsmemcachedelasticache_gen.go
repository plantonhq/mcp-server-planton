// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-memcached-elasticache
type AwsMemcachedElasticacheSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Memcached engine version to deploy. Uses three-part versioning:
	//  "1.6.22", "1.6.17", "1.5.16", etc.
	//  Transit encryption requires version 1.6.12 or later.
	EngineVersion string `json:"engine_version" jsonschema:"required,Memcached engine version to deploy. Uses three-part versioning: '1.6.22'; '1.6.17'; '1.5.16'; etc. Transit encryption requires version 1.6.12 or later."`
	// ElastiCache node type. Determines CPU, memory, and network capacity.
	//  Examples: "cache.t3.micro" (dev), "cache.r7g.large" (production).
	//  Changing node_type forces cluster recreation — Memcached does not support
	//  vertical scaling in-place.
	NodeType string `json:"node_type" jsonschema:"required,ElastiCache node type. Determines CPU; memory; and network capacity. Examples: 'cache.t3.micro' (dev); 'cache.r7g.large' (production). Changing node_type forces cluster recreation — Memcached does n..."`
	// Number of cache nodes in the cluster. Memcached distributes keys across
	//  all nodes via consistent hashing. Range: 1–40. Default: 1.
	NumCacheNodes int32 `json:"num_cache_nodes,omitempty" jsonschema:"Number of cache nodes in the cluster. Memcached distributes keys across all nodes via consistent hashing. Range: 1–40. Default: 1."`
	// AZ distribution mode. "single-az" places all nodes in one AZ (default).
	//  "cross-az" distributes nodes across multiple AZs for resilience.
	//  cross-az requires num_cache_nodes > 1.
	AzMode string `json:"az_mode,omitempty" jsonschema:"AZ distribution mode. 'single-az' places all nodes in one AZ (default). 'cross-az' distributes nodes across multiple AZs for resilience. cross-az requires num_cache_nodes > 1."`
	// Port on which the cluster accepts connections. Default: 11211.
	//  This is a ForceNew attribute — changing it destroys and recreates the
	//  cluster.
	Port int32 `json:"port,omitempty" jsonschema:"Port on which the cluster accepts connections. Default: 11211. This is a ForceNew attribute — changing it destroys and recreates the cluster."`
	// Enable encryption in transit (TLS) for all client connections.
	//  Requires Memcached engine version 1.6.12 or later. Attempting to enable
	//  this on earlier versions will result in an AWS API error.
	//  Note: Memcached does NOT support encryption at rest.
	TransitEncryptionEnabled bool `json:"transit_encryption_enabled,omitempty" jsonschema:"Enable encryption in transit (TLS) for all client connections. Requires Memcached engine version 1.6.12 or later. Attempting to enable this on earlier versions will result in an AWS API error. Note: M..."`
	// Subnet IDs for the ElastiCache subnet group. Provide subnets in at least
	//  two AZs when using cross-az mode. A subnet group is created automatically
	//  from these subnets.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs for the ElastiCache subnet group. Provide subnets in at least two AZs when using cross-az mode. A subnet group is created automatically from these subnets."`
	// VPC security groups to attach to the cluster nodes. Controls network-level
	//  access to the Memcached endpoint. Since Memcached has no authentication,
	//  security groups are the primary access control mechanism.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"VPC security groups to attach to the cluster nodes. Controls network-level access to the Memcached endpoint. Since Memcached has no authentication; security groups are the primary access control mecha..."`
	// Parameter group family for custom parameters. Required when `parameters`
	//  is provided. Examples: "memcached1.6", "memcached1.5", "memcached1.4".
	ParameterGroupFamily string `json:"parameter_group_family,omitempty" jsonschema:"Parameter group family for custom parameters. Required when 'parameters' is provided. Examples: 'memcached1.6'; 'memcached1.5'; 'memcached1.4'."`
	// Custom cache parameters to apply via a managed parameter group. Common
	//  Memcached parameters include: chunk_size, chunk_size_growth_factor,
	//  max_simultaneous_connections, binding_protocol.
	Parameters []*AwsMemcachedElasticacheParameterInput `json:"parameters,omitempty" jsonschema:"Custom cache parameters to apply via a managed parameter group. Common Memcached parameters include: chunk_size; chunk_size_growth_factor; max_simultaneous_connections; binding_protocol."`
	// Weekly maintenance window in UTC. Format: "ddd:hh24:mi-ddd:hh24:mi".
	//  Example: "sun:05:00-sun:06:00". Leave empty for AWS-assigned default.
	MaintenanceWindow string `json:"maintenance_window,omitempty" jsonschema:"Weekly maintenance window in UTC. Format: 'ddd:hh24:mi-ddd:hh24:mi'. Example: 'sun:05:00-sun:06:00'. Leave empty for AWS-assigned default."`
	// Apply changes immediately instead of waiting for the next maintenance
	//  window. May cause brief downtime for some operations.
	ApplyImmediately bool `json:"apply_immediately,omitempty" jsonschema:"Apply changes immediately instead of waiting for the next maintenance window. May cause brief downtime for some operations."`
	// Automatically apply minor engine version upgrades during maintenance
	//  windows. Recommended for staying on supported versions.
	AutoMinorVersionUpgrade bool `json:"auto_minor_version_upgrade,omitempty" jsonschema:"Automatically apply minor engine version upgrades during maintenance windows. Recommended for staying on supported versions."`
	// SNS topic ARN for cluster event notifications (node additions, removals,
	//  maintenance events, etc.).
	NotificationTopicArn string `json:"notification_topic_arn,omitempty" jsonschema:"SNS topic ARN for cluster event notifications (node additions; removals; maintenance events; etc.)."`
	// Preferred Availability Zones for the cache nodes. When provided, the list
	//  length must match num_cache_nodes. Nodes are placed in the specified AZs
	//  in order. Leave empty for AWS-managed AZ distribution.
	PreferredAvailabilityZones []string `json:"preferred_availability_zones,omitempty" jsonschema:"Preferred Availability Zones for the cache nodes. When provided; the list length must match num_cache_nodes. Nodes are placed in the specified AZs in order. Leave empty for AWS-managed AZ distribution..."`
}

func (s *AwsMemcachedElasticacheSpecInput) validate() error {
	if s.EngineVersion == "" {
		return fmt.Errorf("engine_version is required")
	}
	if s.NodeType == "" {
		return fmt.Errorf("node_type is required")
	}
	for i, v := range s.Parameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("parameters[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsMemcachedElasticacheSpecInput) applyDefaults() {
	if s.Port == 0 {
		s.Port = 11211
	}
}

func (s *AwsMemcachedElasticacheSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["engine_version"] = s.EngineVersion
	m["node_type"] = s.NodeType
	if s.NumCacheNodes != 0 {
		m["num_cache_nodes"] = s.NumCacheNodes
	}
	if s.AzMode != "" {
		m["az_mode"] = s.AzMode
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.TransitEncryptionEnabled {
		m["transit_encryption_enabled"] = s.TransitEncryptionEnabled
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.ParameterGroupFamily != "" {
		m["parameter_group_family"] = s.ParameterGroupFamily
	}
	if len(s.Parameters) > 0 {
		items := make([]any, len(s.Parameters))
		for i, v := range s.Parameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["parameters"] = items
	}
	if s.MaintenanceWindow != "" {
		m["maintenance_window"] = s.MaintenanceWindow
	}
	if s.ApplyImmediately {
		m["apply_immediately"] = s.ApplyImmediately
	}
	if s.AutoMinorVersionUpgrade {
		m["auto_minor_version_upgrade"] = s.AutoMinorVersionUpgrade
	}
	if s.NotificationTopicArn != "" {
		m["notification_topic_arn"] = s.NotificationTopicArn
	}
	if len(s.PreferredAvailabilityZones) > 0 {
		m["preferred_availability_zones"] = s.PreferredAvailabilityZones
	}
	return m
}

// AwsMemcachedElasticacheParameter defines a single cache parameter override
//
//	for the managed parameter group. Parameters tune Memcached engine behavior
//	(e.g., chunk_size, max_simultaneous_connections, binding_protocol).
type AwsMemcachedElasticacheParameterInput struct {
	// Parameter name (e.g., "chunk_size", "binding_protocol").
	Name string `json:"name" jsonschema:"required,Parameter name (e.g.; 'chunk_size'; 'binding_protocol')."`
	// Parameter value (e.g., "96", "auto").
	Value string `json:"value" jsonschema:"required,Parameter value (e.g.; '96'; 'auto')."`
}

func (s *AwsMemcachedElasticacheParameterInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AwsMemcachedElasticacheParameterInput) applyDefaults() {
}

func (s *AwsMemcachedElasticacheParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	return m
}

// ParseAwsMemcachedElasticache validates and normalizes a AwsMemcachedElasticache cloud_object.
func ParseAwsMemcachedElasticache(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsMemcachedElasticache"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsMemcachedElasticacheSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
