// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsSnsTopic is the Kubernetes-style resource envelope for an AWS SNS topic.
type AwsSnsTopicSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Whether to create a FIFO topic. Standard topics are created when false.
	//  FIFO topics guarantee strict ordering and exactly-once delivery to SQS FIFO
	//  queue subscribers. This setting cannot be changed after topic creation.
	FifoTopic bool `json:"fifo_topic,omitempty" jsonschema:"Whether to create a FIFO topic. Standard topics are created when false. FIFO topics guarantee strict ordering and exactly-once delivery to SQS FIFO queue subscribers. This setting cannot be changed af..."`
	// Enable content-based deduplication for FIFO topics. When enabled, SNS uses
	//  a SHA-256 hash of the message body as the deduplication ID, removing the
	//  need for the publisher to supply an explicit deduplication ID.
	//  Only valid when `fifo_topic` is true.
	ContentBasedDeduplication bool `json:"content_based_deduplication,omitempty" jsonschema:"Enable content-based deduplication for FIFO topics. When enabled; SNS uses a SHA-256 hash of the message body as the deduplication ID; removing the need for the publisher to supply an explicit dedupli..."`
	// Throughput scope for FIFO topics. Controls whether the throughput quota
	//  applies per topic or per message group.
	//  Valid values: "Topic", "MessageGroup". Only valid when `fifo_topic` is true.
	FifoThroughputScope string `json:"fifo_throughput_scope,omitempty" jsonschema:"Throughput scope for FIFO topics. Controls whether the throughput quota applies per topic or per message group. Valid values: 'Topic'; 'MessageGroup'. Only valid when 'fifo_topic' is true."`
	// Human-readable display name for the topic. Used as the "from" label in SMS
	//  messages and as a readable identifier in the AWS console. Maximum 256
	//  characters for Standard topics, 10 characters for SMS display names.
	DisplayName string `json:"display_name,omitempty" jsonschema:"Human-readable display name for the topic. Used as the 'from' label in SMS messages and as a readable identifier in the AWS console. Maximum 256 characters for Standard topics; 10 characters for SMS d..."`
	// Customer-managed KMS key for server-side encryption. When set, SNS encrypts
	//  message bodies using this key. Accepts a direct KMS key ID/ARN or a
	//  reference to an AwsKmsKey resource. When not set, SNS does not encrypt
	//  messages at rest (unlike SQS, SNS has no "managed SSE" option — encryption
	//  requ...
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key for server-side encryption. When set; SNS encrypts message bodies using this key. Accepts a direct KMS key ID/ARN or a reference to an AwsKmsKey resource. When not set; SNS do..."`
	// IAM access policy for the topic. Controls which AWS principals can perform
	//  actions on this topic (e.g., Publish, Subscribe). Expressed as a standard
	//  IAM policy document structure. Common use cases include granting EventBridge
	//  permission to publish, allowing cross-account subscriptions, or restric...
	Policy any `json:"policy,omitempty" jsonschema:"IAM access policy for the topic. Controls which AWS principals can perform actions on this topic (e.g.; Publish; Subscribe). Expressed as a standard IAM policy document structure. Common use cases inc..."`
	// HTTP/HTTPS delivery retry policy for the topic. Expressed as a JSON string
	//  matching the SNS delivery policy format. Controls retry backoff, max retries,
	//  and throttle behavior for HTTP/S subscriptions. Most users do not need to
	//  customize this. When not set, AWS applies its default delivery policy.
	DeliveryPolicy string `json:"delivery_policy,omitempty" jsonschema:"HTTP/HTTPS delivery retry policy for the topic. Expressed as a JSON string matching the SNS delivery policy format. Controls retry backoff; max retries; and throttle behavior for HTTP/S subscriptions...."`
	// AWS X-Ray tracing configuration. When set to "Active", SNS publishes trace
	//  data for messages. When set to "PassThrough", SNS passes through the trace
	//  header but does not sample. Leave empty to use the AWS default (PassThrough).
	//  Valid values: "Active", "PassThrough".
	TracingConfig string `json:"tracing_config,omitempty" jsonschema:"AWS X-Ray tracing configuration. When set to 'Active'; SNS publishes trace data for messages. When set to 'PassThrough'; SNS passes through the trace header but does not sample. Leave empty to use the..."`
	// SNS message signature version. Version 1 uses SHA1, version 2 uses SHA256.
	//  SHA256 (version 2) is recommended for new topics. Leave at 0 to use the
	//  AWS default (version 1).
	SignatureVersion int32 `json:"signature_version,omitempty" jsonschema:"SNS message signature version. Version 1 uses SHA1; version 2 uses SHA256. SHA256 (version 2) is recommended for new topics. Leave at 0 to use the AWS default (version 1)."`
	// Inline subscriptions for this topic. Each subscription defines a protocol,
	//  endpoint, and optional filtering configuration. The subscription `name` field
	//  is used as the key in the `subscription_arns` output map, enabling downstream
	//  resources to reference specific subscription ARNs via `valueFrom`.
	Subscriptions []*AwsSnsTopicSubscriptionInput `json:"subscriptions,omitempty" jsonschema:"Inline subscriptions for this topic. Each subscription defines a protocol; endpoint; and optional filtering configuration. The subscription 'name' field is used as the key in the 'subscription_arns' o..."`
}

func (s *AwsSnsTopicSpecInput) validate() error {
	for i, v := range s.Subscriptions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("subscriptions[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsSnsTopicSpecInput) applyDefaults() {
}

func (s *AwsSnsTopicSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.FifoTopic {
		m["fifo_topic"] = s.FifoTopic
	}
	if s.ContentBasedDeduplication {
		m["content_based_deduplication"] = s.ContentBasedDeduplication
	}
	if s.FifoThroughputScope != "" {
		m["fifo_throughput_scope"] = s.FifoThroughputScope
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	// unsupported type "object" for field Policy
	if s.DeliveryPolicy != "" {
		m["delivery_policy"] = s.DeliveryPolicy
	}
	if s.TracingConfig != "" {
		m["tracing_config"] = s.TracingConfig
	}
	if s.SignatureVersion != 0 {
		m["signature_version"] = s.SignatureVersion
	}
	if len(s.Subscriptions) > 0 {
		items := make([]any, len(s.Subscriptions))
		for i, v := range s.Subscriptions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["subscriptions"] = items
	}
	return m
}

// AwsSnsSubscriptionRedriveConfig configures the dead letter queue for a
//
//	subscription's delivery failures. When SNS cannot deliver a message after
//	all retry attempts, the message is moved to the specified SQS queue.
type AwsSnsSubscriptionRedriveConfigInput struct {
	// ARN of the SQS dead letter queue for failed message deliveries. Accepts a
	//  direct ARN or a reference to an AwsSqsQueue resource. The SQS queue must
	//  reside in the same AWS account and region as the SNS topic.
	DeadLetterTargetArn string `json:"dead_letter_target_arn" jsonschema:"required,ARN of the SQS dead letter queue for failed message deliveries. Accepts a direct ARN or a reference to an AwsSqsQueue resource. The SQS queue must reside in the same AWS account and region as the SNS ..."`
}

func (s *AwsSnsSubscriptionRedriveConfigInput) validate() error {
	if s.DeadLetterTargetArn == "" {
		return fmt.Errorf("dead_letter_target_arn is required")
	}
	return nil
}

func (s *AwsSnsSubscriptionRedriveConfigInput) applyDefaults() {
}

func (s *AwsSnsSubscriptionRedriveConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["dead_letter_target_arn"] = s.DeadLetterTargetArn
	return m
}

// AwsSnsTopicSubscription defines an inline subscription to deliver messages
//
//	from the parent SNS topic to a target endpoint.
//
//	Subscriptions are bundled with the topic because they are tightly coupled —
//	a subscription cannot exist without a topic, and most users define them
//	together. Each subscription's `name` field serves as a key in the
//	`subscription_arns` output map.
type AwsSnsTopicSubscriptionInput struct {
	// User-assigned name for this subscription. Used as a key in the
	//  `subscription_arns` output map so downstream resources can reference
	//  specific subscription ARNs. Must be unique within the topic's subscriptions.
	Name string `json:"name" jsonschema:"required,User-assigned name for this subscription. Used as a key in the 'subscription_arns' output map so downstream resources can reference specific subscription ARNs. Must be unique within the topic's subscr..."`
	// Protocol for message delivery. Determines how SNS delivers messages to the
	//  endpoint. Each protocol has specific endpoint format requirements:
	//  - "sqs": SQS queue ARN
	//  - "lambda": Lambda function ARN
	//  - "http" / "https": URL endpoint
	//  - "email" / "email-json": email address
	//  - "sms": phone number in...
	Protocol string `json:"protocol" jsonschema:"required,Protocol for message delivery. Determines how SNS delivers messages to the endpoint. Each protocol has specific endpoint format requirements: - 'sqs': SQS queue ARN - 'lambda': Lambda function ARN - '..."`
	// Endpoint to deliver messages to. The format depends on the protocol (see
	//  `protocol` field documentation). Accepts a direct value or a reference to
	//  another resource's output. For example, an SQS subscription can reference
	//  an AwsSqsQueue's queue ARN via `valueFrom`.
	//
	//  No `default_kind` is set becau...
	Endpoint string `json:"endpoint" jsonschema:"required,Endpoint to deliver messages to. The format depends on the protocol (see 'protocol' field documentation). Accepts a direct value or a reference to another resource's output. For example; an SQS subscr..."`
	// Filter policy to select which messages this subscription receives. Messages
	//  that do not match the filter are not delivered. The filter can be applied to
	//  message attributes (default) or the message body (see `filter_policy_scope`).
	//  Expressed as a JSON structure in YAML.
	FilterPolicy any `json:"filter_policy,omitempty" jsonschema:"Filter policy to select which messages this subscription receives. Messages that do not match the filter are not delivered. The filter can be applied to message attributes (default) or the message bod..."`
	// Scope for the filter policy. Controls whether the filter is evaluated against
	//  message attributes or the message body.
	//  Valid values: "MessageAttributes" (default), "MessageBody".
	//  Only relevant when `filter_policy` is set.
	FilterPolicyScope string `json:"filter_policy_scope,omitempty" jsonschema:"Scope for the filter policy. Controls whether the filter is evaluated against message attributes or the message body. Valid values: 'MessageAttributes' (default); 'MessageBody'. Only relevant when 'fi..."`
	// When true, messages are delivered as-is without JSON wrapping. Supported
	//  for SQS, HTTP/S, and Firehose protocols. When false (default), SNS wraps
	//  the message in a JSON envelope containing metadata (MessageId, TopicArn,
	//  Timestamp, etc.).
	RawMessageDelivery bool `json:"raw_message_delivery,omitempty" jsonschema:"When true; messages are delivered as-is without JSON wrapping. Supported for SQS; HTTP/S; and Firehose protocols. When false (default); SNS wraps the message in a JSON envelope containing metadata (Me..."`
	// Dead letter queue configuration for this subscription. When message delivery
	//  fails after all retry attempts, the message is routed to the specified SQS
	//  queue for investigation. This is separate from the SQS queue's own DLQ —
	//  this handles SNS-to-subscriber delivery failures.
	RedriveConfig *AwsSnsSubscriptionRedriveConfigInput `json:"redrive_config,omitempty" jsonschema:"Dead letter queue configuration for this subscription. When message delivery fails after all retry attempts; the message is routed to the specified SQS queue for investigation. This is separate from t..."`
	// IAM role ARN for Firehose delivery. Required when protocol is "firehose".
	//  The role must grant SNS permission to write to the Firehose delivery stream.
	//  Accepts a direct ARN or a reference to an AwsIamRole resource.
	SubscriptionRoleArn string `json:"subscription_role_arn,omitempty" jsonschema:"IAM role ARN for Firehose delivery. Required when protocol is 'firehose'. The role must grant SNS permission to write to the Firehose delivery stream. Accepts a direct ARN or a reference to an AwsIamR..."`
}

func (s *AwsSnsTopicSubscriptionInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Protocol == "" {
		return fmt.Errorf("protocol is required")
	}
	if s.Endpoint == "" {
		return fmt.Errorf("endpoint is required")
	}
	if s.RedriveConfig != nil {
		if err := s.RedriveConfig.validate(); err != nil {
			return fmt.Errorf("redrive_config: %w", err)
		}
	}
	return nil
}

func (s *AwsSnsTopicSubscriptionInput) applyDefaults() {
	if s.RedriveConfig != nil {
		s.RedriveConfig.applyDefaults()
	}
}

func (s *AwsSnsTopicSubscriptionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["protocol"] = s.Protocol
	m["endpoint"] = s.Endpoint
	// unsupported type "object" for field FilterPolicy
	if s.FilterPolicyScope != "" {
		m["filter_policy_scope"] = s.FilterPolicyScope
	}
	if s.RawMessageDelivery {
		m["raw_message_delivery"] = s.RawMessageDelivery
	}
	if s.RedriveConfig != nil {
		m["redrive_config"] = s.RedriveConfig.toMap()
	}
	if s.SubscriptionRoleArn != "" {
		m["subscription_role_arn"] = s.SubscriptionRoleArn
	}
	return m
}

// ParseAwsSnsTopic validates and normalizes a AwsSnsTopic cloud_object.
func ParseAwsSnsTopic(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsSnsTopic"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsSnsTopicSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
