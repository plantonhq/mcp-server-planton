// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsIamUser represents an AWS IAM User resource for programmatic access.
//
//	IAM users provide long-lived credentials for CI/CD pipelines, third-party integrations,
//	and service accounts that require AWS API access.
type AwsIamUserSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// user_name is the IAM user name. Must be 1-64 characters and match the regex
	//  pattern "^[a-zA-Z0-9+=,.@_-]{1,64}$" (letters, digits, and +=,.@_-).
	UserName string `json:"user_name" jsonschema:"required,user_name is the IAM user name. Must be 1-64 characters and match the regex pattern '^[a-zA-Z0-9+=;.@_-]{1;64}$' (letters; digits; and +=;.@_-)."`
	// managed_policy_arns is a list of IAM managed policy ARNs to attach to the user.
	//  Each ARN must start with "arn:aws:iam::". The list must be unique.
	ManagedPolicyArns []string `json:"managed_policy_arns,omitempty" jsonschema:"managed_policy_arns is a list of IAM managed policy ARNs to attach to the user. Each ARN must start with 'arn:aws:iam::'. The list must be unique."`
	// inline_policies is a map of inline policy documents to attach to the user.
	//  Keys are policy names (max 128 characters); values are the IAM policy JSON (as a Struct).
	InlinePolicies map[string]any `json:"inline_policies,omitempty" jsonschema:"inline_policies is a map of inline policy documents to attach to the user. Keys are policy names (max 128 characters); values are the IAM policy JSON (as a Struct)."`
	// disable_access_keys, if true, prevents creation of access keys for this user.
	//  If false (default), one active access key will be created for the user.
	DisableAccessKeys bool `json:"disable_access_keys,omitempty" jsonschema:"disable_access_keys; if true; prevents creation of access keys for this user. If false (default); one active access key will be created for the user."`
}

func (s *AwsIamUserSpecInput) validate() error {
	if s.UserName == "" {
		return fmt.Errorf("user_name is required")
	}
	return nil
}

func (s *AwsIamUserSpecInput) applyDefaults() {
}

func (s *AwsIamUserSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["user_name"] = s.UserName
	if len(s.ManagedPolicyArns) > 0 {
		m["managed_policy_arns"] = s.ManagedPolicyArns
	}
	if len(s.InlinePolicies) > 0 {
		m["inline_policies"] = s.InlinePolicies
	}
	if s.DisableAccessKeys {
		m["disable_access_keys"] = s.DisableAccessKeys
	}
	return m
}

// ParseAwsIamUser validates and normalizes a AwsIamUser cloud_object.
func ParseAwsIamUser(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsIamUser"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsIamUserSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
