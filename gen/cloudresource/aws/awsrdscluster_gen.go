// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-rds-cluster
type AwsRdsClusterSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// subnet_ids is the list of subnet IDs used by the DB subnet group for the cluster.
	//  Provide at least two subnets in distinct Availability Zones for high availability.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"subnet_ids is the list of subnet IDs used by the DB subnet group for the cluster. Provide at least two subnets in distinct Availability Zones for high availability."`
	// Optional name of an existing DB subnet group to use instead of providing subnet_ids.
	DbSubnetGroupName string `json:"db_subnet_group_name,omitempty" jsonschema:"Optional name of an existing DB subnet group to use instead of providing subnet_ids."`
	// vpc_security_group_ids are additional security groups attached to the cluster.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"vpc_security_group_ids are additional security groups attached to the cluster."`
	// allowed_cidr_blocks are IPv4 CIDRs to allow ingress to the cluster SG (if created/managed here).
	//  Example: "10.0.0.0/16", "0.0.0.0/0"
	AllowedCidrBlocks []string `json:"allowed_cidr_blocks,omitempty" jsonschema:"allowed_cidr_blocks are IPv4 CIDRs to allow ingress to the cluster SG (if created/managed here). Example: '10.0.0.0/16'; '0.0.0.0/0'"`
	// associate_security_group_ids lists existing SGs to associate (alongside any created/managed SG).
	AssociateSecurityGroupIds []string `json:"associate_security_group_ids,omitempty" jsonschema:"associate_security_group_ids lists existing SGs to associate (alongside any created/managed SG)."`
	// database_name is the name of the initial database to create in the cluster.
	DatabaseName string `json:"database_name,omitempty" jsonschema:"database_name is the name of the initial database to create in the cluster."`
	// manage_master_user_password, when true, lets RDS manage the master user password in AWS Secrets Manager.
	ManageMasterUserPassword bool `json:"manage_master_user_password,omitempty" jsonschema:"manage_master_user_password; when true; lets RDS manage the master user password in AWS Secrets Manager."`
	// master_user_secret_kms_key_id is the KMS key identifier (ARN/alias) for encrypting the managed secret.
	MasterUserSecretKmsKeyId string `json:"master_user_secret_kms_key_id,omitempty" jsonschema:"master_user_secret_kms_key_id is the KMS key identifier (ARN/alias) for encrypting the managed secret."`
	// username is the master database user name.
	Username string `json:"username,omitempty" jsonschema:"username is the master database user name."`
	// password is the master user password. Cannot be set when manage_master_user_password is true.
	Password string `json:"password,omitempty" jsonschema:"password is the master user password. Cannot be set when manage_master_user_password is true."`
	// port on which the cluster accepts connections.
	Port int32 `json:"port,omitempty" jsonschema:"port on which the cluster accepts connections."`
	// engine for the cluster. Examples: "aurora-mysql", "aurora-postgresql".
	Engine string `json:"engine" jsonschema:"required,engine for the cluster. Examples: 'aurora-mysql'; 'aurora-postgresql'."`
	// engine_version to deploy. Example: "8.0.mysql_aurora.3.05.2" or "14.6" for Aurora PostgreSQL.
	EngineVersion string `json:"engine_version" jsonschema:"required,engine_version to deploy. Example: '8.0.mysql_aurora.3.05.2' or '14.6' for Aurora PostgreSQL."`
	// storage_encrypted indicates whether to enable storage encryption for the cluster.
	StorageEncrypted bool `json:"storage_encrypted,omitempty" jsonschema:"storage_encrypted indicates whether to enable storage encryption for the cluster."`
	// kms_key_id KMS key ARN to use for storage encryption when storage_encrypted is true.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"kms_key_id KMS key ARN to use for storage encryption when storage_encrypted is true."`
	// enabled_cloudwatch_logs_exports lists database logs to export to CloudWatch Logs.
	//  Aurora MySQL: [audit, error, general, slowquery]
	//  Aurora PostgreSQL: [postgresql, upgrade]
	EnabledCloudwatchLogsExports []string `json:"enabled_cloudwatch_logs_exports,omitempty" jsonschema:"enabled_cloudwatch_logs_exports lists database logs to export to CloudWatch Logs. Aurora MySQL: [audit; error; general; slowquery] Aurora PostgreSQL: [postgresql; upgrade]"`
	// deletion_protection prevents accidental deletion.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"deletion_protection prevents accidental deletion."`
	// preferred_maintenance_window in UTC, format 'ddd:hh24:mi-ddd:hh24:mi'.
	PreferredMaintenanceWindow string `json:"preferred_maintenance_window,omitempty" jsonschema:"preferred_maintenance_window in UTC; format 'ddd:hh24:mi-ddd:hh24:mi'."`
	// backup_retention_period in days (> 0 to enable automated backups).
	BackupRetentionPeriod int32 `json:"backup_retention_period,omitempty" jsonschema:"backup_retention_period in days (> 0 to enable automated backups)."`
	// preferred_backup_window in UTC, format 'hh24:mi-hh24:mi'. Must not overlap maintenance window.
	PreferredBackupWindow string `json:"preferred_backup_window,omitempty" jsonschema:"preferred_backup_window in UTC; format 'hh24:mi-hh24:mi'. Must not overlap maintenance window."`
	// copy_tags_to_snapshot copies tags from the cluster to snapshots.
	CopyTagsToSnapshot bool `json:"copy_tags_to_snapshot,omitempty" jsonschema:"copy_tags_to_snapshot copies tags from the cluster to snapshots."`
	// skip_final_snapshot controls whether a final snapshot is created before cluster deletion.
	SkipFinalSnapshot bool `json:"skip_final_snapshot,omitempty" jsonschema:"skip_final_snapshot controls whether a final snapshot is created before cluster deletion."`
	// final_snapshot_identifier is the identifier to use for the final snapshot when skip_final_snapshot is false.
	FinalSnapshotIdentifier string `json:"final_snapshot_identifier,omitempty" jsonschema:"final_snapshot_identifier is the identifier to use for the final snapshot when skip_final_snapshot is false."`
	// iam_database_authentication_enabled enables mapping of IAM users/roles to database logins.
	IamDatabaseAuthenticationEnabled bool `json:"iam_database_authentication_enabled,omitempty" jsonschema:"iam_database_authentication_enabled enables mapping of IAM users/roles to database logins."`
	// enable_http_endpoint enables the Data API for Aurora Serverless (where supported).
	EnableHttpEndpoint bool `json:"enable_http_endpoint,omitempty" jsonschema:"enable_http_endpoint enables the Data API for Aurora Serverless (where supported)."`
	// serverless_v2_scaling controls Aurora Serverless v2 capacity scaling (if supported by engine/engine_version).
	ServerlessV2Scaling *AwsRdsClusterServerlessV2ScalingConfigurationInput `json:"serverless_v2_scaling,omitempty" jsonschema:"serverless_v2_scaling controls Aurora Serverless v2 capacity scaling (if supported by engine/engine_version)."`
	// snapshot_identifier creates the cluster from the specified snapshot, when provided.
	SnapshotIdentifier string `json:"snapshot_identifier,omitempty" jsonschema:"snapshot_identifier creates the cluster from the specified snapshot; when provided."`
	// replication_source_identifier creates a read replica of another cluster when provided (ARN or identifier).
	ReplicationSourceIdentifier string `json:"replication_source_identifier,omitempty" jsonschema:"replication_source_identifier creates a read replica of another cluster when provided (ARN or identifier)."`
	// db_cluster_parameter_group_name is the cluster-level parameter group to associate.
	DbClusterParameterGroupName string `json:"db_cluster_parameter_group_name,omitempty" jsonschema:"db_cluster_parameter_group_name is the cluster-level parameter group to associate."`
	// cluster-level parameters to apply (depends on DB family).
	Parameters []*AwsRdsClusterParameterInput `json:"parameters,omitempty" jsonschema:"cluster-level parameters to apply (depends on DB family)."`
	// vpc_id for the cluster networking context (optional; generally derivable from subnet_ids/subnet group).
	VpcId string `json:"vpc_id,omitempty" jsonschema:"vpc_id for the cluster networking context (optional; generally derivable from subnet_ids/subnet group)."`
	// Optional engine mode. For Aurora Serverless v1 use "serverless"; otherwise "provisioned".
	EngineMode string `json:"engine_mode,omitempty" jsonschema:"Optional engine mode. For Aurora Serverless v1 use 'serverless'; otherwise 'provisioned'."`
	// storage_type for Aurora (if supported): "aurora" or "aurora-iopt1".
	StorageType string `json:"storage_type,omitempty" jsonschema:"storage_type for Aurora (if supported): 'aurora' or 'aurora-iopt1'."`
}

func (s *AwsRdsClusterSpecInput) validate() error {
	if s.Engine == "" {
		return fmt.Errorf("engine is required")
	}
	if s.EngineVersion == "" {
		return fmt.Errorf("engine_version is required")
	}
	if s.ServerlessV2Scaling != nil {
		if err := s.ServerlessV2Scaling.validate(); err != nil {
			return fmt.Errorf("serverless_v2_scaling: %w", err)
		}
	}
	for i, v := range s.Parameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("parameters[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsRdsClusterSpecInput) applyDefaults() {
	if s.Username == "" {
		s.Username = "master"
	}
	if s.ServerlessV2Scaling != nil {
		s.ServerlessV2Scaling.applyDefaults()
	}
}

func (s *AwsRdsClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if s.DbSubnetGroupName != "" {
		m["db_subnet_group_name"] = s.DbSubnetGroupName
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if len(s.AllowedCidrBlocks) > 0 {
		m["allowed_cidr_blocks"] = s.AllowedCidrBlocks
	}
	if len(s.AssociateSecurityGroupIds) > 0 {
		m["associate_security_group_ids"] = s.AssociateSecurityGroupIds
	}
	if s.DatabaseName != "" {
		m["database_name"] = s.DatabaseName
	}
	if s.ManageMasterUserPassword {
		m["manage_master_user_password"] = s.ManageMasterUserPassword
	}
	if s.MasterUserSecretKmsKeyId != "" {
		m["master_user_secret_kms_key_id"] = s.MasterUserSecretKmsKeyId
	}
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	m["engine"] = s.Engine
	m["engine_version"] = s.EngineVersion
	if s.StorageEncrypted {
		m["storage_encrypted"] = s.StorageEncrypted
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if len(s.EnabledCloudwatchLogsExports) > 0 {
		m["enabled_cloudwatch_logs_exports"] = s.EnabledCloudwatchLogsExports
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if s.PreferredMaintenanceWindow != "" {
		m["preferred_maintenance_window"] = s.PreferredMaintenanceWindow
	}
	if s.BackupRetentionPeriod != 0 {
		m["backup_retention_period"] = s.BackupRetentionPeriod
	}
	if s.PreferredBackupWindow != "" {
		m["preferred_backup_window"] = s.PreferredBackupWindow
	}
	if s.CopyTagsToSnapshot {
		m["copy_tags_to_snapshot"] = s.CopyTagsToSnapshot
	}
	if s.SkipFinalSnapshot {
		m["skip_final_snapshot"] = s.SkipFinalSnapshot
	}
	if s.FinalSnapshotIdentifier != "" {
		m["final_snapshot_identifier"] = s.FinalSnapshotIdentifier
	}
	if s.IamDatabaseAuthenticationEnabled {
		m["iam_database_authentication_enabled"] = s.IamDatabaseAuthenticationEnabled
	}
	if s.EnableHttpEndpoint {
		m["enable_http_endpoint"] = s.EnableHttpEndpoint
	}
	if s.ServerlessV2Scaling != nil {
		m["serverless_v2_scaling"] = s.ServerlessV2Scaling.toMap()
	}
	if s.SnapshotIdentifier != "" {
		m["snapshot_identifier"] = s.SnapshotIdentifier
	}
	if s.ReplicationSourceIdentifier != "" {
		m["replication_source_identifier"] = s.ReplicationSourceIdentifier
	}
	if s.DbClusterParameterGroupName != "" {
		m["db_cluster_parameter_group_name"] = s.DbClusterParameterGroupName
	}
	if len(s.Parameters) > 0 {
		items := make([]any, len(s.Parameters))
		for i, v := range s.Parameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["parameters"] = items
	}
	if s.VpcId != "" {
		m["vpc_id"] = s.VpcId
	}
	if s.EngineMode != "" {
		m["engine_mode"] = s.EngineMode
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	return m
}

// AwsRdsClusterParameter represents a cluster parameter to apply via the DB cluster parameter group.
type AwsRdsClusterParameterInput struct {
	// apply_method is either "immediate" (default) or "pending-reboot".
	ApplyMethod string `json:"apply_method,omitempty" jsonschema:"apply_method is either 'immediate' (default) or 'pending-reboot'."`
	// name of the parameter.
	Name string `json:"name,omitempty" jsonschema:"name of the parameter."`
	// value of the parameter.
	Value string `json:"value,omitempty" jsonschema:"value of the parameter."`
}

func (s *AwsRdsClusterParameterInput) validate() error {
	return nil
}

func (s *AwsRdsClusterParameterInput) applyDefaults() {
}

func (s *AwsRdsClusterParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ApplyMethod != "" {
		m["apply_method"] = s.ApplyMethod
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	return m
}

// AwsRdsClusterServerlessV2ScalingConfiguration configures Aurora Serverless v2 capacity scaling.
type AwsRdsClusterServerlessV2ScalingConfigurationInput struct {
	// min_capacity is the minimum ACU.
	MinCapacity float64 `json:"min_capacity,omitempty" jsonschema:"min_capacity is the minimum ACU."`
	// max_capacity is the maximum ACU.
	MaxCapacity float64 `json:"max_capacity,omitempty" jsonschema:"max_capacity is the maximum ACU."`
}

func (s *AwsRdsClusterServerlessV2ScalingConfigurationInput) validate() error {
	return nil
}

func (s *AwsRdsClusterServerlessV2ScalingConfigurationInput) applyDefaults() {
}

func (s *AwsRdsClusterServerlessV2ScalingConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinCapacity != 0 {
		m["min_capacity"] = s.MinCapacity
	}
	if s.MaxCapacity != 0 {
		m["max_capacity"] = s.MaxCapacity
	}
	return m
}

// ParseAwsRdsCluster validates and normalizes a AwsRdsCluster cloud_object.
func ParseAwsRdsCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsRdsCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsRdsClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
