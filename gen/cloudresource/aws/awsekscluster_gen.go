// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-eks-cluster
type AwsEksClusterSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// subnet_ids is the list of subnet IDs (in the cluster's VPC) where the EKS control plane will attach network interfaces.
	//  Provide at least two subnets in distinct Availability Zones for high availability.
	SubnetIds []string `json:"subnet_ids" jsonschema:"required,subnet_ids is the list of subnet IDs (in the cluster's VPC) where the EKS control plane will attach network interfaces. Provide at least two subnets in distinct Availability Zones for high availabilit..."`
	// cluster_role_arn is the ARN of an IAM role for the EKS cluster to use when interacting with AWS services.
	//  This role must have the AmazonEKSClusterPolicy attached.
	//  Example: "arn:aws:iam::123456789012:role/EksClusterServiceRole"
	ClusterRoleArn string `json:"cluster_role_arn" jsonschema:"required,cluster_role_arn is the ARN of an IAM role for the EKS cluster to use when interacting with AWS services. This role must have the AmazonEKSClusterPolicy attached. Example: 'arn:aws:iam::123456789012:r..."`
	// version is the Kubernetes version of the cluster control plane to deploy (e.g., "1.25").
	//  Must match the pattern ^1\.(2[4-9]|3[0-9])$ (for example, "1.24", "1.25", etc.). If not set, the latest supported version is used.
	Version string `json:"version,omitempty" jsonschema:"version is the Kubernetes version of the cluster control plane to deploy (e.g.; '1.25'). Must match the pattern ^1\\.(2[4-9]|3[0-9])$ (for example; '1.24'; '1.25'; etc.). If not set; the latest support..."`
	// disable_public_endpoint determines if the cluster's API endpoint should be private-only.
	//  If false (default), the cluster API endpoint is publicly accessible; if true, the endpoint is accessible only within the VPC.
	DisablePublicEndpoint bool `json:"disable_public_endpoint,omitempty" jsonschema:"disable_public_endpoint determines if the cluster's API endpoint should be private-only. If false (default); the cluster API endpoint is publicly accessible; if true; the endpoint is accessible only w..."`
	// public_access_cidrs restricts which IPv4 CIDR blocks can access the cluster's public API endpoint.
	//  If this list is empty, AWS defaults to 0.0.0.0/0 (all IPv4 addresses). Each entry must be a valid IPv4 CIDR (e.g., "203.0.113.0/24").
	PublicAccessCidrs []string `json:"public_access_cidrs,omitempty" jsonschema:"public_access_cidrs restricts which IPv4 CIDR blocks can access the cluster's public API endpoint. If this list is empty; AWS defaults to 0.0.0.0/0 (all IPv4 addresses). Each entry must be a valid IPv..."`
	// enable_control_plane_logs, if true, enables all control plane log types for the cluster (API, audit, authenticator, controller manager, scheduler) to CloudWatch.
	//  Default is false, meaning control plane logging is disabled unless explicitly enabled.
	EnableControlPlaneLogs bool `json:"enable_control_plane_logs,omitempty" jsonschema:"enable_control_plane_logs; if true; enables all control plane log types for the cluster (API; audit; authenticator; controller manager; scheduler) to CloudWatch. Default is false; meaning control plan..."`
	// kms_key_arn is an optional KMS Key ARN to use for envelope encryption of Kubernetes secrets.
	//  If provided, this customer-managed KMS key will encrypt secrets; if not set, the cluster uses the default AWS-managed EKS key.
	KmsKeyArn string `json:"kms_key_arn,omitempty" jsonschema:"kms_key_arn is an optional KMS Key ARN to use for envelope encryption of Kubernetes secrets. If provided; this customer-managed KMS key will encrypt secrets; if not set; the cluster uses the default A..."`
}

func (s *AwsEksClusterSpecInput) validate() error {
	if len(s.SubnetIds) == 0 {
		return fmt.Errorf("subnet_ids is required")
	}
	if len(s.SubnetIds) < 2 {
		return fmt.Errorf("subnet_ids requires at least 2 items, got %d", len(s.SubnetIds))
	}
	if s.ClusterRoleArn == "" {
		return fmt.Errorf("cluster_role_arn is required")
	}
	return nil
}

func (s *AwsEksClusterSpecInput) applyDefaults() {
}

func (s *AwsEksClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["subnet_ids"] = s.SubnetIds
	m["cluster_role_arn"] = s.ClusterRoleArn
	if s.Version != "" {
		m["version"] = s.Version
	}
	if s.DisablePublicEndpoint {
		m["disable_public_endpoint"] = s.DisablePublicEndpoint
	}
	if len(s.PublicAccessCidrs) > 0 {
		m["public_access_cidrs"] = s.PublicAccessCidrs
	}
	if s.EnableControlPlaneLogs {
		m["enable_control_plane_logs"] = s.EnableControlPlaneLogs
	}
	if s.KmsKeyArn != "" {
		m["kms_key_arn"] = s.KmsKeyArn
	}
	return m
}

// ParseAwsEksCluster validates and normalizes a AwsEksCluster cloud_object.
func ParseAwsEksCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEksCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEksClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
