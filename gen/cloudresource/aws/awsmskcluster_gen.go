// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-msk-cluster
type AwsMskClusterSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// kafka_version is the Apache Kafka version for all brokers in the cluster.
	//  Examples: "3.6.0", "3.5.1", "3.4.0", "2.8.1".
	//  Upgrades are applied via rolling restart; downgrades force cluster replacement.
	KafkaVersion string `json:"kafka_version" jsonschema:"required,kafka_version is the Apache Kafka version for all brokers in the cluster. Examples: '3.6.0'; '3.5.1'; '3.4.0'; '2.8.1'. Upgrades are applied via rolling restart; downgrades force cluster replacement."`
	// number_of_broker_nodes is the total number of Kafka broker nodes in the cluster.
	//  Must be a multiple of the number of subnets provided in subnet_ids so that
	//  brokers are evenly distributed across Availability Zones.
	NumberOfBrokerNodes int32 `json:"number_of_broker_nodes" jsonschema:"required,number_of_broker_nodes is the total number of Kafka broker nodes in the cluster. Must be a multiple of the number of subnets provided in subnet_ids so that brokers are evenly distributed across Availa..."`
	// instance_type determines the compute and memory capacity of each broker node.
	//  Standard types: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge.
	//  Graviton types: kafka.m7g.large, kafka.m7g.xlarge (better price-performance).
	//  Small/dev types: kafka.t3.small.
	InstanceType string `json:"instance_type" jsonschema:"required,instance_type determines the compute and memory capacity of each broker node. Standard types: kafka.m5.large; kafka.m5.xlarge; kafka.m5.2xlarge; kafka.m5.4xlarge. Graviton types: kafka.m7g.large; kafk..."`
	// subnet_ids are the VPC subnets where broker nodes are placed.
	//  Brokers are distributed round-robin across subnets. The number of broker nodes
	//  must be a multiple of the number of subnets for even AZ distribution.
	//  ForceNew: changing subnets forces cluster replacement.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"subnet_ids are the VPC subnets where broker nodes are placed. Brokers are distributed round-robin across subnets. The number of broker nodes must be a multiple of the number of subnets for even AZ dis..."`
	// security_group_ids are source security groups allowed to reach brokers on Kafka and ZooKeeper ports.
	//  When provided (along with vpc_id), a managed security group is created with ingress rules
	//  permitting TCP traffic from these source security groups on ports 9092-9098 (Kafka) and 2181-2182 (ZooKeepe...
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"security_group_ids are source security groups allowed to reach brokers on Kafka and ZooKeeper ports. When provided (along with vpc_id); a managed security group is created with ingress rules permittin..."`
	// allowed_cidr_blocks are IPv4 CIDR ranges allowed to reach brokers.
	//  When provided (along with vpc_id), a managed security group is created with ingress rules
	//  permitting TCP traffic from these CIDRs on ports 9092-9098 (Kafka) and 2181-2182 (ZooKeeper).
	AllowedCidrBlocks []string `json:"allowed_cidr_blocks,omitempty" jsonschema:"allowed_cidr_blocks are IPv4 CIDR ranges allowed to reach brokers. When provided (along with vpc_id); a managed security group is created with ingress rules permitting TCP traffic from these CIDRs on ..."`
	// associate_security_group_ids are existing security groups attached directly to the cluster
	//  alongside the managed security group (if one is created from security_group_ids/allowed_cidr_blocks).
	//  IMPORTANT: The broker_node_group_info.security_groups field in AWS is ForceNew.
	//  Adding or removing entri...
	AssociateSecurityGroupIds []string `json:"associate_security_group_ids,omitempty" jsonschema:"associate_security_group_ids are existing security groups attached directly to the cluster alongside the managed security group (if one is created from security_group_ids/allowed_cidr_blocks). IMPORTA..."`
	// vpc_id is the VPC in which to create the managed security group.
	//  Required when security_group_ids or allowed_cidr_blocks are provided.
	VpcId string `json:"vpc_id,omitempty" jsonschema:"vpc_id is the VPC in which to create the managed security group. Required when security_group_ids or allowed_cidr_blocks are provided."`
	// ebs_volume_size_gib is the size of the EBS volume per broker, in GiB.
	//  Range: 1-16384. If omitted, AWS uses the instance-type-specific default.
	EbsVolumeSizeGib int32 `json:"ebs_volume_size_gib,omitempty" jsonschema:"ebs_volume_size_gib is the size of the EBS volume per broker; in GiB. Range: 1-16384. If omitted; AWS uses the instance-type-specific default."`
	// provisioned_throughput_enabled enables provisioned EBS throughput for higher streaming performance.
	//  Only supported on kafka.m5.4xlarge and larger instance types with ebs_volume_size_gib >= 10 GiB.
	ProvisionedThroughputEnabled bool `json:"provisioned_throughput_enabled,omitempty" jsonschema:"provisioned_throughput_enabled enables provisioned EBS throughput for higher streaming performance. Only supported on kafka.m5.4xlarge and larger instance types with ebs_volume_size_gib >= 10 GiB."`
	// provisioned_throughput_mbs is the provisioned EBS throughput in MiB/s per broker.
	//  Range: 250-2375. Required when provisioned_throughput_enabled is true.
	ProvisionedThroughputMbs int32 `json:"provisioned_throughput_mbs,omitempty" jsonschema:"provisioned_throughput_mbs is the provisioned EBS throughput in MiB/s per broker. Range: 250-2375. Required when provisioned_throughput_enabled is true."`
	// storage_mode controls data storage strategy.
	//  "LOCAL" (default): all data on broker EBS volumes.
	//  "TIERED": hot data on EBS, warm data automatically offloaded to S3 for cost optimization.
	//  Tiered storage requires Kafka 2.8.2.tiered+ and supported instance types.
	StorageMode string `json:"storage_mode,omitempty" jsonschema:"storage_mode controls data storage strategy. 'LOCAL' (default): all data on broker EBS volumes. 'TIERED': hot data on EBS; warm data automatically offloaded to S3 for cost optimization. Tiered storage..."`
	// kms_key_arn is the KMS key ARN for encrypting data at rest on broker EBS volumes.
	//  If omitted, AWS uses the default aws/msk service key.
	//  ForceNew: changing the KMS key forces cluster replacement.
	KmsKeyArn string `json:"kms_key_arn,omitempty" jsonschema:"kms_key_arn is the KMS key ARN for encrypting data at rest on broker EBS volumes. If omitted; AWS uses the default aws/msk service key. ForceNew: changing the KMS key forces cluster replacement."`
	// client_broker_encryption controls encryption for data in transit between clients and brokers.
	//  "TLS" (default, recommended): all client-broker traffic is TLS-encrypted (port 9094).
	//  "TLS_PLAINTEXT": both TLS (9094) and plaintext (9092) are available.
	//  "PLAINTEXT": all client-broker traffic is unencr...
	ClientBrokerEncryption string `json:"client_broker_encryption,omitempty" jsonschema:"client_broker_encryption controls encryption for data in transit between clients and brokers. 'TLS' (default; recommended): all client-broker traffic is TLS-encrypted (port 9094). 'TLS_PLAINTEXT': bot..."`
	// in_cluster_encryption enables TLS encryption for data in transit between brokers.
	//  Strongly recommended for production. ForceNew: changing this forces cluster replacement.
	InClusterEncryption bool `json:"in_cluster_encryption,omitempty" jsonschema:"in_cluster_encryption enables TLS encryption for data in transit between brokers. Strongly recommended for production. ForceNew: changing this forces cluster replacement."`
	// authentication configures client authentication methods for the cluster.
	//  Multiple methods can be enabled simultaneously (e.g., SASL/IAM + TLS).
	//  If no authentication is configured, the cluster accepts unauthenticated connections.
	Authentication *AwsMskClusterAuthenticationInput `json:"authentication,omitempty" jsonschema:"authentication configures client authentication methods for the cluster. Multiple methods can be enabled simultaneously (e.g.; SASL/IAM + TLS). If no authentication is configured; the cluster accepts ..."`
	// configuration_arn is the ARN of an externally managed MSK Configuration resource.
	//  MSK Configurations hold Apache Kafka server.properties overrides (e.g., replication factor,
	//  min ISR, log retention). Mutually exclusive with server_properties.
	ConfigurationArn string `json:"configuration_arn,omitempty" jsonschema:"configuration_arn is the ARN of an externally managed MSK Configuration resource. MSK Configurations hold Apache Kafka server.properties overrides (e.g.; replication factor; min ISR; log retention). M..."`
	// configuration_revision is the revision number of the external MSK Configuration.
	//  Required when configuration_arn is set. Must be >= 1.
	ConfigurationRevision int32 `json:"configuration_revision,omitempty" jsonschema:"configuration_revision is the revision number of the external MSK Configuration. Required when configuration_arn is set. Must be >= 1."`
	// server_properties defines Apache Kafka server.properties overrides as key-value pairs.
	//  When provided, an inline MSK Configuration resource is created and associated with the cluster.
	//  Common properties: auto.create.topics.enable, default.replication.factor, min.insync.replicas,
	//  num.partitions, log...
	ServerProperties map[string]string `json:"server_properties,omitempty" jsonschema:"server_properties defines Apache Kafka server.properties overrides as key-value pairs. When provided; an inline MSK Configuration resource is created and associated with the cluster. Common properties..."`
	// logging configures broker log delivery to one or more destinations.
	//  All three destinations (CloudWatch Logs, Kinesis Data Firehose, S3) can be
	//  enabled simultaneously for different operational workflows.
	Logging *AwsMskClusterLoggingInput `json:"logging,omitempty" jsonschema:"logging configures broker log delivery to one or more destinations. All three destinations (CloudWatch Logs; Kinesis Data Firehose; S3) can be enabled simultaneously for different operational workflow..."`
	// enhanced_monitoring sets the level of CloudWatch metrics published by the cluster.
	//  "DEFAULT": cluster-level and topic-level metrics.
	//  "PER_BROKER": adds per-broker metrics.
	//  "PER_TOPIC_PER_BROKER": adds per-topic-per-broker metrics.
	//  "PER_TOPIC_PER_PARTITION": most granular, adds per-partition metr...
	EnhancedMonitoring string `json:"enhanced_monitoring,omitempty" jsonschema:"enhanced_monitoring sets the level of CloudWatch metrics published by the cluster. 'DEFAULT': cluster-level and topic-level metrics. 'PER_BROKER': adds per-broker metrics. 'PER_TOPIC_PER_BROKER': adds..."`
	// jmx_exporter_enabled enables the Prometheus JMX Exporter on all brokers.
	//  When enabled, JMX metrics are available on port 11001 for Prometheus scraping.
	//  Provides detailed JVM and Kafka broker metrics.
	JmxExporterEnabled bool `json:"jmx_exporter_enabled,omitempty" jsonschema:"jmx_exporter_enabled enables the Prometheus JMX Exporter on all brokers. When enabled; JMX metrics are available on port 11001 for Prometheus scraping. Provides detailed JVM and Kafka broker metrics."`
	// node_exporter_enabled enables the Prometheus Node Exporter on all brokers.
	//  When enabled, host-level metrics (CPU, memory, disk, network) are available
	//  on port 11002 for Prometheus scraping.
	NodeExporterEnabled bool `json:"node_exporter_enabled,omitempty" jsonschema:"node_exporter_enabled enables the Prometheus Node Exporter on all brokers. When enabled; host-level metrics (CPU; memory; disk; network) are available on port 11002 for Prometheus scraping."`
	// public_access_type controls whether the cluster is reachable from the public internet.
	//  "DISABLED" (default): brokers are only reachable within the VPC.
	//  "SERVICE_PROVIDED_EIPS": AWS assigns Elastic IPs to brokers for public access.
	//  Public access requires specific authentication (SASL/IAM or SASL/S...
	PublicAccessType string `json:"public_access_type,omitempty" jsonschema:"public_access_type controls whether the cluster is reachable from the public internet. 'DISABLED' (default): brokers are only reachable within the VPC. 'SERVICE_PROVIDED_EIPS': AWS assigns Elastic IPs..."`
}

func (s *AwsMskClusterSpecInput) validate() error {
	if s.KafkaVersion == "" {
		return fmt.Errorf("kafka_version is required")
	}
	if s.InstanceType == "" {
		return fmt.Errorf("instance_type is required")
	}
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	if s.Authentication != nil {
		if err := s.Authentication.validate(); err != nil {
			return fmt.Errorf("authentication: %w", err)
		}
	}
	if s.Logging != nil {
		if err := s.Logging.validate(); err != nil {
			return fmt.Errorf("logging: %w", err)
		}
	}
	return nil
}

func (s *AwsMskClusterSpecInput) applyDefaults() {
	if s.ClientBrokerEncryption == "" {
		s.ClientBrokerEncryption = "TLS"
	}
	// default: InClusterEncryption = true (applied at zero-value)
	if s.Authentication != nil {
		s.Authentication.applyDefaults()
	}
	if s.Logging != nil {
		s.Logging.applyDefaults()
	}
}

func (s *AwsMskClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["kafka_version"] = s.KafkaVersion
	m["number_of_broker_nodes"] = s.NumberOfBrokerNodes
	m["instance_type"] = s.InstanceType
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if len(s.AllowedCidrBlocks) > 0 {
		m["allowed_cidr_blocks"] = s.AllowedCidrBlocks
	}
	if len(s.AssociateSecurityGroupIds) > 0 {
		m["associate_security_group_ids"] = s.AssociateSecurityGroupIds
	}
	if s.VpcId != "" {
		m["vpc_id"] = s.VpcId
	}
	if s.EbsVolumeSizeGib != 0 {
		m["ebs_volume_size_gib"] = s.EbsVolumeSizeGib
	}
	if s.ProvisionedThroughputEnabled {
		m["provisioned_throughput_enabled"] = s.ProvisionedThroughputEnabled
	}
	if s.ProvisionedThroughputMbs != 0 {
		m["provisioned_throughput_mbs"] = s.ProvisionedThroughputMbs
	}
	if s.StorageMode != "" {
		m["storage_mode"] = s.StorageMode
	}
	if s.KmsKeyArn != "" {
		m["kms_key_arn"] = s.KmsKeyArn
	}
	if s.ClientBrokerEncryption != "" {
		m["client_broker_encryption"] = s.ClientBrokerEncryption
	}
	if s.InClusterEncryption {
		m["in_cluster_encryption"] = s.InClusterEncryption
	}
	if s.Authentication != nil {
		m["authentication"] = s.Authentication.toMap()
	}
	if s.ConfigurationArn != "" {
		m["configuration_arn"] = s.ConfigurationArn
	}
	if s.ConfigurationRevision != 0 {
		m["configuration_revision"] = s.ConfigurationRevision
	}
	if len(s.ServerProperties) > 0 {
		m["server_properties"] = s.ServerProperties
	}
	if s.Logging != nil {
		m["logging"] = s.Logging.toMap()
	}
	if s.EnhancedMonitoring != "" {
		m["enhanced_monitoring"] = s.EnhancedMonitoring
	}
	if s.JmxExporterEnabled {
		m["jmx_exporter_enabled"] = s.JmxExporterEnabled
	}
	if s.NodeExporterEnabled {
		m["node_exporter_enabled"] = s.NodeExporterEnabled
	}
	if s.PublicAccessType != "" {
		m["public_access_type"] = s.PublicAccessType
	}
	return m
}

// AwsMskClusterAuthentication configures client authentication methods for the MSK cluster.
//
//	Multiple methods can be enabled simultaneously to support diverse client populations.
type AwsMskClusterAuthenticationInput struct {
	// sasl_iam_enabled enables SASL/IAM authentication.
	//  Recommended for most workloads. Clients authenticate using AWS IAM credentials
	//  (access key, role assumption, or instance profiles). No password management required.
	//  Brokers listen on port 9098 for SASL/IAM connections.
	SaslIamEnabled bool `json:"sasl_iam_enabled,omitempty" jsonschema:"sasl_iam_enabled enables SASL/IAM authentication. Recommended for most workloads. Clients authenticate using AWS IAM credentials (access key; role assumption; or instance profiles). No password manage..."`
	// sasl_scram_enabled enables SASL/SCRAM-SHA-512 authentication.
	//  Clients authenticate with username/password stored in AWS Secrets Manager.
	//  Useful for non-AWS clients that cannot use IAM. Brokers listen on port 9096.
	//  Secrets must be associated with the cluster via aws_msk_scram_secret_association.
	SaslScramEnabled bool `json:"sasl_scram_enabled,omitempty" jsonschema:"sasl_scram_enabled enables SASL/SCRAM-SHA-512 authentication. Clients authenticate with username/password stored in AWS Secrets Manager. Useful for non-AWS clients that cannot use IAM. Brokers listen ..."`
	// tls_enabled enables mutual TLS (mTLS) authentication.
	//  Clients present X.509 certificates signed by a private Certificate Authority.
	//  Requires tls_certificate_authority_arns to specify trusted CAs.
	//  Brokers listen on port 9094 for TLS connections.
	TlsEnabled bool `json:"tls_enabled,omitempty" jsonschema:"tls_enabled enables mutual TLS (mTLS) authentication. Clients present X.509 certificates signed by a private Certificate Authority. Requires tls_certificate_authority_arns to specify trusted CAs. Brok..."`
	// tls_certificate_authority_arns are the ARNs of ACM Private Certificate Authority resources
	//  trusted for client certificate validation. Required when tls_enabled is true.
	TlsCertificateAuthorityArns []string `json:"tls_certificate_authority_arns,omitempty" jsonschema:"tls_certificate_authority_arns are the ARNs of ACM Private Certificate Authority resources trusted for client certificate validation. Required when tls_enabled is true."`
	// unauthenticated allows clients to connect without any authentication.
	//  Not recommended for production. Useful for development or when network-level
	//  security (VPC + security groups) provides sufficient access control.
	Unauthenticated bool `json:"unauthenticated,omitempty" jsonschema:"unauthenticated allows clients to connect without any authentication. Not recommended for production. Useful for development or when network-level security (VPC + security groups) provides sufficient ..."`
}

func (s *AwsMskClusterAuthenticationInput) validate() error {
	return nil
}

func (s *AwsMskClusterAuthenticationInput) applyDefaults() {
}

func (s *AwsMskClusterAuthenticationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.SaslIamEnabled {
		m["sasl_iam_enabled"] = s.SaslIamEnabled
	}
	if s.SaslScramEnabled {
		m["sasl_scram_enabled"] = s.SaslScramEnabled
	}
	if s.TlsEnabled {
		m["tls_enabled"] = s.TlsEnabled
	}
	if len(s.TlsCertificateAuthorityArns) > 0 {
		m["tls_certificate_authority_arns"] = s.TlsCertificateAuthorityArns
	}
	if s.Unauthenticated {
		m["unauthenticated"] = s.Unauthenticated
	}
	return m
}

// AwsMskClusterCloudwatchLogging configures CloudWatch Logs delivery for broker logs.
type AwsMskClusterCloudwatchLoggingInput struct {
	// enabled controls whether broker logs are delivered to CloudWatch Logs.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled controls whether broker logs are delivered to CloudWatch Logs."`
	// log_group is the CloudWatch Logs group that receives broker logs.
	//  Required when enabled is true.
	LogGroup string `json:"log_group,omitempty" jsonschema:"log_group is the CloudWatch Logs group that receives broker logs. Required when enabled is true."`
}

func (s *AwsMskClusterCloudwatchLoggingInput) validate() error {
	return nil
}

func (s *AwsMskClusterCloudwatchLoggingInput) applyDefaults() {
}

func (s *AwsMskClusterCloudwatchLoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.LogGroup != "" {
		m["log_group"] = s.LogGroup
	}
	return m
}

// AwsMskClusterFirehoseLogging configures Kinesis Data Firehose delivery for broker logs.
type AwsMskClusterFirehoseLoggingInput struct {
	// enabled controls whether broker logs are delivered to Kinesis Data Firehose.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled controls whether broker logs are delivered to Kinesis Data Firehose."`
	// delivery_stream is the Firehose delivery stream that receives broker logs.
	//  Required when enabled is true.
	DeliveryStream string `json:"delivery_stream,omitempty" jsonschema:"delivery_stream is the Firehose delivery stream that receives broker logs. Required when enabled is true."`
}

func (s *AwsMskClusterFirehoseLoggingInput) validate() error {
	return nil
}

func (s *AwsMskClusterFirehoseLoggingInput) applyDefaults() {
}

func (s *AwsMskClusterFirehoseLoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.DeliveryStream != "" {
		m["delivery_stream"] = s.DeliveryStream
	}
	return m
}

// AwsMskClusterLogging configures broker log delivery destinations.
//
//	All three destinations can be enabled simultaneously.
type AwsMskClusterLoggingInput struct {
	// cloudwatch_logs configures delivery of broker logs to CloudWatch Logs.
	CloudwatchLogs *AwsMskClusterCloudwatchLoggingInput `json:"cloudwatch_logs,omitempty" jsonschema:"cloudwatch_logs configures delivery of broker logs to CloudWatch Logs."`
	// firehose configures delivery of broker logs to a Kinesis Data Firehose stream.
	Firehose *AwsMskClusterFirehoseLoggingInput `json:"firehose,omitempty" jsonschema:"firehose configures delivery of broker logs to a Kinesis Data Firehose stream."`
	// s3 configures delivery of broker logs to an S3 bucket.
	S3 *AwsMskClusterS3LoggingInput `json:"s3,omitempty" jsonschema:"s3 configures delivery of broker logs to an S3 bucket."`
}

func (s *AwsMskClusterLoggingInput) validate() error {
	if s.CloudwatchLogs != nil {
		if err := s.CloudwatchLogs.validate(); err != nil {
			return fmt.Errorf("cloudwatch_logs: %w", err)
		}
	}
	if s.Firehose != nil {
		if err := s.Firehose.validate(); err != nil {
			return fmt.Errorf("firehose: %w", err)
		}
	}
	if s.S3 != nil {
		if err := s.S3.validate(); err != nil {
			return fmt.Errorf("s3: %w", err)
		}
	}
	return nil
}

func (s *AwsMskClusterLoggingInput) applyDefaults() {
	if s.CloudwatchLogs != nil {
		s.CloudwatchLogs.applyDefaults()
	}
	if s.Firehose != nil {
		s.Firehose.applyDefaults()
	}
	if s.S3 != nil {
		s.S3.applyDefaults()
	}
}

func (s *AwsMskClusterLoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CloudwatchLogs != nil {
		m["cloudwatch_logs"] = s.CloudwatchLogs.toMap()
	}
	if s.Firehose != nil {
		m["firehose"] = s.Firehose.toMap()
	}
	if s.S3 != nil {
		m["s3"] = s.S3.toMap()
	}
	return m
}

// AwsMskClusterS3Logging configures S3 delivery for broker logs.
type AwsMskClusterS3LoggingInput struct {
	// enabled controls whether broker logs are delivered to S3.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled controls whether broker logs are delivered to S3."`
	// bucket is the S3 bucket that receives broker logs.
	//  Required when enabled is true.
	Bucket string `json:"bucket,omitempty" jsonschema:"bucket is the S3 bucket that receives broker logs. Required when enabled is true."`
	// prefix is an optional S3 key prefix for log objects.
	//  Example: "msk-logs/my-cluster/" produces keys like "msk-logs/my-cluster/broker-1/...".
	Prefix string `json:"prefix,omitempty" jsonschema:"prefix is an optional S3 key prefix for log objects. Example: 'msk-logs/my-cluster/' produces keys like 'msk-logs/my-cluster/broker-1/...'."`
}

func (s *AwsMskClusterS3LoggingInput) validate() error {
	return nil
}

func (s *AwsMskClusterS3LoggingInput) applyDefaults() {
}

func (s *AwsMskClusterS3LoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Bucket != "" {
		m["bucket"] = s.Bucket
	}
	if s.Prefix != "" {
		m["prefix"] = s.Prefix
	}
	return m
}

// ParseAwsMskCluster validates and normalizes a AwsMskCluster cloud_object.
func ParseAwsMskCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsMskCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsMskClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
