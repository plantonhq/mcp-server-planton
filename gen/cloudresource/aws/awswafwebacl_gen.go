// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsWafWebAcl represents an AWS WAFv2 Web Access Control List that protects
//
//	web applications from common exploits, bots, and volumetric attacks. The
//	Web ACL contains an ordered set of rules that inspect incoming requests and
//	take actions based on matching conditions.
//
//	Associate the Web ACL with ALB, API Gateway, CloudFront, AppSync, Cognito,
//	or App Runner by referencing the web_acl_arn output via StringValueOrRef.
type AwsWafWebAclSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Scope determines where the Web ACL can be used.
	//
	//  "REGIONAL" — protects ALB, API Gateway, AppSync, Cognito, App Runner
	//  resources in any AWS region.
	//
	//  "CLOUDFRONT" — protects CloudFront distributions. The Web ACL MUST be
	//  created in the us-east-1 region. Ensure your provider configuration
	//  targe...
	Scope string `json:"scope" jsonschema:"required,Scope determines where the Web ACL can be used. 'REGIONAL' — protects ALB; API Gateway; AppSync; Cognito; App Runner resources in any AWS region. 'CLOUDFRONT' — protects CloudFront distributions. ..."`
	// Action to take when no rule matches a request. This is the "baseline"
	//  security posture:
	//  - "allow" (permissive): allow all traffic unless a rule blocks it.
	//    Use when most traffic is legitimate (e.g., public website).
	//  - "block" (restrictive): block all traffic unless a rule allows it.
	//    Use when...
	DefaultAction *AwsWafWebAclDefaultActionInput `json:"default_action" jsonschema:"required,Action to take when no rule matches a request. This is the 'baseline' security posture: - 'allow' (permissive): allow all traffic unless a rule blocks it. Use when most traffic is legitimate (e.g.; pu..."`
	// Human-readable description of the Web ACL. Max 256 characters.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the Web ACL. Max 256 characters."`
	// Ordered set of rules evaluated against each incoming request. Rules are
	//  evaluated by priority (lowest number first). When a rule matches, its
	//  action is taken and evaluation stops for that request.
	//
	//  When no rules are provided, only the default_action applies. This is
	//  valid but uncommon — most W...
	Rules []*AwsWafWebAclRuleInput `json:"rules,omitempty" jsonschema:"Ordered set of rules evaluated against each incoming request. Rules are evaluated by priority (lowest number first). When a rule matches; its action is taken and evaluation stops for that request. Whe..."`
	// CloudWatch metrics configuration for the Web ACL itself.
	//
	//  When omitted, the IaC module applies sensible defaults:
	//  - cloudwatch_metrics_enabled = true
	//  - sampled_requests_enabled = true
	//  - metric_name = resource name
	VisibilityConfig *AwsWafWebAclVisibilityConfigInput `json:"visibility_config,omitempty" jsonschema:"CloudWatch metrics configuration for the Web ACL itself. When omitted; the IaC module applies sensible defaults: - cloudwatch_metrics_enabled = true - sampled_requests_enabled = true - metric_name = r..."`
	// Reusable response body templates that can be referenced by block actions
	//  via custom_response_body_key. Define branded error pages or structured
	//  error responses here and reference them by key from individual rules.
	//
	//  Each entry requires a unique key (used as the reference), content string,
	//  and con...
	CustomResponseBodies []*AwsWafWebAclCustomResponseBodyInput `json:"custom_response_bodies,omitempty" jsonschema:"Reusable response body templates that can be referenced by block actions via custom_response_body_key. Define branded error pages or structured error responses here and reference them by key from indi..."`
	// Domains to accept in web request tokens for CAPTCHA and Challenge actions.
	//  Required when using CAPTCHA/Challenge with multiple domains that share
	//  the same Web ACL. When omitted, tokens are scoped to the request domain.
	TokenDomains []string `json:"token_domains,omitempty" jsonschema:"Domains to accept in web request tokens for CAPTCHA and Challenge actions. Required when using CAPTCHA/Challenge with multiple domains that share the same Web ACL. When omitted; tokens are scoped to t..."`
	// Optional logging configuration. When provided, WAF sends detailed request
	//  logs to the specified destination (CloudWatch Logs, S3, or Kinesis
	//  Firehose).
	//
	//  Important naming constraint: the destination resource name must start with
	//  "aws-waf-logs-" (enforced by AWS). For example:
	//  - CloudWatch Log Gr...
	Logging *AwsWafWebAclLoggingConfigInput `json:"logging,omitempty" jsonschema:"Optional logging configuration. When provided; WAF sends detailed request logs to the specified destination (CloudWatch Logs; S3; or Kinesis Firehose). Important naming constraint: the destination res..."`
}

func (s *AwsWafWebAclSpecInput) validate() error {
	if s.Scope == "" {
		return fmt.Errorf("scope is required")
	}
	if s.DefaultAction == nil {
		return fmt.Errorf("default_action is required")
	}
	if s.DefaultAction != nil {
		if err := s.DefaultAction.validate(); err != nil {
			return fmt.Errorf("default_action: %w", err)
		}
	}
	for i, v := range s.Rules {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rules[%d]: %w", i, err)
			}
		}
	}
	if s.VisibilityConfig != nil {
		if err := s.VisibilityConfig.validate(); err != nil {
			return fmt.Errorf("visibility_config: %w", err)
		}
	}
	for i, v := range s.CustomResponseBodies {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("custom_response_bodies[%d]: %w", i, err)
			}
		}
	}
	if s.Logging != nil {
		if err := s.Logging.validate(); err != nil {
			return fmt.Errorf("logging: %w", err)
		}
	}
	return nil
}

func (s *AwsWafWebAclSpecInput) applyDefaults() {
	if s.DefaultAction != nil {
		s.DefaultAction.applyDefaults()
	}
	if s.VisibilityConfig != nil {
		s.VisibilityConfig.applyDefaults()
	}
	if s.Logging != nil {
		s.Logging.applyDefaults()
	}
}

func (s *AwsWafWebAclSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["scope"] = s.Scope
	if s.DefaultAction != nil {
		m["default_action"] = s.DefaultAction.toMap()
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if len(s.Rules) > 0 {
		items := make([]any, len(s.Rules))
		for i, v := range s.Rules {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rules"] = items
	}
	if s.VisibilityConfig != nil {
		m["visibility_config"] = s.VisibilityConfig.toMap()
	}
	if len(s.CustomResponseBodies) > 0 {
		items := make([]any, len(s.CustomResponseBodies))
		for i, v := range s.CustomResponseBodies {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["custom_response_bodies"] = items
	}
	if len(s.TokenDomains) > 0 {
		m["token_domains"] = s.TokenDomains
	}
	if s.Logging != nil {
		m["logging"] = s.Logging.toMap()
	}
	return m
}

// AwsWafWebAclCustomHeader defines an HTTP header name-value pair for custom
//
//	request handling (inserted into forwarded requests) or custom responses
//	(returned in block responses).
type AwsWafWebAclCustomHeaderInput struct {
	// HTTP header name (case-insensitive).
	Name string `json:"name" jsonschema:"required,HTTP header name (case-insensitive)."`
	// HTTP header value.
	Value string `json:"value" jsonschema:"required,HTTP header value."`
}

func (s *AwsWafWebAclCustomHeaderInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AwsWafWebAclCustomHeaderInput) applyDefaults() {
}

func (s *AwsWafWebAclCustomHeaderInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	return m
}

// AwsWafWebAclCustomResponse defines the HTTP response returned to clients
//
//	when a request is blocked. Use this to provide branded error pages or
//	structured API error responses instead of the default AWS WAF block page.
type AwsWafWebAclCustomResponseInput struct {
	// HTTP response status code to return. Range: 200-600.
	//  Common values: 403 (Forbidden), 429 (Too Many Requests), 503 (Service Unavailable).
	ResponseCode int32 `json:"response_code" jsonschema:"required,HTTP response status code to return. Range: 200-600. Common values: 403 (Forbidden); 429 (Too Many Requests); 503 (Service Unavailable)."`
	// Key referencing a custom_response_body defined at the Web ACL level.
	//  When set, the response body from the matching custom_response_body is
	//  returned with the specified response_code and content type.
	CustomResponseBodyKey string `json:"custom_response_body_key,omitempty" jsonschema:"Key referencing a custom_response_body defined at the Web ACL level. When set; the response body from the matching custom_response_body is returned with the specified response_code and content type."`
	// Additional HTTP headers to include in the block response.
	ResponseHeaders []*AwsWafWebAclCustomHeaderInput `json:"response_headers,omitempty" jsonschema:"Additional HTTP headers to include in the block response."`
}

func (s *AwsWafWebAclCustomResponseInput) validate() error {
	for i, v := range s.ResponseHeaders {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("response_headers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsWafWebAclCustomResponseInput) applyDefaults() {
}

func (s *AwsWafWebAclCustomResponseInput) toMap() map[string]any {
	m := make(map[string]any)
	m["response_code"] = s.ResponseCode
	if s.CustomResponseBodyKey != "" {
		m["custom_response_body_key"] = s.CustomResponseBodyKey
	}
	if len(s.ResponseHeaders) > 0 {
		items := make([]any, len(s.ResponseHeaders))
		for i, v := range s.ResponseHeaders {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["response_headers"] = items
	}
	return m
}

// AwsWafWebAclCustomResponseBody defines a reusable response body template
//
//	that can be referenced by block actions via custom_response_body_key.
//
//	Define common error pages once and reference them from multiple rules to
//	maintain consistent user experience across different block scenarios.
type AwsWafWebAclCustomResponseBodyInput struct {
	// Unique key used to reference this response body from custom_response
	//  configurations. Must be unique within the Web ACL.
	Key string `json:"key" jsonschema:"required,Unique key used to reference this response body from custom_response configurations. Must be unique within the Web ACL."`
	// The response body content (HTML, plain text, or JSON).
	Content string `json:"content" jsonschema:"required,The response body content (HTML; plain text; or JSON)."`
	// MIME type of the content.
	//  Valid values: "TEXT_PLAIN", "TEXT_HTML", "APPLICATION_JSON".
	ContentType string `json:"content_type" jsonschema:"required,MIME type of the content. Valid values: 'TEXT_PLAIN'; 'TEXT_HTML'; 'APPLICATION_JSON'."`
}

func (s *AwsWafWebAclCustomResponseBodyInput) validate() error {
	if s.Key == "" {
		return fmt.Errorf("key is required")
	}
	if s.Content == "" {
		return fmt.Errorf("content is required")
	}
	if s.ContentType == "" {
		return fmt.Errorf("content_type is required")
	}
	return nil
}

func (s *AwsWafWebAclCustomResponseBodyInput) applyDefaults() {
}

func (s *AwsWafWebAclCustomResponseBodyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["key"] = s.Key
	m["content"] = s.Content
	m["content_type"] = s.ContentType
	return m
}

// AwsWafWebAclDefaultAction defines the action taken when no rule matches
//
//	an incoming request.
type AwsWafWebAclDefaultActionInput struct {
	// Action type: "allow" or "block".
	Type string `json:"type" jsonschema:"required,Action type: 'allow' or 'block'."`
	// Custom response configuration for block actions. Only valid when
	//  type is "block". Specifies the HTTP response code and optional body
	//  to return to blocked requests.
	CustomResponse *AwsWafWebAclCustomResponseInput `json:"custom_response,omitempty" jsonschema:"Custom response configuration for block actions. Only valid when type is 'block'. Specifies the HTTP response code and optional body to return to blocked requests."`
	// Custom request headers to insert for allow actions. Only valid when
	//  type is "allow". Headers are added to the request before forwarding
	//  to the protected resource.
	CustomRequestHeaders []*AwsWafWebAclCustomHeaderInput `json:"custom_request_headers,omitempty" jsonschema:"Custom request headers to insert for allow actions. Only valid when type is 'allow'. Headers are added to the request before forwarding to the protected resource."`
}

func (s *AwsWafWebAclDefaultActionInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.CustomResponse != nil {
		if err := s.CustomResponse.validate(); err != nil {
			return fmt.Errorf("custom_response: %w", err)
		}
	}
	for i, v := range s.CustomRequestHeaders {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("custom_request_headers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsWafWebAclDefaultActionInput) applyDefaults() {
	if s.CustomResponse != nil {
		s.CustomResponse.applyDefaults()
	}
}

func (s *AwsWafWebAclDefaultActionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.CustomResponse != nil {
		m["custom_response"] = s.CustomResponse.toMap()
	}
	if len(s.CustomRequestHeaders) > 0 {
		items := make([]any, len(s.CustomRequestHeaders))
		for i, v := range s.CustomRequestHeaders {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["custom_request_headers"] = items
	}
	return m
}

// AwsWafWebAclForwardedIpConfig specifies how to extract the real client IP
//
//	from a forwarded header when the Web ACL sits behind a proxy, CDN, or
//	load balancer that adds client IP information to the request.
//
//	Used by: geo_match, ip_set_reference, and rate_based (FORWARDED_IP) rules.
type AwsWafWebAclForwardedIpConfigInput struct {
	// Name of the HTTP header containing the forwarded IP address.
	//  Common values: "X-Forwarded-For", "X-Real-IP", "True-Client-IP".
	HeaderName string `json:"header_name" jsonschema:"required,Name of the HTTP header containing the forwarded IP address. Common values: 'X-Forwarded-For'; 'X-Real-IP'; 'True-Client-IP'."`
	// How to handle requests with missing or invalid forwarded IP headers.
	//  - "MATCH": Treat as a match (allows the rule to process the request).
	//  - "NO_MATCH": Treat as no match (skips the rule for this request).
	FallbackBehavior string `json:"fallback_behavior" jsonschema:"required,How to handle requests with missing or invalid forwarded IP headers. - 'MATCH': Treat as a match (allows the rule to process the request). - 'NO_MATCH': Treat as no match (skips the rule for this requ..."`
	// Which IP address to use from multi-value forwarded headers.
	//  Only applicable for IP Set reference rules (ignored by geo_match and
	//  rate_based).
	//
	//  - "FIRST": Use the first IP in the header (closest to the client).
	//  - "LAST": Use the last IP (closest to the server).
	//  - "ANY": Match if any IP in the he...
	Position string `json:"position,omitempty" jsonschema:"Which IP address to use from multi-value forwarded headers. Only applicable for IP Set reference rules (ignored by geo_match and rate_based). - 'FIRST': Use the first IP in the header (closest to the ..."`
}

func (s *AwsWafWebAclForwardedIpConfigInput) validate() error {
	if s.HeaderName == "" {
		return fmt.Errorf("header_name is required")
	}
	if s.FallbackBehavior == "" {
		return fmt.Errorf("fallback_behavior is required")
	}
	return nil
}

func (s *AwsWafWebAclForwardedIpConfigInput) applyDefaults() {
}

func (s *AwsWafWebAclForwardedIpConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["header_name"] = s.HeaderName
	m["fallback_behavior"] = s.FallbackBehavior
	if s.Position != "" {
		m["position"] = s.Position
	}
	return m
}

// AwsWafWebAclGeoMatchStatement matches requests based on the country of
//
//	origin determined from the source IP address (or a forwarded IP header).
//
//	Common use cases:
//	- Block traffic from embargoed or high-risk countries
//	- Allow traffic only from countries where your service operates
//	- Apply different rules based on geographic region
type AwsWafWebAclGeoMatchStatementInput struct {
	// ISO 3166-1 alpha-2 country codes to match against.
	//  Examples: "US", "CA", "GB", "DE", "JP", "AU".
	//
	//  At least one country code is required.
	CountryCodes []string `json:"country_codes" jsonschema:"required,ISO 3166-1 alpha-2 country codes to match against. Examples: 'US'; 'CA'; 'GB'; 'DE'; 'JP'; 'AU'. At least one country code is required."`
	// Optional forwarded IP configuration. Use when the Web ACL is behind a
	//  proxy or CDN and the real client IP is in a forwarded header.
	ForwardedIpConfig *AwsWafWebAclForwardedIpConfigInput `json:"forwarded_ip_config,omitempty" jsonschema:"Optional forwarded IP configuration. Use when the Web ACL is behind a proxy or CDN and the real client IP is in a forwarded header."`
}

func (s *AwsWafWebAclGeoMatchStatementInput) validate() error {
	if len(s.CountryCodes) == 0 {
		return fmt.Errorf("country_codes is required")
	}
	if len(s.CountryCodes) < 1 {
		return fmt.Errorf("country_codes requires at least 1 items, got %d", len(s.CountryCodes))
	}
	if s.ForwardedIpConfig != nil {
		if err := s.ForwardedIpConfig.validate(); err != nil {
			return fmt.Errorf("forwarded_ip_config: %w", err)
		}
	}
	return nil
}

func (s *AwsWafWebAclGeoMatchStatementInput) applyDefaults() {
	if s.ForwardedIpConfig != nil {
		s.ForwardedIpConfig.applyDefaults()
	}
}

func (s *AwsWafWebAclGeoMatchStatementInput) toMap() map[string]any {
	m := make(map[string]any)
	m["country_codes"] = s.CountryCodes
	if s.ForwardedIpConfig != nil {
		m["forwarded_ip_config"] = s.ForwardedIpConfig.toMap()
	}
	return m
}

// AwsWafWebAclIpSetReferenceStatement matches requests against a pre-defined
//
//	WAFv2 IP Set. IP Sets are separate WAFv2 resources that contain lists of
//	IP addresses or CIDR ranges.
//
//	Common use cases:
//	- Allowlist known partner or office IP ranges
//	- Blocklist known malicious IP addresses
//	- Restrict API access to specific IP ranges
//
//	Note: AwsWafIpSet is not yet an OpenMCF component. Provide the IP Set
//	ARN as a plain string. IP Sets must be created separately via the AWS
//	console, CLI, or Terraform.
type AwsWafWebAclIpSetReferenceStatementInput struct {
	// ARN of the WAFv2 IP Set to reference. The IP Set must exist in the
	//  same region and account as the Web ACL (or in us-east-1 for CLOUDFRONT
	//  scope).
	Arn string `json:"arn" jsonschema:"required,ARN of the WAFv2 IP Set to reference. The IP Set must exist in the same region and account as the Web ACL (or in us-east-1 for CLOUDFRONT scope)."`
	// Optional forwarded IP configuration. Use when the Web ACL is behind a
	//  proxy or CDN and the real client IP is in a forwarded header.
	//
	//  When set, the position field controls which IP from the forwarded header
	//  is matched against the IP Set (FIRST, LAST, or ANY).
	ForwardedIpConfig *AwsWafWebAclForwardedIpConfigInput `json:"forwarded_ip_config,omitempty" jsonschema:"Optional forwarded IP configuration. Use when the Web ACL is behind a proxy or CDN and the real client IP is in a forwarded header. When set; the position field controls which IP from the forwarded he..."`
}

func (s *AwsWafWebAclIpSetReferenceStatementInput) validate() error {
	if s.Arn == "" {
		return fmt.Errorf("arn is required")
	}
	if s.ForwardedIpConfig != nil {
		if err := s.ForwardedIpConfig.validate(); err != nil {
			return fmt.Errorf("forwarded_ip_config: %w", err)
		}
	}
	return nil
}

func (s *AwsWafWebAclIpSetReferenceStatementInput) applyDefaults() {
	if s.ForwardedIpConfig != nil {
		s.ForwardedIpConfig.applyDefaults()
	}
}

func (s *AwsWafWebAclIpSetReferenceStatementInput) toMap() map[string]any {
	m := make(map[string]any)
	m["arn"] = s.Arn
	if s.ForwardedIpConfig != nil {
		m["forwarded_ip_config"] = s.ForwardedIpConfig.toMap()
	}
	return m
}

// AwsWafWebAclLoggingConfig defines the logging destination and optional
//
//	field redaction for WAF request logs.
//
//	WAF logging captures detailed information about each request inspected by
//	the Web ACL, including matched rules, actions taken, and request metadata.
//	This data is essential for security monitoring, forensics, and WAF tuning.
//
//	Important: The destination resource name must start with "aws-waf-logs-"
//	(enforced by AWS at the API level).
type AwsWafWebAclLoggingConfigInput struct {
	// ARN of the logging destination. Must be one of:
	//  - CloudWatch Logs log group ARN
	//  - S3 bucket ARN
	//  - Kinesis Firehose delivery stream ARN
	//
	//  The destination resource name must start with "aws-waf-logs-".
	//
	//  No default_kind is set because the destination can be any of three
	//  different resource types.
	DestinationArn string `json:"destination_arn" jsonschema:"required,ARN of the logging destination. Must be one of: - CloudWatch Logs log group ARN - S3 bucket ARN - Kinesis Firehose delivery stream ARN The destination resource name must start with 'aws-waf-logs-'. No..."`
	// HTTP header names to redact from logs. Redacted headers appear as
	//  "REDACTED" in log entries instead of their actual values.
	//
	//  Common headers to redact: "Authorization", "Cookie", "X-Api-Key".
	RedactedHeaderNames []string `json:"redacted_header_names,omitempty" jsonschema:"HTTP header names to redact from logs. Redacted headers appear as 'REDACTED' in log entries instead of their actual values. Common headers to redact: 'Authorization'; 'Cookie'; 'X-Api-Key'."`
	// Redact the URI path from log entries. When true, the URI path appears
	//  as "REDACTED" in logs.
	RedactUriPath bool `json:"redact_uri_path,omitempty" jsonschema:"Redact the URI path from log entries. When true; the URI path appears as 'REDACTED' in logs."`
	// Redact the query string from log entries. When true, query string
	//  parameters appear as "REDACTED" in logs.
	RedactQueryString bool `json:"redact_query_string,omitempty" jsonschema:"Redact the query string from log entries. When true; query string parameters appear as 'REDACTED' in logs."`
}

func (s *AwsWafWebAclLoggingConfigInput) validate() error {
	if s.DestinationArn == "" {
		return fmt.Errorf("destination_arn is required")
	}
	return nil
}

func (s *AwsWafWebAclLoggingConfigInput) applyDefaults() {
}

func (s *AwsWafWebAclLoggingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["destination_arn"] = s.DestinationArn
	if len(s.RedactedHeaderNames) > 0 {
		m["redacted_header_names"] = s.RedactedHeaderNames
	}
	if s.RedactUriPath {
		m["redact_uri_path"] = s.RedactUriPath
	}
	if s.RedactQueryString {
		m["redact_query_string"] = s.RedactQueryString
	}
	return m
}

// AwsWafWebAclManagedRuleGroupStatement references an AWS Managed Rule Group
//
//	or a marketplace rule group. Managed rule groups are pre-configured
//	collections of rules maintained by AWS or third-party vendors.
//
//	Common AWS Managed Rule Groups:
//	- AWSManagedRulesCommonRuleSet — Core rule set (XSS, file inclusion, etc.)
//	- AWSManagedRulesKnownBadInputsRuleSet — Known bad input patterns
//	- AWSManagedRulesSQLiRuleSet — SQL injection protection
//	- AWSManagedRulesAmazonIpReputationList — IP reputation filtering
//	- AWSManagedRulesAnonymousIpList — Anonymous IP blocking (VPN, Tor, etc.)
//	- AWSManagedRulesBotControlRuleSet — Bot detection and control
//
//	Each managed rule group consumes Web ACL Capacity Units (WCUs). The total
//	across all rules must not exceed 5,000 WCUs per Web ACL.
type AwsWafWebAclManagedRuleGroupStatementInput struct {
	// Name of the managed rule group (e.g., "AWSManagedRulesCommonRuleSet").
	Name string `json:"name" jsonschema:"required,Name of the managed rule group (e.g.; 'AWSManagedRulesCommonRuleSet')."`
	// Vendor that publishes the rule group.
	//  "AWS" for AWS Managed Rules, or the marketplace vendor name.
	VendorName string `json:"vendor_name" jsonschema:"required,Vendor that publishes the rule group. 'AWS' for AWS Managed Rules; or the marketplace vendor name."`
	// Pin to a specific version of the managed rule group (e.g., "Version_1.0").
	//  When omitted, WAF uses the vendor's default (typically the latest) version.
	//  Pinning prevents unexpected behavior changes when the vendor updates rules.
	Version string `json:"version,omitempty" jsonschema:"Pin to a specific version of the managed rule group (e.g.; 'Version_1.0'). When omitted; WAF uses the vendor's default (typically the latest) version. Pinning prevents unexpected behavior changes when..."`
	// Override the action for specific rules within the managed group. This is
	//  essential for tuning: you can set individual rules to "count" while the
	//  rest of the group enforces, allowing you to identify false positives
	//  before enabling enforcement.
	RuleActionOverrides []*AwsWafWebAclRuleActionOverrideInput `json:"rule_action_overrides,omitempty" jsonschema:"Override the action for specific rules within the managed group. This is essential for tuning: you can set individual rules to 'count' while the rest of the group enforces; allowing you to identify fa..."`
	// Optional scope-down statement to narrow which requests the managed rule
	//  group evaluates. Only requests matching the scope-down statement are
	//  inspected by the rule group.
	//
	//  Provide the raw AWS WAFv2 JSON statement structure as a Struct. Uses the
	//  same format as the custom_statement escape hatch on ...
	ScopeDownStatement any `json:"scope_down_statement,omitempty" jsonschema:"Optional scope-down statement to narrow which requests the managed rule group evaluates. Only requests matching the scope-down statement are inspected by the rule group. Provide the raw AWS WAFv2 JSON..."`
}

func (s *AwsWafWebAclManagedRuleGroupStatementInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.VendorName == "" {
		return fmt.Errorf("vendor_name is required")
	}
	for i, v := range s.RuleActionOverrides {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("rule_action_overrides[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsWafWebAclManagedRuleGroupStatementInput) applyDefaults() {
}

func (s *AwsWafWebAclManagedRuleGroupStatementInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["vendor_name"] = s.VendorName
	if s.Version != "" {
		m["version"] = s.Version
	}
	if len(s.RuleActionOverrides) > 0 {
		items := make([]any, len(s.RuleActionOverrides))
		for i, v := range s.RuleActionOverrides {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["rule_action_overrides"] = items
	}
	// unsupported type "object" for field ScopeDownStatement
	return m
}

// AwsWafWebAclRateBasedStatement tracks and limits request rates. When the
//
//	rate of requests from a tracked key (typically an IP address) exceeds the
//	configured limit within an evaluation window, the rule's action is taken
//	for subsequent requests from that key until the rate drops below the limit.
//
//	Rate-based rules are effective against:
//	- DDoS attacks and HTTP floods
//	- Brute-force login attempts
//	- API abuse and scraping
//	- Credential stuffing
type AwsWafWebAclRateBasedStatementInput struct {
	// Maximum number of requests allowed from a single tracked key within the
	//  evaluation window. When exceeded, the rule's action applies.
	//  Range: 10 to 2,000,000,000.
	//
	//  Common values:
	//  - 100-500: Strict API rate limiting
	//  - 1000-2000: Standard web application protection
	//  - 10000+: DDoS mitigation for hi...
	Limit int32 `json:"limit" jsonschema:"required,Maximum number of requests allowed from a single tracked key within the evaluation window. When exceeded; the rule's action applies. Range: 10 to 2;000;000;000. Common values: - 100-500: Strict API ra..."`
	// Duration in seconds over which request rates are evaluated.
	//  Valid values: 60, 120, 300 (default), 600.
	//  Shorter windows detect bursts faster but may produce more false positives.
	EvaluationWindowSec int32 `json:"evaluation_window_sec,omitempty" jsonschema:"Duration in seconds over which request rates are evaluated. Valid values: 60; 120; 300 (default); 600. Shorter windows detect bursts faster but may produce more false positives."`
	// How to aggregate requests for rate tracking.
	//
	//  Valid values:
	//  - "IP" (default): Track by source IP address. Simplest and most common.
	//  - "FORWARDED_IP": Track by IP from a forwarded header (e.g., X-Forwarded-For).
	//    Requires forwarded_ip_config. Use when behind a proxy or CDN.
	//  - "CONSTANT": Count ...
	AggregateKeyType string `json:"aggregate_key_type,omitempty" jsonschema:"How to aggregate requests for rate tracking. Valid values: - 'IP' (default): Track by source IP address. Simplest and most common. - 'FORWARDED_IP': Track by IP from a forwarded header (e.g.; X-Forwar..."`
	// Forwarded IP configuration. Required when aggregate_key_type is
	//  "FORWARDED_IP". Specifies which header contains the real client IP
	//  and how to handle missing or invalid headers.
	ForwardedIpConfig *AwsWafWebAclForwardedIpConfigInput `json:"forwarded_ip_config,omitempty" jsonschema:"Forwarded IP configuration. Required when aggregate_key_type is 'FORWARDED_IP'. Specifies which header contains the real client IP and how to handle missing or invalid headers."`
	// Optional scope-down statement to narrow which requests are counted
	//  toward the rate limit. Only requests matching this statement contribute
	//  to the rate calculation.
	//
	//  Example (rate limit only POST requests to /login):
	//    scopeDownStatement:
	//      ByteMatchStatement:
	//        SearchString: /login
	//      ...
	ScopeDownStatement any `json:"scope_down_statement,omitempty" jsonschema:"Optional scope-down statement to narrow which requests are counted toward the rate limit. Only requests matching this statement contribute to the rate calculation. Example (rate limit only POST reques..."`
}

func (s *AwsWafWebAclRateBasedStatementInput) validate() error {
	if s.ForwardedIpConfig != nil {
		if err := s.ForwardedIpConfig.validate(); err != nil {
			return fmt.Errorf("forwarded_ip_config: %w", err)
		}
	}
	return nil
}

func (s *AwsWafWebAclRateBasedStatementInput) applyDefaults() {
	if s.ForwardedIpConfig != nil {
		s.ForwardedIpConfig.applyDefaults()
	}
}

func (s *AwsWafWebAclRateBasedStatementInput) toMap() map[string]any {
	m := make(map[string]any)
	m["limit"] = s.Limit
	if s.EvaluationWindowSec != 0 {
		m["evaluation_window_sec"] = s.EvaluationWindowSec
	}
	if s.AggregateKeyType != "" {
		m["aggregate_key_type"] = s.AggregateKeyType
	}
	if s.ForwardedIpConfig != nil {
		m["forwarded_ip_config"] = s.ForwardedIpConfig.toMap()
	}
	// unsupported type "object" for field ScopeDownStatement
	return m
}

// AwsWafWebAclRule defines a single rule in the Web ACL. Each rule evaluates
//
//	incoming requests against a statement (match condition) and takes an action
//	when the statement matches.
//
//	Rules are evaluated in priority order (lowest priority number first). When
//	a rule matches, its action is taken and evaluation stops for that request.
//
//	There are two action models:
//	- Custom rules (rate_based, geo_match, ip_set_reference, custom_statement):
//	  Use the `action` field to specify what happens on match.
//	- Rule group rules (managed_rule_group): Use the `override_action` field
//	  to either use the group's own actions ("none") or override everything
//	  to count ("count") for testing/monitoring.
type AwsWafWebAclRuleInput struct {
	// Unique name for this rule. Used in CloudWatch metrics and log entries.
	//  1-128 characters, must be unique within the Web ACL.
	Name string `json:"name" jsonschema:"required,Unique name for this rule. Used in CloudWatch metrics and log entries. 1-128 characters; must be unique within the Web ACL."`
	// Evaluation priority. Lower numbers are evaluated first. Must be unique
	//  across all rules in the Web ACL. Range: 0-2147483647.
	Priority int32 `json:"priority" jsonschema:"required,Evaluation priority. Lower numbers are evaluated first. Must be unique across all rules in the Web ACL. Range: 0-2147483647."`
	// AWS Managed Rule Group or marketplace rule group. Use override_action
	//  to control whether the group's own actions apply ("none") or are
	//  overridden to count ("count").
	ManagedRuleGroup *AwsWafWebAclManagedRuleGroupStatementInput `json:"managed_rule_group,omitempty" jsonschema:"AWS Managed Rule Group or marketplace rule group. Use override_action to control whether the group's own actions apply ('none') or are overridden to count ('count')."`
	// Rate-based rule that tracks and limits request rates from individual
	//  IP addresses or custom aggregation keys. Use action to specify what
	//  happens when the rate limit is exceeded.
	RateBased *AwsWafWebAclRateBasedStatementInput `json:"rate_based,omitempty" jsonschema:"Rate-based rule that tracks and limits request rates from individual IP addresses or custom aggregation keys. Use action to specify what happens when the rate limit is exceeded."`
	// Geographic match statement that matches requests based on the country
	//  of origin. Use action to allow or block traffic from specific countries.
	GeoMatch *AwsWafWebAclGeoMatchStatementInput `json:"geo_match,omitempty" jsonschema:"Geographic match statement that matches requests based on the country of origin. Use action to allow or block traffic from specific countries."`
	// IP set reference statement that matches requests against a pre-defined
	//  WAFv2 IP Set (allowlist or blocklist). Use action to specify behavior.
	IpSetReference *AwsWafWebAclIpSetReferenceStatementInput `json:"ip_set_reference,omitempty" jsonschema:"IP set reference statement that matches requests against a pre-defined WAFv2 IP Set (allowlist or blocklist). Use action to specify behavior."`
	// Escape hatch for any WAFv2 statement type not modeled as a first-class
	//  message. Provide the raw AWS WAFv2 JSON statement structure as a Struct.
	//
	//  Common uses: SqliMatchStatement, XssMatchStatement, ByteMatchStatement,
	//  RegexMatchStatement, SizeConstraintStatement, LabelMatchStatement,
	//  AndStatement...
	CustomStatement any `json:"custom_statement,omitempty" jsonschema:"Escape hatch for any WAFv2 statement type not modeled as a first-class message. Provide the raw AWS WAFv2 JSON statement structure as a Struct. Common uses: SqliMatchStatement; XssMatchStatement; Byte..."`
	// Action for custom rules (rate_based, geo_match, ip_set_reference,
	//  custom_statement). Specifies what happens when the rule matches.
	//
	//  Valid values: "allow", "block", "count", "captcha", "challenge".
	//
	//  Required for custom rules. Must NOT be set for managed_rule_group rules.
	Action string `json:"action,omitempty" jsonschema:"Action for custom rules (rate_based; geo_match; ip_set_reference; custom_statement). Specifies what happens when the rule matches. Valid values: 'allow'; 'block'; 'count'; 'captcha'; 'challenge'. Requ..."`
	// Override action for rule group rules (managed_rule_group). Controls
	//  whether the group's own actions are used or overridden.
	//
	//  Valid values:
	//  - "none": Use the rule group's configured actions as-is (most common).
	//  - "count": Override all actions to count (useful for testing/monitoring
	//    a new rule ...
	OverrideAction string `json:"override_action,omitempty" jsonschema:"Override action for rule group rules (managed_rule_group). Controls whether the group's own actions are used or overridden. Valid values: - 'none': Use the rule group's configured actions as-is (most ..."`
	// Custom response for block actions. Only valid when action is "block".
	//  Specifies the HTTP response code and optional body.
	CustomResponse *AwsWafWebAclCustomResponseInput `json:"custom_response,omitempty" jsonschema:"Custom response for block actions. Only valid when action is 'block'. Specifies the HTTP response code and optional body."`
	// Custom request headers to insert for allow/count/captcha/challenge actions.
	//  Headers are added to the request before forwarding to the protected resource.
	CustomRequestHeaders []*AwsWafWebAclCustomHeaderInput `json:"custom_request_headers,omitempty" jsonschema:"Custom request headers to insert for allow/count/captcha/challenge actions. Headers are added to the request before forwarding to the protected resource."`
	// Labels added to requests that match this rule. Labels are key-value pairs
	//  (namespace:name format) that can be matched by LabelMatchStatement in
	//  subsequent rules, enabling multi-stage rule evaluation.
	RuleLabels []string `json:"rule_labels,omitempty" jsonschema:"Labels added to requests that match this rule. Labels are key-value pairs (namespace:name format) that can be matched by LabelMatchStatement in subsequent rules; enabling multi-stage rule evaluation."`
	// CloudWatch metrics configuration for this rule. When omitted, the IaC
	//  module applies sensible defaults:
	//  - cloudwatch_metrics_enabled = true
	//  - sampled_requests_enabled = true
	//  - metric_name = rule name
	VisibilityConfig *AwsWafWebAclVisibilityConfigInput `json:"visibility_config,omitempty" jsonschema:"CloudWatch metrics configuration for this rule. When omitted; the IaC module applies sensible defaults: - cloudwatch_metrics_enabled = true - sampled_requests_enabled = true - metric_name = rule name"`
}

func (s *AwsWafWebAclRuleInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.ManagedRuleGroup != nil {
		if err := s.ManagedRuleGroup.validate(); err != nil {
			return fmt.Errorf("managed_rule_group: %w", err)
		}
	}
	if s.RateBased != nil {
		if err := s.RateBased.validate(); err != nil {
			return fmt.Errorf("rate_based: %w", err)
		}
	}
	if s.GeoMatch != nil {
		if err := s.GeoMatch.validate(); err != nil {
			return fmt.Errorf("geo_match: %w", err)
		}
	}
	if s.IpSetReference != nil {
		if err := s.IpSetReference.validate(); err != nil {
			return fmt.Errorf("ip_set_reference: %w", err)
		}
	}
	if s.CustomResponse != nil {
		if err := s.CustomResponse.validate(); err != nil {
			return fmt.Errorf("custom_response: %w", err)
		}
	}
	for i, v := range s.CustomRequestHeaders {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("custom_request_headers[%d]: %w", i, err)
			}
		}
	}
	if s.VisibilityConfig != nil {
		if err := s.VisibilityConfig.validate(); err != nil {
			return fmt.Errorf("visibility_config: %w", err)
		}
	}
	return nil
}

func (s *AwsWafWebAclRuleInput) applyDefaults() {
	if s.ManagedRuleGroup != nil {
		s.ManagedRuleGroup.applyDefaults()
	}
	if s.RateBased != nil {
		s.RateBased.applyDefaults()
	}
	if s.GeoMatch != nil {
		s.GeoMatch.applyDefaults()
	}
	if s.IpSetReference != nil {
		s.IpSetReference.applyDefaults()
	}
	if s.CustomResponse != nil {
		s.CustomResponse.applyDefaults()
	}
	if s.VisibilityConfig != nil {
		s.VisibilityConfig.applyDefaults()
	}
}

func (s *AwsWafWebAclRuleInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["priority"] = s.Priority
	if s.ManagedRuleGroup != nil {
		m["managed_rule_group"] = s.ManagedRuleGroup.toMap()
	}
	if s.RateBased != nil {
		m["rate_based"] = s.RateBased.toMap()
	}
	if s.GeoMatch != nil {
		m["geo_match"] = s.GeoMatch.toMap()
	}
	if s.IpSetReference != nil {
		m["ip_set_reference"] = s.IpSetReference.toMap()
	}
	// unsupported type "object" for field CustomStatement
	if s.Action != "" {
		m["action"] = s.Action
	}
	if s.OverrideAction != "" {
		m["override_action"] = s.OverrideAction
	}
	if s.CustomResponse != nil {
		m["custom_response"] = s.CustomResponse.toMap()
	}
	if len(s.CustomRequestHeaders) > 0 {
		items := make([]any, len(s.CustomRequestHeaders))
		for i, v := range s.CustomRequestHeaders {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["custom_request_headers"] = items
	}
	if len(s.RuleLabels) > 0 {
		m["rule_labels"] = s.RuleLabels
	}
	if s.VisibilityConfig != nil {
		m["visibility_config"] = s.VisibilityConfig.toMap()
	}
	return m
}

// AwsWafWebAclRuleActionOverride overrides the action for a specific rule
//
//	within a managed rule group. This is the primary mechanism for tuning
//	managed rule groups without disabling them entirely.
//
//	Common workflow: Set a new managed rule group's override_action to "none"
//	(enforce), but override specific noisy rules to "count" until you verify
//	they don't produce false positives. Then remove the override to enforce.
type AwsWafWebAclRuleActionOverrideInput struct {
	// Name of the rule within the managed group to override.
	//  Must match a rule name defined in the managed rule group.
	Name string `json:"name" jsonschema:"required,Name of the rule within the managed group to override. Must match a rule name defined in the managed rule group."`
	// Action to use instead of the rule's configured action.
	//  Valid values: "allow", "block", "count", "captcha", "challenge".
	//  Most commonly set to "count" for monitoring without enforcement.
	Action string `json:"action" jsonschema:"required,Action to use instead of the rule's configured action. Valid values: 'allow'; 'block'; 'count'; 'captcha'; 'challenge'. Most commonly set to 'count' for monitoring without enforcement."`
}

func (s *AwsWafWebAclRuleActionOverrideInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Action == "" {
		return fmt.Errorf("action is required")
	}
	return nil
}

func (s *AwsWafWebAclRuleActionOverrideInput) applyDefaults() {
}

func (s *AwsWafWebAclRuleActionOverrideInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["action"] = s.Action
	return m
}

// AwsWafWebAclVisibilityConfig controls CloudWatch metrics and request
//
//	sampling for a Web ACL or individual rule. Every Web ACL and rule in AWS
//	requires a visibility configuration.
//
//	When this message is omitted (on either the spec or a rule), the IaC module
//	applies sensible defaults: metrics enabled, sampling enabled, and the
//	metric_name derived from the resource or rule name.
type AwsWafWebAclVisibilityConfigInput struct {
	// Enable CloudWatch metrics for this Web ACL or rule.
	//  Default: true (applied by IaC module when omitted).
	CloudwatchMetricsEnabled bool `json:"cloudwatch_metrics_enabled,omitempty" jsonschema:"Enable CloudWatch metrics for this Web ACL or rule. Default: true (applied by IaC module when omitted)."`
	// Enable request sampling for this Web ACL or rule. Sampled requests are
	//  viewable in the AWS WAF console for debugging rule matches.
	//  Default: true (applied by IaC module when omitted).
	SampledRequestsEnabled bool `json:"sampled_requests_enabled,omitempty" jsonschema:"Enable request sampling for this Web ACL or rule. Sampled requests are viewable in the AWS WAF console for debugging rule matches. Default: true (applied by IaC module when omitted)."`
	// CloudWatch metric name for this Web ACL or rule. Must be unique within
	//  the Web ACL's rules.
	//  Default: resource name (Web ACL) or rule name (applied by IaC module).
	MetricName string `json:"metric_name,omitempty" jsonschema:"CloudWatch metric name for this Web ACL or rule. Must be unique within the Web ACL's rules. Default: resource name (Web ACL) or rule name (applied by IaC module)."`
}

func (s *AwsWafWebAclVisibilityConfigInput) validate() error {
	return nil
}

func (s *AwsWafWebAclVisibilityConfigInput) applyDefaults() {
}

func (s *AwsWafWebAclVisibilityConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CloudwatchMetricsEnabled {
		m["cloudwatch_metrics_enabled"] = s.CloudwatchMetricsEnabled
	}
	if s.SampledRequestsEnabled {
		m["sampled_requests_enabled"] = s.SampledRequestsEnabled
	}
	if s.MetricName != "" {
		m["metric_name"] = s.MetricName
	}
	return m
}

// ParseAwsWafWebAcl validates and normalizes a AwsWafWebAcl cloud_object.
func ParseAwsWafWebAcl(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsWafWebAcl"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsWafWebAclSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
