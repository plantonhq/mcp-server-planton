// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsCodeBuildProject is a deployment component for creating and managing
//
//	AWS CodeBuild projects with an optional webhook for source-triggered builds.
//	CodeBuild compiles source code, runs tests, and produces deployable artifacts
//	in fully managed build containers.
type AwsCodeBuildProjectSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// source defines where the build input comes from and how to fetch it.
	Source *AwsCodeBuildSourceInput `json:"source" jsonschema:"required,source defines where the build input comes from and how to fetch it."`
	// environment defines the build container: image, compute, and variables.
	Environment *AwsCodeBuildEnvironmentInput `json:"environment" jsonschema:"required,environment defines the build container: image; compute; and variables."`
	// artifacts defines where the build output goes.
	Artifacts *AwsCodeBuildArtifactsInput `json:"artifacts" jsonschema:"required,artifacts defines where the build output goes."`
	// service_role is the IAM role ARN that grants CodeBuild permission to
	//  access source code, write artifacts, publish logs, and interact with
	//  other AWS services during the build.
	ServiceRole string `json:"service_role" jsonschema:"required,service_role is the IAM role ARN that grants CodeBuild permission to access source code; write artifacts; publish logs; and interact with other AWS services during the build."`
	// description is a human-readable description of the project (max 255 chars).
	Description string `json:"description,omitempty" jsonschema:"description is a human-readable description of the project (max 255 chars)."`
	// encryption_key is the ARN of a KMS key used to encrypt build artifacts.
	//  If omitted, CodeBuild uses the AWS-managed key for S3.
	EncryptionKey string `json:"encryption_key,omitempty" jsonschema:"encryption_key is the ARN of a KMS key used to encrypt build artifacts. If omitted; CodeBuild uses the AWS-managed key for S3."`
	// build_timeout is the maximum duration of a single build, in minutes.
	//  Range: 5-2160 (36 hours). Default: 60.
	BuildTimeout int32 `json:"build_timeout,omitempty" jsonschema:"build_timeout is the maximum duration of a single build; in minutes. Range: 5-2160 (36 hours). Default: 60."`
	// queued_timeout is the maximum time a build can wait in the queue before
	//  timing out, in minutes. Range: 5-480 (8 hours). Default: 480.
	QueuedTimeout int32 `json:"queued_timeout,omitempty" jsonschema:"queued_timeout is the maximum time a build can wait in the queue before timing out; in minutes. Range: 5-480 (8 hours). Default: 480."`
	// concurrent_build_limit caps the number of concurrent builds. Useful for
	//  cost control. Minimum 1. Omit to allow unlimited concurrency.
	ConcurrentBuildLimit int32 `json:"concurrent_build_limit,omitempty" jsonschema:"concurrent_build_limit caps the number of concurrent builds. Useful for cost control. Minimum 1. Omit to allow unlimited concurrency."`
	// source_version is the default branch, tag, or commit ID to build.
	//  For GitHub: branch name, tag, or full commit SHA.
	//  For S3: object version ID.
	SourceVersion string `json:"source_version,omitempty" jsonschema:"source_version is the default branch; tag; or commit ID to build. For GitHub: branch name; tag; or full commit SHA. For S3: object version ID."`
	// cache configures build caching to speed up subsequent builds.
	Cache *AwsCodeBuildCacheInput `json:"cache,omitempty" jsonschema:"cache configures build caching to speed up subsequent builds."`
	// logs_config controls where build logs are sent.
	LogsConfig *AwsCodeBuildLogsConfigInput `json:"logs_config,omitempty" jsonschema:"logs_config controls where build logs are sent."`
	// vpc_config places the build in a VPC, giving it access to private
	//  resources such as RDS databases, ElastiCache clusters, or internal APIs.
	VpcConfig *AwsCodeBuildVpcConfigInput `json:"vpc_config,omitempty" jsonschema:"vpc_config places the build in a VPC; giving it access to private resources such as RDS databases; ElastiCache clusters; or internal APIs."`
	// webhook configures automatic build triggers from the source provider.
	//  Only valid when source type supports webhooks: GITHUB, BITBUCKET,
	//  GITHUB_ENTERPRISE, GITLAB, GITLAB_SELF_MANAGED, CODECOMMIT.
	//  Omit for CodePipeline-triggered or manual-only projects.
	Webhook *AwsCodeBuildWebhookInput `json:"webhook,omitempty" jsonschema:"webhook configures automatic build triggers from the source provider. Only valid when source type supports webhooks: GITHUB; BITBUCKET; GITHUB_ENTERPRISE; GITLAB; GITLAB_SELF_MANAGED; CODECOMMIT. Omit..."`
}

func (s *AwsCodeBuildProjectSpecInput) validate() error {
	if s.Source == nil {
		return fmt.Errorf("source is required")
	}
	if s.Source != nil {
		if err := s.Source.validate(); err != nil {
			return fmt.Errorf("source: %w", err)
		}
	}
	if s.Environment == nil {
		return fmt.Errorf("environment is required")
	}
	if s.Environment != nil {
		if err := s.Environment.validate(); err != nil {
			return fmt.Errorf("environment: %w", err)
		}
	}
	if s.Artifacts == nil {
		return fmt.Errorf("artifacts is required")
	}
	if s.Artifacts != nil {
		if err := s.Artifacts.validate(); err != nil {
			return fmt.Errorf("artifacts: %w", err)
		}
	}
	if s.ServiceRole == "" {
		return fmt.Errorf("service_role is required")
	}
	if s.Cache != nil {
		if err := s.Cache.validate(); err != nil {
			return fmt.Errorf("cache: %w", err)
		}
	}
	if s.LogsConfig != nil {
		if err := s.LogsConfig.validate(); err != nil {
			return fmt.Errorf("logs_config: %w", err)
		}
	}
	if s.VpcConfig != nil {
		if err := s.VpcConfig.validate(); err != nil {
			return fmt.Errorf("vpc_config: %w", err)
		}
	}
	if s.Webhook != nil {
		if err := s.Webhook.validate(); err != nil {
			return fmt.Errorf("webhook: %w", err)
		}
	}
	return nil
}

func (s *AwsCodeBuildProjectSpecInput) applyDefaults() {
	if s.Source != nil {
		s.Source.applyDefaults()
	}
	if s.Environment != nil {
		s.Environment.applyDefaults()
	}
	if s.Artifacts != nil {
		s.Artifacts.applyDefaults()
	}
	if s.BuildTimeout == 0 {
		s.BuildTimeout = 60
	}
	if s.QueuedTimeout == 0 {
		s.QueuedTimeout = 480
	}
	if s.Cache != nil {
		s.Cache.applyDefaults()
	}
	if s.LogsConfig != nil {
		s.LogsConfig.applyDefaults()
	}
	if s.VpcConfig != nil {
		s.VpcConfig.applyDefaults()
	}
	if s.Webhook != nil {
		s.Webhook.applyDefaults()
	}
}

func (s *AwsCodeBuildProjectSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.Source != nil {
		m["source"] = s.Source.toMap()
	}
	if s.Environment != nil {
		m["environment"] = s.Environment.toMap()
	}
	if s.Artifacts != nil {
		m["artifacts"] = s.Artifacts.toMap()
	}
	m["service_role"] = s.ServiceRole
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.EncryptionKey != "" {
		m["encryption_key"] = s.EncryptionKey
	}
	if s.BuildTimeout != 0 {
		m["build_timeout"] = s.BuildTimeout
	}
	if s.QueuedTimeout != 0 {
		m["queued_timeout"] = s.QueuedTimeout
	}
	if s.ConcurrentBuildLimit != 0 {
		m["concurrent_build_limit"] = s.ConcurrentBuildLimit
	}
	if s.SourceVersion != "" {
		m["source_version"] = s.SourceVersion
	}
	if s.Cache != nil {
		m["cache"] = s.Cache.toMap()
	}
	if s.LogsConfig != nil {
		m["logs_config"] = s.LogsConfig.toMap()
	}
	if s.VpcConfig != nil {
		m["vpc_config"] = s.VpcConfig.toMap()
	}
	if s.Webhook != nil {
		m["webhook"] = s.Webhook.toMap()
	}
	return m
}

// AwsCodeBuildArtifacts defines the build output configuration.
type AwsCodeBuildArtifactsInput struct {
	// type is the artifact output type.
	//    NO_ARTIFACTS:  No output artifacts (CI-only builds, or push to ECR in buildspec)
	//    S3:            Write artifacts to an S3 bucket
	//    CODEPIPELINE:  Artifacts managed by CodePipeline
	Type string `json:"type" jsonschema:"required,type is the artifact output type. NO_ARTIFACTS: No output artifacts (CI-only builds; or push to ECR in buildspec) S3: Write artifacts to an S3 bucket CODEPIPELINE: Artifacts managed by CodePipeline"`
	// location is the S3 bucket name for artifact output.
	//  Required when type is S3.
	Location string `json:"location,omitempty" jsonschema:"location is the S3 bucket name for artifact output. Required when type is S3."`
	// name is the artifact output name (object key in S3).
	Name string `json:"name,omitempty" jsonschema:"name is the artifact output name (object key in S3)."`
	// path is the S3 prefix for the artifact output.
	Path string `json:"path,omitempty" jsonschema:"path is the S3 prefix for the artifact output."`
	// packaging controls how artifacts are packaged.
	//    NONE: No packaging (files uploaded as-is)
	//    ZIP:  Files packaged into a ZIP archive
	Packaging string `json:"packaging,omitempty" jsonschema:"packaging controls how artifacts are packaged. NONE: No packaging (files uploaded as-is) ZIP: Files packaged into a ZIP archive"`
	// namespace_type controls whether artifact paths include the build ID.
	//    NONE:     No namespace (artifacts at path/name)
	//    BUILD_ID: Artifacts at path/<build-id>/name
	NamespaceType string `json:"namespace_type,omitempty" jsonschema:"namespace_type controls whether artifact paths include the build ID. NONE: No namespace (artifacts at path/name) BUILD_ID: Artifacts at path/<build-id>/name"`
	// encryption_disabled disables server-side encryption for artifacts.
	//  By default, CodeBuild encrypts artifacts using the project's encryption key.
	EncryptionDisabled bool `json:"encryption_disabled,omitempty" jsonschema:"encryption_disabled disables server-side encryption for artifacts. By default; CodeBuild encrypts artifacts using the project's encryption key."`
}

func (s *AwsCodeBuildArtifactsInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *AwsCodeBuildArtifactsInput) applyDefaults() {
}

func (s *AwsCodeBuildArtifactsInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.Location != "" {
		m["location"] = s.Location
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Packaging != "" {
		m["packaging"] = s.Packaging
	}
	if s.NamespaceType != "" {
		m["namespace_type"] = s.NamespaceType
	}
	if s.EncryptionDisabled {
		m["encryption_disabled"] = s.EncryptionDisabled
	}
	return m
}

// AwsCodeBuildCache configures build caching to speed up subsequent builds.
type AwsCodeBuildCacheInput struct {
	// type is the cache type.
	//    NO_CACHE: Caching disabled (default)
	//    S3:       Cache stored in an S3 bucket
	//    LOCAL:    Cache stored on the build host (ephemeral, useful for Docker layers)
	Type string `json:"type,omitempty" jsonschema:"type is the cache type. NO_CACHE: Caching disabled (default) S3: Cache stored in an S3 bucket LOCAL: Cache stored on the build host (ephemeral; useful for Docker layers)"`
	// location is the S3 bucket and optional prefix for cache storage.
	//  Required when type is S3. Format: "bucket-name" or "bucket-name/prefix".
	Location string `json:"location,omitempty" jsonschema:"location is the S3 bucket and optional prefix for cache storage. Required when type is S3. Format: 'bucket-name' or 'bucket-name/prefix'."`
	// modes specifies what to cache when type is LOCAL.
	//    LOCAL_SOURCE_CACHE:        Cache Git metadata
	//    LOCAL_DOCKER_LAYER_CACHE:  Cache Docker layers
	//    LOCAL_CUSTOM_CACHE:        Cache paths specified in buildspec
	Modes []string `json:"modes,omitempty" jsonschema:"modes specifies what to cache when type is LOCAL. LOCAL_SOURCE_CACHE: Cache Git metadata LOCAL_DOCKER_LAYER_CACHE: Cache Docker layers LOCAL_CUSTOM_CACHE: Cache paths specified in buildspec"`
}

func (s *AwsCodeBuildCacheInput) validate() error {
	return nil
}

func (s *AwsCodeBuildCacheInput) applyDefaults() {
	if s.Type == "" {
		s.Type = "NO_CACHE"
	}
}

func (s *AwsCodeBuildCacheInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Type != "" {
		m["type"] = s.Type
	}
	if s.Location != "" {
		m["location"] = s.Location
	}
	if len(s.Modes) > 0 {
		m["modes"] = s.Modes
	}
	return m
}

// AwsCodeBuildCloudWatchLogs configures CloudWatch Logs for builds.
type AwsCodeBuildCloudWatchLogsInput struct {
	// status controls whether CloudWatch logging is enabled.
	//  Default: ENABLED.
	Status string `json:"status,omitempty" jsonschema:"status controls whether CloudWatch logging is enabled. Default: ENABLED."`
	// group_name is the CloudWatch Logs log group name.
	//  If omitted, CodeBuild creates a default log group.
	GroupName string `json:"group_name,omitempty" jsonschema:"group_name is the CloudWatch Logs log group name. If omitted; CodeBuild creates a default log group."`
	// stream_name is the CloudWatch Logs log stream name prefix.
	//  If omitted, CodeBuild generates a default stream name.
	StreamName string `json:"stream_name,omitempty" jsonschema:"stream_name is the CloudWatch Logs log stream name prefix. If omitted; CodeBuild generates a default stream name."`
}

func (s *AwsCodeBuildCloudWatchLogsInput) validate() error {
	return nil
}

func (s *AwsCodeBuildCloudWatchLogsInput) applyDefaults() {
	if s.Status == "" {
		s.Status = "ENABLED"
	}
}

func (s *AwsCodeBuildCloudWatchLogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Status != "" {
		m["status"] = s.Status
	}
	if s.GroupName != "" {
		m["group_name"] = s.GroupName
	}
	if s.StreamName != "" {
		m["stream_name"] = s.StreamName
	}
	return m
}

// AwsCodeBuildEnvironment defines the build container configuration.
type AwsCodeBuildEnvironmentInput struct {
	// type is the build environment type.
	//    LINUX_CONTAINER:              Standard Linux (x86_64)
	//    LINUX_GPU_CONTAINER:          Linux with GPU support
	//    ARM_CONTAINER:                Linux (ARM64)
	//    WINDOWS_SERVER_2019_CONTAINER: Windows Server 2019
	//    WINDOWS_SERVER_2022_CONTAINER: Windows Server 2...
	Type string `json:"type" jsonschema:"required,type is the build environment type. LINUX_CONTAINER: Standard Linux (x86_64) LINUX_GPU_CONTAINER: Linux with GPU support ARM_CONTAINER: Linux (ARM64) WINDOWS_SERVER_2019_CONTAINER: Windows Server 2019..."`
	// compute_type is the compute capacity for the build container.
	//    Standard:     BUILD_GENERAL1_SMALL, BUILD_GENERAL1_MEDIUM,
	//                  BUILD_GENERAL1_LARGE, BUILD_GENERAL1_XLARGE, BUILD_GENERAL1_2XLARGE
	//    Lambda:       BUILD_LAMBDA_1GB through BUILD_LAMBDA_10GB
	ComputeType string `json:"compute_type" jsonschema:"required,compute_type is the compute capacity for the build container. Standard: BUILD_GENERAL1_SMALL; BUILD_GENERAL1_MEDIUM; BUILD_GENERAL1_LARGE; BUILD_GENERAL1_XLARGE; BUILD_GENERAL1_2XLARGE Lambda: BUILD_L..."`
	// image is the Docker image identifier for the build environment.
	//  Use AWS managed images (e.g., "aws/codebuild/amazonlinux2-x86_64-standard:5.0")
	//  or a custom image URI from ECR or Docker Hub.
	Image string `json:"image" jsonschema:"required,image is the Docker image identifier for the build environment. Use AWS managed images (e.g.; 'aws/codebuild/amazonlinux2-x86_64-standard:5.0') or a custom image URI from ECR or Docker Hub."`
	// privileged_mode enables Docker daemon access inside the build container.
	//  Required for building Docker images. Only applicable to non-Lambda types.
	PrivilegedMode bool `json:"privileged_mode,omitempty" jsonschema:"privileged_mode enables Docker daemon access inside the build container. Required for building Docker images. Only applicable to non-Lambda types."`
	// image_pull_credentials_type controls how the build image is pulled.
	//    CODEBUILD:    CodeBuild uses its own credentials (default, for AWS images)
	//    SERVICE_ROLE: CodeBuild uses the project's service role (for ECR private images)
	ImagePullCredentialsType string `json:"image_pull_credentials_type,omitempty" jsonschema:"image_pull_credentials_type controls how the build image is pulled. CODEBUILD: CodeBuild uses its own credentials (default; for AWS images) SERVICE_ROLE: CodeBuild uses the project's service role (for..."`
	// environment_variables define key-value pairs available during the build.
	//  Supports plaintext values, SSM Parameter Store references, and
	//  Secrets Manager references.
	EnvironmentVariables []*AwsCodeBuildEnvironmentVariableInput `json:"environment_variables,omitempty" jsonschema:"environment_variables define key-value pairs available during the build. Supports plaintext values; SSM Parameter Store references; and Secrets Manager references."`
	// registry_credential provides credentials for pulling the build image
	//  from a private Docker registry. Only needed when image_pull_credentials_type
	//  is SERVICE_ROLE and the image is in a non-ECR private registry.
	RegistryCredential *AwsCodeBuildRegistryCredentialInput `json:"registry_credential,omitempty" jsonschema:"registry_credential provides credentials for pulling the build image from a private Docker registry. Only needed when image_pull_credentials_type is SERVICE_ROLE and the image is in a non-ECR private ..."`
}

func (s *AwsCodeBuildEnvironmentInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.ComputeType == "" {
		return fmt.Errorf("compute_type is required")
	}
	if s.Image == "" {
		return fmt.Errorf("image is required")
	}
	for i, v := range s.EnvironmentVariables {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("environment_variables[%d]: %w", i, err)
			}
		}
	}
	if s.RegistryCredential != nil {
		if err := s.RegistryCredential.validate(); err != nil {
			return fmt.Errorf("registry_credential: %w", err)
		}
	}
	return nil
}

func (s *AwsCodeBuildEnvironmentInput) applyDefaults() {
	if s.ImagePullCredentialsType == "" {
		s.ImagePullCredentialsType = "CODEBUILD"
	}
	if s.RegistryCredential != nil {
		s.RegistryCredential.applyDefaults()
	}
}

func (s *AwsCodeBuildEnvironmentInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	m["compute_type"] = s.ComputeType
	m["image"] = s.Image
	if s.PrivilegedMode {
		m["privileged_mode"] = s.PrivilegedMode
	}
	if s.ImagePullCredentialsType != "" {
		m["image_pull_credentials_type"] = s.ImagePullCredentialsType
	}
	if len(s.EnvironmentVariables) > 0 {
		items := make([]any, len(s.EnvironmentVariables))
		for i, v := range s.EnvironmentVariables {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["environment_variables"] = items
	}
	if s.RegistryCredential != nil {
		m["registry_credential"] = s.RegistryCredential.toMap()
	}
	return m
}

// AwsCodeBuildEnvironmentVariable defines a build environment variable.
type AwsCodeBuildEnvironmentVariableInput struct {
	// name is the environment variable name.
	Name string `json:"name" jsonschema:"required,name is the environment variable name."`
	// value is the environment variable value. For PARAMETER_STORE type,
	//  this is the SSM parameter name. For SECRETS_MANAGER, this is the
	//  secret ARN or name.
	Value string `json:"value" jsonschema:"required,value is the environment variable value. For PARAMETER_STORE type; this is the SSM parameter name. For SECRETS_MANAGER; this is the secret ARN or name."`
	// type controls how the value is interpreted.
	//    PLAINTEXT:       Value is used as-is (default)
	//    PARAMETER_STORE: Value is an SSM Parameter Store parameter name
	//    SECRETS_MANAGER: Value is a Secrets Manager secret ARN or name
	Type string `json:"type,omitempty" jsonschema:"type controls how the value is interpreted. PLAINTEXT: Value is used as-is (default) PARAMETER_STORE: Value is an SSM Parameter Store parameter name SECRETS_MANAGER: Value is a Secrets Manager secret ..."`
}

func (s *AwsCodeBuildEnvironmentVariableInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AwsCodeBuildEnvironmentVariableInput) applyDefaults() {
	if s.Type == "" {
		s.Type = "PLAINTEXT"
	}
}

func (s *AwsCodeBuildEnvironmentVariableInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	if s.Type != "" {
		m["type"] = s.Type
	}
	return m
}

// AwsCodeBuildLogsConfig controls where build logs are sent.
type AwsCodeBuildLogsConfigInput struct {
	// cloudwatch_logs configures CloudWatch Logs for build output.
	CloudwatchLogs *AwsCodeBuildCloudWatchLogsInput `json:"cloudwatch_logs,omitempty" jsonschema:"cloudwatch_logs configures CloudWatch Logs for build output."`
	// s3_logs configures S3 logging for build output.
	S3Logs *AwsCodeBuildS3LogsInput `json:"s3_logs,omitempty" jsonschema:"s3_logs configures S3 logging for build output."`
}

func (s *AwsCodeBuildLogsConfigInput) validate() error {
	if s.CloudwatchLogs != nil {
		if err := s.CloudwatchLogs.validate(); err != nil {
			return fmt.Errorf("cloudwatch_logs: %w", err)
		}
	}
	if s.S3Logs != nil {
		if err := s.S3Logs.validate(); err != nil {
			return fmt.Errorf("s3_logs: %w", err)
		}
	}
	return nil
}

func (s *AwsCodeBuildLogsConfigInput) applyDefaults() {
	if s.CloudwatchLogs != nil {
		s.CloudwatchLogs.applyDefaults()
	}
	if s.S3Logs != nil {
		s.S3Logs.applyDefaults()
	}
}

func (s *AwsCodeBuildLogsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.CloudwatchLogs != nil {
		m["cloudwatch_logs"] = s.CloudwatchLogs.toMap()
	}
	if s.S3Logs != nil {
		m["s3_logs"] = s.S3Logs.toMap()
	}
	return m
}

// AwsCodeBuildRegistryCredential provides credentials for pulling images
//
//	from a private Docker registry.
type AwsCodeBuildRegistryCredentialInput struct {
	// credential is the ARN or name of the Secrets Manager secret containing
	//  the Docker registry credentials (username + password).
	Credential string `json:"credential" jsonschema:"required,credential is the ARN or name of the Secrets Manager secret containing the Docker registry credentials (username + password)."`
	// credential_provider is the credential provider type.
	//  Currently only SECRETS_MANAGER is supported by AWS.
	CredentialProvider string `json:"credential_provider" jsonschema:"required,credential_provider is the credential provider type. Currently only SECRETS_MANAGER is supported by AWS."`
}

func (s *AwsCodeBuildRegistryCredentialInput) validate() error {
	if s.Credential == "" {
		return fmt.Errorf("credential is required")
	}
	if s.CredentialProvider == "" {
		return fmt.Errorf("credential_provider is required")
	}
	return nil
}

func (s *AwsCodeBuildRegistryCredentialInput) applyDefaults() {
}

func (s *AwsCodeBuildRegistryCredentialInput) toMap() map[string]any {
	m := make(map[string]any)
	m["credential"] = s.Credential
	m["credential_provider"] = s.CredentialProvider
	return m
}

// AwsCodeBuildS3Logs configures S3 logging for builds.
type AwsCodeBuildS3LogsInput struct {
	// status controls whether S3 logging is enabled.
	//  Default: DISABLED.
	Status string `json:"status,omitempty" jsonschema:"status controls whether S3 logging is enabled. Default: DISABLED."`
	// location is the S3 bucket and prefix for log storage.
	//  Format: "bucket-name" or "bucket-name/prefix".
	Location string `json:"location,omitempty" jsonschema:"location is the S3 bucket and prefix for log storage. Format: 'bucket-name' or 'bucket-name/prefix'."`
	// encryption_disabled disables server-side encryption for log files.
	EncryptionDisabled bool `json:"encryption_disabled,omitempty" jsonschema:"encryption_disabled disables server-side encryption for log files."`
}

func (s *AwsCodeBuildS3LogsInput) validate() error {
	return nil
}

func (s *AwsCodeBuildS3LogsInput) applyDefaults() {
	if s.Status == "" {
		s.Status = "DISABLED"
	}
}

func (s *AwsCodeBuildS3LogsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Status != "" {
		m["status"] = s.Status
	}
	if s.Location != "" {
		m["location"] = s.Location
	}
	if s.EncryptionDisabled {
		m["encryption_disabled"] = s.EncryptionDisabled
	}
	return m
}

// AwsCodeBuildSource defines the source code location and retrieval settings.
type AwsCodeBuildSourceInput struct {
	// type is the source provider.
	//    GITHUB:                GitHub.com repository (via CodeStar Connections)
	//    BITBUCKET:             Bitbucket Cloud repository
	//    CODECOMMIT:            AWS CodeCommit repository
	//    CODEPIPELINE:          Source provided by CodePipeline (no location needed)
	//    GITHUB_EN...
	Type string `json:"type" jsonschema:"required,type is the source provider. GITHUB: GitHub.com repository (via CodeStar Connections) BITBUCKET: Bitbucket Cloud repository CODECOMMIT: AWS CodeCommit repository CODEPIPELINE: Source provided by CodeP..."`
	// location is the source code repository URL or S3 path.
	//  Required for all types except CODEPIPELINE and NO_SOURCE.
	//  Format depends on type:
	//    GITHUB/BITBUCKET/GITLAB: https URL (e.g., https://github.com/owner/repo.git)
	//    CODECOMMIT: HTTPS clone URL
	//    S3: bucket/path (e.g., my-bucket/source.zip)
	//   ...
	Location string `json:"location,omitempty" jsonschema:"location is the source code repository URL or S3 path. Required for all types except CODEPIPELINE and NO_SOURCE. Format depends on type: GITHUB/BITBUCKET/GITLAB: https URL (e.g.; https://github.com/ow..."`
	// buildspec is the build specification, either as an inline YAML string or
	//  a path relative to the source root (e.g., "buildspec.yml").
	//  If omitted, CodeBuild looks for buildspec.yml at the source root.
	//  Required when source type is NO_SOURCE.
	Buildspec string `json:"buildspec,omitempty" jsonschema:"buildspec is the build specification; either as an inline YAML string or a path relative to the source root (e.g.; 'buildspec.yml'). If omitted; CodeBuild looks for buildspec.yml at the source root. R..."`
	// git_clone_depth limits the Git clone depth. 0 means full clone.
	//  Only applicable for Git-based source types.
	GitCloneDepth int32 `json:"git_clone_depth,omitempty" jsonschema:"git_clone_depth limits the Git clone depth. 0 means full clone. Only applicable for Git-based source types."`
	// report_build_status reports build start and finish status back to the
	//  source provider (e.g., GitHub commit status checks).
	//  Only applicable for GITHUB, BITBUCKET, GITHUB_ENTERPRISE, GITLAB, GITLAB_SELF_MANAGED.
	ReportBuildStatus bool `json:"report_build_status,omitempty" jsonschema:"report_build_status reports build start and finish status back to the source provider (e.g.; GitHub commit status checks). Only applicable for GITHUB; BITBUCKET; GITHUB_ENTERPRISE; GITLAB; GITLAB_SELF..."`
	// fetch_submodules controls whether Git submodules are fetched during the
	//  source download phase. Only applicable for Git-based source types.
	FetchSubmodules bool `json:"fetch_submodules,omitempty" jsonschema:"fetch_submodules controls whether Git submodules are fetched during the source download phase. Only applicable for Git-based source types."`
}

func (s *AwsCodeBuildSourceInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	return nil
}

func (s *AwsCodeBuildSourceInput) applyDefaults() {
}

func (s *AwsCodeBuildSourceInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	if s.Location != "" {
		m["location"] = s.Location
	}
	if s.Buildspec != "" {
		m["buildspec"] = s.Buildspec
	}
	if s.GitCloneDepth != 0 {
		m["git_clone_depth"] = s.GitCloneDepth
	}
	if s.ReportBuildStatus {
		m["report_build_status"] = s.ReportBuildStatus
	}
	if s.FetchSubmodules {
		m["fetch_submodules"] = s.FetchSubmodules
	}
	return m
}

// AwsCodeBuildVpcConfig places the build environment inside a VPC, enabling
//
//	access to private resources (RDS, ElastiCache, internal APIs, etc.).
type AwsCodeBuildVpcConfigInput struct {
	// vpc_id is the VPC where build containers are launched.
	VpcId string `json:"vpc_id" jsonschema:"required,vpc_id is the VPC where build containers are launched."`
	// subnet_ids are the VPC subnets where build containers are placed.
	//  Use private subnets for security. Maximum 16 subnets.
	SubnetIds []string `json:"subnet_ids" jsonschema:"required,subnet_ids are the VPC subnets where build containers are placed. Use private subnets for security. Maximum 16 subnets."`
	// security_group_ids are the VPC security groups applied to build containers.
	//  Maximum 5 security groups.
	SecurityGroupIds []string `json:"security_group_ids" jsonschema:"required,security_group_ids are the VPC security groups applied to build containers. Maximum 5 security groups."`
}

func (s *AwsCodeBuildVpcConfigInput) validate() error {
	if s.VpcId == "" {
		return fmt.Errorf("vpc_id is required")
	}
	if len(s.SubnetIds) == 0 {
		return fmt.Errorf("subnet_ids is required")
	}
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	if len(s.SecurityGroupIds) == 0 {
		return fmt.Errorf("security_group_ids is required")
	}
	if len(s.SecurityGroupIds) < 1 {
		return fmt.Errorf("security_group_ids requires at least 1 items, got %d", len(s.SecurityGroupIds))
	}
	return nil
}

func (s *AwsCodeBuildVpcConfigInput) applyDefaults() {
}

func (s *AwsCodeBuildVpcConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["vpc_id"] = s.VpcId
	m["subnet_ids"] = s.SubnetIds
	m["security_group_ids"] = s.SecurityGroupIds
	return m
}

// AwsCodeBuildWebhook configures automatic build triggers from the source
//
//	provider. Creates a webhook that listens for repository events.
type AwsCodeBuildWebhookInput struct {
	// build_type controls the build type triggered by the webhook.
	//    BUILD:             Standard single build (default)
	//    BUILD_BATCH:       Batch build
	BuildType string `json:"build_type,omitempty" jsonschema:"build_type controls the build type triggered by the webhook. BUILD: Standard single build (default) BUILD_BATCH: Batch build"`
	// filter_groups define which repository events trigger a build.
	//  Multiple groups are OR'd together — a build triggers if ANY group matches.
	//  Within a group, filters are AND'd — ALL filters in the group must match.
	FilterGroups []*AwsCodeBuildWebhookFilterGroupInput `json:"filter_groups,omitempty" jsonschema:"filter_groups define which repository events trigger a build. Multiple groups are OR'd together — a build triggers if ANY group matches. Within a group; filters are AND'd — ALL filters in the grou..."`
}

func (s *AwsCodeBuildWebhookInput) validate() error {
	for i, v := range s.FilterGroups {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("filter_groups[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsCodeBuildWebhookInput) applyDefaults() {
}

func (s *AwsCodeBuildWebhookInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.BuildType != "" {
		m["build_type"] = s.BuildType
	}
	if len(s.FilterGroups) > 0 {
		items := make([]any, len(s.FilterGroups))
		for i, v := range s.FilterGroups {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["filter_groups"] = items
	}
	return m
}

// AwsCodeBuildWebhookFilter defines a single condition for webhook filtering.
type AwsCodeBuildWebhookFilterInput struct {
	// type is the event field to match against.
	//    EVENT:            Event type (PUSH, PULL_REQUEST_CREATED, etc.)
	//    BASE_REF:         Base branch for PRs (regex)
	//    HEAD_REF:         Branch or tag name (regex)
	//    ACTOR_ACCOUNT_ID: Source provider account ID
	//    FILE_PATH:        Changed file paths (regex...
	Type string `json:"type" jsonschema:"required,type is the event field to match against. EVENT: Event type (PUSH; PULL_REQUEST_CREATED; etc.) BASE_REF: Base branch for PRs (regex) HEAD_REF: Branch or tag name (regex) ACTOR_ACCOUNT_ID: Source provi..."`
	// pattern is the regex pattern or comma-separated event list to match.
	//  For EVENT type: comma-separated values like "PUSH, PULL_REQUEST_CREATED".
	//  For other types: a regex pattern (e.g., "^refs/heads/main$").
	Pattern string `json:"pattern" jsonschema:"required,pattern is the regex pattern or comma-separated event list to match. For EVENT type: comma-separated values like 'PUSH; PULL_REQUEST_CREATED'. For other types: a regex pattern (e.g.; '^refs/heads/main..."`
	// exclude_matched_pattern inverts the match — the filter passes when the
	//  pattern does NOT match. Useful for excluding branches or paths.
	ExcludeMatchedPattern bool `json:"exclude_matched_pattern,omitempty" jsonschema:"exclude_matched_pattern inverts the match — the filter passes when the pattern does NOT match. Useful for excluding branches or paths."`
}

func (s *AwsCodeBuildWebhookFilterInput) validate() error {
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	if s.Pattern == "" {
		return fmt.Errorf("pattern is required")
	}
	return nil
}

func (s *AwsCodeBuildWebhookFilterInput) applyDefaults() {
}

func (s *AwsCodeBuildWebhookFilterInput) toMap() map[string]any {
	m := make(map[string]any)
	m["type"] = s.Type
	m["pattern"] = s.Pattern
	if s.ExcludeMatchedPattern {
		m["exclude_matched_pattern"] = s.ExcludeMatchedPattern
	}
	return m
}

// AwsCodeBuildWebhookFilterGroup is a set of filters that are AND'd together.
//
//	A build triggers when ALL filters in the group match the webhook event.
type AwsCodeBuildWebhookFilterGroupInput struct {
	// filters are the individual conditions in this group.
	Filters []*AwsCodeBuildWebhookFilterInput `json:"filters,omitempty" jsonschema:"filters are the individual conditions in this group."`
}

func (s *AwsCodeBuildWebhookFilterGroupInput) validate() error {
	if len(s.Filters) < 1 {
		return fmt.Errorf("filters requires at least 1 items, got %d", len(s.Filters))
	}
	for i, v := range s.Filters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("filters[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsCodeBuildWebhookFilterGroupInput) applyDefaults() {
}

func (s *AwsCodeBuildWebhookFilterGroupInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Filters) > 0 {
		items := make([]any, len(s.Filters))
		for i, v := range s.Filters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["filters"] = items
	}
	return m
}

// ParseAwsCodeBuildProject validates and normalizes a AwsCodeBuildProject cloud_object.
func ParseAwsCodeBuildProject(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsCodeBuildProject"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsCodeBuildProjectSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
