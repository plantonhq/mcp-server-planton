// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-opensearch-domain
type AwsOpenSearchDomainSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// OpenSearch or Elasticsearch engine version. Format: "OpenSearch_X.Y" (e.g.,
	//  "OpenSearch_2.11") or "Elasticsearch_X.Y" (e.g., "Elasticsearch_7.10").
	//  Changing to an incompatible version forces domain recreation.
	EngineVersion string `json:"engine_version" jsonschema:"required,OpenSearch or Elasticsearch engine version. Format: 'OpenSearch_X.Y' (e.g.; 'OpenSearch_2.11') or 'Elasticsearch_X.Y' (e.g.; 'Elasticsearch_7.10'). Changing to an incompatible version forces domain re..."`
	// Cluster topology: data nodes, dedicated masters, zone awareness, warm/cold storage.
	ClusterConfig *AwsOpenSearchDomainClusterConfigInput `json:"cluster_config" jsonschema:"required,Cluster topology: data nodes; dedicated masters; zone awareness; warm/cold storage."`
	// EBS volume configuration for data node storage. Required for most instance types
	//  (all except certain storage-optimized types that use instance storage).
	EbsOptions *AwsOpenSearchDomainEbsOptionsInput `json:"ebs_options" jsonschema:"required,EBS volume configuration for data node storage. Required for most instance types (all except certain storage-optimized types that use instance storage)."`
	// Enable encryption at rest for indices and automated snapshots. Uses the
	//  AWS-managed `aws/es` key unless `kms_key_id` is provided.
	//  ForceNew when disabling on older engine versions.
	EncryptAtRestEnabled bool `json:"encrypt_at_rest_enabled,omitempty" jsonschema:"Enable encryption at rest for indices and automated snapshots. Uses the AWS-managed 'aws/es' key unless 'kms_key_id' is provided. ForceNew when disabling on older engine versions."`
	// Customer-managed KMS key ARN or ID for at-rest encryption. ForceNew — the
	//  KMS key cannot be changed after domain creation.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key ARN or ID for at-rest encryption. ForceNew — the KMS key cannot be changed after domain creation."`
	// Enable TLS encryption for all traffic between nodes in the cluster.
	//  Strongly recommended for production.
	NodeToNodeEncryptionEnabled bool `json:"node_to_node_encryption_enabled,omitempty" jsonschema:"Enable TLS encryption for all traffic between nodes in the cluster. Strongly recommended for production."`
	// VPC placement configuration. When provided, the domain is deployed into VPC
	//  subnets and is not publicly accessible. ForceNew — adding or removing VPC
	//  options destroys and recreates the domain.
	VpcOptions *AwsOpenSearchDomainVpcOptionsInput `json:"vpc_options,omitempty" jsonschema:"VPC placement configuration. When provided; the domain is deployed into VPC subnets and is not publicly accessible. ForceNew — adding or removing VPC options destroys and recreates the domain."`
	// HTTPS enforcement, TLS policy, and custom endpoint configuration.
	DomainEndpointOptions *AwsOpenSearchDomainEndpointOptionsInput `json:"domain_endpoint_options,omitempty" jsonschema:"HTTPS enforcement; TLS policy; and custom endpoint configuration."`
	// Advanced security options enable fine-grained access control: internal user
	//  database, IAM-based authentication, and role-based index-level permissions.
	//  Once enabled, FGAC cannot be disabled (ForceNew).
	AdvancedSecurityOptions *AwsOpenSearchDomainAdvancedSecurityOptionsInput `json:"advanced_security_options,omitempty" jsonschema:"Advanced security options enable fine-grained access control: internal user database; IAM-based authentication; and role-based index-level permissions. Once enabled; FGAC cannot be disabled (ForceNew)..."`
	// Publish domain logs to CloudWatch Logs for monitoring and troubleshooting.
	//  Up to 4 configurations — one per log type (INDEX_SLOW_LOGS, SEARCH_SLOW_LOGS,
	//  ES_APPLICATION_LOGS, AUDIT_LOGS).
	LogPublishingOptions []*AwsOpenSearchDomainLogPublishingOptionInput `json:"log_publishing_options,omitempty" jsonschema:"Publish domain logs to CloudWatch Logs for monitoring and troubleshooting. Up to 4 configurations — one per log type (INDEX_SLOW_LOGS; SEARCH_SLOW_LOGS; ES_APPLICATION_LOGS; AUDIT_LOGS)."`
	// IAM-based access policy for the domain. Serialized to JSON by the IaC modules.
	//  Controls who can perform actions on the domain and its indices.
	//  For VPC domains, this works in conjunction with security groups.
	//  For public domains, this is the primary access control mechanism (unless FGAC is enabled)...
	AccessPolicies any `json:"access_policies,omitempty" jsonschema:"IAM-based access policy for the domain. Serialized to JSON by the IaC modules. Controls who can perform actions on the domain and its indices. For VPC domains; this works in conjunction with security ..."`
	// Enable AWS Auto-Tune to automatically optimize JVM heap size, disk I/O,
	//  and other performance settings based on cluster metrics.
	AutoTuneEnabled bool `json:"auto_tune_enabled,omitempty" jsonschema:"Enable AWS Auto-Tune to automatically optimize JVM heap size; disk I/O; and other performance settings based on cluster metrics."`
	// Enable automatic service software updates. When true, AWS applies mandatory
	//  and optional service software updates during the off-peak window.
	AutoSoftwareUpdateEnabled bool `json:"auto_software_update_enabled,omitempty" jsonschema:"Enable automatic service software updates. When true; AWS applies mandatory and optional service software updates during the off-peak window."`
	// IP address type for the domain. "ipv4" (default) or "dualstack" (IPv4 + IPv6).
	//  Changing from "dualstack" to "ipv4" forces domain recreation.
	IpAddressType string `json:"ip_address_type,omitempty" jsonschema:"IP address type for the domain. 'ipv4' (default) or 'dualstack' (IPv4 + IPv6). Changing from 'dualstack' to 'ipv4' forces domain recreation."`
	// Low-level key-value configuration options. Common options:
	//  - "rest.action.multi.allow_explicit_index": "true" (default)
	//  - "indices.fielddata.cache.size": percentage of heap
	//  - "indices.query.bool.max_clause_count": max boolean clauses
	//  Values must be strings.
	AdvancedOptions map[string]string `json:"advanced_options,omitempty" jsonschema:"Low-level key-value configuration options. Common options: - 'rest.action.multi.allow_explicit_index': 'true' (default) - 'indices.fielddata.cache.size': percentage of heap - 'indices.query.bool.max_c..."`
}

func (s *AwsOpenSearchDomainSpecInput) validate() error {
	if s.EngineVersion == "" {
		return fmt.Errorf("engine_version is required")
	}
	if s.ClusterConfig == nil {
		return fmt.Errorf("cluster_config is required")
	}
	if s.ClusterConfig != nil {
		if err := s.ClusterConfig.validate(); err != nil {
			return fmt.Errorf("cluster_config: %w", err)
		}
	}
	if s.EbsOptions == nil {
		return fmt.Errorf("ebs_options is required")
	}
	if s.EbsOptions != nil {
		if err := s.EbsOptions.validate(); err != nil {
			return fmt.Errorf("ebs_options: %w", err)
		}
	}
	if s.VpcOptions != nil {
		if err := s.VpcOptions.validate(); err != nil {
			return fmt.Errorf("vpc_options: %w", err)
		}
	}
	if s.DomainEndpointOptions != nil {
		if err := s.DomainEndpointOptions.validate(); err != nil {
			return fmt.Errorf("domain_endpoint_options: %w", err)
		}
	}
	if s.AdvancedSecurityOptions != nil {
		if err := s.AdvancedSecurityOptions.validate(); err != nil {
			return fmt.Errorf("advanced_security_options: %w", err)
		}
	}
	for i, v := range s.LogPublishingOptions {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("log_publishing_options[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsOpenSearchDomainSpecInput) applyDefaults() {
	if s.ClusterConfig != nil {
		s.ClusterConfig.applyDefaults()
	}
	if s.EbsOptions != nil {
		s.EbsOptions.applyDefaults()
	}
	if s.VpcOptions != nil {
		s.VpcOptions.applyDefaults()
	}
	if s.DomainEndpointOptions != nil {
		s.DomainEndpointOptions.applyDefaults()
	}
	if s.AdvancedSecurityOptions != nil {
		s.AdvancedSecurityOptions.applyDefaults()
	}
}

func (s *AwsOpenSearchDomainSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["engine_version"] = s.EngineVersion
	if s.ClusterConfig != nil {
		m["cluster_config"] = s.ClusterConfig.toMap()
	}
	if s.EbsOptions != nil {
		m["ebs_options"] = s.EbsOptions.toMap()
	}
	if s.EncryptAtRestEnabled {
		m["encrypt_at_rest_enabled"] = s.EncryptAtRestEnabled
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.NodeToNodeEncryptionEnabled {
		m["node_to_node_encryption_enabled"] = s.NodeToNodeEncryptionEnabled
	}
	if s.VpcOptions != nil {
		m["vpc_options"] = s.VpcOptions.toMap()
	}
	if s.DomainEndpointOptions != nil {
		m["domain_endpoint_options"] = s.DomainEndpointOptions.toMap()
	}
	if s.AdvancedSecurityOptions != nil {
		m["advanced_security_options"] = s.AdvancedSecurityOptions.toMap()
	}
	if len(s.LogPublishingOptions) > 0 {
		items := make([]any, len(s.LogPublishingOptions))
		for i, v := range s.LogPublishingOptions {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["log_publishing_options"] = items
	}
	// unsupported type "object" for field AccessPolicies
	if s.AutoTuneEnabled {
		m["auto_tune_enabled"] = s.AutoTuneEnabled
	}
	if s.AutoSoftwareUpdateEnabled {
		m["auto_software_update_enabled"] = s.AutoSoftwareUpdateEnabled
	}
	if s.IpAddressType != "" {
		m["ip_address_type"] = s.IpAddressType
	}
	if len(s.AdvancedOptions) > 0 {
		m["advanced_options"] = s.AdvancedOptions
	}
	return m
}

// AwsOpenSearchDomainAdvancedSecurityOptions configures fine-grained access control
//
//	(FGAC) for the domain. FGAC enables internal user database authentication,
//	IAM-based authentication, and role-based index-level permissions.
//
//	Once enabled, FGAC cannot be disabled without recreating the domain.
type AwsOpenSearchDomainAdvancedSecurityOptionsInput struct {
	// Enable fine-grained access control. ForceNew if disabling (cannot disable
	//  once enabled without domain recreation).
	Enabled bool `json:"enabled,omitempty" jsonschema:"Enable fine-grained access control. ForceNew if disabling (cannot disable once enabled without domain recreation)."`
	// Enable the internal user database. When true, you can create users and roles
	//  directly in OpenSearch Dashboards. When false, use IAM or SAML for authentication.
	InternalUserDatabaseEnabled bool `json:"internal_user_database_enabled,omitempty" jsonschema:"Enable the internal user database. When true; you can create users and roles directly in OpenSearch Dashboards. When false; use IAM or SAML for authentication."`
	// IAM entity ARN (user or role) designated as the master user. The master user
	//  has full access to the cluster, indices, and OpenSearch Dashboards.
	//  Mutually exclusive with master_user_name/master_user_password.
	MasterUserArn string `json:"master_user_arn,omitempty" jsonschema:"IAM entity ARN (user or role) designated as the master user. The master user has full access to the cluster; indices; and OpenSearch Dashboards. Mutually exclusive with master_user_name/master_user_pa..."`
	// Username for the internal user database master user.
	//  Mutually exclusive with master_user_arn.
	MasterUserName string `json:"master_user_name,omitempty" jsonschema:"Username for the internal user database master user. Mutually exclusive with master_user_arn."`
	// Password for the internal user database master user. Must be at least 8
	//  characters with uppercase, lowercase, digit, and special character.
	//  Mutually exclusive with master_user_arn.
	MasterUserPassword string `json:"master_user_password,omitempty" jsonschema:"Password for the internal user database master user. Must be at least 8 characters with uppercase; lowercase; digit; and special character. Mutually exclusive with master_user_arn."`
}

func (s *AwsOpenSearchDomainAdvancedSecurityOptionsInput) validate() error {
	return nil
}

func (s *AwsOpenSearchDomainAdvancedSecurityOptionsInput) applyDefaults() {
}

func (s *AwsOpenSearchDomainAdvancedSecurityOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.InternalUserDatabaseEnabled {
		m["internal_user_database_enabled"] = s.InternalUserDatabaseEnabled
	}
	if s.MasterUserArn != "" {
		m["master_user_arn"] = s.MasterUserArn
	}
	if s.MasterUserName != "" {
		m["master_user_name"] = s.MasterUserName
	}
	if s.MasterUserPassword != "" {
		m["master_user_password"] = s.MasterUserPassword
	}
	return m
}

// AwsOpenSearchDomainClusterConfig defines the cluster topology including data
//
//	nodes, dedicated master nodes, zone awareness, and UltraWarm/cold storage tiers.
type AwsOpenSearchDomainClusterConfigInput struct {
	// Instance type for data nodes. Uses the `.search` suffix.
	//  Examples: "t3.small.search" (dev), "r6g.large.search" (production),
	//  "r6g.2xlarge.search" (high-memory workloads).
	InstanceType string `json:"instance_type" jsonschema:"required,Instance type for data nodes. Uses the '.search' suffix. Examples: 't3.small.search' (dev); 'r6g.large.search' (production); 'r6g.2xlarge.search' (high-memory workloads)."`
	// Number of data node instances. Default: 1.
	//  For zone-aware deployments, use a multiple of the availability zone count.
	InstanceCount int32 `json:"instance_count,omitempty" jsonschema:"Number of data node instances. Default: 1. For zone-aware deployments; use a multiple of the availability zone count."`
	// Enable dedicated master nodes for cluster stability. Dedicated masters handle
	//  cluster management tasks (shard allocation, index state management) without
	//  competing with data node workloads. Recommended for production.
	DedicatedMasterEnabled bool `json:"dedicated_master_enabled,omitempty" jsonschema:"Enable dedicated master nodes for cluster stability. Dedicated masters handle cluster management tasks (shard allocation; index state management) without competing with data node workloads. Recommende..."`
	// Instance type for dedicated master nodes. Does not need EBS storage.
	//  Example: "r6g.large.search". Only used when `dedicated_master_enabled` is true.
	DedicatedMasterType string `json:"dedicated_master_type,omitempty" jsonschema:"Instance type for dedicated master nodes. Does not need EBS storage. Example: 'r6g.large.search'. Only used when 'dedicated_master_enabled' is true."`
	// Number of dedicated master nodes. AWS recommends 3 for production (provides
	//  quorum for split-brain protection). Only used when `dedicated_master_enabled` is true.
	DedicatedMasterCount int32 `json:"dedicated_master_count,omitempty" jsonschema:"Number of dedicated master nodes. AWS recommends 3 for production (provides quorum for split-brain protection). Only used when 'dedicated_master_enabled' is true."`
	// Enable zone awareness to distribute data nodes and replicas across multiple
	//  Availability Zones for resilience against AZ-level failures.
	ZoneAwarenessEnabled bool `json:"zone_awareness_enabled,omitempty" jsonschema:"Enable zone awareness to distribute data nodes and replicas across multiple Availability Zones for resilience against AZ-level failures."`
	// Number of Availability Zones. Must be 2 or 3.
	//  Only used when `zone_awareness_enabled` is true.
	AvailabilityZoneCount int32 `json:"availability_zone_count,omitempty" jsonschema:"Number of Availability Zones. Must be 2 or 3. Only used when 'zone_awareness_enabled' is true."`
	// Enable UltraWarm storage tier for infrequently accessed, read-only data.
	//  UltraWarm uses S3-backed storage at lower cost per GB than hot storage.
	WarmEnabled bool `json:"warm_enabled,omitempty" jsonschema:"Enable UltraWarm storage tier for infrequently accessed; read-only data. UltraWarm uses S3-backed storage at lower cost per GB than hot storage."`
	// Instance type for UltraWarm nodes. Examples: "ultrawarm1.medium.search",
	//  "ultrawarm1.large.search". Only used when `warm_enabled` is true.
	WarmType string `json:"warm_type,omitempty" jsonschema:"Instance type for UltraWarm nodes. Examples: 'ultrawarm1.medium.search'; 'ultrawarm1.large.search'. Only used when 'warm_enabled' is true."`
	// Number of UltraWarm nodes. Range: 2-150.
	//  Only used when `warm_enabled` is true.
	WarmCount int32 `json:"warm_count,omitempty" jsonschema:"Number of UltraWarm nodes. Range: 2-150. Only used when 'warm_enabled' is true."`
	// Enable cold storage backed by S3. Requires UltraWarm to be enabled.
	//  Cold storage provides the lowest-cost tier for data that is rarely queried.
	ColdStorageEnabled bool `json:"cold_storage_enabled,omitempty" jsonschema:"Enable cold storage backed by S3. Requires UltraWarm to be enabled. Cold storage provides the lowest-cost tier for data that is rarely queried."`
	// Enable Multi-AZ with Standby for 99.99% availability SLA. Deploys standby
	//  nodes in a different AZ that take over automatically during AZ failures.
	//  Requires 3 AZs and at least 3 data nodes.
	MultiAzWithStandbyEnabled bool `json:"multi_az_with_standby_enabled,omitempty" jsonschema:"Enable Multi-AZ with Standby for 99.99% availability SLA. Deploys standby nodes in a different AZ that take over automatically during AZ failures. Requires 3 AZs and at least 3 data nodes."`
}

func (s *AwsOpenSearchDomainClusterConfigInput) validate() error {
	if s.InstanceType == "" {
		return fmt.Errorf("instance_type is required")
	}
	return nil
}

func (s *AwsOpenSearchDomainClusterConfigInput) applyDefaults() {
	if s.InstanceCount == 0 {
		s.InstanceCount = 1
	}
}

func (s *AwsOpenSearchDomainClusterConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["instance_type"] = s.InstanceType
	if s.InstanceCount != 0 {
		m["instance_count"] = s.InstanceCount
	}
	if s.DedicatedMasterEnabled {
		m["dedicated_master_enabled"] = s.DedicatedMasterEnabled
	}
	if s.DedicatedMasterType != "" {
		m["dedicated_master_type"] = s.DedicatedMasterType
	}
	if s.DedicatedMasterCount != 0 {
		m["dedicated_master_count"] = s.DedicatedMasterCount
	}
	if s.ZoneAwarenessEnabled {
		m["zone_awareness_enabled"] = s.ZoneAwarenessEnabled
	}
	if s.AvailabilityZoneCount != 0 {
		m["availability_zone_count"] = s.AvailabilityZoneCount
	}
	if s.WarmEnabled {
		m["warm_enabled"] = s.WarmEnabled
	}
	if s.WarmType != "" {
		m["warm_type"] = s.WarmType
	}
	if s.WarmCount != 0 {
		m["warm_count"] = s.WarmCount
	}
	if s.ColdStorageEnabled {
		m["cold_storage_enabled"] = s.ColdStorageEnabled
	}
	if s.MultiAzWithStandbyEnabled {
		m["multi_az_with_standby_enabled"] = s.MultiAzWithStandbyEnabled
	}
	return m
}

// AwsOpenSearchDomainEbsOptions defines EBS volume configuration for data node storage.
type AwsOpenSearchDomainEbsOptionsInput struct {
	// Whether EBS volumes are attached to data nodes. Required for most instance
	//  types. Only storage-optimized instances (e.g., i3) use instance storage.
	EbsEnabled bool `json:"ebs_enabled,omitempty" jsonschema:"Whether EBS volumes are attached to data nodes. Required for most instance types. Only storage-optimized instances (e.g.; i3) use instance storage."`
	// EBS volume type. "gp3" (recommended), "gp2", "io1", or "standard".
	//  gp3 provides predictable performance with configurable IOPS and throughput.
	VolumeType string `json:"volume_type,omitempty" jsonschema:"EBS volume type. 'gp3' (recommended); 'gp2'; 'io1'; or 'standard'. gp3 provides predictable performance with configurable IOPS and throughput."`
	// Size of each EBS volume in GB. The total storage is volume_size * instance_count.
	VolumeSize int32 `json:"volume_size,omitempty" jsonschema:"Size of each EBS volume in GB. The total storage is volume_size * instance_count."`
	// Provisioned IOPS for the volume. Only valid for "gp3" and "io1" volume types.
	//  gp3 baseline: 3000 IOPS. io1: specify based on workload.
	Iops int32 `json:"iops,omitempty" jsonschema:"Provisioned IOPS for the volume. Only valid for 'gp3' and 'io1' volume types. gp3 baseline: 3000 IOPS. io1: specify based on workload."`
	// Provisioned throughput in MiB/s. Only valid for "gp3" volume type.
	//  Minimum: 125 MiB/s. gp3 baseline: 125 MiB/s.
	Throughput int32 `json:"throughput,omitempty" jsonschema:"Provisioned throughput in MiB/s. Only valid for 'gp3' volume type. Minimum: 125 MiB/s. gp3 baseline: 125 MiB/s."`
}

func (s *AwsOpenSearchDomainEbsOptionsInput) validate() error {
	return nil
}

func (s *AwsOpenSearchDomainEbsOptionsInput) applyDefaults() {
}

func (s *AwsOpenSearchDomainEbsOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EbsEnabled {
		m["ebs_enabled"] = s.EbsEnabled
	}
	if s.VolumeType != "" {
		m["volume_type"] = s.VolumeType
	}
	if s.VolumeSize != 0 {
		m["volume_size"] = s.VolumeSize
	}
	if s.Iops != 0 {
		m["iops"] = s.Iops
	}
	if s.Throughput != 0 {
		m["throughput"] = s.Throughput
	}
	return m
}

// AwsOpenSearchDomainEndpointOptions configures the domain's HTTPS behavior,
//
//	TLS policy, and optional custom endpoint.
type AwsOpenSearchDomainEndpointOptionsInput struct {
	// Require HTTPS for all traffic to the domain endpoint. Default: true.
	//  Strongly recommended for all environments.
	EnforceHttps bool `json:"enforce_https,omitempty" jsonschema:"Require HTTPS for all traffic to the domain endpoint. Default: true. Strongly recommended for all environments."`
	// TLS security policy for the HTTPS endpoint. Controls the minimum TLS version
	//  and cipher suites. Example: "Policy-Min-TLS-1-2-PFS-2023-10" (recommended).
	//  Leave empty for the provider default.
	TlsSecurityPolicy string `json:"tls_security_policy,omitempty" jsonschema:"TLS security policy for the HTTPS endpoint. Controls the minimum TLS version and cipher suites. Example: 'Policy-Min-TLS-1-2-PFS-2023-10' (recommended). Leave empty for the provider default."`
	// Enable a custom domain endpoint (e.g., "search.example.com") instead of the
	//  AWS-generated endpoint.
	CustomEndpointEnabled bool `json:"custom_endpoint_enabled,omitempty" jsonschema:"Enable a custom domain endpoint (e.g.; 'search.example.com') instead of the AWS-generated endpoint."`
	// The fully qualified domain name for the custom endpoint.
	//  Only used when `custom_endpoint_enabled` is true.
	CustomEndpoint string `json:"custom_endpoint,omitempty" jsonschema:"The fully qualified domain name for the custom endpoint. Only used when 'custom_endpoint_enabled' is true."`
	// ACM certificate ARN for the custom endpoint. Must be a valid certificate
	//  covering the custom_endpoint FQDN.
	//  Only used when `custom_endpoint_enabled` is true.
	CustomEndpointCertificateArn string `json:"custom_endpoint_certificate_arn,omitempty" jsonschema:"ACM certificate ARN for the custom endpoint. Must be a valid certificate covering the custom_endpoint FQDN. Only used when 'custom_endpoint_enabled' is true."`
}

func (s *AwsOpenSearchDomainEndpointOptionsInput) validate() error {
	return nil
}

func (s *AwsOpenSearchDomainEndpointOptionsInput) applyDefaults() {
	// default: EnforceHttps = true (applied at zero-value)
}

func (s *AwsOpenSearchDomainEndpointOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.EnforceHttps {
		m["enforce_https"] = s.EnforceHttps
	}
	if s.TlsSecurityPolicy != "" {
		m["tls_security_policy"] = s.TlsSecurityPolicy
	}
	if s.CustomEndpointEnabled {
		m["custom_endpoint_enabled"] = s.CustomEndpointEnabled
	}
	if s.CustomEndpoint != "" {
		m["custom_endpoint"] = s.CustomEndpoint
	}
	if s.CustomEndpointCertificateArn != "" {
		m["custom_endpoint_certificate_arn"] = s.CustomEndpointCertificateArn
	}
	return m
}

// AwsOpenSearchDomainLogPublishingOption configures delivery of a specific log type
//
//	to a CloudWatch Logs log group for monitoring, troubleshooting, and auditing.
type AwsOpenSearchDomainLogPublishingOptionInput struct {
	// Type of log to publish. Values:
	//  - "INDEX_SLOW_LOGS" — indexing operations exceeding the slow log threshold
	//  - "SEARCH_SLOW_LOGS" — search queries exceeding the slow log threshold
	//  - "ES_APPLICATION_LOGS" — OpenSearch application and error logs
	//  - "AUDIT_LOGS" — fine-grained access control a...
	LogType string `json:"log_type" jsonschema:"required,Type of log to publish. Values: - 'INDEX_SLOW_LOGS' — indexing operations exceeding the slow log threshold - 'SEARCH_SLOW_LOGS' — search queries exceeding the slow log threshold - 'ES_APPLICATION_..."`
	// CloudWatch Logs log group ARN where logs are published.
	CloudwatchLogGroupArn string `json:"cloudwatch_log_group_arn" jsonschema:"required,CloudWatch Logs log group ARN where logs are published."`
	// Whether this log publishing option is active. Default: true.
	//  Set to false to temporarily disable publishing without removing the configuration.
	Enabled bool `json:"enabled,omitempty" jsonschema:"Whether this log publishing option is active. Default: true. Set to false to temporarily disable publishing without removing the configuration."`
}

func (s *AwsOpenSearchDomainLogPublishingOptionInput) validate() error {
	if s.LogType == "" {
		return fmt.Errorf("log_type is required")
	}
	if s.CloudwatchLogGroupArn == "" {
		return fmt.Errorf("cloudwatch_log_group_arn is required")
	}
	return nil
}

func (s *AwsOpenSearchDomainLogPublishingOptionInput) applyDefaults() {
	// default: Enabled = true (applied at zero-value)
}

func (s *AwsOpenSearchDomainLogPublishingOptionInput) toMap() map[string]any {
	m := make(map[string]any)
	m["log_type"] = s.LogType
	m["cloudwatch_log_group_arn"] = s.CloudwatchLogGroupArn
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	return m
}

// AwsOpenSearchDomainVpcOptions defines VPC placement for the domain.
//
//	When configured, the domain is not publicly accessible and instead uses
//	VPC endpoints for traffic. VPC configuration is ForceNew.
type AwsOpenSearchDomainVpcOptionsInput struct {
	// Subnet IDs where OpenSearch deploys ENIs. For zone-aware domains, provide
	//  subnets in 2 or 3 AZs matching the cluster's availability_zone_count.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs where OpenSearch deploys ENIs. For zone-aware domains; provide subnets in 2 or 3 AZs matching the cluster's availability_zone_count."`
	// Security group IDs controlling inbound/outbound traffic to the domain.
	//  Must allow HTTPS (port 443) from clients that need to access OpenSearch.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security group IDs controlling inbound/outbound traffic to the domain. Must allow HTTPS (port 443) from clients that need to access OpenSearch."`
}

func (s *AwsOpenSearchDomainVpcOptionsInput) validate() error {
	return nil
}

func (s *AwsOpenSearchDomainVpcOptionsInput) applyDefaults() {
}

func (s *AwsOpenSearchDomainVpcOptionsInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	return m
}

// ParseAwsOpenSearchDomain validates and normalizes a AwsOpenSearchDomain cloud_object.
func ParseAwsOpenSearchDomain(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsOpenSearchDomain"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsOpenSearchDomainSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
