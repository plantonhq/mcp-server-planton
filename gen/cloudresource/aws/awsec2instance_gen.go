// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsEc2Instance represents a single EC2 virtual machine instance on AWS.
//
//	This resource provisions one EC2 instance with networking, IAM, and access configuration.
type AwsEc2InstanceSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// name of the EC2 instance.
	InstanceName string `json:"instance_name" jsonschema:"required,name of the EC2 instance."`
	// Amazon Machine Image ID to use for launching the instance.
	//  This is the unique identifier of the OS image (AMI) that the EC2 will run.
	//  Example: "ami-0abcdef1234567890" for an Ubuntu or Amazon Linux image.
	AmiId string `json:"ami_id" jsonschema:"required,Amazon Machine Image ID to use for launching the instance. This is the unique identifier of the OS image (AMI) that the EC2 will run. Example: 'ami-0abcdef1234567890' for an Ubuntu or Amazon Linux ima..."`
	// EC2 instance type (flavor) determining vCPU count and memory.
	//  Example: "t3.small" (2 vCPUs, 2 GiB RAM) or "m5.large" (2 vCPUs, 8 GiB RAM).
	InstanceType string `json:"instance_type" jsonschema:"required,EC2 instance type (flavor) determining vCPU count and memory. Example: 't3.small' (2 vCPUs; 2 GiB RAM) or 'm5.large' (2 vCPUs; 8 GiB RAM)."`
	// Reference to the target subnet where this instance will reside.
	//  This should be a private subnet within an existing VPC.
	//  The default kind expects an AwsVpc resource, using one of its private subnet IDs.
	SubnetId string `json:"subnet_id" jsonschema:"required,Reference to the target subnet where this instance will reside. This should be a private subnet within an existing VPC. The default kind expects an AwsVpc resource; using one of its private subnet IDs..."`
	// One or more security group IDs to attach to the instance's network interface.
	//  These security groups control inbound/outbound traffic for the instance.
	//  Typically includes at least one security group for application or SSH access.
	SecurityGroupIds []string `json:"security_group_ids" jsonschema:"required,One or more security group IDs to attach to the instance's network interface. These security groups control inbound/outbound traffic for the instance. Typically includes at least one security group fo..."`
	// Method for connecting to the instance for administration or SSH access.
	//  - SSM: Use AWS Systems Manager Session Manager (no SSH key needed, requires an IAM instance profile with SSM permissions).
	//  - BASTION: Use a traditional SSH method with a key pair (requires a key_name for the EC2 instance).
	//  - ...
	ConnectionMethod string `json:"connection_method,omitempty" jsonschema:"enum=BASTION|INSTANCE_CONNECT,Method for connecting to the instance for administration or SSH access. - SSM: Use AWS Systems Manager Session Manager (no SSH key needed; requires an IAM instance profile with SSM permissions). - BAS..."`
	// The ARN of an IAM instance profile to attach to the EC2 instance.
	//  This profile should include an IAM role with necessary permissions (for example, SSM Session Manager access if using SSM).
	//  **Required if** connection_method is SSM; optional otherwise.
	IamInstanceProfileArn string `json:"iam_instance_profile_arn,omitempty" jsonschema:"The ARN of an IAM instance profile to attach to the EC2 instance. This profile should include an IAM role with necessary permissions (for example; SSM Session Manager access if using SSM). **Required ..."`
	// The name of an EC2 Key Pair to associate with the instance for SSH access.
	//  This is the key pair name as created in AWS (not the public key material).
	//  **Required if** connection_method is BASTION or INSTANCE_CONNECT; not used for SSM.
	KeyName string `json:"key_name,omitempty" jsonschema:"The name of an EC2 Key Pair to associate with the instance for SSH access. This is the key pair name as created in AWS (not the public key material). **Required if** connection_method is BASTION or IN..."`
	// Size of the root EBS volume in GiB.
	//  This defines the storage capacity for the instance's root filesystem.
	//  Defaults to 30 GiB if not specified.
	RootVolumeSizeGb int32 `json:"root_volume_size_gb,omitempty" jsonschema:"Size of the root EBS volume in GiB. This defines the storage capacity for the instance's root filesystem. Defaults to 30 GiB if not specified."`
	// Map of tags to apply to the EC2 instance.
	//  Tags are key-value pairs for metadata and organization of AWS resources (e.g., {"env": "production", "app": "web"}).
	Tags map[string]string `json:"tags,omitempty" jsonschema:"Map of tags to apply to the EC2 instance. Tags are key-value pairs for metadata and organization of AWS resources (e.g.; {'env': 'production'; 'app': 'web'})."`
	// User data script to provide when launching the instance (cloud-init or shell script).
	//  This can be a plaintext or base64-encoded string, up to 32 KiB.
	//  Use this to perform initial configuration on boot (install packages, configure software, etc.).
	UserData string `json:"user_data,omitempty" jsonschema:"User data script to provide when launching the instance (cloud-init or shell script). This can be a plaintext or base64-encoded string; up to 32 KiB. Use this to perform initial configuration on boot ..."`
	// Enable EBS optimization for the instance (if supported by the instance type).
	//  When true, the instance uses dedicated throughput for EBS I/O, which can improve performance for I/O-intensive workloads.
	EbsOptimized bool `json:"ebs_optimized,omitempty" jsonschema:"Enable EBS optimization for the instance (if supported by the instance type). When true; the instance uses dedicated throughput for EBS I/O; which can improve performance for I/O-intensive workloads."`
	// If true, prevents the instance from being terminated via the AWS API (enables termination protection).
	//  This adds a safety measure against accidental deletion of the instance.
	DisableApiTermination bool `json:"disable_api_termination,omitempty" jsonschema:"If true; prevents the instance from being terminated via the AWS API (enables termination protection). This adds a safety measure against accidental deletion of the instance."`
}

func (s *AwsEc2InstanceSpecInput) validate() error {
	if s.InstanceName == "" {
		return fmt.Errorf("instance_name is required")
	}
	if s.AmiId == "" {
		return fmt.Errorf("ami_id is required")
	}
	if s.InstanceType == "" {
		return fmt.Errorf("instance_type is required")
	}
	if s.SubnetId == "" {
		return fmt.Errorf("subnet_id is required")
	}
	if len(s.SecurityGroupIds) == 0 {
		return fmt.Errorf("security_group_ids is required")
	}
	if len(s.SecurityGroupIds) < 1 {
		return fmt.Errorf("security_group_ids requires at least 1 items, got %d", len(s.SecurityGroupIds))
	}
	switch s.ConnectionMethod {
	case "", "BASTION", "INSTANCE_CONNECT":
	default:
		return fmt.Errorf("invalid connection_method: %q", s.ConnectionMethod)
	}
	return nil
}

func (s *AwsEc2InstanceSpecInput) applyDefaults() {
	if s.ConnectionMethod == "" {
		s.ConnectionMethod = "SSM"
	}
	if s.RootVolumeSizeGb == 0 {
		s.RootVolumeSizeGb = 30
	}
}

func (s *AwsEc2InstanceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["instance_name"] = s.InstanceName
	m["ami_id"] = s.AmiId
	m["instance_type"] = s.InstanceType
	m["subnet_id"] = s.SubnetId
	m["security_group_ids"] = s.SecurityGroupIds
	if s.ConnectionMethod != "" {
		m["connection_method"] = s.ConnectionMethod
	}
	if s.IamInstanceProfileArn != "" {
		m["iam_instance_profile_arn"] = s.IamInstanceProfileArn
	}
	if s.KeyName != "" {
		m["key_name"] = s.KeyName
	}
	if s.RootVolumeSizeGb != 0 {
		m["root_volume_size_gb"] = s.RootVolumeSizeGb
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.UserData != "" {
		m["user_data"] = s.UserData
	}
	if s.EbsOptimized {
		m["ebs_optimized"] = s.EbsOptimized
	}
	if s.DisableApiTermination {
		m["disable_api_termination"] = s.DisableApiTermination
	}
	return m
}

// ParseAwsEc2Instance validates and normalizes a AwsEc2Instance cloud_object.
func ParseAwsEc2Instance(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEc2Instance"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEc2InstanceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
