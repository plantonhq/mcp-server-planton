// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsHttpApiGateway is the Kubernetes-style resource envelope for an AWS API Gateway HTTP API.
//
//	HTTP APIs are the recommended API type for building RESTful APIs and HTTP proxies
//	in AWS. They offer lower latency and cost compared to REST APIs, with native support
//	for Lambda proxy integration, JWT authorization, and automatic deployments.
type AwsHttpApiGatewaySpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Human-readable description of the API (max 1024 characters).
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the API (max 1024 characters)."`
	// CORS configuration for cross-origin requests. When not set, no CORS
	//  headers are returned by the API.
	CorsConfiguration *AwsHttpApiGatewayCorsConfigInput `json:"cors_configuration,omitempty" jsonschema:"CORS configuration for cross-origin requests. When not set; no CORS headers are returned by the API."`
	// Disable the default execute-api endpoint. Set to true when a custom domain
	//  is configured externally to prevent direct access via the default endpoint.
	DisableExecuteApiEndpoint bool `json:"disable_execute_api_endpoint,omitempty" jsonschema:"Disable the default execute-api endpoint. Set to true when a custom domain is configured externally to prevent direct access via the default endpoint."`
	// Stage configuration for the deployed API. When not set, a "$default" stage
	//  with auto_deploy=true is created automatically, which is the recommended
	//  configuration for most HTTP APIs.
	Stage *AwsHttpApiGatewayStageConfigInput `json:"stage,omitempty" jsonschema:"Stage configuration for the deployed API. When not set; a '$default' stage with auto_deploy=true is created automatically; which is the recommended configuration for most HTTP APIs."`
	// API routes mapping request patterns to backend integrations. Each route
	//  specifies a route key (e.g., "GET /users", "$default") and an inline
	//  integration that defines the backend target.
	//
	//  When multiple routes share the same integration configuration (same type,
	//  URI, and payload format), the IaC m...
	Routes []*AwsHttpApiGatewayRouteInput `json:"routes,omitempty" jsonschema:"API routes mapping request patterns to backend integrations. Each route specifies a route key (e.g.; 'GET /users'; '$default') and an inline integration that defines the backend target. When multiple ..."`
	// Named authorizers that can be referenced by routes. Define JWT authorizers
	//  for Cognito/Auth0/OIDC integration, or Lambda (REQUEST) authorizers for
	//  custom authorization logic. Routes reference authorizers by name.
	Authorizers []*AwsHttpApiGatewayAuthorizerInput `json:"authorizers,omitempty" jsonschema:"Named authorizers that can be referenced by routes. Define JWT authorizers for Cognito/Auth0/OIDC integration; or Lambda (REQUEST) authorizers for custom authorization logic. Routes reference authoriz..."`
}

func (s *AwsHttpApiGatewaySpecInput) validate() error {
	if s.CorsConfiguration != nil {
		if err := s.CorsConfiguration.validate(); err != nil {
			return fmt.Errorf("cors_configuration: %w", err)
		}
	}
	if s.Stage != nil {
		if err := s.Stage.validate(); err != nil {
			return fmt.Errorf("stage: %w", err)
		}
	}
	if len(s.Routes) < 1 {
		return fmt.Errorf("routes requires at least 1 items, got %d", len(s.Routes))
	}
	for i, v := range s.Routes {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("routes[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.Authorizers {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("authorizers[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsHttpApiGatewaySpecInput) applyDefaults() {
	if s.CorsConfiguration != nil {
		s.CorsConfiguration.applyDefaults()
	}
	if s.Stage != nil {
		s.Stage.applyDefaults()
	}
}

func (s *AwsHttpApiGatewaySpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.CorsConfiguration != nil {
		m["cors_configuration"] = s.CorsConfiguration.toMap()
	}
	if s.DisableExecuteApiEndpoint {
		m["disable_execute_api_endpoint"] = s.DisableExecuteApiEndpoint
	}
	if s.Stage != nil {
		m["stage"] = s.Stage.toMap()
	}
	if len(s.Routes) > 0 {
		items := make([]any, len(s.Routes))
		for i, v := range s.Routes {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["routes"] = items
	}
	if len(s.Authorizers) > 0 {
		items := make([]any, len(s.Authorizers))
		for i, v := range s.Authorizers {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["authorizers"] = items
	}
	return m
}

// AwsHttpApiGatewayAccessLogConfig configures access logging for the API stage.
type AwsHttpApiGatewayAccessLogConfigInput struct {
	// CloudWatch Log Group ARN for access log delivery. Accepts a direct ARN
	//  or a reference to an AwsCloudwatchLogGroup resource.
	DestinationArn string `json:"destination_arn" jsonschema:"required,CloudWatch Log Group ARN for access log delivery. Accepts a direct ARN or a reference to an AwsCloudwatchLogGroup resource."`
	// Log format template. Uses API Gateway access log variables (e.g.,
	//  $context.requestId, $context.identity.sourceIp, $context.httpMethod).
	//
	//  Common JSON format:
	//    {"requestId":"$context.requestId","ip":"$context.identity.sourceIp",
	//     "method":"$context.httpMethod","path":"$context.routeKey",
	//     "s...
	Format string `json:"format,omitempty" jsonschema:"Log format template. Uses API Gateway access log variables (e.g.; $context.requestId; $context.identity.sourceIp; $context.httpMethod). Common JSON format: {'requestId':'$context.requestId';'ip':'$con..."`
}

func (s *AwsHttpApiGatewayAccessLogConfigInput) validate() error {
	if s.DestinationArn == "" {
		return fmt.Errorf("destination_arn is required")
	}
	return nil
}

func (s *AwsHttpApiGatewayAccessLogConfigInput) applyDefaults() {
}

func (s *AwsHttpApiGatewayAccessLogConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["destination_arn"] = s.DestinationArn
	if s.Format != "" {
		m["format"] = s.Format
	}
	return m
}

// AwsHttpApiGatewayAuthorizer defines a named authorizer that can be referenced
//
//	by routes. HTTP APIs support two authorizer types:
//	- JWT: Validates JSON Web Tokens from Cognito, Auth0, or any OIDC provider.
//	- REQUEST: Invokes a Lambda function for custom authorization logic.
type AwsHttpApiGatewayAuthorizerInput struct {
	// Unique name for this authorizer. Routes reference authorizers by this name.
	//  Must be unique across all authorizers in the spec.
	Name string `json:"name,omitempty" jsonschema:"Unique name for this authorizer. Routes reference authorizers by this name. Must be unique across all authorizers in the spec."`
	// Authorizer type. Valid values:
	//  - "JWT": Validates a JSON Web Token using the configured issuer and audiences.
	//  - "REQUEST": Invokes a Lambda function that returns an authorization decision.
	AuthorizerType string `json:"authorizer_type,omitempty" jsonschema:"Authorizer type. Valid values: - 'JWT': Validates a JSON Web Token using the configured issuer and audiences. - 'REQUEST': Invokes a Lambda function that returns an authorization decision."`
	// JWT configuration. Required when authorizer_type is "JWT".
	//  Configures the token issuer and expected audiences for JWT validation.
	JwtConfiguration *AwsHttpApiGatewayJwtConfigInput `json:"jwt_configuration,omitempty" jsonschema:"JWT configuration. Required when authorizer_type is 'JWT'. Configures the token issuer and expected audiences for JWT validation."`
	// Lambda function URI for REQUEST authorizers. This is the Lambda function
	//  invoke ARN. Required when authorizer_type is "REQUEST".
	AuthorizerUri string `json:"authorizer_uri,omitempty" jsonschema:"Lambda function URI for REQUEST authorizers. This is the Lambda function invoke ARN. Required when authorizer_type is 'REQUEST'."`
	// IAM role ARN that API Gateway assumes to invoke the Lambda authorizer.
	//  Only applicable to REQUEST authorizers.
	AuthorizerCredentialsArn string `json:"authorizer_credentials_arn,omitempty" jsonschema:"IAM role ARN that API Gateway assumes to invoke the Lambda authorizer. Only applicable to REQUEST authorizers."`
	// Identity sources used to extract the authorization token or context.
	//  For JWT authorizers: "$request.header.Authorization" (typical).
	//  For REQUEST authorizers: varies by implementation.
	IdentitySources []string `json:"identity_sources,omitempty" jsonschema:"Identity sources used to extract the authorization token or context. For JWT authorizers: '$request.header.Authorization' (typical). For REQUEST authorizers: varies by implementation."`
	// Time in seconds that API Gateway caches the authorizer result.
	//  Range: 0-3600. Set to 0 to disable caching.
	//  AWS default: 300 for REQUEST authorizers with identity sources.
	ResultTtlSeconds int32 `json:"result_ttl_seconds,omitempty" jsonschema:"Time in seconds that API Gateway caches the authorizer result. Range: 0-3600. Set to 0 to disable caching. AWS default: 300 for REQUEST authorizers with identity sources."`
	// Enable simple boolean responses from Lambda authorizers.
	//  When true, the Lambda returns {"isAuthorized": true/false} instead of an
	//  IAM policy document. Simpler to implement for most use cases.
	//  Only applicable to REQUEST authorizers.
	EnableSimpleResponses bool `json:"enable_simple_responses,omitempty" jsonschema:"Enable simple boolean responses from Lambda authorizers. When true; the Lambda returns {'isAuthorized': true/false} instead of an IAM policy document. Simpler to implement for most use cases. Only app..."`
	// Payload format version for the Lambda authorizer event.
	//  - "2.0" (recommended): Simplified event with direct access to headers/query params.
	//  - "1.0": Legacy format.
	//  Only applicable to REQUEST authorizers.
	AuthorizerPayloadFormatVersion string `json:"authorizer_payload_format_version,omitempty" jsonschema:"Payload format version for the Lambda authorizer event. - '2.0' (recommended): Simplified event with direct access to headers/query params. - '1.0': Legacy format. Only applicable to REQUEST authorize..."`
}

func (s *AwsHttpApiGatewayAuthorizerInput) validate() error {
	if s.JwtConfiguration != nil {
		if err := s.JwtConfiguration.validate(); err != nil {
			return fmt.Errorf("jwt_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsHttpApiGatewayAuthorizerInput) applyDefaults() {
	if s.JwtConfiguration != nil {
		s.JwtConfiguration.applyDefaults()
	}
}

func (s *AwsHttpApiGatewayAuthorizerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.AuthorizerType != "" {
		m["authorizer_type"] = s.AuthorizerType
	}
	if s.JwtConfiguration != nil {
		m["jwt_configuration"] = s.JwtConfiguration.toMap()
	}
	if s.AuthorizerUri != "" {
		m["authorizer_uri"] = s.AuthorizerUri
	}
	if s.AuthorizerCredentialsArn != "" {
		m["authorizer_credentials_arn"] = s.AuthorizerCredentialsArn
	}
	if len(s.IdentitySources) > 0 {
		m["identity_sources"] = s.IdentitySources
	}
	if s.ResultTtlSeconds != 0 {
		m["result_ttl_seconds"] = s.ResultTtlSeconds
	}
	if s.EnableSimpleResponses {
		m["enable_simple_responses"] = s.EnableSimpleResponses
	}
	if s.AuthorizerPayloadFormatVersion != "" {
		m["authorizer_payload_format_version"] = s.AuthorizerPayloadFormatVersion
	}
	return m
}

// AwsHttpApiGatewayCorsConfig configures cross-origin resource sharing (CORS) for the API.
//
//	CORS allows web browsers to make requests to the API from a different domain.
//	When not configured, the API returns no CORS headers and browsers block
//	cross-origin requests.
type AwsHttpApiGatewayCorsConfigInput struct {
	// Origins allowed to make cross-origin requests (e.g., "https://example.com", "*").
	AllowOrigins []string `json:"allow_origins,omitempty" jsonschema:"Origins allowed to make cross-origin requests (e.g.; 'https://example.com'; '*')."`
	// HTTP methods allowed for cross-origin requests (e.g., "GET", "POST", "OPTIONS").
	AllowMethods []string `json:"allow_methods,omitempty" jsonschema:"HTTP methods allowed for cross-origin requests (e.g.; 'GET'; 'POST'; 'OPTIONS')."`
	// Request headers allowed in cross-origin requests (e.g., "Content-Type", "Authorization").
	AllowHeaders []string `json:"allow_headers,omitempty" jsonschema:"Request headers allowed in cross-origin requests (e.g.; 'Content-Type'; 'Authorization')."`
	// Response headers exposed to the browser in cross-origin responses.
	ExposeHeaders []string `json:"expose_headers,omitempty" jsonschema:"Response headers exposed to the browser in cross-origin responses."`
	// Maximum time in seconds that browsers can cache CORS preflight results.
	//  Reduces the number of preflight OPTIONS requests. Range: 0-86400.
	MaxAgeSeconds int32 `json:"max_age_seconds,omitempty" jsonschema:"Maximum time in seconds that browsers can cache CORS preflight results. Reduces the number of preflight OPTIONS requests. Range: 0-86400."`
	// Whether the API supports credentials (cookies, authorization headers)
	//  in cross-origin requests.
	AllowCredentials bool `json:"allow_credentials,omitempty" jsonschema:"Whether the API supports credentials (cookies; authorization headers) in cross-origin requests."`
}

func (s *AwsHttpApiGatewayCorsConfigInput) validate() error {
	return nil
}

func (s *AwsHttpApiGatewayCorsConfigInput) applyDefaults() {
}

func (s *AwsHttpApiGatewayCorsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.AllowOrigins) > 0 {
		m["allow_origins"] = s.AllowOrigins
	}
	if len(s.AllowMethods) > 0 {
		m["allow_methods"] = s.AllowMethods
	}
	if len(s.AllowHeaders) > 0 {
		m["allow_headers"] = s.AllowHeaders
	}
	if len(s.ExposeHeaders) > 0 {
		m["expose_headers"] = s.ExposeHeaders
	}
	if s.MaxAgeSeconds != 0 {
		m["max_age_seconds"] = s.MaxAgeSeconds
	}
	if s.AllowCredentials {
		m["allow_credentials"] = s.AllowCredentials
	}
	return m
}

// AwsHttpApiGatewayIntegration defines the backend target for a route.
//
//	For HTTP APIs, the two primary integration types are AWS_PROXY (Lambda) and
//	HTTP_PROXY (upstream HTTP service).
type AwsHttpApiGatewayIntegrationInput struct {
	// Integration type. Valid values:
	//  - "AWS_PROXY": Lambda proxy integration -- API Gateway invokes a Lambda
	//    function and passes the HTTP request as the event.
	//  - "HTTP_PROXY": HTTP proxy integration -- API Gateway forwards the
	//    request to an upstream HTTP endpoint.
	IntegrationType string `json:"integration_type,omitempty" jsonschema:"Integration type. Valid values: - 'AWS_PROXY': Lambda proxy integration -- API Gateway invokes a Lambda function and passes the HTTP request as the event. - 'HTTP_PROXY': HTTP proxy integration -- API..."`
	// Integration URI. For AWS_PROXY integrations this is the Lambda function
	//  ARN. For HTTP_PROXY integrations this is the upstream HTTP URL.
	//  Accepts a direct value or a reference to another resource's output
	//  (e.g., an AwsLambda function_arn).
	IntegrationUri string `json:"integration_uri" jsonschema:"required,Integration URI. For AWS_PROXY integrations this is the Lambda function ARN. For HTTP_PROXY integrations this is the upstream HTTP URL. Accepts a direct value or a reference to another resource's outp..."`
	// Payload format version for Lambda integrations. Controls the format of the
	//  event sent to the Lambda function.
	//  - "2.0" (recommended): Simplified event structure with direct body access.
	//  - "1.0": Legacy format with multi-value headers and base64 encoding.
	//  Defaults to "2.0" when empty. Only applica...
	PayloadFormatVersion string `json:"payload_format_version,omitempty" jsonschema:"Payload format version for Lambda integrations. Controls the format of the event sent to the Lambda function. - '2.0' (recommended): Simplified event structure with direct body access. - '1.0': Legacy..."`
	// HTTP method used for the integration request. Defaults to the route's HTTP
	//  method for HTTP_PROXY integrations. For AWS_PROXY (Lambda) integrations,
	//  this is always POST regardless of the value set here.
	IntegrationMethod string `json:"integration_method,omitempty" jsonschema:"HTTP method used for the integration request. Defaults to the route's HTTP method for HTTP_PROXY integrations. For AWS_PROXY (Lambda) integrations; this is always POST regardless of the value set here..."`
	// Integration timeout in milliseconds. If the backend does not respond within
	//  this duration, API Gateway returns a 504 Gateway Timeout.
	//  Range: 50-30000 (50ms to 30s). AWS default: 30000 (30s).
	//  Leave at 0 to use the AWS default.
	TimeoutMilliseconds int32 `json:"timeout_milliseconds,omitempty" jsonschema:"Integration timeout in milliseconds. If the backend does not respond within this duration; API Gateway returns a 504 Gateway Timeout. Range: 50-30000 (50ms to 30s). AWS default: 30000 (30s). Leave at ..."`
}

func (s *AwsHttpApiGatewayIntegrationInput) validate() error {
	if s.IntegrationUri == "" {
		return fmt.Errorf("integration_uri is required")
	}
	return nil
}

func (s *AwsHttpApiGatewayIntegrationInput) applyDefaults() {
}

func (s *AwsHttpApiGatewayIntegrationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.IntegrationType != "" {
		m["integration_type"] = s.IntegrationType
	}
	m["integration_uri"] = s.IntegrationUri
	if s.PayloadFormatVersion != "" {
		m["payload_format_version"] = s.PayloadFormatVersion
	}
	if s.IntegrationMethod != "" {
		m["integration_method"] = s.IntegrationMethod
	}
	if s.TimeoutMilliseconds != 0 {
		m["timeout_milliseconds"] = s.TimeoutMilliseconds
	}
	return m
}

// AwsHttpApiGatewayJwtConfig configures JWT validation for a JWT authorizer.
type AwsHttpApiGatewayJwtConfigInput struct {
	// Token issuer URL. API Gateway validates that the JWT's "iss" claim matches
	//  this value. For Cognito: "https://cognito-idp.{region}.amazonaws.com/{userPoolId}".
	//  For Auth0: "https://{domain}/".
	Issuer string `json:"issuer,omitempty" jsonschema:"Token issuer URL. API Gateway validates that the JWT's 'iss' claim matches this value. For Cognito: 'https://cognito-idp.{region}.amazonaws.com/{userPoolId}'. For Auth0: 'https://{domain}/'."`
	// Expected audiences. API Gateway validates that the JWT's "aud" claim matches
	//  one of these values. For Cognito this is the app client ID.
	Audiences []string `json:"audiences,omitempty" jsonschema:"Expected audiences. API Gateway validates that the JWT's 'aud' claim matches one of these values. For Cognito this is the app client ID."`
}

func (s *AwsHttpApiGatewayJwtConfigInput) validate() error {
	return nil
}

func (s *AwsHttpApiGatewayJwtConfigInput) applyDefaults() {
}

func (s *AwsHttpApiGatewayJwtConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Issuer != "" {
		m["issuer"] = s.Issuer
	}
	if len(s.Audiences) > 0 {
		m["audiences"] = s.Audiences
	}
	return m
}

// AwsHttpApiGatewayRoute maps a request pattern to a backend integration.
//
//	Each route defines a route key (HTTP method + path or "$default") and the
//	integration configuration that processes matching requests.
type AwsHttpApiGatewayRouteInput struct {
	// Route key defining the request pattern to match. Format: "{METHOD} {PATH}"
	//  for specific routes (e.g., "GET /users", "POST /orders/{id}") or "$default"
	//  for a catch-all route that handles unmatched requests.
	RouteKey string `json:"route_key,omitempty" jsonschema:"Route key defining the request pattern to match. Format: '{METHOD} {PATH}' for specific routes (e.g.; 'GET /users'; 'POST /orders/{id}') or '$default' for a catch-all route that handles unmatched requ..."`
	// Backend integration that processes requests matching this route.
	Integration *AwsHttpApiGatewayIntegrationInput `json:"integration" jsonschema:"required,Backend integration that processes requests matching this route."`
	// Authorization type for this route. Valid values:
	//  - "NONE" (default): No authorization required.
	//  - "JWT": JSON Web Token authorization using a JWT authorizer.
	//  - "AWS_IAM": AWS IAM authorization using SigV4 signatures.
	AuthorizationType string `json:"authorization_type,omitempty" jsonschema:"Authorization type for this route. Valid values: - 'NONE' (default): No authorization required. - 'JWT': JSON Web Token authorization using a JWT authorizer. - 'AWS_IAM': AWS IAM authorization using S..."`
	// Name of the authorizer to use for this route. Must match the name of an
	//  authorizer defined in the `authorizers` field. Required when
	//  `authorization_type` is "JWT".
	AuthorizerName string `json:"authorizer_name,omitempty" jsonschema:"Name of the authorizer to use for this route. Must match the name of an authorizer defined in the 'authorizers' field. Required when 'authorization_type' is 'JWT'."`
	// OAuth 2.0 scopes required for JWT authorization. The request must include
	//  all specified scopes to be authorized. Only applicable when
	//  `authorization_type` is "JWT".
	AuthorizationScopes []string `json:"authorization_scopes,omitempty" jsonschema:"OAuth 2.0 scopes required for JWT authorization. The request must include all specified scopes to be authorized. Only applicable when 'authorization_type' is 'JWT'."`
}

func (s *AwsHttpApiGatewayRouteInput) validate() error {
	if s.Integration == nil {
		return fmt.Errorf("integration is required")
	}
	if s.Integration != nil {
		if err := s.Integration.validate(); err != nil {
			return fmt.Errorf("integration: %w", err)
		}
	}
	return nil
}

func (s *AwsHttpApiGatewayRouteInput) applyDefaults() {
	if s.Integration != nil {
		s.Integration.applyDefaults()
	}
}

func (s *AwsHttpApiGatewayRouteInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.RouteKey != "" {
		m["route_key"] = s.RouteKey
	}
	if s.Integration != nil {
		m["integration"] = s.Integration.toMap()
	}
	if s.AuthorizationType != "" {
		m["authorization_type"] = s.AuthorizationType
	}
	if s.AuthorizerName != "" {
		m["authorizer_name"] = s.AuthorizerName
	}
	if len(s.AuthorizationScopes) > 0 {
		m["authorization_scopes"] = s.AuthorizationScopes
	}
	return m
}

// AwsHttpApiGatewayStageConfig configures the deployment stage for the API.
//
//	Most HTTP APIs use a single "$default" stage with auto-deploy enabled.
type AwsHttpApiGatewayStageConfigInput struct {
	// Stage name. Defaults to "$default" when empty, which is the recommended
	//  configuration for HTTP APIs. Named stages (e.g., "prod", "dev") append
	//  the stage name to the invoke URL path.
	Name string `json:"name,omitempty" jsonschema:"Stage name. Defaults to '$default' when empty; which is the recommended configuration for HTTP APIs. Named stages (e.g.; 'prod'; 'dev') append the stage name to the invoke URL path."`
	// Enable automatic deployment when routes, integrations, or authorizers
	//  change. Defaults to true when the stage name is "$default" or empty.
	//  Set to false to require explicit deployments.
	AutoDeploy bool `json:"auto_deploy,omitempty" jsonschema:"Enable automatic deployment when routes; integrations; or authorizers change. Defaults to true when the stage name is '$default' or empty. Set to false to require explicit deployments."`
	// Access logging configuration. When set, API Gateway streams access logs
	//  to the specified CloudWatch Log Group.
	AccessLog *AwsHttpApiGatewayAccessLogConfigInput `json:"access_log,omitempty" jsonschema:"Access logging configuration. When set; API Gateway streams access logs to the specified CloudWatch Log Group."`
	// Default throttling settings applied to all routes unless overridden
	//  per route in the stage route settings.
	DefaultThrottle *AwsHttpApiGatewayThrottleConfigInput `json:"default_throttle,omitempty" jsonschema:"Default throttling settings applied to all routes unless overridden per route in the stage route settings."`
	// Stage variables passed to integrations. These act as environment-specific
	//  configuration values accessible in integration request parameters.
	StageVariables map[string]string `json:"stage_variables,omitempty" jsonschema:"Stage variables passed to integrations. These act as environment-specific configuration values accessible in integration request parameters."`
}

func (s *AwsHttpApiGatewayStageConfigInput) validate() error {
	if s.AccessLog != nil {
		if err := s.AccessLog.validate(); err != nil {
			return fmt.Errorf("access_log: %w", err)
		}
	}
	if s.DefaultThrottle != nil {
		if err := s.DefaultThrottle.validate(); err != nil {
			return fmt.Errorf("default_throttle: %w", err)
		}
	}
	return nil
}

func (s *AwsHttpApiGatewayStageConfigInput) applyDefaults() {
	if s.AccessLog != nil {
		s.AccessLog.applyDefaults()
	}
	if s.DefaultThrottle != nil {
		s.DefaultThrottle.applyDefaults()
	}
}

func (s *AwsHttpApiGatewayStageConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.AutoDeploy {
		m["auto_deploy"] = s.AutoDeploy
	}
	if s.AccessLog != nil {
		m["access_log"] = s.AccessLog.toMap()
	}
	if s.DefaultThrottle != nil {
		m["default_throttle"] = s.DefaultThrottle.toMap()
	}
	if len(s.StageVariables) > 0 {
		m["stage_variables"] = s.StageVariables
	}
	return m
}

// AwsHttpApiGatewayThrottleConfig configures request throttling for the API stage.
type AwsHttpApiGatewayThrottleConfigInput struct {
	// Maximum number of concurrent requests allowed (burst). API Gateway uses
	//  the token bucket algorithm where burst_limit is the bucket size.
	BurstLimit int32 `json:"burst_limit,omitempty" jsonschema:"Maximum number of concurrent requests allowed (burst). API Gateway uses the token bucket algorithm where burst_limit is the bucket size."`
	// Steady-state request rate limit (requests per second). API Gateway uses
	//  this as the token refill rate.
	RateLimit float64 `json:"rate_limit,omitempty" jsonschema:"Steady-state request rate limit (requests per second). API Gateway uses this as the token refill rate."`
}

func (s *AwsHttpApiGatewayThrottleConfigInput) validate() error {
	return nil
}

func (s *AwsHttpApiGatewayThrottleConfigInput) applyDefaults() {
}

func (s *AwsHttpApiGatewayThrottleConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.BurstLimit != 0 {
		m["burst_limit"] = s.BurstLimit
	}
	if s.RateLimit != 0 {
		m["rate_limit"] = s.RateLimit
	}
	return m
}

// ParseAwsHttpApiGateway validates and normalizes a AwsHttpApiGateway cloud_object.
func ParseAwsHttpApiGateway(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsHttpApiGateway"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsHttpApiGatewaySpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
