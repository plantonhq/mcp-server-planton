// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsEcsService represents a containerized application deployed on AWS ECS.
//
//	This resource manages ECS services that can run on either Fargate or EC2.
type AwsEcsServiceSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// cluster_arn is the ARN of the ECS cluster where this service will run.
	//  This must already exist (created by a separate EcsCluster resource or otherwise).
	//  Example: "arn:aws:ecs:us-east-1:123456789012:cluster/my-mixed-cluster"
	ClusterArn string `json:"cluster_arn" jsonschema:"required,cluster_arn is the ARN of the ECS cluster where this service will run. This must already exist (created by a separate EcsCluster resource or otherwise). Example: 'arn:aws:ecs:us-east-1:123456789012:cl..."`
	// AWS ECS Service container configuration.
	Container *AwsEcsServiceContainerInput `json:"container" jsonschema:"required,AWS ECS Service container configuration."`
	// ECS service network configuration.
	Network *AwsEcsServiceNetworkInput `json:"network" jsonschema:"required,ECS service network configuration."`
	// IAM configuration for the ECS service.
	Iam *AwsEcsServiceIamInput `json:"iam,omitempty" jsonschema:"IAM configuration for the ECS service."`
	// alb defines how an ALB fronts traffic to this ECS service, supporting path- or hostname-based routing.
	Alb *AwsEcsServiceAlbInput `json:"alb,omitempty" jsonschema:"alb defines how an ALB fronts traffic to this ECS service; supporting path- or hostname-based routing."`
	// health_check_grace_period_seconds is the number of seconds ECS will ignore ALB health check failures
	//  during container startup. This prevents a race condition where the ALB marks a task unhealthy
	//  before the application has finished booting. Recommended: 60-120 seconds for typical apps.
	//  Only valid ...
	HealthCheckGracePeriodSeconds int32 `json:"health_check_grace_period_seconds,omitempty" jsonschema:"health_check_grace_period_seconds is the number of seconds ECS will ignore ALB health check failures during container startup. This prevents a race condition where the ALB marks a task unhealthy befor..."`
	// autoscaling configuration for the ECS service using target tracking.
	//  When enabled, AWS Application Auto Scaling automatically adjusts the desired task count
	//  based on CPU or memory utilization.
	Autoscaling *AwsEcsServiceAutoscalingInput `json:"autoscaling,omitempty" jsonschema:"autoscaling configuration for the ECS service using target tracking. When enabled; AWS Application Auto Scaling automatically adjusts the desired task count based on CPU or memory utilization."`
}

func (s *AwsEcsServiceSpecInput) validate() error {
	if s.ClusterArn == "" {
		return fmt.Errorf("cluster_arn is required")
	}
	if s.Container == nil {
		return fmt.Errorf("container is required")
	}
	if s.Container != nil {
		if err := s.Container.validate(); err != nil {
			return fmt.Errorf("container: %w", err)
		}
	}
	if s.Network == nil {
		return fmt.Errorf("network is required")
	}
	if s.Network != nil {
		if err := s.Network.validate(); err != nil {
			return fmt.Errorf("network: %w", err)
		}
	}
	if s.Iam != nil {
		if err := s.Iam.validate(); err != nil {
			return fmt.Errorf("iam: %w", err)
		}
	}
	if s.Alb != nil {
		if err := s.Alb.validate(); err != nil {
			return fmt.Errorf("alb: %w", err)
		}
	}
	if s.Autoscaling != nil {
		if err := s.Autoscaling.validate(); err != nil {
			return fmt.Errorf("autoscaling: %w", err)
		}
	}
	return nil
}

func (s *AwsEcsServiceSpecInput) applyDefaults() {
	if s.Container != nil {
		s.Container.applyDefaults()
	}
	if s.Network != nil {
		s.Network.applyDefaults()
	}
	if s.Iam != nil {
		s.Iam.applyDefaults()
	}
	if s.Alb != nil {
		s.Alb.applyDefaults()
	}
	if s.HealthCheckGracePeriodSeconds == 0 {
		s.HealthCheckGracePeriodSeconds = 60
	}
	if s.Autoscaling != nil {
		s.Autoscaling.applyDefaults()
	}
}

func (s *AwsEcsServiceSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["cluster_arn"] = s.ClusterArn
	if s.Container != nil {
		m["container"] = s.Container.toMap()
	}
	if s.Network != nil {
		m["network"] = s.Network.toMap()
	}
	if s.Iam != nil {
		m["iam"] = s.Iam.toMap()
	}
	if s.Alb != nil {
		m["alb"] = s.Alb.toMap()
	}
	if s.HealthCheckGracePeriodSeconds != 0 {
		m["health_check_grace_period_seconds"] = s.HealthCheckGracePeriodSeconds
	}
	if s.Autoscaling != nil {
		m["autoscaling"] = s.Autoscaling.toMap()
	}
	return m
}

// AwsEcsServiceAlb indicates how an ALB fronts this ECS service, supporting path- or hostname-based routing.
type AwsEcsServiceAlbInput struct {
	// enabled controls whether an ALB is used. If false, no ALB is attached.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled controls whether an ALB is used. If false; no ALB is attached."`
	// arn is the ARN of the ALB. Required if enabled = true.
	Arn string `json:"arn,omitempty" jsonschema:"arn is the ARN of the ALB. Required if enabled = true."`
	// routingType can be "path" or "hostname" if enabled.
	//  If "path", specify a path (e.g. "/my-service").
	//  If "hostname", specify a hostname (e.g. "api.example.com").
	RoutingType string `json:"routing_type,omitempty" jsonschema:"routingType can be 'path' or 'hostname' if enabled. If 'path'; specify a path (e.g. '/my-service'). If 'hostname'; specify a hostname (e.g. 'api.example.com')."`
	// path is used if routingType = "path".
	Path string `json:"path,omitempty" jsonschema:"path is used if routingType = 'path'."`
	// hostname is used if routingType = "hostname".
	Hostname string `json:"hostname,omitempty" jsonschema:"hostname is used if routingType = 'hostname'."`
	// listener_port is the port on the ALB to forward traffic to.
	ListenerPort int32 `json:"listener_port" jsonschema:"required,listener_port is the port on the ALB to forward traffic to."`
	// listener_priority is the priority of the ALB listener rule.
	//  Lower numbers have higher priority. This value should be unique across all rules for this ALB.
	ListenerPriority int32 `json:"listener_priority,omitempty" jsonschema:"listener_priority is the priority of the ALB listener rule. Lower numbers have higher priority. This value should be unique across all rules for this ALB."`
	// health_check overrides the default target-group health check.
	HealthCheck *AwsEcsServiceHealthCheckInput `json:"health_check,omitempty" jsonschema:"health_check overrides the default target-group health check."`
}

func (s *AwsEcsServiceAlbInput) validate() error {
	if s.HealthCheck != nil {
		if err := s.HealthCheck.validate(); err != nil {
			return fmt.Errorf("health_check: %w", err)
		}
	}
	return nil
}

func (s *AwsEcsServiceAlbInput) applyDefaults() {
	if s.ListenerPriority == 0 {
		s.ListenerPriority = 100
	}
	if s.HealthCheck != nil {
		s.HealthCheck.applyDefaults()
	}
}

func (s *AwsEcsServiceAlbInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Arn != "" {
		m["arn"] = s.Arn
	}
	if s.RoutingType != "" {
		m["routing_type"] = s.RoutingType
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	m["listener_port"] = s.ListenerPort
	if s.ListenerPriority != 0 {
		m["listener_priority"] = s.ListenerPriority
	}
	if s.HealthCheck != nil {
		m["health_check"] = s.HealthCheck.toMap()
	}
	return m
}

// AwsEcsServiceAutoscaling defines target tracking auto scaling configuration for the ECS service.
//
//	AWS Application Auto Scaling automatically adjusts the desired task count to maintain
//	the target metric (CPU or memory utilization).
type AwsEcsServiceAutoscalingInput struct {
	// enabled controls whether autoscaling is configured for this service.
	Enabled bool `json:"enabled,omitempty" jsonschema:"enabled controls whether autoscaling is configured for this service."`
	// min_tasks is the minimum number of tasks to maintain.
	//  Must be >= 1 and <= max_tasks.
	MinTasks int32 `json:"min_tasks,omitempty" jsonschema:"min_tasks is the minimum number of tasks to maintain. Must be >= 1 and <= max_tasks."`
	// max_tasks is the maximum number of tasks to scale to.
	//  Must be >= min_tasks.
	MaxTasks int32 `json:"max_tasks,omitempty" jsonschema:"max_tasks is the maximum number of tasks to scale to. Must be >= min_tasks."`
	// target_cpu_percent is the target average CPU utilization (as a percentage) across all tasks.
	//  AWS will scale out when CPU exceeds this threshold and scale in when it drops below.
	//  Recommended: 70-75 for production workloads.
	//  Example: 75 means target 75% CPU utilization.
	TargetCpuPercent int32 `json:"target_cpu_percent,omitempty" jsonschema:"target_cpu_percent is the target average CPU utilization (as a percentage) across all tasks. AWS will scale out when CPU exceeds this threshold and scale in when it drops below. Recommended: 70-75 for..."`
	// target_memory_percent is the target average memory utilization (as a percentage) across all tasks.
	//  Similar to target_cpu_percent but for memory.
	//  This is optional; most services scale on CPU alone.
	TargetMemoryPercent int32 `json:"target_memory_percent,omitempty" jsonschema:"target_memory_percent is the target average memory utilization (as a percentage) across all tasks. Similar to target_cpu_percent but for memory. This is optional; most services scale on CPU alone."`
}

func (s *AwsEcsServiceAutoscalingInput) validate() error {
	return nil
}

func (s *AwsEcsServiceAutoscalingInput) applyDefaults() {
	if s.TargetCpuPercent == 0 {
		s.TargetCpuPercent = 75
	}
}

func (s *AwsEcsServiceAutoscalingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.MinTasks != 0 {
		m["min_tasks"] = s.MinTasks
	}
	if s.MaxTasks != 0 {
		m["max_tasks"] = s.MaxTasks
	}
	if s.TargetCpuPercent != 0 {
		m["target_cpu_percent"] = s.TargetCpuPercent
	}
	if s.TargetMemoryPercent != 0 {
		m["target_memory_percent"] = s.TargetMemoryPercent
	}
	return m
}

// AwsEcsServiceContainer is a wrapper for the container spec.
type AwsEcsServiceContainerInput struct {
	// container image
	Image *AwsEcsServiceContainerImageInput `json:"image,omitempty" jsonschema:"container image"`
	// container environment variables, secrets, and environment files
	Env *AwsEcsServiceContainerEnvInput `json:"env,omitempty" jsonschema:"container environment variables; secrets; and environment files"`
	// container_port is the port inside the container that should be exposed to receive traffic.
	//  This is optional if the service doesn't need inbound requests (e.g., a background worker).
	//  Example: 80 for HTTP
	Port int32 `json:"port,omitempty" jsonschema:"container_port is the port inside the container that should be exposed to receive traffic. This is optional if the service doesn't need inbound requests (e.g.; a background worker). Example: 80 for HT..."`
	// replicas is the number of task replicas to run for this service.
	//  higher values improve availability at increased cost.
	Replicas int32 `json:"replicas,omitempty" jsonschema:"replicas is the number of task replicas to run for this service. higher values improve availability at increased cost."`
	// cpu is the amount of vCPU (in CPU units) to allocate for the entire task.
	//  Valid Fargate values include 256, 512, 1024, 2048, etc., subject to ECS constraints.
	//  Example: 512
	Cpu int32 `json:"cpu" jsonschema:"required,cpu is the amount of vCPU (in CPU units) to allocate for the entire task. Valid Fargate values include 256; 512; 1024; 2048; etc.; subject to ECS constraints. Example: 512"`
	// memory is the total MiB of RAM for the task.
	//  Valid values depend on CPU. For example, 512 CPU can pair with 1024–4096 MiB.
	//  Example: 1024
	Memory int32 `json:"memory" jsonschema:"required,memory is the total MiB of RAM for the task. Valid values depend on CPU. For example; 512 CPU can pair with 1024–4096 MiB. Example: 1024"`
	// logging controls whether CloudWatch log configuration is injected automatically.
	Logging *AwsEcsServiceContainerLoggingInput `json:"logging,omitempty" jsonschema:"logging controls whether CloudWatch log configuration is injected automatically."`
}

func (s *AwsEcsServiceContainerInput) validate() error {
	if s.Image != nil {
		if err := s.Image.validate(); err != nil {
			return fmt.Errorf("image: %w", err)
		}
	}
	if s.Env != nil {
		if err := s.Env.validate(); err != nil {
			return fmt.Errorf("env: %w", err)
		}
	}
	if s.Logging != nil {
		if err := s.Logging.validate(); err != nil {
			return fmt.Errorf("logging: %w", err)
		}
	}
	return nil
}

func (s *AwsEcsServiceContainerInput) applyDefaults() {
	if s.Image != nil {
		s.Image.applyDefaults()
	}
	if s.Env != nil {
		s.Env.applyDefaults()
	}
	if s.Logging != nil {
		s.Logging.applyDefaults()
	}
}

func (s *AwsEcsServiceContainerInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Image != nil {
		m["image"] = s.Image.toMap()
	}
	if s.Env != nil {
		m["env"] = s.Env.toMap()
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.Replicas != 0 {
		m["replicas"] = s.Replicas
	}
	m["cpu"] = s.Cpu
	m["memory"] = s.Memory
	if s.Logging != nil {
		m["logging"] = s.Logging.toMap()
	}
	return m
}

// AwsEcsServiceContainerEnv is a wrapper for environment variables, secrets, and files.
type AwsEcsServiceContainerEnvInput struct {
	// map of environment variables to be set in the container.
	//  The key is the name of the variable, and the value is the value to be set.
	Variables map[string]string `json:"variables,omitempty" jsonschema:"map of environment variables to be set in the container. The key is the name of the variable; and the value is the value to be set."`
	// map of environment secrets to be set in the container.
	//  The key is the name of the variable, and the value is the value to be set.
	//  The value can be a plaintext value or a reference to a secret in AWS Secrets Manager or SSM Parameter Store.
	Secrets map[string]string `json:"secrets,omitempty" jsonschema:"map of environment secrets to be set in the container. The key is the name of the variable; and the value is the value to be set. The value can be a plaintext value or a reference to a secret in AWS S..."`
	// s3_files is a list of S3 URIs whose contents are loaded as environment variables
	//  via the ECS "environmentFiles" feature.
	S3Files []string `json:"s3_files,omitempty" jsonschema:"s3_files is a list of S3 URIs whose contents are loaded as environment variables via the ECS 'environmentFiles' feature."`
}

func (s *AwsEcsServiceContainerEnvInput) validate() error {
	return nil
}

func (s *AwsEcsServiceContainerEnvInput) applyDefaults() {
}

func (s *AwsEcsServiceContainerEnvInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.Variables) > 0 {
		m["variables"] = s.Variables
	}
	if len(s.Secrets) > 0 {
		m["secrets"] = s.Secrets
	}
	if len(s.S3Files) > 0 {
		m["s3_files"] = s.S3Files
	}
	return m
}

// AwsEcsServiceContainerImage represents the container image information.
type AwsEcsServiceContainerImageInput struct {
	// The repository of the image (e.g., "gcr.io/project/image").
	Repo string `json:"repo,omitempty" jsonschema:"The repository of the image (e.g.; 'gcr.io/project/image')."`
	// The tag of the image (e.g., "latest" or "1.0.0").
	Tag string `json:"tag,omitempty" jsonschema:"The tag of the image (e.g.; 'latest' or '1.0.0')."`
}

func (s *AwsEcsServiceContainerImageInput) validate() error {
	return nil
}

func (s *AwsEcsServiceContainerImageInput) applyDefaults() {
}

func (s *AwsEcsServiceContainerImageInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Repo != "" {
		m["repo"] = s.Repo
	}
	if s.Tag != "" {
		m["tag"] = s.Tag
	}
	return m
}

// AwsEcsServiceContainerLogging controls CloudWatch logging for the container.
type AwsEcsServiceContainerLoggingInput struct {
	// If true (default), the module auto-creates a CloudWatch Log Group
	//  named "/ecs/<serviceName>" with 30-day retention and configures
	//  the awslogs driver.
	Enabled bool `json:"enabled,omitempty" jsonschema:"If true (default); the module auto-creates a CloudWatch Log Group named '/ecs/<serviceName>' with 30-day retention and configures the awslogs driver."`
}

func (s *AwsEcsServiceContainerLoggingInput) validate() error {
	return nil
}

func (s *AwsEcsServiceContainerLoggingInput) applyDefaults() {
}

func (s *AwsEcsServiceContainerLoggingInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	return m
}

// AwsEcsServiceHealthCheck defines ALB target-group health check settings.
type AwsEcsServiceHealthCheckInput struct {
	// protocol can be HTTP, HTTPS, or TCP.
	Protocol string `json:"protocol,omitempty" jsonschema:"protocol can be HTTP; HTTPS; or TCP."`
	// path to ping (HTTP/HTTPS only), defaults to "/".
	Path string `json:"path,omitempty" jsonschema:"path to ping (HTTP/HTTPS only); defaults to '/'."`
	// port may be "traffic-port" or an explicit port number as string.
	Port string `json:"port,omitempty" jsonschema:"port may be 'traffic-port' or an explicit port number as string."`
	// interval between checks in seconds. AWS default is 30.
	Interval int32 `json:"interval,omitempty" jsonschema:"interval between checks in seconds. AWS default is 30."`
	// timeout per check in seconds. AWS default is 5.
	Timeout int32 `json:"timeout,omitempty" jsonschema:"timeout per check in seconds. AWS default is 5."`
	// number of successes before a target is considered healthy. AWS default is 5.
	HealthyThreshold int32 `json:"healthy_threshold,omitempty" jsonschema:"number of successes before a target is considered healthy. AWS default is 5."`
	// number of failures before a target is considered unhealthy. AWS default is 2.
	UnhealthyThreshold int32 `json:"unhealthy_threshold,omitempty" jsonschema:"number of failures before a target is considered unhealthy. AWS default is 2."`
}

func (s *AwsEcsServiceHealthCheckInput) validate() error {
	return nil
}

func (s *AwsEcsServiceHealthCheckInput) applyDefaults() {
}

func (s *AwsEcsServiceHealthCheckInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Protocol != "" {
		m["protocol"] = s.Protocol
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Port != "" {
		m["port"] = s.Port
	}
	if s.Interval != 0 {
		m["interval"] = s.Interval
	}
	if s.Timeout != 0 {
		m["timeout"] = s.Timeout
	}
	if s.HealthyThreshold != 0 {
		m["healthy_threshold"] = s.HealthyThreshold
	}
	if s.UnhealthyThreshold != 0 {
		m["unhealthy_threshold"] = s.UnhealthyThreshold
	}
	return m
}

// AWS ECS Service IAM configuration
type AwsEcsServiceIamInput struct {
	// task_execution_role_arn is the IAM role used by ECS to pull private images and write logs.
	//  If omitted, a default "ecsTaskExecutionRole" may be assumed, but it must already exist.
	//  Example: "arn:aws:iam::123456789012:role/ecsTaskExecutionRole"
	TaskExecutionRoleArn string `json:"task_execution_role_arn,omitempty" jsonschema:"task_execution_role_arn is the IAM role used by ECS to pull private images and write logs. If omitted; a default 'ecsTaskExecutionRole' may be assumed; but it must already exist. Example: 'arn:aws:iam..."`
	// task_role_arn is the IAM role your container uses if it needs AWS permissions.
	//  Omit if your container does not call AWS APIs.
	//  Example: "arn:aws:iam::123456789012:role/myAppTaskRole"
	TaskRoleArn string `json:"task_role_arn,omitempty" jsonschema:"task_role_arn is the IAM role your container uses if it needs AWS permissions. Omit if your container does not call AWS APIs. Example: 'arn:aws:iam::123456789012:role/myAppTaskRole'"`
}

func (s *AwsEcsServiceIamInput) validate() error {
	return nil
}

func (s *AwsEcsServiceIamInput) applyDefaults() {
}

func (s *AwsEcsServiceIamInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.TaskExecutionRoleArn != "" {
		m["task_execution_role_arn"] = s.TaskExecutionRoleArn
	}
	if s.TaskRoleArn != "" {
		m["task_role_arn"] = s.TaskRoleArn
	}
	return m
}

// AwsEcsServiceNetwork defines the networking configuration for the ECS service.
type AwsEcsServiceNetworkInput struct {
	// subnets is a list of VPC subnet IDs where the Fargate tasks will run.
	//  Typically private subnets for production, often at least two for high availability.
	Subnets []string `json:"subnets" jsonschema:"required,subnets is a list of VPC subnet IDs where the Fargate tasks will run. Typically private subnets for production; often at least two for high availability."`
	// security_groups is a list of security group IDs to apply to each task's ENI.
	//  If not provided, ECS may use the default VPC security group, which is not ideal for production.
	SecurityGroups []string `json:"security_groups,omitempty" jsonschema:"security_groups is a list of security group IDs to apply to each task's ENI. If not provided; ECS may use the default VPC security group; which is not ideal for production."`
}

func (s *AwsEcsServiceNetworkInput) validate() error {
	if len(s.Subnets) == 0 {
		return fmt.Errorf("subnets is required")
	}
	return nil
}

func (s *AwsEcsServiceNetworkInput) applyDefaults() {
}

func (s *AwsEcsServiceNetworkInput) toMap() map[string]any {
	m := make(map[string]any)
	m["subnets"] = s.Subnets
	if len(s.SecurityGroups) > 0 {
		m["security_groups"] = s.SecurityGroups
	}
	return m
}

// ParseAwsEcsService validates and normalizes a AwsEcsService cloud_object.
func ParseAwsEcsService(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEcsService"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEcsServiceSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
