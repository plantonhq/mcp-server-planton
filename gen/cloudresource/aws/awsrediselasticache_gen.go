// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-redis-elasticache
type AwsRedisElasticacheSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Cache engine to use. Redis is the dominant choice; Valkey is the open-source
	//  Redis-compatible alternative. Values: "redis", "valkey".
	Engine string `json:"engine" jsonschema:"required,Cache engine to use. Redis is the dominant choice; Valkey is the open-source Redis-compatible alternative. Values: 'redis'; 'valkey'."`
	// Engine version to deploy. Examples: "7.1", "7.0", "6.2" for Redis;
	//  "7.2" for Valkey. Leave empty to use the provider default.
	EngineVersion string `json:"engine_version,omitempty" jsonschema:"Engine version to deploy. Examples: '7.1'; '7.0'; '6.2' for Redis; '7.2' for Valkey. Leave empty to use the provider default."`
	// Human-readable description for the replication group. Required by AWS.
	Description string `json:"description" jsonschema:"required,Human-readable description for the replication group. Required by AWS."`
	// ElastiCache node type. Determines CPU, memory, and network capacity.
	//  Examples: "cache.t3.micro" (dev), "cache.r7g.large" (production),
	//  "cache.r6gd.xlarge" (data tiering).
	NodeType string `json:"node_type" jsonschema:"required,ElastiCache node type. Determines CPU; memory; and network capacity. Examples: 'cache.t3.micro' (dev); 'cache.r7g.large' (production); 'cache.r6gd.xlarge' (data tiering)."`
	// Port on which the cluster accepts connections. Default: 6379.
	//  This is a ForceNew attribute — changing it destroys and recreates the cluster.
	Port int32 `json:"port,omitempty" jsonschema:"Port on which the cluster accepts connections. Default: 6379. This is a ForceNew attribute — changing it destroys and recreates the cluster."`
	// Total number of cache clusters (nodes) in the replication group. This includes
	//  the primary and all read replicas. For example, 3 means 1 primary + 2 replicas.
	//  Range: 1–6. Mutually exclusive with `num_node_groups`.
	NumCacheClusters int32 `json:"num_cache_clusters,omitempty" jsonschema:"Total number of cache clusters (nodes) in the replication group. This includes the primary and all read replicas. For example; 3 means 1 primary + 2 replicas. Range: 1–6. Mutually exclusive with 'nu..."`
	// Number of node groups (shards) for Cluster Mode Enabled. Each shard holds a
	//  partition of the keyspace. Mutually exclusive with `num_cache_clusters`.
	NumNodeGroups int32 `json:"num_node_groups,omitempty" jsonschema:"Number of node groups (shards) for Cluster Mode Enabled. Each shard holds a partition of the keyspace. Mutually exclusive with 'num_cache_clusters'."`
	// Number of read replicas per shard. Range: 0–5. Only valid when
	//  `num_node_groups` is set.
	ReplicasPerNodeGroup int32 `json:"replicas_per_node_group,omitempty" jsonschema:"Number of read replicas per shard. Range: 0–5. Only valid when 'num_node_groups' is set."`
	// Enable automatic failover to a read replica if the primary fails.
	//  Requires `num_cache_clusters >= 2` (non-clustered) or `num_node_groups > 0`
	//  (clustered mode, where failover is always on).
	AutomaticFailoverEnabled bool `json:"automatic_failover_enabled,omitempty" jsonschema:"Enable automatic failover to a read replica if the primary fails. Requires 'num_cache_clusters >= 2' (non-clustered) or 'num_node_groups > 0' (clustered mode; where failover is always on)."`
	// Deploy replicas across multiple Availability Zones for resilience against
	//  AZ-level failures. Requires `automatic_failover_enabled` to be true.
	MultiAzEnabled bool `json:"multi_az_enabled,omitempty" jsonschema:"Deploy replicas across multiple Availability Zones for resilience against AZ-level failures. Requires 'automatic_failover_enabled' to be true."`
	// Subnet IDs for the ElastiCache subnet group. Provide subnets in at least two
	//  AZs for multi-AZ deployments. A subnet group is created automatically from
	//  these subnets.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs for the ElastiCache subnet group. Provide subnets in at least two AZs for multi-AZ deployments. A subnet group is created automatically from these subnets."`
	// VPC security groups to attach to the cluster nodes. Controls network-level
	//  access to the Redis/Valkey endpoint.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"VPC security groups to attach to the cluster nodes. Controls network-level access to the Redis/Valkey endpoint."`
	// Enable encryption at rest for data stored on disk and in snapshots.
	//  ForceNew — changing this destroys and recreates the cluster.
	AtRestEncryptionEnabled bool `json:"at_rest_encryption_enabled,omitempty" jsonschema:"Enable encryption at rest for data stored on disk and in snapshots. ForceNew — changing this destroys and recreates the cluster."`
	// Enable encryption in transit (TLS) for all client connections and
	//  replication traffic. Strongly recommended for production.
	TransitEncryptionEnabled bool `json:"transit_encryption_enabled,omitempty" jsonschema:"Enable encryption in transit (TLS) for all client connections and replication traffic. Strongly recommended for production."`
	// TLS enforcement mode. "preferred" allows both TLS and non-TLS connections
	//  (useful during migration); "required" enforces TLS for all connections.
	//  Only valid when `transit_encryption_enabled` is true.
	TransitEncryptionMode string `json:"transit_encryption_mode,omitempty" jsonschema:"TLS enforcement mode. 'preferred' allows both TLS and non-TLS connections (useful during migration); 'required' enforces TLS for all connections. Only valid when 'transit_encryption_enabled' is true."`
	// Customer-managed KMS key for at-rest encryption. When set, ElastiCache uses
	//  this key instead of the AWS-managed key. ForceNew — changing this destroys
	//  and recreates the cluster.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key for at-rest encryption. When set; ElastiCache uses this key instead of the AWS-managed key. ForceNew — changing this destroys and recreates the cluster."`
	// Redis AUTH token (password) for client authentication. Requires
	//  `transit_encryption_enabled` to be true. 16–128 printable characters.
	//  Mutually exclusive with `user_group_ids`.
	AuthToken string `json:"auth_token,omitempty" jsonschema:"Redis AUTH token (password) for client authentication. Requires 'transit_encryption_enabled' to be true. 16–128 printable characters. Mutually exclusive with 'user_group_ids'."`
	// Redis ACL user group IDs for fine-grained access control. Each user group
	//  defines users with specific command and key permissions. Mutually exclusive
	//  with `auth_token`.
	UserGroupIds []string `json:"user_group_ids,omitempty" jsonschema:"Redis ACL user group IDs for fine-grained access control. Each user group defines users with specific command and key permissions. Mutually exclusive with 'auth_token'."`
	// Weekly maintenance window in UTC. Format: "ddd:hh24:mi-ddd:hh24:mi".
	//  Example: "sun:05:00-sun:06:00". Leave empty for AWS-assigned default.
	MaintenanceWindow string `json:"maintenance_window,omitempty" jsonschema:"Weekly maintenance window in UTC. Format: 'ddd:hh24:mi-ddd:hh24:mi'. Example: 'sun:05:00-sun:06:00'. Leave empty for AWS-assigned default."`
	// Number of days to retain automatic snapshots before deletion. 0 disables
	//  automatic snapshots. Range: 0–35.
	SnapshotRetentionLimit int32 `json:"snapshot_retention_limit,omitempty" jsonschema:"Number of days to retain automatic snapshots before deletion. 0 disables automatic snapshots. Range: 0–35."`
	// Daily snapshot window in UTC. Format: "hh24:mi-hh24:mi".
	//  Example: "03:00-04:00". Leave empty for AWS-assigned default.
	SnapshotWindow string `json:"snapshot_window,omitempty" jsonschema:"Daily snapshot window in UTC. Format: 'hh24:mi-hh24:mi'. Example: '03:00-04:00'. Leave empty for AWS-assigned default."`
	// Identifier for the final snapshot taken when the cluster is deleted. If not
	//  provided, no final snapshot is created.
	FinalSnapshotIdentifier string `json:"final_snapshot_identifier,omitempty" jsonschema:"Identifier for the final snapshot taken when the cluster is deleted. If not provided; no final snapshot is created."`
	// Apply changes immediately instead of waiting for the next maintenance window.
	//  May cause brief downtime for some operations.
	ApplyImmediately bool `json:"apply_immediately,omitempty" jsonschema:"Apply changes immediately instead of waiting for the next maintenance window. May cause brief downtime for some operations."`
	// Parameter group family for custom parameters. Required when `parameters` is
	//  provided. Examples: "redis7", "redis6.x", "valkey7".
	ParameterGroupFamily string `json:"parameter_group_family,omitempty" jsonschema:"Parameter group family for custom parameters. Required when 'parameters' is provided. Examples: 'redis7'; 'redis6.x'; 'valkey7'."`
	// Custom cache parameters to apply via a managed parameter group. Common
	//  examples: maxmemory-policy, timeout, tcp-keepalive.
	Parameters []*AwsRedisElasticacheParameterInput `json:"parameters,omitempty" jsonschema:"Custom cache parameters to apply via a managed parameter group. Common examples: maxmemory-policy; timeout; tcp-keepalive."`
	// Log delivery configurations for slow-log and/or engine-log. At most 2
	//  entries — one per log type. Logs can be delivered to CloudWatch Logs or
	//  Kinesis Data Firehose.
	LogDeliveryConfigurations []*AwsRedisElasticacheLogDeliveryConfigInput `json:"log_delivery_configurations,omitempty" jsonschema:"Log delivery configurations for slow-log and/or engine-log. At most 2 entries — one per log type. Logs can be delivered to CloudWatch Logs or Kinesis Data Firehose."`
	// SNS topic ARN for cluster event notifications (failover, maintenance,
	//  configuration changes, etc.).
	NotificationTopicArn string `json:"notification_topic_arn,omitempty" jsonschema:"SNS topic ARN for cluster event notifications (failover; maintenance; configuration changes; etc.)."`
	// Automatically apply minor engine version upgrades during maintenance windows.
	AutoMinorVersionUpgrade bool `json:"auto_minor_version_upgrade,omitempty" jsonschema:"Automatically apply minor engine version upgrades during maintenance windows."`
	// Enable data tiering — automatically moves less-frequently-accessed data to
	//  SSD storage for up to 5x more data per node. Only available on r6gd node
	//  types. ForceNew — cannot be changed after creation.
	DataTieringEnabled bool `json:"data_tiering_enabled,omitempty" jsonschema:"Enable data tiering — automatically moves less-frequently-accessed data to SSD storage for up to 5x more data per node. Only available on r6gd node types. ForceNew — cannot be changed after creati..."`
}

func (s *AwsRedisElasticacheSpecInput) validate() error {
	if s.Engine == "" {
		return fmt.Errorf("engine is required")
	}
	if s.Description == "" {
		return fmt.Errorf("description is required")
	}
	if s.NodeType == "" {
		return fmt.Errorf("node_type is required")
	}
	for i, v := range s.Parameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("parameters[%d]: %w", i, err)
			}
		}
	}
	for i, v := range s.LogDeliveryConfigurations {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("log_delivery_configurations[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsRedisElasticacheSpecInput) applyDefaults() {
	if s.Port == 0 {
		s.Port = 6379
	}
}

func (s *AwsRedisElasticacheSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["engine"] = s.Engine
	if s.EngineVersion != "" {
		m["engine_version"] = s.EngineVersion
	}
	m["description"] = s.Description
	m["node_type"] = s.NodeType
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.NumCacheClusters != 0 {
		m["num_cache_clusters"] = s.NumCacheClusters
	}
	if s.NumNodeGroups != 0 {
		m["num_node_groups"] = s.NumNodeGroups
	}
	if s.ReplicasPerNodeGroup != 0 {
		m["replicas_per_node_group"] = s.ReplicasPerNodeGroup
	}
	if s.AutomaticFailoverEnabled {
		m["automatic_failover_enabled"] = s.AutomaticFailoverEnabled
	}
	if s.MultiAzEnabled {
		m["multi_az_enabled"] = s.MultiAzEnabled
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.AtRestEncryptionEnabled {
		m["at_rest_encryption_enabled"] = s.AtRestEncryptionEnabled
	}
	if s.TransitEncryptionEnabled {
		m["transit_encryption_enabled"] = s.TransitEncryptionEnabled
	}
	if s.TransitEncryptionMode != "" {
		m["transit_encryption_mode"] = s.TransitEncryptionMode
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.AuthToken != "" {
		m["auth_token"] = s.AuthToken
	}
	if len(s.UserGroupIds) > 0 {
		m["user_group_ids"] = s.UserGroupIds
	}
	if s.MaintenanceWindow != "" {
		m["maintenance_window"] = s.MaintenanceWindow
	}
	if s.SnapshotRetentionLimit != 0 {
		m["snapshot_retention_limit"] = s.SnapshotRetentionLimit
	}
	if s.SnapshotWindow != "" {
		m["snapshot_window"] = s.SnapshotWindow
	}
	if s.FinalSnapshotIdentifier != "" {
		m["final_snapshot_identifier"] = s.FinalSnapshotIdentifier
	}
	if s.ApplyImmediately {
		m["apply_immediately"] = s.ApplyImmediately
	}
	if s.ParameterGroupFamily != "" {
		m["parameter_group_family"] = s.ParameterGroupFamily
	}
	if len(s.Parameters) > 0 {
		items := make([]any, len(s.Parameters))
		for i, v := range s.Parameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["parameters"] = items
	}
	if len(s.LogDeliveryConfigurations) > 0 {
		items := make([]any, len(s.LogDeliveryConfigurations))
		for i, v := range s.LogDeliveryConfigurations {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["log_delivery_configurations"] = items
	}
	if s.NotificationTopicArn != "" {
		m["notification_topic_arn"] = s.NotificationTopicArn
	}
	if s.AutoMinorVersionUpgrade {
		m["auto_minor_version_upgrade"] = s.AutoMinorVersionUpgrade
	}
	if s.DataTieringEnabled {
		m["data_tiering_enabled"] = s.DataTieringEnabled
	}
	return m
}

// AwsRedisElasticacheLogDeliveryConfig configures delivery of Redis/Valkey engine
//
//	logs to an external destination. Each replication group supports at most two
//	configurations — one for slow-log and one for engine-log.
type AwsRedisElasticacheLogDeliveryConfigInput struct {
	// Type of destination. Values: "cloudwatch-logs", "kinesis-firehose".
	DestinationType string `json:"destination_type" jsonschema:"required,Type of destination. Values: 'cloudwatch-logs'; 'kinesis-firehose'."`
	// Destination identifier. For CloudWatch Logs: the log group name.
	//  For Kinesis Firehose: the delivery stream name.
	Destination string `json:"destination" jsonschema:"required,Destination identifier. For CloudWatch Logs: the log group name. For Kinesis Firehose: the delivery stream name."`
	// Log serialization format. Values: "text", "json".
	LogFormat string `json:"log_format" jsonschema:"required,Log serialization format. Values: 'text'; 'json'."`
	// Type of log to deliver. Values: "slow-log" (commands exceeding slowlog
	//  threshold), "engine-log" (engine-level diagnostic output).
	LogType string `json:"log_type" jsonschema:"required,Type of log to deliver. Values: 'slow-log' (commands exceeding slowlog threshold); 'engine-log' (engine-level diagnostic output)."`
}

func (s *AwsRedisElasticacheLogDeliveryConfigInput) validate() error {
	if s.DestinationType == "" {
		return fmt.Errorf("destination_type is required")
	}
	if s.Destination == "" {
		return fmt.Errorf("destination is required")
	}
	if s.LogFormat == "" {
		return fmt.Errorf("log_format is required")
	}
	if s.LogType == "" {
		return fmt.Errorf("log_type is required")
	}
	return nil
}

func (s *AwsRedisElasticacheLogDeliveryConfigInput) applyDefaults() {
}

func (s *AwsRedisElasticacheLogDeliveryConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["destination_type"] = s.DestinationType
	m["destination"] = s.Destination
	m["log_format"] = s.LogFormat
	m["log_type"] = s.LogType
	return m
}

// AwsRedisElasticacheParameter defines a single cache parameter override for
//
//	the managed parameter group. Parameters tune Redis/Valkey engine behavior
//	(e.g., maxmemory-policy, timeout, tcp-keepalive).
type AwsRedisElasticacheParameterInput struct {
	// Parameter name (e.g., "maxmemory-policy", "timeout").
	Name string `json:"name" jsonschema:"required,Parameter name (e.g.; 'maxmemory-policy'; 'timeout')."`
	// Parameter value (e.g., "volatile-lru", "300").
	Value string `json:"value" jsonschema:"required,Parameter value (e.g.; 'volatile-lru'; '300')."`
}

func (s *AwsRedisElasticacheParameterInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Value == "" {
		return fmt.Errorf("value is required")
	}
	return nil
}

func (s *AwsRedisElasticacheParameterInput) applyDefaults() {
}

func (s *AwsRedisElasticacheParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["value"] = s.Value
	return m
}

// ParseAwsRedisElasticache validates and normalizes a AwsRedisElasticache cloud_object.
func ParseAwsRedisElasticache(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsRedisElasticache"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsRedisElasticacheSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
