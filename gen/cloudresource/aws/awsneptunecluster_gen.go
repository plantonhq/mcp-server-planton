// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsNeptuneCluster is a deployment component for creating and managing
//
//	Amazon Neptune graph database clusters. Neptune supports property-graph
//	queries via Apache TinkerPop Gremlin and RDF queries via SPARQL.
type AwsNeptuneClusterSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// subnet_ids is the list of subnet IDs for the Neptune subnet group.
	//  Provide at least two subnets in distinct Availability Zones for high availability.
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"subnet_ids is the list of subnet IDs for the Neptune subnet group. Provide at least two subnets in distinct Availability Zones for high availability."`
	// neptune_subnet_group_name is an optional name of an existing Neptune subnet group
	//  to use instead of creating one from subnet_ids.
	NeptuneSubnetGroupName string `json:"neptune_subnet_group_name,omitempty" jsonschema:"neptune_subnet_group_name is an optional name of an existing Neptune subnet group to use instead of creating one from subnet_ids."`
	// security_group_ids are the VPC security groups to associate with the cluster.
	//  Ingress rules are created on a managed security group for these source SGs.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"security_group_ids are the VPC security groups to associate with the cluster. Ingress rules are created on a managed security group for these source SGs."`
	// allowed_cidr_blocks are IPv4 CIDRs to allow ingress to the cluster security group
	//  on the Neptune port.
	AllowedCidrBlocks []string `json:"allowed_cidr_blocks,omitempty" jsonschema:"allowed_cidr_blocks are IPv4 CIDRs to allow ingress to the cluster security group on the Neptune port."`
	// vpc_id is the VPC where the cluster will be deployed. Required when creating
	//  a managed security group via security_group_ids or allowed_cidr_blocks.
	VpcId string `json:"vpc_id,omitempty" jsonschema:"vpc_id is the VPC where the cluster will be deployed. Required when creating a managed security group via security_group_ids or allowed_cidr_blocks."`
	// engine_version is the Neptune engine version to deploy.
	//  Examples: "1.2.1.0", "1.3.0.0", "1.3.1.0"
	EngineVersion string `json:"engine_version,omitempty" jsonschema:"engine_version is the Neptune engine version to deploy. Examples: '1.2.1.0'; '1.3.0.0'; '1.3.1.0'"`
	// port is the TCP port on which the cluster accepts connections.
	Port int32 `json:"port,omitempty" jsonschema:"port is the TCP port on which the cluster accepts connections."`
	// storage_type controls the storage I/O model for the cluster.
	//  "standard" is the default; "iopt1" enables I/O-Optimized storage for
	//  read-heavy workloads with higher throughput and predictable pricing.
	StorageType string `json:"storage_type,omitempty" jsonschema:"storage_type controls the storage I/O model for the cluster. 'standard' is the default; 'iopt1' enables I/O-Optimized storage for read-heavy workloads with higher throughput and predictable pricing."`
	// instance_count is the number of instances to create in the cluster.
	//  The first instance is the primary writer; additional instances are read replicas.
	InstanceCount int32 `json:"instance_count,omitempty" jsonschema:"instance_count is the number of instances to create in the cluster. The first instance is the primary writer; additional instances are read replicas."`
	// instance_class is the compute and memory capacity of the DB instances.
	//  Examples: "db.r6g.large", "db.r6g.xlarge", "db.r5.large"
	//  Use "db.serverless" for Neptune Serverless (requires serverless_v2_scaling).
	InstanceClass string `json:"instance_class,omitempty" jsonschema:"instance_class is the compute and memory capacity of the DB instances. Examples: 'db.r6g.large'; 'db.r6g.xlarge'; 'db.r5.large' Use 'db.serverless' for Neptune Serverless (requires serverless_v2_scali..."`
	// serverless_v2_scaling configures Neptune Serverless capacity scaling.
	//  When set, instance_class should be "db.serverless".
	//  Neptune Capacity Units (NCUs): min 1.0, max 128.0.
	ServerlessV2Scaling *AwsNeptuneClusterServerlessV2ScalingConfigurationInput `json:"serverless_v2_scaling,omitempty" jsonschema:"serverless_v2_scaling configures Neptune Serverless capacity scaling. When set; instance_class should be 'db.serverless'. Neptune Capacity Units (NCUs): min 1.0; max 128.0."`
	// storage_encrypted indicates whether to encrypt the cluster storage at rest.
	StorageEncrypted bool `json:"storage_encrypted,omitempty" jsonschema:"storage_encrypted indicates whether to encrypt the cluster storage at rest."`
	// kms_key_id is the ARN of the KMS key for storage encryption.
	//  When storage_encrypted is true and this is not set, the AWS-managed key is used.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"kms_key_id is the ARN of the KMS key for storage encryption. When storage_encrypted is true and this is not set; the AWS-managed key is used."`
	// iam_database_authentication_enabled enables IAM database authentication,
	//  allowing IAM users and roles to authenticate to Neptune using temporary credentials.
	IamDatabaseAuthenticationEnabled bool `json:"iam_database_authentication_enabled,omitempty" jsonschema:"iam_database_authentication_enabled enables IAM database authentication; allowing IAM users and roles to authenticate to Neptune using temporary credentials."`
	// iam_roles is a list of IAM role ARNs to associate with the Neptune cluster.
	//  These roles allow Neptune to access other AWS services (e.g., S3 for bulk data loading).
	IamRoles []string `json:"iam_roles,omitempty" jsonschema:"iam_roles is a list of IAM role ARNs to associate with the Neptune cluster. These roles allow Neptune to access other AWS services (e.g.; S3 for bulk data loading)."`
	// backup_retention_period is the number of days to retain automated backups (1-35).
	BackupRetentionPeriod int32 `json:"backup_retention_period,omitempty" jsonschema:"backup_retention_period is the number of days to retain automated backups (1-35)."`
	// preferred_backup_window is the daily time range for automated backups in UTC.
	//  Format: "hh24:mi-hh24:mi" (e.g., "03:00-04:00").
	PreferredBackupWindow string `json:"preferred_backup_window,omitempty" jsonschema:"preferred_backup_window is the daily time range for automated backups in UTC. Format: 'hh24:mi-hh24:mi' (e.g.; '03:00-04:00')."`
	// preferred_maintenance_window is the weekly time range for maintenance in UTC.
	//  Format: "ddd:hh24:mi-ddd:hh24:mi" (e.g., "sun:05:00-sun:06:00").
	PreferredMaintenanceWindow string `json:"preferred_maintenance_window,omitempty" jsonschema:"preferred_maintenance_window is the weekly time range for maintenance in UTC. Format: 'ddd:hh24:mi-ddd:hh24:mi' (e.g.; 'sun:05:00-sun:06:00')."`
	// deletion_protection prevents accidental cluster deletion when enabled.
	DeletionProtection bool `json:"deletion_protection,omitempty" jsonschema:"deletion_protection prevents accidental cluster deletion when enabled."`
	// skip_final_snapshot controls whether a final snapshot is created on deletion.
	SkipFinalSnapshot bool `json:"skip_final_snapshot,omitempty" jsonschema:"skip_final_snapshot controls whether a final snapshot is created on deletion."`
	// final_snapshot_identifier is the identifier for the final snapshot when
	//  skip_final_snapshot is false.
	FinalSnapshotIdentifier string `json:"final_snapshot_identifier,omitempty" jsonschema:"final_snapshot_identifier is the identifier for the final snapshot when skip_final_snapshot is false."`
	// enabled_cloudwatch_logs_exports lists log types to export to CloudWatch Logs.
	//  Valid values for Neptune: "audit", "slowquery"
	EnabledCloudwatchLogsExports []string `json:"enabled_cloudwatch_logs_exports,omitempty" jsonschema:"enabled_cloudwatch_logs_exports lists log types to export to CloudWatch Logs. Valid values for Neptune: 'audit'; 'slowquery'"`
	// apply_immediately specifies whether modifications are applied immediately
	//  or during the next maintenance window.
	ApplyImmediately bool `json:"apply_immediately,omitempty" jsonschema:"apply_immediately specifies whether modifications are applied immediately or during the next maintenance window."`
	// copy_tags_to_snapshot copies cluster tags to snapshots when enabled.
	CopyTagsToSnapshot bool `json:"copy_tags_to_snapshot,omitempty" jsonschema:"copy_tags_to_snapshot copies cluster tags to snapshots when enabled."`
	// allow_major_version_upgrade allows major engine version upgrades when applying
	//  changes. Required when updating engine_version to a new major version.
	AllowMajorVersionUpgrade bool `json:"allow_major_version_upgrade,omitempty" jsonschema:"allow_major_version_upgrade allows major engine version upgrades when applying changes. Required when updating engine_version to a new major version."`
	// cluster_parameter_group_name is the name of an existing Neptune cluster
	//  parameter group to use.
	ClusterParameterGroupName string `json:"cluster_parameter_group_name,omitempty" jsonschema:"cluster_parameter_group_name is the name of an existing Neptune cluster parameter group to use."`
	// cluster_parameters are custom parameters for the cluster parameter group.
	//  When provided (and cluster_parameter_group_name is not set), a new parameter
	//  group is created with these parameters.
	ClusterParameters []*AwsNeptuneClusterParameterInput `json:"cluster_parameters,omitempty" jsonschema:"cluster_parameters are custom parameters for the cluster parameter group. When provided (and cluster_parameter_group_name is not set); a new parameter group is created with these parameters."`
}

func (s *AwsNeptuneClusterSpecInput) validate() error {
	if s.ServerlessV2Scaling != nil {
		if err := s.ServerlessV2Scaling.validate(); err != nil {
			return fmt.Errorf("serverless_v2_scaling: %w", err)
		}
	}
	for i, v := range s.ClusterParameters {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("cluster_parameters[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsNeptuneClusterSpecInput) applyDefaults() {
	if s.EngineVersion == "" {
		s.EngineVersion = "1.3.0.0"
	}
	if s.Port == 0 {
		s.Port = 8182
	}
	if s.InstanceCount == 0 {
		s.InstanceCount = 1
	}
	if s.InstanceClass == "" {
		s.InstanceClass = "db.r6g.large"
	}
	if s.ServerlessV2Scaling != nil {
		s.ServerlessV2Scaling.applyDefaults()
	}
	// default: StorageEncrypted = true (applied at zero-value)
	if s.BackupRetentionPeriod == 0 {
		s.BackupRetentionPeriod = 7
	}
}

func (s *AwsNeptuneClusterSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if s.NeptuneSubnetGroupName != "" {
		m["neptune_subnet_group_name"] = s.NeptuneSubnetGroupName
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if len(s.AllowedCidrBlocks) > 0 {
		m["allowed_cidr_blocks"] = s.AllowedCidrBlocks
	}
	if s.VpcId != "" {
		m["vpc_id"] = s.VpcId
	}
	if s.EngineVersion != "" {
		m["engine_version"] = s.EngineVersion
	}
	if s.Port != 0 {
		m["port"] = s.Port
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.InstanceCount != 0 {
		m["instance_count"] = s.InstanceCount
	}
	if s.InstanceClass != "" {
		m["instance_class"] = s.InstanceClass
	}
	if s.ServerlessV2Scaling != nil {
		m["serverless_v2_scaling"] = s.ServerlessV2Scaling.toMap()
	}
	if s.StorageEncrypted {
		m["storage_encrypted"] = s.StorageEncrypted
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.IamDatabaseAuthenticationEnabled {
		m["iam_database_authentication_enabled"] = s.IamDatabaseAuthenticationEnabled
	}
	if len(s.IamRoles) > 0 {
		m["iam_roles"] = s.IamRoles
	}
	if s.BackupRetentionPeriod != 0 {
		m["backup_retention_period"] = s.BackupRetentionPeriod
	}
	if s.PreferredBackupWindow != "" {
		m["preferred_backup_window"] = s.PreferredBackupWindow
	}
	if s.PreferredMaintenanceWindow != "" {
		m["preferred_maintenance_window"] = s.PreferredMaintenanceWindow
	}
	if s.DeletionProtection {
		m["deletion_protection"] = s.DeletionProtection
	}
	if s.SkipFinalSnapshot {
		m["skip_final_snapshot"] = s.SkipFinalSnapshot
	}
	if s.FinalSnapshotIdentifier != "" {
		m["final_snapshot_identifier"] = s.FinalSnapshotIdentifier
	}
	if len(s.EnabledCloudwatchLogsExports) > 0 {
		m["enabled_cloudwatch_logs_exports"] = s.EnabledCloudwatchLogsExports
	}
	if s.ApplyImmediately {
		m["apply_immediately"] = s.ApplyImmediately
	}
	if s.CopyTagsToSnapshot {
		m["copy_tags_to_snapshot"] = s.CopyTagsToSnapshot
	}
	if s.AllowMajorVersionUpgrade {
		m["allow_major_version_upgrade"] = s.AllowMajorVersionUpgrade
	}
	if s.ClusterParameterGroupName != "" {
		m["cluster_parameter_group_name"] = s.ClusterParameterGroupName
	}
	if len(s.ClusterParameters) > 0 {
		items := make([]any, len(s.ClusterParameters))
		for i, v := range s.ClusterParameters {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["cluster_parameters"] = items
	}
	return m
}

// AwsNeptuneClusterParameter represents a parameter for the Neptune cluster parameter group.
type AwsNeptuneClusterParameterInput struct {
	// name is the parameter name (e.g., "neptune_enable_audit_log").
	Name string `json:"name,omitempty" jsonschema:"name is the parameter name (e.g.; 'neptune_enable_audit_log')."`
	// value is the parameter value.
	Value string `json:"value,omitempty" jsonschema:"value is the parameter value."`
	// apply_method specifies when the parameter is applied: "immediate" or "pending-reboot".
	ApplyMethod string `json:"apply_method,omitempty" jsonschema:"apply_method specifies when the parameter is applied: 'immediate' or 'pending-reboot'."`
}

func (s *AwsNeptuneClusterParameterInput) validate() error {
	return nil
}

func (s *AwsNeptuneClusterParameterInput) applyDefaults() {
}

func (s *AwsNeptuneClusterParameterInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Value != "" {
		m["value"] = s.Value
	}
	if s.ApplyMethod != "" {
		m["apply_method"] = s.ApplyMethod
	}
	return m
}

// AwsNeptuneClusterServerlessV2ScalingConfiguration configures Neptune Serverless
//
//	capacity scaling. Neptune Capacity Units (NCUs) determine the compute and memory
//	resources available.
type AwsNeptuneClusterServerlessV2ScalingConfigurationInput struct {
	// min_capacity is the minimum Neptune Capacity Units (NCUs).
	//  Valid range: 1.0 to 128.0.
	MinCapacity float64 `json:"min_capacity,omitempty" jsonschema:"min_capacity is the minimum Neptune Capacity Units (NCUs). Valid range: 1.0 to 128.0."`
	// max_capacity is the maximum Neptune Capacity Units (NCUs).
	//  Valid range: 1.0 to 128.0. Must be >= min_capacity.
	MaxCapacity float64 `json:"max_capacity,omitempty" jsonschema:"max_capacity is the maximum Neptune Capacity Units (NCUs). Valid range: 1.0 to 128.0. Must be >= min_capacity."`
}

func (s *AwsNeptuneClusterServerlessV2ScalingConfigurationInput) validate() error {
	return nil
}

func (s *AwsNeptuneClusterServerlessV2ScalingConfigurationInput) applyDefaults() {
}

func (s *AwsNeptuneClusterServerlessV2ScalingConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinCapacity != 0 {
		m["min_capacity"] = s.MinCapacity
	}
	if s.MaxCapacity != 0 {
		m["max_capacity"] = s.MaxCapacity
	}
	return m
}

// ParseAwsNeptuneCluster validates and normalizes a AwsNeptuneCluster cloud_object.
func ParseAwsNeptuneCluster(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsNeptuneCluster"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsNeptuneClusterSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
