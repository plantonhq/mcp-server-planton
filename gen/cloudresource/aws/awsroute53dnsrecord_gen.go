// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsRoute53DnsRecord represents a DNS record in an AWS Route53 hosted zone.
//
//	It follows the Kubernetes Resource Model (KRM) pattern with metadata, spec, and status.
//
//	This resource enables creating individual DNS records with support for:
//	  - Standard record types (A, AAAA, CNAME, MX, TXT, etc.)
//	  - Alias records (Route53's killer feature for AWS resources)
//	  - Advanced routing policies (weighted, latency, failover, geolocation)
//
//	Example usage:
//	  apiVersion: aws.openmcf.org/v1
//	  kind: AwsRoute53DnsRecord
//	  metadata:
//	    name: www-example
//	  spec:
//	    hosted_zone_id: Z1234567890ABC
//	    name: www.example.com
//	    type: A
//	    ttl: 300
//	    values:
//	      - 192.0.2.1
type AwsRoute53DnsRecordSpecInput struct {
	// The Route53 hosted zone ID where this DNS record will be created.
	//  Can be provided as a literal value or referenced from an AwsRoute53Zone resource.
	//
	//  When using value_from, the default kind is AwsRoute53Zone and the default field path
	//  is "status.outputs.zone_id", allowing you to wire this directly...
	Region string `json:"region,omitempty" jsonschema:"The Route53 hosted zone ID where this DNS record will be created. Can be provided as a literal value or referenced from an AwsRoute53Zone resource. When using value_from; the default kind is AwsRoute5..."`
	ZoneId string `json:"zone_id" jsonschema:"required"`
	// The name of the DNS record (fully qualified domain name or subdomain).
	//  Examples:
	//    - "example.com" for zone apex
	//    - "www.example.com" for subdomain
	//    - "*.example.com" for wildcard
	//  Route53 automatically appends a trailing dot if not provided.
	Name string `json:"name" jsonschema:"required,The name of the DNS record (fully qualified domain name or subdomain). Examples: - 'example.com' for zone apex - 'www.example.com' for subdomain - '*.example.com' for wildcard Route53 automatically ap..."`
	// The type of DNS record to create.
	//  Common types: A (IPv4), AAAA (IPv6), CNAME, MX, TXT, NS, SRV, CAA
	Type string `json:"type" jsonschema:"required,enum=A|AAAA|CNAME|MX|TXT|SRV|NS|CAA,The type of DNS record to create. Common types: A (IPv4); AAAA (IPv6); CNAME; MX; TXT; NS; SRV; CAA"`
	// Time to live (TTL) for the DNS record in seconds.
	//  TTL specifies how long DNS resolvers should cache the record.
	//  Common values:
	//    - 60: For records you might change during incidents
	//    - 300: Default for most records (5 minutes)
	//    - 86400: For static records (1 day)
	//  Note: TTL is ignored for alia...
	Ttl int32 `json:"ttl,omitempty" jsonschema:"Time to live (TTL) for the DNS record in seconds. TTL specifies how long DNS resolvers should cache the record. Common values: - 60: For records you might change during incidents - 300: Default for mo..."`
	// The values for the DNS record.
	//  Format depends on record type:
	//    - A record: IPv4 addresses (e.g., ["192.0.2.1", "192.0.2.2"])
	//    - AAAA record: IPv6 addresses (e.g., ["2001:db8::1"])
	//    - CNAME record: Target hostname (e.g., ["target.example.com"])
	//    - MX record: Priority and mail server (e.g., [...
	Values []string `json:"values,omitempty" jsonschema:"The values for the DNS record. Format depends on record type: - A record: IPv4 addresses (e.g.; ['192.0.2.1'; '192.0.2.2']) - AAAA record: IPv6 addresses (e.g.; ['2001:db8::1']) - CNAME record: Target..."`
	// Alias target configuration for Route53 alias records.
	//  Alias records are Route53's killer feature - they allow:
	//    1. Pointing zone apex (example.com) to AWS resources without CNAME restrictions
	//    2. Free queries (no Route53 charges for alias queries to AWS resources)
	//    3. Automatic IP updates whe...
	AliasTarget *AwsRoute53AliasTargetInput `json:"alias_target,omitempty" jsonschema:"Alias target configuration for Route53 alias records. Alias records are Route53's killer feature - they allow: 1. Pointing zone apex (example.com) to AWS resources without CNAME restrictions 2. Free q..."`
	// Routing policy configuration for advanced traffic management.
	//  Route53 supports multiple routing strategies:
	//    - Simple: Default single-value response (no config needed)
	//    - Weighted: Split traffic across resources (blue/green, canary)
	//    - Latency: Route to lowest-latency endpoint (global apps)
	//  ...
	RoutingPolicy *AwsRoute53RoutingPolicyInput `json:"routing_policy,omitempty" jsonschema:"Routing policy configuration for advanced traffic management. Route53 supports multiple routing strategies: - Simple: Default single-value response (no config needed) - Weighted: Split traffic across ..."`
	// Health check ID to attach for failover routing.
	//  Health checks monitor endpoint availability and trigger automatic failover.
	//  Create health checks separately in Route53 and reference by ID.
	//  Only used with failover routing policy.
	HealthCheckId string `json:"health_check_id,omitempty" jsonschema:"Health check ID to attach for failover routing. Health checks monitor endpoint availability and trigger automatic failover. Create health checks separately in Route53 and reference by ID. Only used wi..."`
	// Set identifier for routing policies.
	//  Required for weighted, latency, failover, and geolocation routing.
	//  Must be unique among records with the same name and type.
	//  Example: "primary", "secondary", "us-east-1", "weight-70"
	SetIdentifier string `json:"set_identifier,omitempty" jsonschema:"Set identifier for routing policies. Required for weighted; latency; failover; and geolocation routing. Must be unique among records with the same name and type. Example: 'primary'; 'secondary'; 'us-e..."`
}

func (s *AwsRoute53DnsRecordSpecInput) validate() error {
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Type == "" {
		return fmt.Errorf("type is required")
	}
	switch s.Type {
	case "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "NS", "CAA":
	default:
		return fmt.Errorf("invalid type: %q", s.Type)
	}
	if s.AliasTarget != nil {
		if err := s.AliasTarget.validate(); err != nil {
			return fmt.Errorf("alias_target: %w", err)
		}
	}
	if s.RoutingPolicy != nil {
		if err := s.RoutingPolicy.validate(); err != nil {
			return fmt.Errorf("routing_policy: %w", err)
		}
	}
	return nil
}

func (s *AwsRoute53DnsRecordSpecInput) applyDefaults() {
	if s.AliasTarget != nil {
		s.AliasTarget.applyDefaults()
	}
	if s.RoutingPolicy != nil {
		s.RoutingPolicy.applyDefaults()
	}
}

func (s *AwsRoute53DnsRecordSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["zone_id"] = s.ZoneId
	m["name"] = s.Name
	m["type"] = s.Type
	if s.Ttl != 0 {
		m["ttl"] = s.Ttl
	}
	if len(s.Values) > 0 {
		m["values"] = s.Values
	}
	if s.AliasTarget != nil {
		m["alias_target"] = s.AliasTarget.toMap()
	}
	if s.RoutingPolicy != nil {
		m["routing_policy"] = s.RoutingPolicy.toMap()
	}
	if s.HealthCheckId != "" {
		m["health_check_id"] = s.HealthCheckId
	}
	if s.SetIdentifier != "" {
		m["set_identifier"] = s.SetIdentifier
	}
	return m
}

// AwsRoute53AliasTarget defines an alias record target.
//
//	Alias records are a Route53-specific extension to DNS that allows routing traffic
//	to AWS resources without the limitations of CNAME records.
//
//	Key benefits:
//	  - Works at zone apex (example.com) where CNAME is not allowed
//	  - No query charges for alias queries to AWS resources
//	  - Automatic updates when target resource's IP changes
//
//	Both dns_name and zone_id can be provided as literals or referenced from AWS resources.
//	The default kind for both is AwsAlb, enabling seamless wiring to Application Load Balancers.
type AwsRoute53AliasTargetInput struct {
	// The DNS name of the target resource.
	//  Can be provided as a literal value or referenced from an AWS resource.
	//
	//  When using value_from, the default kind is AwsAlb and the default field path
	//  is "status.outputs.load_balancer_dns_name".
	//
	//  Example literals:
	//    - CloudFront: "d1234abcd.cloudfront.net"
	//    ...
	DnsName string `json:"dns_name" jsonschema:"required,The DNS name of the target resource. Can be provided as a literal value or referenced from an AWS resource. When using value_from; the default kind is AwsAlb and the default field path is 'status.outp..."`
	// The hosted zone ID of the target resource (AWS service's zone ID, not your Route53 zone).
	//  Can be provided as a literal value or referenced from an AWS resource.
	//
	//  When using value_from, the default kind is AwsAlb and the default field path
	//  is "status.outputs.load_balancer_hosted_zone_id".
	//
	//  Common...
	ZoneId string `json:"zone_id" jsonschema:"required,The hosted zone ID of the target resource (AWS service's zone ID; not your Route53 zone). Can be provided as a literal value or referenced from an AWS resource. When using value_from; the default kind..."`
	// Evaluate target health.
	//  If true, Route53 checks the health of the target before responding.
	//  Useful for automatic failover when combined with health checks.
	//  Default: false
	EvaluateTargetHealth bool `json:"evaluate_target_health,omitempty" jsonschema:"Evaluate target health. If true; Route53 checks the health of the target before responding. Useful for automatic failover when combined with health checks. Default: false"`
}

func (s *AwsRoute53AliasTargetInput) validate() error {
	if s.DnsName == "" {
		return fmt.Errorf("dns_name is required")
	}
	if s.ZoneId == "" {
		return fmt.Errorf("zone_id is required")
	}
	return nil
}

func (s *AwsRoute53AliasTargetInput) applyDefaults() {
}

func (s *AwsRoute53AliasTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["dns_name"] = s.DnsName
	m["zone_id"] = s.ZoneId
	if s.EvaluateTargetHealth {
		m["evaluate_target_health"] = s.EvaluateTargetHealth
	}
	return m
}

// AwsRoute53FailoverPolicy enables active-passive failover.
//
//	Primary serves traffic when healthy; secondary takes over on failure.
type AwsRoute53FailoverPolicyInput struct {
	// Failover record type.
	//  Must have exactly one PRIMARY and one SECONDARY record per name/type combo.
	FailoverType string `json:"failover_type" jsonschema:"required,enum=primary|secondary,Failover record type. Must have exactly one PRIMARY and one SECONDARY record per name/type combo."`
}

func (s *AwsRoute53FailoverPolicyInput) validate() error {
	if s.FailoverType == "" {
		return fmt.Errorf("failover_type is required")
	}
	switch s.FailoverType {
	case "primary", "secondary":
	default:
		return fmt.Errorf("invalid failover_type: %q", s.FailoverType)
	}
	return nil
}

func (s *AwsRoute53FailoverPolicyInput) applyDefaults() {
}

func (s *AwsRoute53FailoverPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["failover_type"] = s.FailoverType
	return m
}

// AwsRoute53GeolocationPolicy routes traffic based on user's location.
//
//	Supports routing at continent, country, or US state level.
type AwsRoute53GeolocationPolicyInput struct {
	// Continent code (two-letter).
	//  Examples: "NA" (North America), "EU" (Europe), "AS" (Asia)
	//  Note: Use continent OR country, not both. Country is more specific.
	Continent string `json:"continent,omitempty" jsonschema:"Continent code (two-letter). Examples: 'NA' (North America); 'EU' (Europe); 'AS' (Asia) Note: Use continent OR country; not both. Country is more specific."`
	// Country code (two-letter ISO 3166-1 alpha-2).
	//  Examples: "US" (United States), "GB" (United Kingdom), "DE" (Germany)
	Country string `json:"country,omitempty" jsonschema:"Country code (two-letter ISO 3166-1 alpha-2). Examples: 'US' (United States); 'GB' (United Kingdom); 'DE' (Germany)"`
	// Subdivision code (US state only).
	//  Only valid when country is "US".
	//  Examples: "CA" (California), "NY" (New York), "TX" (Texas)
	Subdivision string `json:"subdivision,omitempty" jsonschema:"Subdivision code (US state only). Only valid when country is 'US'. Examples: 'CA' (California); 'NY' (New York); 'TX' (Texas)"`
}

func (s *AwsRoute53GeolocationPolicyInput) validate() error {
	return nil
}

func (s *AwsRoute53GeolocationPolicyInput) applyDefaults() {
}

func (s *AwsRoute53GeolocationPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Continent != "" {
		m["continent"] = s.Continent
	}
	if s.Country != "" {
		m["country"] = s.Country
	}
	if s.Subdivision != "" {
		m["subdivision"] = s.Subdivision
	}
	return m
}

// AwsRoute53LatencyPolicy routes users to the resource with lowest latency.
//
//	Route53 measures latency from AWS regions and routes to best performer.
type AwsRoute53LatencyPolicyInput struct {
	// The AWS region where this resource is located.
	//  Route53 uses this to measure latency from user locations.
	//  Example: "us-east-1", "eu-west-1", "ap-southeast-1"
	Region string `json:"region" jsonschema:"required,The AWS region where this resource is located. Route53 uses this to measure latency from user locations. Example: 'us-east-1'; 'eu-west-1'; 'ap-southeast-1'"`
}

func (s *AwsRoute53LatencyPolicyInput) validate() error {
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	return nil
}

func (s *AwsRoute53LatencyPolicyInput) applyDefaults() {
}

func (s *AwsRoute53LatencyPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	m["region"] = s.Region
	return m
}

// AwsRoute53RoutingPolicy defines traffic routing policies for DNS records.
//
//	Route53 supports multiple routing strategies beyond simple DNS resolution.
type AwsRoute53RoutingPolicyInput struct {
	// Weighted routing: distribute traffic based on assigned weights.
	//  Use cases: blue/green deployments, canary releases, load distribution.
	Weighted *AwsRoute53WeightedPolicyInput `json:"weighted,omitempty" jsonschema:"Weighted routing: distribute traffic based on assigned weights. Use cases: blue/green deployments; canary releases; load distribution."`
	// Latency-based routing: route to the lowest-latency endpoint.
	//  Use cases: global applications, multi-region deployments.
	Latency *AwsRoute53LatencyPolicyInput `json:"latency,omitempty" jsonschema:"Latency-based routing: route to the lowest-latency endpoint. Use cases: global applications; multi-region deployments."`
	// Failover routing: automatic failover to secondary when primary fails.
	//  Use cases: active-passive disaster recovery, high availability.
	Failover *AwsRoute53FailoverPolicyInput `json:"failover,omitempty" jsonschema:"Failover routing: automatic failover to secondary when primary fails. Use cases: active-passive disaster recovery; high availability."`
	// Geolocation routing: route based on user's geographic location.
	//  Use cases: GDPR compliance, localized content, geographic restrictions.
	Geolocation *AwsRoute53GeolocationPolicyInput `json:"geolocation,omitempty" jsonschema:"Geolocation routing: route based on user's geographic location. Use cases: GDPR compliance; localized content; geographic restrictions."`
}

func (s *AwsRoute53RoutingPolicyInput) validate() error {
	if s.Weighted != nil {
		if err := s.Weighted.validate(); err != nil {
			return fmt.Errorf("weighted: %w", err)
		}
	}
	if s.Latency != nil {
		if err := s.Latency.validate(); err != nil {
			return fmt.Errorf("latency: %w", err)
		}
	}
	if s.Failover != nil {
		if err := s.Failover.validate(); err != nil {
			return fmt.Errorf("failover: %w", err)
		}
	}
	if s.Geolocation != nil {
		if err := s.Geolocation.validate(); err != nil {
			return fmt.Errorf("geolocation: %w", err)
		}
	}
	return nil
}

func (s *AwsRoute53RoutingPolicyInput) applyDefaults() {
	if s.Weighted != nil {
		s.Weighted.applyDefaults()
	}
	if s.Latency != nil {
		s.Latency.applyDefaults()
	}
	if s.Failover != nil {
		s.Failover.applyDefaults()
	}
	if s.Geolocation != nil {
		s.Geolocation.applyDefaults()
	}
}

func (s *AwsRoute53RoutingPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Weighted != nil {
		m["weighted"] = s.Weighted.toMap()
	}
	if s.Latency != nil {
		m["latency"] = s.Latency.toMap()
	}
	if s.Failover != nil {
		m["failover"] = s.Failover.toMap()
	}
	if s.Geolocation != nil {
		m["geolocation"] = s.Geolocation.toMap()
	}
	return m
}

// AwsRoute53WeightedPolicy enables traffic splitting across resources.
//
//	Weights are relative - Route53 calculates percentage based on sum of all weights.
type AwsRoute53WeightedPolicyInput struct {
	// Weight value (0-255).
	//  Higher weight means more traffic.
	//  Weight of 0 stops traffic to this record (useful for quick traffic draining).
	//  Example: Records with weights 70 and 30 get 70% and 30% of traffic.
	Weight int32 `json:"weight,omitempty" jsonschema:"Weight value (0-255). Higher weight means more traffic. Weight of 0 stops traffic to this record (useful for quick traffic draining). Example: Records with weights 70 and 30 get 70% and 30% of traffic..."`
}

func (s *AwsRoute53WeightedPolicyInput) validate() error {
	return nil
}

func (s *AwsRoute53WeightedPolicyInput) applyDefaults() {
}

func (s *AwsRoute53WeightedPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Weight != 0 {
		m["weight"] = s.Weight
	}
	return m
}

// ParseAwsRoute53DnsRecord validates and normalizes a AwsRoute53DnsRecord cloud_object.
func ParseAwsRoute53DnsRecord(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsRoute53DnsRecord"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsRoute53DnsRecordSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
