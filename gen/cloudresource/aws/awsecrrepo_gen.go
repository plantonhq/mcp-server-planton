// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-ecr-repo
type AwsEcrRepoSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// repositoryName is the name of the ECR repository. Must be unique within
	//  the AWS account and region. Commonly includes the microservice or project name.
	//  Example: "github.com/team-blue/my-microservice"
	RepositoryName string `json:"repository_name" jsonschema:"required,repositoryName is the name of the ECR repository. Must be unique within the AWS account and region. Commonly includes the microservice or project name. Example: 'github.com/team-blue/my-microservice'"`
	// indicates whether image tags can be overwritten (MUTABLE) or not (IMMUTABLE).
	ImageImmutable bool `json:"image_immutable,omitempty" jsonschema:"indicates whether image tags can be overwritten (MUTABLE) or not (IMMUTABLE)."`
	// encryptionType determines how ECR encrypts images at rest. Default is AES256,
	//  using AWS-managed encryption. Use KMS to specify your own KMS key for compliance.
	//  EncryptionType determines how images are encrypted at rest in ECR.
	//  By default, AWS uses AES-256 (service-managed keys). Choose KMS to use...
	EncryptionType string `json:"encryption_type,omitempty" jsonschema:"encryptionType determines how ECR encrypts images at rest. Default is AES256; using AWS-managed encryption. Use KMS to specify your own KMS key for compliance. EncryptionType determines how images are..."`
	// kmsKeyId is the ARN or ID of a KMS key used when encryption_type = KMS.
	//  If omitted, AWS uses the default service-managed key for ECR.
	//  Ignored if encryption_type = AES256.
	//  Can reference an AwsKmsKey resource.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"kmsKeyId is the ARN or ID of a KMS key used when encryption_type = KMS. If omitted; AWS uses the default service-managed key for ECR. Ignored if encryption_type = AES256. Can reference an AwsKmsKey re..."`
	// forceDelete, if true, allows deleting the repository even when it contains
	//  images (all images get removed on delete). By default, it is false, preventing
	//  accidental data loss.
	ForceDelete bool `json:"force_delete,omitempty" jsonschema:"forceDelete; if true; allows deleting the repository even when it contains images (all images get removed on delete). By default; it is false; preventing accidental data loss."`
	// scanOnPush enables automatic image scanning when images are pushed to the repository.
	//  This is a production security essential - enables shift-left vulnerability detection.
	//  Defaults to true for security best practices.
	ScanOnPush bool `json:"scan_on_push,omitempty" jsonschema:"scanOnPush enables automatic image scanning when images are pushed to the repository. This is a production security essential - enables shift-left vulnerability detection. Defaults to true for securit..."`
	// lifecyclePolicyRules defines automated image lifecycle management rules for cost control.
	//  This is essential for production to prevent uncontrolled storage costs.
	//  If not specified, no lifecycle policy is applied (not recommended for production).
	LifecyclePolicy *AwsEcrRepoLifecyclePolicyInput `json:"lifecycle_policy,omitempty" jsonschema:"lifecyclePolicyRules defines automated image lifecycle management rules for cost control. This is essential for production to prevent uncontrolled storage costs. If not specified; no lifecycle policy ..."`
}

func (s *AwsEcrRepoSpecInput) validate() error {
	if s.RepositoryName == "" {
		return fmt.Errorf("repository_name is required")
	}
	if s.LifecyclePolicy != nil {
		if err := s.LifecyclePolicy.validate(); err != nil {
			return fmt.Errorf("lifecycle_policy: %w", err)
		}
	}
	return nil
}

func (s *AwsEcrRepoSpecInput) applyDefaults() {
	if s.EncryptionType == "" {
		s.EncryptionType = "AES256"
	}
	// default: ScanOnPush = true (applied at zero-value)
	if s.LifecyclePolicy != nil {
		s.LifecyclePolicy.applyDefaults()
	}
}

func (s *AwsEcrRepoSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["repository_name"] = s.RepositoryName
	if s.ImageImmutable {
		m["image_immutable"] = s.ImageImmutable
	}
	if s.EncryptionType != "" {
		m["encryption_type"] = s.EncryptionType
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.ForceDelete {
		m["force_delete"] = s.ForceDelete
	}
	if s.ScanOnPush {
		m["scan_on_push"] = s.ScanOnPush
	}
	if s.LifecyclePolicy != nil {
		m["lifecycle_policy"] = s.LifecyclePolicy.toMap()
	}
	return m
}

// AwsEcrRepoLifecyclePolicy defines lifecycle rules for automatic image expiration.
//
//	This is critical for cost control in active CI/CD environments that generate many images.
type AwsEcrRepoLifecyclePolicyInput struct {
	// expireUntaggedAfterDays removes untagged images after the specified number of days.
	//  Untagged images are typically intermediate build layers or failed builds.
	//  Recommended: 1-14 days. Default: 14 days if not specified.
	ExpireUntaggedAfterDays int32 `json:"expire_untagged_after_days,omitempty" jsonschema:"expireUntaggedAfterDays removes untagged images after the specified number of days. Untagged images are typically intermediate build layers or failed builds. Recommended: 1-14 days. Default: 14 days i..."`
	// maxImageCount keeps only the most recent N images, expiring all older ones.
	//  This prevents unbounded growth from CI/CD pipelines creating many tagged images.
	//  Recommended: 30-100 depending on deployment frequency. Default: 30 if not specified.
	MaxImageCount int32 `json:"max_image_count,omitempty" jsonschema:"maxImageCount keeps only the most recent N images; expiring all older ones. This prevents unbounded growth from CI/CD pipelines creating many tagged images. Recommended: 30-100 depending on deployment..."`
}

func (s *AwsEcrRepoLifecyclePolicyInput) validate() error {
	return nil
}

func (s *AwsEcrRepoLifecyclePolicyInput) applyDefaults() {
	if s.ExpireUntaggedAfterDays == 0 {
		s.ExpireUntaggedAfterDays = 14
	}
	if s.MaxImageCount == 0 {
		s.MaxImageCount = 30
	}
}

func (s *AwsEcrRepoLifecyclePolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.ExpireUntaggedAfterDays != 0 {
		m["expire_untagged_after_days"] = s.ExpireUntaggedAfterDays
	}
	if s.MaxImageCount != 0 {
		m["max_image_count"] = s.MaxImageCount
	}
	return m
}

// ParseAwsEcrRepo validates and normalizes a AwsEcrRepo cloud_object.
func ParseAwsEcrRepo(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEcrRepo"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEcrRepoSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
