// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-fsx-windows-file-system
type AwsFsxWindowsFileSystemSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Deployment type controlling availability and performance characteristics.
	//  ForceNew — cannot be changed after creation.
	//
	//  - "SINGLE_AZ_1": first-generation single-AZ. Limited throughput tiers.
	//  - "SINGLE_AZ_2": latest single-AZ with higher throughput ceiling and HDD
	//    support. Recommended for mos...
	DeploymentType string `json:"deployment_type,omitempty" jsonschema:"Deployment type controlling availability and performance characteristics. ForceNew — cannot be changed after creation. - 'SINGLE_AZ_1': first-generation single-AZ. Limited throughput tiers. - 'SINGL..."`
	// Storage capacity in GiB. Required.
	//
	//  Valid ranges depend on storage type:
	//  - SSD: 32–65536 GiB
	//  - HDD: 2000–65536 GiB
	//
	//  Storage can be increased after creation but never decreased.
	StorageCapacityGib int32 `json:"storage_capacity_gib,omitempty" jsonschema:"Storage capacity in GiB. Required. Valid ranges depend on storage type: - SSD: 32–65536 GiB - HDD: 2000–65536 GiB Storage can be increased after creation but never decreased."`
	// Storage media type. ForceNew — cannot be changed after creation.
	//
	//  - "SSD": solid-state drives. Sub-millisecond latency. Required for
	//    SINGLE_AZ_1. Recommended for most workloads.
	//  - "HDD": hard disk drives. Lower cost, higher latency. Only available for
	//    SINGLE_AZ_2 and MULTI_AZ_1 deployment ...
	StorageType string `json:"storage_type,omitempty" jsonschema:"Storage media type. ForceNew — cannot be changed after creation. - 'SSD': solid-state drives. Sub-millisecond latency. Required for SINGLE_AZ_1. Recommended for most workloads. - 'HDD': hard disk dr..."`
	// Throughput capacity in MB/s. Required.
	//
	//  Valid values: 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4608, 6144, 9216, 12288.
	//  The maximum available throughput depends on the deployment type.
	//
	//  Throughput can be changed after creation to scale performance up or down.
	ThroughputCapacity int32 `json:"throughput_capacity,omitempty" jsonschema:"Throughput capacity in MB/s. Required. Valid values: 8; 16; 32; 64; 128; 256; 512; 1024; 2048; 4608; 6144; 9216; 12288. The maximum available throughput depends on the deployment type. Throughput can ..."`
	// Subnet IDs for the file system's network interfaces. Required. ForceNew.
	//
	//  - SINGLE_AZ_1 / SINGLE_AZ_2: exactly one subnet.
	//  - MULTI_AZ_1: exactly two subnets in different availability zones.
	//
	//  All compute resources mounting this file system must have SMB network
	//  connectivity to these subnets (TCP ...
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs for the file system's network interfaces. Required. ForceNew. - SINGLE_AZ_1 / SINGLE_AZ_2: exactly one subnet. - MULTI_AZ_1: exactly two subnets in different availability zones. All compute..."`
	// Preferred subnet for the active file server in a MULTI_AZ_1 deployment.
	//  ForceNew. Required when deployment_type is MULTI_AZ_1. Must be one of the
	//  subnets specified in subnet_ids.
	//
	//  In a failover event, the standby file server in the other subnet takes over.
	//  Ignored for SINGLE_AZ deployments.
	PreferredSubnetId string `json:"preferred_subnet_id,omitempty" jsonschema:"Preferred subnet for the active file server in a MULTI_AZ_1 deployment. ForceNew. Required when deployment_type is MULTI_AZ_1. Must be one of the subnets specified in subnet_ids. In a failover event; ..."`
	// Security groups for the file system's network interfaces. ForceNew.
	//
	//  Must allow SMB traffic between the file system and its clients:
	//  - TCP port 445 (SMB)
	//  - TCP port 5985 (WinRM for PowerShell remote administration)
	//
	//  Additionally, for Active Directory communication:
	//  - TCP/UDP port 53 (DNS), TCP/...
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security groups for the file system's network interfaces. ForceNew. Must allow SMB traffic between the file system and its clients: - TCP port 445 (SMB) - TCP port 5985 (WinRM for PowerShell remote ad..."`
	// Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key
	//  cannot be changed after creation. When omitted, the file system uses the
	//  AWS-managed FSx key. All Windows file systems are encrypted at rest by
	//  default; this field upgrades to a customer-managed key.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key cannot be changed after creation. When omitted; the file system uses the AWS-managed FSx key. All Windows file systems are..."`
	// ID of an existing AWS Managed Microsoft AD (Directory Service) to join.
	//  ForceNew. Mutually exclusive with `self_managed_active_directory`.
	//
	//  Use this when you have an AWS Directory Service managed AD already
	//  provisioned. The file system joins the domain automatically.
	ActiveDirectoryId string `json:"active_directory_id,omitempty" jsonschema:"ID of an existing AWS Managed Microsoft AD (Directory Service) to join. ForceNew. Mutually exclusive with 'self_managed_active_directory'. Use this when you have an AWS Directory Service managed AD al..."`
	// Self-managed Active Directory configuration for joining an on-premises or
	//  EC2-hosted AD domain. Mutually exclusive with `active_directory_id`.
	//
	//  Use this when your AD domain controller runs outside AWS Directory Service
	//  (e.g., on-premises AD, AD on EC2, or Azure AD DS).
	SelfManagedActiveDirectory *AwsFsxWindowsFileSystemSelfManagedActiveDirectoryInput `json:"self_managed_active_directory,omitempty" jsonschema:"Self-managed Active Directory configuration for joining an on-premises or EC2-hosted AD domain. Mutually exclusive with 'active_directory_id'. Use this when your AD domain controller runs outside AWS ..."`
	// DNS alias names to associate with the file system. Up to 50 aliases.
	//
	//  Aliases allow the file system to be accessed via custom DNS names
	//  (e.g., "finance.corp.example.com") in addition to the default DNS name.
	//  Useful for DFS namespace integration, migration from on-premises filers,
	//  or providing us...
	Aliases []string `json:"aliases,omitempty" jsonschema:"DNS alias names to associate with the file system. Up to 50 aliases. Aliases allow the file system to be accessed via custom DNS names (e.g.; 'finance.corp.example.com') in addition to the default DNS..."`
	// Audit log configuration for tracking file access and file share access
	//  events. Logs are sent to CloudWatch Logs for compliance and security
	//  monitoring. When omitted, audit logging is disabled.
	AuditLogConfiguration *AwsFsxWindowsFileSystemAuditLogConfigurationInput `json:"audit_log_configuration,omitempty" jsonschema:"Audit log configuration for tracking file access and file share access events. Logs are sent to CloudWatch Logs for compliance and security monitoring. When omitted; audit logging is disabled."`
	// SSD IOPS configuration for the file system. Controls the total provisioned
	//  IOPS. When omitted, AWS uses AUTOMATIC mode which scales IOPS with storage.
	//  Only applicable to SSD storage type.
	DiskIopsConfiguration *AwsFsxWindowsFileSystemDiskIopsConfigurationInput `json:"disk_iops_configuration,omitempty" jsonschema:"SSD IOPS configuration for the file system. Controls the total provisioned IOPS. When omitted; AWS uses AUTOMATIC mode which scales IOPS with storage. Only applicable to SSD storage type."`
	// Number of days to retain automatic backups. Range: 0-90. Set to 0 to
	//  disable automatic backups.
	//
	//  Default: 7
	AutomaticBackupRetentionDays int32 `json:"automatic_backup_retention_days,omitempty" jsonschema:"Number of days to retain automatic backups. Range: 0-90. Set to 0 to disable automatic backups. Default: 7"`
	// Daily UTC time to start automatic backups, in HH:MM format (e.g., "01:00").
	//  If not specified and backups are enabled, AWS chooses a default window.
	DailyAutomaticBackupStartTime string `json:"daily_automatic_backup_start_time,omitempty" jsonschema:"Daily UTC time to start automatic backups; in HH:MM format (e.g.; '01:00'). If not specified and backups are enabled; AWS chooses a default window."`
	// Copy tags from the file system to backups. ForceNew.
	CopyTagsToBackups bool `json:"copy_tags_to_backups,omitempty" jsonschema:"Copy tags from the file system to backups. ForceNew."`
	// Skip creating a final backup when the file system is deleted.
	//
	//  Default: true
	SkipFinalBackup bool `json:"skip_final_backup,omitempty" jsonschema:"Skip creating a final backup when the file system is deleted. Default: true"`
	// Weekly UTC maintenance window in the format "d:HH:MM" where d is the day of
	//  the week (1=Monday, 7=Sunday). Example: "7:02:00" for Sunday at 02:00 UTC.
	//  If not specified, AWS chooses a default window.
	WeeklyMaintenanceStartTime string `json:"weekly_maintenance_start_time,omitempty" jsonschema:"Weekly UTC maintenance window in the format 'd:HH:MM' where d is the day of the week (1=Monday; 7=Sunday). Example: '7:02:00' for Sunday at 02:00 UTC. If not specified; AWS chooses a default window."`
}

func (s *AwsFsxWindowsFileSystemSpecInput) validate() error {
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	if s.SelfManagedActiveDirectory != nil {
		if err := s.SelfManagedActiveDirectory.validate(); err != nil {
			return fmt.Errorf("self_managed_active_directory: %w", err)
		}
	}
	if s.AuditLogConfiguration != nil {
		if err := s.AuditLogConfiguration.validate(); err != nil {
			return fmt.Errorf("audit_log_configuration: %w", err)
		}
	}
	if s.DiskIopsConfiguration != nil {
		if err := s.DiskIopsConfiguration.validate(); err != nil {
			return fmt.Errorf("disk_iops_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxWindowsFileSystemSpecInput) applyDefaults() {
	if s.DeploymentType == "" {
		s.DeploymentType = "SINGLE_AZ_2"
	}
	if s.StorageType == "" {
		s.StorageType = "SSD"
	}
	if s.SelfManagedActiveDirectory != nil {
		s.SelfManagedActiveDirectory.applyDefaults()
	}
	if s.AuditLogConfiguration != nil {
		s.AuditLogConfiguration.applyDefaults()
	}
	if s.DiskIopsConfiguration != nil {
		s.DiskIopsConfiguration.applyDefaults()
	}
	if s.AutomaticBackupRetentionDays == 0 {
		s.AutomaticBackupRetentionDays = 7
	}
	// default: SkipFinalBackup = true (applied at zero-value)
}

func (s *AwsFsxWindowsFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.DeploymentType != "" {
		m["deployment_type"] = s.DeploymentType
	}
	if s.StorageCapacityGib != 0 {
		m["storage_capacity_gib"] = s.StorageCapacityGib
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.ThroughputCapacity != 0 {
		m["throughput_capacity"] = s.ThroughputCapacity
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if s.PreferredSubnetId != "" {
		m["preferred_subnet_id"] = s.PreferredSubnetId
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.ActiveDirectoryId != "" {
		m["active_directory_id"] = s.ActiveDirectoryId
	}
	if s.SelfManagedActiveDirectory != nil {
		m["self_managed_active_directory"] = s.SelfManagedActiveDirectory.toMap()
	}
	if len(s.Aliases) > 0 {
		m["aliases"] = s.Aliases
	}
	if s.AuditLogConfiguration != nil {
		m["audit_log_configuration"] = s.AuditLogConfiguration.toMap()
	}
	if s.DiskIopsConfiguration != nil {
		m["disk_iops_configuration"] = s.DiskIopsConfiguration.toMap()
	}
	if s.AutomaticBackupRetentionDays != 0 {
		m["automatic_backup_retention_days"] = s.AutomaticBackupRetentionDays
	}
	if s.DailyAutomaticBackupStartTime != "" {
		m["daily_automatic_backup_start_time"] = s.DailyAutomaticBackupStartTime
	}
	if s.CopyTagsToBackups {
		m["copy_tags_to_backups"] = s.CopyTagsToBackups
	}
	if s.SkipFinalBackup {
		m["skip_final_backup"] = s.SkipFinalBackup
	}
	if s.WeeklyMaintenanceStartTime != "" {
		m["weekly_maintenance_start_time"] = s.WeeklyMaintenanceStartTime
	}
	return m
}

// AwsFsxWindowsFileSystemAuditLogConfiguration configures Windows audit logging
//
//	for the file system. Two independent audit levels can be set: one for file
//	access events (open, read, write, delete) and one for file share access events
//	(connect, disconnect, change permissions). Logs are sent to CloudWatch Logs.
type AwsFsxWindowsFileSystemAuditLogConfigurationInput struct {
	// Logging level for individual file access events (open, read, write, delete,
	//  rename, change permissions on files and folders).
	//
	//  - "DISABLED": no file access logging.
	//  - "SUCCESS_ONLY": log successful access events only.
	//  - "FAILURE_ONLY": log failed access attempts only (e.g., access denied).
	//  - "S...
	FileAccessAuditLogLevel string `json:"file_access_audit_log_level,omitempty" jsonschema:"Logging level for individual file access events (open; read; write; delete; rename; change permissions on files and folders). - 'DISABLED': no file access logging. - 'SUCCESS_ONLY': log successful acc..."`
	// Logging level for file share access events (connect to share, disconnect,
	//  change share permissions).
	//
	//  - "DISABLED": no file share access logging.
	//  - "SUCCESS_ONLY": log successful share access events only.
	//  - "FAILURE_ONLY": log failed share access attempts only.
	//  - "SUCCESS_AND_FAILURE": log all ...
	FileShareAccessAuditLogLevel string `json:"file_share_access_audit_log_level,omitempty" jsonschema:"Logging level for file share access events (connect to share; disconnect; change share permissions). - 'DISABLED': no file share access logging. - 'SUCCESS_ONLY': log successful share access events on..."`
	// CloudWatch Logs log group ARN to receive audit events. The log group must
	//  start with "/aws/fsx/" as required by AWS. If not set when audit levels are
	//  enabled, FSx creates a default log stream in the "/aws/fsx/windows" group.
	//
	//  Only valid when at least one audit log level is not DISABLED.
	AuditLogDestination string `json:"audit_log_destination,omitempty" jsonschema:"CloudWatch Logs log group ARN to receive audit events. The log group must start with '/aws/fsx/' as required by AWS. If not set when audit levels are enabled; FSx creates a default log stream in the '..."`
}

func (s *AwsFsxWindowsFileSystemAuditLogConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxWindowsFileSystemAuditLogConfigurationInput) applyDefaults() {
	if s.FileAccessAuditLogLevel == "" {
		s.FileAccessAuditLogLevel = "DISABLED"
	}
	if s.FileShareAccessAuditLogLevel == "" {
		s.FileShareAccessAuditLogLevel = "DISABLED"
	}
}

func (s *AwsFsxWindowsFileSystemAuditLogConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.FileAccessAuditLogLevel != "" {
		m["file_access_audit_log_level"] = s.FileAccessAuditLogLevel
	}
	if s.FileShareAccessAuditLogLevel != "" {
		m["file_share_access_audit_log_level"] = s.FileShareAccessAuditLogLevel
	}
	if s.AuditLogDestination != "" {
		m["audit_log_destination"] = s.AuditLogDestination
	}
	return m
}

// AwsFsxWindowsFileSystemDiskIopsConfiguration controls the SSD IOPS provisioned
//
//	for the file system. In AUTOMATIC mode, IOPS scale with storage capacity. In
//	USER_PROVISIONED mode, you specify the exact IOPS independently of storage.
//	Only applicable to SSD storage type.
type AwsFsxWindowsFileSystemDiskIopsConfigurationInput struct {
	// IOPS provisioning mode.
	//
	//  - "AUTOMATIC": IOPS scale automatically based on storage capacity.
	//    Provides 3 IOPS per GiB of storage.
	//  - "USER_PROVISIONED": you specify the exact IOPS via the `iops` field.
	//    Allows higher performance independent of storage size but at extra cost.
	//
	//  Default: AUTOMATIC
	Mode string `json:"mode,omitempty" jsonschema:"IOPS provisioning mode. - 'AUTOMATIC': IOPS scale automatically based on storage capacity. Provides 3 IOPS per GiB of storage. - 'USER_PROVISIONED': you specify the exact IOPS via the 'iops' field. Al..."`
	// Total SSD IOPS provisioned. Only valid when mode is "USER_PROVISIONED".
	//
	//  Valid range: 0–350000.
	Iops int32 `json:"iops,omitempty" jsonschema:"Total SSD IOPS provisioned. Only valid when mode is 'USER_PROVISIONED'. Valid range: 0–350000."`
}

func (s *AwsFsxWindowsFileSystemDiskIopsConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxWindowsFileSystemDiskIopsConfigurationInput) applyDefaults() {
	if s.Mode == "" {
		s.Mode = "AUTOMATIC"
	}
}

func (s *AwsFsxWindowsFileSystemDiskIopsConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Mode != "" {
		m["mode"] = s.Mode
	}
	if s.Iops != 0 {
		m["iops"] = s.Iops
	}
	return m
}

// AwsFsxWindowsFileSystemSelfManagedActiveDirectory configures the file system
//
//	to join a self-managed Active Directory domain. Use this when your AD domain
//	controller runs outside AWS Directory Service (e.g., on-premises, on EC2,
//	or Azure AD DS).
//
//	Two authentication methods are supported (mutually exclusive):
//	1. Direct credentials: `username` + `password`
//	2. AWS Secrets Manager: `domain_join_service_account_secret_arn`
//
//	The Secrets Manager approach is recommended for production as it avoids
//	storing credentials in the resource manifest.
type AwsFsxWindowsFileSystemSelfManagedActiveDirectoryInput struct {
	// Fully qualified domain name of the self-managed AD directory.
	//  Example: "corp.example.com"
	DomainName string `json:"domain_name,omitempty" jsonschema:"Fully qualified domain name of the self-managed AD directory. Example: 'corp.example.com'"`
	// IP addresses of the DNS servers for the AD domain. Required.
	//  Must be reachable from the file system's subnets (same VPC CIDR or
	//  RFC 1918 private ranges). Minimum 1, maximum 2 IP addresses.
	DnsIps []string `json:"dns_ips,omitempty" jsonschema:"IP addresses of the DNS servers for the AD domain. Required. Must be reachable from the file system's subnets (same VPC CIDR or RFC 1918 private ranges). Minimum 1; maximum 2 IP addresses."`
	// Service account username for domain join operations. Mutually exclusive
	//  with `domain_join_service_account_secret_arn`. Length: 1-256 characters.
	Username string `json:"username,omitempty" jsonschema:"Service account username for domain join operations. Mutually exclusive with 'domain_join_service_account_secret_arn'. Length: 1-256 characters."`
	// Service account password for domain join operations. Mutually exclusive
	//  with `domain_join_service_account_secret_arn`. Length: 1-256 characters.
	//
	//  For production workloads, prefer `domain_join_service_account_secret_arn`
	//  to avoid storing credentials in the resource manifest.
	Password string `json:"password,omitempty" jsonschema:"Service account password for domain join operations. Mutually exclusive with 'domain_join_service_account_secret_arn'. Length: 1-256 characters. For production workloads; prefer 'domain_join_service_a..."`
	// ARN of an AWS Secrets Manager secret containing the service account
	//  credentials for domain join. Mutually exclusive with `username`/`password`.
	//
	//  The secret must contain a JSON object with "username" and "password" keys.
	//  This is the recommended approach for production deployments.
	DomainJoinServiceAccountSecretArn string `json:"domain_join_service_account_secret_arn,omitempty" jsonschema:"ARN of an AWS Secrets Manager secret containing the service account credentials for domain join. Mutually exclusive with 'username'/'password'. The secret must contain a JSON object with 'username' an..."`
	// Name of the AD group whose members are granted administrative privileges
	//  on the file system. Members can administer the file system from a remote
	//  PowerShell endpoint using the FSx Remote PowerShell.
	//
	//  Default: Domain Admins
	FileSystemAdministratorsGroup string `json:"file_system_administrators_group,omitempty" jsonschema:"Name of the AD group whose members are granted administrative privileges on the file system. Members can administer the file system from a remote PowerShell endpoint using the FSx Remote PowerShell. D..."`
	// Organizational Unit (OU) distinguished name within the AD directory where
	//  the file system's computer object is created.
	//
	//  Example: "OU=FSx,DC=corp,DC=example,DC=com"
	//
	//  Only the OU immediately above the computer object can be specified.
	//  If not provided, the computer object is created in the default...
	OrganizationalUnitDistinguishedName string `json:"organizational_unit_distinguished_name,omitempty" jsonschema:"Organizational Unit (OU) distinguished name within the AD directory where the file system's computer object is created. Example: 'OU=FSx;DC=corp;DC=example;DC=com' Only the OU immediately above the co..."`
}

func (s *AwsFsxWindowsFileSystemSelfManagedActiveDirectoryInput) validate() error {
	if len(s.DnsIps) < 1 {
		return fmt.Errorf("dns_ips requires at least 1 items, got %d", len(s.DnsIps))
	}
	return nil
}

func (s *AwsFsxWindowsFileSystemSelfManagedActiveDirectoryInput) applyDefaults() {
	if s.FileSystemAdministratorsGroup == "" {
		s.FileSystemAdministratorsGroup = "Domain Admins"
	}
}

func (s *AwsFsxWindowsFileSystemSelfManagedActiveDirectoryInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.DomainName != "" {
		m["domain_name"] = s.DomainName
	}
	if len(s.DnsIps) > 0 {
		m["dns_ips"] = s.DnsIps
	}
	if s.Username != "" {
		m["username"] = s.Username
	}
	if s.Password != "" {
		m["password"] = s.Password
	}
	if s.DomainJoinServiceAccountSecretArn != "" {
		m["domain_join_service_account_secret_arn"] = s.DomainJoinServiceAccountSecretArn
	}
	if s.FileSystemAdministratorsGroup != "" {
		m["file_system_administrators_group"] = s.FileSystemAdministratorsGroup
	}
	if s.OrganizationalUnitDistinguishedName != "" {
		m["organizational_unit_distinguished_name"] = s.OrganizationalUnitDistinguishedName
	}
	return m
}

// ParseAwsFsxWindowsFileSystem validates and normalizes a AwsFsxWindowsFileSystem cloud_object.
func ParseAwsFsxWindowsFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsFsxWindowsFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsFsxWindowsFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
