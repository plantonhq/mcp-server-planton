// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsEventBridgeBus is the Kubernetes-style resource envelope for an AWS
//
//	EventBridge custom event bus.
type AwsEventBridgeBusSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Human-readable description of the event bus.
	//  Maximum length is 512 characters.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the event bus. Maximum length is 512 characters."`
	// KMS key identifier for encrypting events on this bus. Accepts a KMS key
	//  ARN, key ID, key alias, or key alias ARN. When omitted, events are
	//  encrypted with an AWS-owned key at no additional cost.
	//
	//  Accepts a direct value or a reference to an AwsKmsKey resource.
	KmsKeyIdentifier string `json:"kms_key_identifier,omitempty" jsonschema:"KMS key identifier for encrypting events on this bus. Accepts a KMS key ARN; key ID; key alias; or key alias ARN. When omitted; events are encrypted with an AWS-owned key at no additional cost. Accept..."`
	// Partner event source name. Set this only when creating a bus for a SaaS
	//  partner integration (e.g., Datadog, Zendesk, PagerDuty).
	//
	//  The value must match the pattern: aws.partner/{partner}/{...} and the bus
	//  name (`metadata.name`) must match this value exactly.
	//
	//  This field is immutable — changing ...
	EventSourceName string `json:"event_source_name,omitempty" jsonschema:"Partner event source name. Set this only when creating a bus for a SaaS partner integration (e.g.; Datadog; Zendesk; PagerDuty). The value must match the pattern: aws.partner/{partner}/{...} and the b..."`
	// Dead letter queue configuration for the event bus. When set, events that
	//  fail delivery to any rule target on this bus are routed to the specified
	//  SQS queue for investigation and reprocessing.
	//
	//  This is the bus-level DLQ — it catches events that cannot be delivered
	//  to ANY target on any rule atta...
	DeadLetterConfig *AwsEventBridgeBusDeadLetterConfigInput `json:"dead_letter_config,omitempty" jsonschema:"Dead letter queue configuration for the event bus. When set; events that fail delivery to any rule target on this bus are routed to the specified SQS queue for investigation and reprocessing. This is ..."`
	// Logging configuration for the event bus. When set, EventBridge writes
	//  event delivery logs to CloudWatch Logs. Useful for debugging event
	//  routing, monitoring delivery failures, and auditing event traffic.
	LogConfig *AwsEventBridgeBusLogConfigInput `json:"log_config,omitempty" jsonschema:"Logging configuration for the event bus. When set; EventBridge writes event delivery logs to CloudWatch Logs. Useful for debugging event routing; monitoring delivery failures; and auditing event traff..."`
}

func (s *AwsEventBridgeBusSpecInput) validate() error {
	if s.DeadLetterConfig != nil {
		if err := s.DeadLetterConfig.validate(); err != nil {
			return fmt.Errorf("dead_letter_config: %w", err)
		}
	}
	if s.LogConfig != nil {
		if err := s.LogConfig.validate(); err != nil {
			return fmt.Errorf("log_config: %w", err)
		}
	}
	return nil
}

func (s *AwsEventBridgeBusSpecInput) applyDefaults() {
	if s.DeadLetterConfig != nil {
		s.DeadLetterConfig.applyDefaults()
	}
	if s.LogConfig != nil {
		s.LogConfig.applyDefaults()
	}
}

func (s *AwsEventBridgeBusSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	if s.KmsKeyIdentifier != "" {
		m["kms_key_identifier"] = s.KmsKeyIdentifier
	}
	if s.EventSourceName != "" {
		m["event_source_name"] = s.EventSourceName
	}
	if s.DeadLetterConfig != nil {
		m["dead_letter_config"] = s.DeadLetterConfig.toMap()
	}
	if s.LogConfig != nil {
		m["log_config"] = s.LogConfig.toMap()
	}
	return m
}

// AwsEventBridgeBusDeadLetterConfig configures a dead letter queue for the event bus.
//
//	Events that fail delivery to any rule target are routed to the specified queue.
type AwsEventBridgeBusDeadLetterConfigInput struct {
	// ARN of the SQS queue to use as the dead letter queue. The queue must
	//  exist in the same AWS account and region as the event bus.
	//
	//  Accepts a direct ARN or a reference to an AwsSqsQueue resource.
	Arn string `json:"arn" jsonschema:"required,ARN of the SQS queue to use as the dead letter queue. The queue must exist in the same AWS account and region as the event bus. Accepts a direct ARN or a reference to an AwsSqsQueue resource."`
}

func (s *AwsEventBridgeBusDeadLetterConfigInput) validate() error {
	if s.Arn == "" {
		return fmt.Errorf("arn is required")
	}
	return nil
}

func (s *AwsEventBridgeBusDeadLetterConfigInput) applyDefaults() {
}

func (s *AwsEventBridgeBusDeadLetterConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["arn"] = s.Arn
	return m
}

// AwsEventBridgeBusLogConfig configures logging for the event bus.
//
//	When enabled, EventBridge sends event delivery logs to CloudWatch Logs.
type AwsEventBridgeBusLogConfigInput struct {
	// Logging level. Controls which events are logged.
	//
	//  Valid values:
	//  - "OFF"   — no logging
	//  - "ERROR" — log only delivery failures
	//  - "INFO"  — log delivery successes and failures
	//  - "TRACE" — log all events including matched/unmatched (most verbose)
	//
	//  When the log_config block is provided, th...
	Level string `json:"level" jsonschema:"required,Logging level. Controls which events are logged. Valid values: - 'OFF' — no logging - 'ERROR' — log only delivery failures - 'INFO' — log delivery successes and failures - 'TRACE' — log all ev..."`
	// Whether to include the full event detail in log entries.
	//
	//  Valid values:
	//  - "NONE" — exclude event detail from logs (smaller log volume)
	//  - "FULL" — include complete event detail in each log entry
	//
	//  Default behavior when omitted: "NONE".
	IncludeDetail string `json:"include_detail,omitempty" jsonschema:"Whether to include the full event detail in log entries. Valid values: - 'NONE' — exclude event detail from logs (smaller log volume) - 'FULL' — include complete event detail in each log entry Def..."`
}

func (s *AwsEventBridgeBusLogConfigInput) validate() error {
	if s.Level == "" {
		return fmt.Errorf("level is required")
	}
	return nil
}

func (s *AwsEventBridgeBusLogConfigInput) applyDefaults() {
}

func (s *AwsEventBridgeBusLogConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["level"] = s.Level
	if s.IncludeDetail != "" {
		m["include_detail"] = s.IncludeDetail
	}
	return m
}

// ParseAwsEventBridgeBus validates and normalizes a AwsEventBridgeBus cloud_object.
func ParseAwsEventBridgeBus(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEventBridgeBus"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEventBridgeBusSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
