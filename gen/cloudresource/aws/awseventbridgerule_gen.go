// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:50:56+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsEventBridgeRule is the Kubernetes-style resource envelope for an AWS
//
//	EventBridge rule with bundled targets.
type AwsEventBridgeRuleSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Name of the event bus to attach this rule to. Defaults to "default" (the
	//  built-in AWS event bus) when not specified. Can reference an
	//  AwsEventBridgeBus resource via `valueFrom`.
	//
	//  Changing this field forces rule replacement (delete + recreate).
	EventBusName string `json:"event_bus_name,omitempty" jsonschema:"Name of the event bus to attach this rule to. Defaults to 'default' (the built-in AWS event bus) when not specified. Can reference an AwsEventBridgeBus resource via 'valueFrom'. Changing this field fo..."`
	// Human-readable description of the rule. Maximum 512 characters.
	Description string `json:"description,omitempty" jsonschema:"Human-readable description of the rule. Maximum 512 characters."`
	// JSON event pattern that this rule matches against. Events that match the
	//  pattern are routed to the rule's targets. Expressed as a structured object
	//  in YAML — the IaC module serializes it to JSON.
	//
	//  Mutually exclusive with `schedule_expression`.
	//
	//  Example patterns:
	//    source: ["aws.ec2"]
	//    detai...
	EventPattern any `json:"event_pattern,omitempty" jsonschema:"JSON event pattern that this rule matches against. Events that match the pattern are routed to the rule's targets. Expressed as a structured object in YAML — the IaC module serializes it to JSON. Mu..."`
	// Schedule expression for time-based rule triggering. Supports cron and rate
	//  expressions.
	//
	//  Mutually exclusive with `event_pattern`.
	//
	//  Examples:
	//    "rate(5 minutes)"        — fire every 5 minutes
	//    "rate(1 hour)"           — fire every hour
	//    "cron(0 12 * * ? *)"     — fire at noon UTC every ...
	ScheduleExpression string `json:"schedule_expression,omitempty" jsonschema:"Schedule expression for time-based rule triggering. Supports cron and rate expressions. Mutually exclusive with 'event_pattern'. Examples: 'rate(5 minutes)' — fire every 5 minutes 'rate(1 hour)' —..."`
	// Rule state. Controls whether the rule is actively matching events.
	//  Valid values: "ENABLED", "DISABLED". Defaults to "ENABLED" in the IaC
	//  module when not set.
	State string `json:"state,omitempty" jsonschema:"Rule state. Controls whether the rule is actively matching events. Valid values: 'ENABLED'; 'DISABLED'. Defaults to 'ENABLED' in the IaC module when not set."`
	// Targets to invoke when the rule matches an event. At least one target is
	//  required. Each target specifies a destination (Lambda, SQS, SNS, Step
	//  Functions, etc.) and optional input transformation, retry policy, and
	//  dead letter queue configuration.
	//
	//  AWS limits: maximum 5 targets per rule.
	Targets []*AwsEventBridgeTargetInput `json:"targets,omitempty" jsonschema:"Targets to invoke when the rule matches an event. At least one target is required. Each target specifies a destination (Lambda; SQS; SNS; Step Functions; etc.) and optional input transformation; retry..."`
}

func (s *AwsEventBridgeRuleSpecInput) validate() error {
	for i, v := range s.Targets {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("targets[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsEventBridgeRuleSpecInput) applyDefaults() {
}

func (s *AwsEventBridgeRuleSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.EventBusName != "" {
		m["event_bus_name"] = s.EventBusName
	}
	if s.Description != "" {
		m["description"] = s.Description
	}
	// unsupported type "object" for field EventPattern
	if s.ScheduleExpression != "" {
		m["schedule_expression"] = s.ScheduleExpression
	}
	if s.State != "" {
		m["state"] = s.State
	}
	if len(s.Targets) > 0 {
		items := make([]any, len(s.Targets))
		for i, v := range s.Targets {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["targets"] = items
	}
	return m
}

// AwsEventBridgeInputTransformer reshapes event data before delivering it to
//
//	the target. Useful for extracting specific fields, reformatting event data,
//	or adding static context.
//
//	The transformer works in two steps:
//	1. `input_paths` extracts values from the event using JSONPath expressions
//	2. `input_template` assembles the final input using the extracted values
type AwsEventBridgeInputTransformerInput struct {
	// Map of variable names to JSONPath expressions that extract values from
	//  the matched event. Keys become variables available in `input_template`.
	//  Maximum 100 entries. Keys must not start with "AWS".
	//
	//  Example:
	//    instance: "$.detail.instance-id"
	//    state: "$.detail.state"
	InputPaths map[string]string `json:"input_paths,omitempty" jsonschema:"Map of variable names to JSONPath expressions that extract values from the matched event. Keys become variables available in 'input_template'. Maximum 100 entries. Keys must not start with 'AWS'. Exam..."`
	// Template that produces the final input for the target. References
	//  variables from `input_paths` using angle brackets: <variable>.
	//  Maximum 8192 characters.
	//
	//  Example: "Instance <instance> transitioned to <state>"
	InputTemplate string `json:"input_template" jsonschema:"required,Template that produces the final input for the target. References variables from 'input_paths' using angle brackets: <variable>. Maximum 8192 characters. Example: 'Instance <instance> transitioned to ..."`
}

func (s *AwsEventBridgeInputTransformerInput) validate() error {
	if s.InputTemplate == "" {
		return fmt.Errorf("input_template is required")
	}
	return nil
}

func (s *AwsEventBridgeInputTransformerInput) applyDefaults() {
}

func (s *AwsEventBridgeInputTransformerInput) toMap() map[string]any {
	m := make(map[string]any)
	if len(s.InputPaths) > 0 {
		m["input_paths"] = s.InputPaths
	}
	m["input_template"] = s.InputTemplate
	return m
}

// AwsEventBridgeTarget defines a target to invoke when the rule matches an
//
//	event. Targets are the downstream consumers of matched events — Lambda
//	functions, SQS queues, SNS topics, Step Functions state machines, and more.
//
//	Each target can independently configure:
//	- Input transformation (constant input, JSONPath extraction, or template)
//	- Retry policy (max age and retry attempts)
//	- Dead letter queue (for events that fail delivery)
type AwsEventBridgeTargetInput struct {
	// User-assigned name for this target. Used as the Pulumi resource name
	//  and as the `target_id` in EventBridge. Must be unique within the rule's
	//  targets. Maximum 64 characters, alphanumeric plus hyphen, underscore,
	//  and period.
	Name string `json:"name" jsonschema:"required,User-assigned name for this target. Used as the Pulumi resource name and as the 'target_id' in EventBridge. Must be unique within the rule's targets. Maximum 64 characters; alphanumeric plus hyphen; u..."`
	// ARN of the target resource. This is the AWS resource that processes
	//  matched events. Common targets include Lambda functions, SQS queues,
	//  SNS topics, Step Functions state machines, and CloudWatch Log Groups.
	//
	//  No `default_kind` is set because the target resource type varies
	//  (Lambda, SQS, SNS, etc....
	Arn string `json:"arn" jsonschema:"required,ARN of the target resource. This is the AWS resource that processes matched events. Common targets include Lambda functions; SQS queues; SNS topics; Step Functions state machines; and CloudWatch Log G..."`
	// IAM role ARN for EventBridge to assume when invoking this target.
	//  Required for targets where EventBridge needs to assume a role:
	//  Step Functions, ECS, Kinesis, Batch, CodeBuild, CodePipeline, and
	//  cross-account event buses.
	//
	//  Not needed for targets that use resource-based policies:
	//  Lambda (functio...
	RoleArn string `json:"role_arn,omitempty" jsonschema:"IAM role ARN for EventBridge to assume when invoking this target. Required for targets where EventBridge needs to assume a role: Step Functions; ECS; Kinesis; Batch; CodeBuild; CodePipeline; and cross..."`
	// Constant JSON input to pass to the target instead of the matched event.
	//  Maximum 8192 characters. Mutually exclusive with `input_path` and
	//  `input_transformer`.
	Input string `json:"input,omitempty" jsonschema:"Constant JSON input to pass to the target instead of the matched event. Maximum 8192 characters. Mutually exclusive with 'input_path' and 'input_transformer'."`
	// JSONPath expression to extract a portion of the matched event and pass
	//  to the target. Maximum 256 characters. Mutually exclusive with `input`
	//  and `input_transformer`.
	//
	//  Example: "$.detail" extracts the detail object from the event.
	InputPath string `json:"input_path,omitempty" jsonschema:"JSONPath expression to extract a portion of the matched event and pass to the target. Maximum 256 characters. Mutually exclusive with 'input' and 'input_transformer'. Example: '$.detail' extracts the ..."`
	// Input transformer to reshape the matched event before passing to the
	//  target. Mutually exclusive with `input` and `input_path`.
	InputTransformer *AwsEventBridgeInputTransformerInput `json:"input_transformer,omitempty" jsonschema:"Input transformer to reshape the matched event before passing to the target. Mutually exclusive with 'input' and 'input_path'."`
	// Dead letter queue for events that fail delivery to this target. When
	//  EventBridge cannot deliver an event after all retry attempts, the event
	//  is routed to the specified SQS queue for investigation.
	DeadLetterConfig *AwsEventBridgeTargetDeadLetterConfigInput `json:"dead_letter_config,omitempty" jsonschema:"Dead letter queue for events that fail delivery to this target. When EventBridge cannot deliver an event after all retry attempts; the event is routed to the specified SQS queue for investigation."`
	// Retry policy controlling how EventBridge retries failed deliveries to
	//  this target. When not set, EventBridge uses the default policy: retry
	//  for 24 hours with up to 185 attempts using exponential backoff.
	RetryPolicy *AwsEventBridgeTargetRetryPolicyInput `json:"retry_policy,omitempty" jsonschema:"Retry policy controlling how EventBridge retries failed deliveries to this target. When not set; EventBridge uses the default policy: retry for 24 hours with up to 185 attempts using exponential backo..."`
	// SQS-specific configuration. Required when targeting a FIFO SQS queue
	//  to specify the message group ID.
	SqsConfig *AwsEventBridgeTargetSqsConfigInput `json:"sqs_config,omitempty" jsonschema:"SQS-specific configuration. Required when targeting a FIFO SQS queue to specify the message group ID."`
}

func (s *AwsEventBridgeTargetInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.Arn == "" {
		return fmt.Errorf("arn is required")
	}
	if s.InputTransformer != nil {
		if err := s.InputTransformer.validate(); err != nil {
			return fmt.Errorf("input_transformer: %w", err)
		}
	}
	if s.DeadLetterConfig != nil {
		if err := s.DeadLetterConfig.validate(); err != nil {
			return fmt.Errorf("dead_letter_config: %w", err)
		}
	}
	if s.RetryPolicy != nil {
		if err := s.RetryPolicy.validate(); err != nil {
			return fmt.Errorf("retry_policy: %w", err)
		}
	}
	if s.SqsConfig != nil {
		if err := s.SqsConfig.validate(); err != nil {
			return fmt.Errorf("sqs_config: %w", err)
		}
	}
	return nil
}

func (s *AwsEventBridgeTargetInput) applyDefaults() {
	if s.InputTransformer != nil {
		s.InputTransformer.applyDefaults()
	}
	if s.DeadLetterConfig != nil {
		s.DeadLetterConfig.applyDefaults()
	}
	if s.RetryPolicy != nil {
		s.RetryPolicy.applyDefaults()
	}
	if s.SqsConfig != nil {
		s.SqsConfig.applyDefaults()
	}
}

func (s *AwsEventBridgeTargetInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	m["arn"] = s.Arn
	if s.RoleArn != "" {
		m["role_arn"] = s.RoleArn
	}
	if s.Input != "" {
		m["input"] = s.Input
	}
	if s.InputPath != "" {
		m["input_path"] = s.InputPath
	}
	if s.InputTransformer != nil {
		m["input_transformer"] = s.InputTransformer.toMap()
	}
	if s.DeadLetterConfig != nil {
		m["dead_letter_config"] = s.DeadLetterConfig.toMap()
	}
	if s.RetryPolicy != nil {
		m["retry_policy"] = s.RetryPolicy.toMap()
	}
	if s.SqsConfig != nil {
		m["sqs_config"] = s.SqsConfig.toMap()
	}
	return m
}

// AwsEventBridgeTargetDeadLetterConfig configures a dead letter queue for
//
//	events that fail delivery to the target after all retry attempts.
type AwsEventBridgeTargetDeadLetterConfigInput struct {
	// ARN of the SQS queue to use as the dead letter queue. The queue must
	//  exist in the same AWS account and region as the rule.
	//
	//  Accepts a direct ARN or a reference to an AwsSqsQueue resource.
	Arn string `json:"arn" jsonschema:"required,ARN of the SQS queue to use as the dead letter queue. The queue must exist in the same AWS account and region as the rule. Accepts a direct ARN or a reference to an AwsSqsQueue resource."`
}

func (s *AwsEventBridgeTargetDeadLetterConfigInput) validate() error {
	if s.Arn == "" {
		return fmt.Errorf("arn is required")
	}
	return nil
}

func (s *AwsEventBridgeTargetDeadLetterConfigInput) applyDefaults() {
}

func (s *AwsEventBridgeTargetDeadLetterConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["arn"] = s.Arn
	return m
}

// AwsEventBridgeTargetRetryPolicy controls how EventBridge retries failed
//
//	event deliveries to a target.
type AwsEventBridgeTargetRetryPolicyInput struct {
	// Maximum time in seconds that EventBridge keeps retrying delivery.
	//  Range: 60 to 86400 (1 minute to 24 hours). Default: 86400 (24 hours).
	MaximumEventAgeInSeconds int32 `json:"maximum_event_age_in_seconds,omitempty" jsonschema:"Maximum time in seconds that EventBridge keeps retrying delivery. Range: 60 to 86400 (1 minute to 24 hours). Default: 86400 (24 hours)."`
	// Maximum number of retry attempts. Range: 0 to 185. Default: 185.
	//  Set to 0 to disable retries (event goes to DLQ immediately on failure).
	MaximumRetryAttempts int32 `json:"maximum_retry_attempts,omitempty" jsonschema:"Maximum number of retry attempts. Range: 0 to 185. Default: 185. Set to 0 to disable retries (event goes to DLQ immediately on failure)."`
}

func (s *AwsEventBridgeTargetRetryPolicyInput) validate() error {
	return nil
}

func (s *AwsEventBridgeTargetRetryPolicyInput) applyDefaults() {
}

func (s *AwsEventBridgeTargetRetryPolicyInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MaximumEventAgeInSeconds != 0 {
		m["maximum_event_age_in_seconds"] = s.MaximumEventAgeInSeconds
	}
	if s.MaximumRetryAttempts != 0 {
		m["maximum_retry_attempts"] = s.MaximumRetryAttempts
	}
	return m
}

// AwsEventBridgeTargetSqsConfig provides SQS-specific configuration for
//
//	targets pointing to SQS queues.
type AwsEventBridgeTargetSqsConfigInput struct {
	// Message group ID for FIFO SQS queues. Required when the target is a
	//  FIFO queue to ensure proper message ordering and deduplication.
	//  Ignored for standard queues.
	MessageGroupId string `json:"message_group_id,omitempty" jsonschema:"Message group ID for FIFO SQS queues. Required when the target is a FIFO queue to ensure proper message ordering and deduplication. Ignored for standard queues."`
}

func (s *AwsEventBridgeTargetSqsConfigInput) validate() error {
	return nil
}

func (s *AwsEventBridgeTargetSqsConfigInput) applyDefaults() {
}

func (s *AwsEventBridgeTargetSqsConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MessageGroupId != "" {
		m["message_group_id"] = s.MessageGroupId
	}
	return m
}

// ParseAwsEventBridgeRule validates and normalizes a AwsEventBridgeRule cloud_object.
func ParseAwsEventBridgeRule(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEventBridgeRule"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEventBridgeRuleSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
