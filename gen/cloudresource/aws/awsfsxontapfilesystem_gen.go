// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-fsx-ontap-file-system
type AwsFsxOntapFileSystemSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Deployment type controlling availability, performance, and scale-out
	//  characteristics. ForceNew — cannot be changed after creation.
	//
	//  - "SINGLE_AZ_1": first-generation single-AZ. Supports multiple HA pairs
	//    (1-12) but increasing HA pairs requires replacement.
	//  - "SINGLE_AZ_2": latest single-AZ w...
	DeploymentType string `json:"deployment_type,omitempty" jsonschema:"Deployment type controlling availability; performance; and scale-out characteristics. ForceNew — cannot be changed after creation. - 'SINGLE_AZ_1': first-generation single-AZ. Supports multiple HA p..."`
	// Storage capacity in GiB. Required.
	//
	//  Valid range: 1024–1048576 GiB (1 TiB – 1 PiB). Storage can be increased
	//  after creation but never decreased. Choose based on data size; ONTAP's
	//  built-in compression and deduplication typically achieve 2-5x data reduction.
	StorageCapacityGib int32 `json:"storage_capacity_gib,omitempty" jsonschema:"Storage capacity in GiB. Required. Valid range: 1024–1048576 GiB (1 TiB – 1 PiB). Storage can be increased after creation but never decreased. Choose based on data size; ONTAP's built-in compressi..."`
	// Storage media type. ForceNew — cannot be changed after creation.
	//
	//  - "SSD": solid-state drives. Sub-millisecond latency. Suitable for
	//    performance-sensitive workloads (databases, VMware, active data).
	//  - "HDD": hard disk drives with SSD cache. Lower cost for throughput-oriented
	//    workloads (dat...
	StorageType string `json:"storage_type,omitempty" jsonschema:"Storage media type. ForceNew — cannot be changed after creation. - 'SSD': solid-state drives. Sub-millisecond latency. Suitable for performance-sensitive workloads (databases; VMware; active data). ..."`
	// Throughput capacity per HA pair in MB/s. Required.
	//
	//  Valid values: 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144.
	//  Total file system throughput = throughput_capacity_per_ha_pair * ha_pairs.
	//
	//  For single HA pair deployments (the common case), this is the total
	//  throughput. For scale-out...
	ThroughputCapacityPerHaPair int32 `json:"throughput_capacity_per_ha_pair,omitempty" jsonschema:"Throughput capacity per HA pair in MB/s. Required. Valid values: 128; 256; 384; 512; 768; 1024; 1536; 2048; 3072; 4096; 6144. Total file system throughput = throughput_capacity_per_ha_pair * ha_pairs...."`
	// Number of high-availability pairs in the file system. Each HA pair adds
	//  an independent pair of file servers providing throughput and IOPS capacity.
	//
	//  - SINGLE_AZ_1 / SINGLE_AZ_2: 1-12 HA pairs. Scale-out for throughput.
	//    SINGLE_AZ_2 can increase HA pairs without replacement. SINGLE_AZ_1
	//    requir...
	HaPairs int32 `json:"ha_pairs,omitempty" jsonschema:"Number of high-availability pairs in the file system. Each HA pair adds an independent pair of file servers providing throughput and IOPS capacity. - SINGLE_AZ_1 / SINGLE_AZ_2: 1-12 HA pairs. Scale-ou..."`
	// Subnet IDs for the file system's network interfaces. Required. ForceNew.
	//
	//  - SINGLE_AZ_1 / SINGLE_AZ_2: exactly one subnet.
	//  - MULTI_AZ_1 / MULTI_AZ_2: exactly two subnets in different availability zones.
	//
	//  All compute resources accessing this file system (via NFS, SMB, or iSCSI)
	//  must have network ...
	SubnetIds []string `json:"subnet_ids,omitempty" jsonschema:"Subnet IDs for the file system's network interfaces. Required. ForceNew. - SINGLE_AZ_1 / SINGLE_AZ_2: exactly one subnet. - MULTI_AZ_1 / MULTI_AZ_2: exactly two subnets in different availability zones..."`
	// Preferred subnet for the active file server in a multi-AZ deployment.
	//  ForceNew. Required when deployment_type is MULTI_AZ_1 or MULTI_AZ_2.
	//  Must be one of the subnets specified in subnet_ids.
	//
	//  In a failover event, the standby file server in the other subnet takes over
	//  automatically. Ignored for s...
	PreferredSubnetId string `json:"preferred_subnet_id,omitempty" jsonschema:"Preferred subnet for the active file server in a multi-AZ deployment. ForceNew. Required when deployment_type is MULTI_AZ_1 or MULTI_AZ_2. Must be one of the subnets specified in subnet_ids. In a fail..."`
	// Security groups for the file system's network interfaces. ForceNew.
	//
	//  Must allow traffic between the file system and its clients:
	//  - TCP port 111 (portmapper)
	//  - TCP port 635 (mountd)
	//  - TCP port 2049 (NFS)
	//  - TCP port 4045-4046 (NFS lock/status)
	//  - TCP port 445 (SMB)
	//  - TCP port 3260 (iSCSI)
	//  - TCP...
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security groups for the file system's network interfaces. ForceNew. Must allow traffic between the file system and its clients: - TCP port 111 (portmapper) - TCP port 635 (mountd) - TCP port 2049 (NFS..."`
	// IP address range for the file system endpoints in a multi-AZ deployment.
	//  ForceNew. Must be a CIDR block within the VPC's CIDR range that does not
	//  overlap with any existing subnets. AWS assigns floating IPs from this range
	//  for seamless failover.
	//
	//  Ignored for single-AZ deployments.
	EndpointIpAddressRange string `json:"endpoint_ip_address_range,omitempty" jsonschema:"IP address range for the file system endpoints in a multi-AZ deployment. ForceNew. Must be a CIDR block within the VPC's CIDR range that does not overlap with any existing subnets. AWS assigns floatin..."`
	// Route table IDs that need routes to the file system in a multi-AZ
	//  deployment. AWS automatically manages the routes for failover. Up to 50
	//  route tables.
	//
	//  Ignored for single-AZ deployments.
	RouteTableIds []string `json:"route_table_ids,omitempty" jsonschema:"Route table IDs that need routes to the file system in a multi-AZ deployment. AWS automatically manages the routes for failover. Up to 50 route tables. Ignored for single-AZ deployments."`
	// Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key
	//  cannot be changed after creation. When omitted, the file system uses the
	//  AWS-managed FSx key. All ONTAP file systems are encrypted at rest by
	//  default; this field upgrades to a customer-managed key.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key ARN for encryption at rest. ForceNew — the KMS key cannot be changed after creation. When omitted; the file system uses the AWS-managed FSx key. All ONTAP file systems are e..."`
	// Password for the ONTAP administrative user ("fsxadmin"). Enables SSH and
	//  REST API access to the file system for advanced administration such as LIF
	//  management, SnapMirror configuration, and aggregate monitoring.
	//
	//  Length: 8-50 characters. Optional — omit if ONTAP CLI access is not needed.
	//  This ...
	FsxAdminPassword string `json:"fsx_admin_password,omitempty" jsonschema:"Password for the ONTAP administrative user ('fsxadmin'). Enables SSH and REST API access to the file system for advanced administration such as LIF management; SnapMirror configuration; and aggregate ..."`
	// SSD IOPS configuration for the file system. Controls the total provisioned
	//  IOPS. When omitted, AWS uses AUTOMATIC mode which provisions 3 IOPS per GiB
	//  of storage capacity. Use USER_PROVISIONED mode for workloads requiring IOPS
	//  beyond what AUTOMATIC provides.
	DiskIopsConfiguration *AwsFsxOntapFileSystemDiskIopsConfigurationInput `json:"disk_iops_configuration,omitempty" jsonschema:"SSD IOPS configuration for the file system. Controls the total provisioned IOPS. When omitted; AWS uses AUTOMATIC mode which provisions 3 IOPS per GiB of storage capacity. Use USER_PROVISIONED mode fo..."`
	// Number of days to retain automatic backups. Range: 0-90. Set to 0 to
	//  disable automatic backups. ONTAP's built-in snapshots provide point-in-time
	//  recovery independently of FSx backups.
	//
	//  Default: 0 (no automatic backups)
	AutomaticBackupRetentionDays int32 `json:"automatic_backup_retention_days,omitempty" jsonschema:"Number of days to retain automatic backups. Range: 0-90. Set to 0 to disable automatic backups. ONTAP's built-in snapshots provide point-in-time recovery independently of FSx backups. Default: 0 (no a..."`
	// Daily UTC time to start automatic backups, in HH:MM format (e.g., "05:00").
	//  If not specified and backups are enabled, AWS chooses a default window.
	DailyAutomaticBackupStartTime string `json:"daily_automatic_backup_start_time,omitempty" jsonschema:"Daily UTC time to start automatic backups; in HH:MM format (e.g.; '05:00'). If not specified and backups are enabled; AWS chooses a default window."`
	// Copy tags from the file system to backups.
	CopyTagsToBackups bool `json:"copy_tags_to_backups,omitempty" jsonschema:"Copy tags from the file system to backups."`
	// Skip creating a final backup when the file system is deleted.
	//
	//  Default: true
	SkipFinalBackup bool `json:"skip_final_backup,omitempty" jsonschema:"Skip creating a final backup when the file system is deleted. Default: true"`
	// Weekly UTC maintenance window in the format "d:HH:MM" where d is the day of
	//  the week (1=Monday, 7=Sunday). Example: "7:02:00" for Sunday at 02:00 UTC.
	//  If not specified, AWS chooses a default window.
	WeeklyMaintenanceStartTime string `json:"weekly_maintenance_start_time,omitempty" jsonschema:"Weekly UTC maintenance window in the format 'd:HH:MM' where d is the day of the week (1=Monday; 7=Sunday). Example: '7:02:00' for Sunday at 02:00 UTC. If not specified; AWS chooses a default window."`
}

func (s *AwsFsxOntapFileSystemSpecInput) validate() error {
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	if s.DiskIopsConfiguration != nil {
		if err := s.DiskIopsConfiguration.validate(); err != nil {
			return fmt.Errorf("disk_iops_configuration: %w", err)
		}
	}
	return nil
}

func (s *AwsFsxOntapFileSystemSpecInput) applyDefaults() {
	if s.DeploymentType == "" {
		s.DeploymentType = "SINGLE_AZ_2"
	}
	if s.StorageType == "" {
		s.StorageType = "SSD"
	}
	if s.HaPairs == 0 {
		s.HaPairs = 1
	}
	if s.DiskIopsConfiguration != nil {
		s.DiskIopsConfiguration.applyDefaults()
	}
	if s.AutomaticBackupRetentionDays == 0 {
		s.AutomaticBackupRetentionDays = 0
	}
	// default: SkipFinalBackup = true (applied at zero-value)
}

func (s *AwsFsxOntapFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.DeploymentType != "" {
		m["deployment_type"] = s.DeploymentType
	}
	if s.StorageCapacityGib != 0 {
		m["storage_capacity_gib"] = s.StorageCapacityGib
	}
	if s.StorageType != "" {
		m["storage_type"] = s.StorageType
	}
	if s.ThroughputCapacityPerHaPair != 0 {
		m["throughput_capacity_per_ha_pair"] = s.ThroughputCapacityPerHaPair
	}
	if s.HaPairs != 0 {
		m["ha_pairs"] = s.HaPairs
	}
	if len(s.SubnetIds) > 0 {
		m["subnet_ids"] = s.SubnetIds
	}
	if s.PreferredSubnetId != "" {
		m["preferred_subnet_id"] = s.PreferredSubnetId
	}
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if s.EndpointIpAddressRange != "" {
		m["endpoint_ip_address_range"] = s.EndpointIpAddressRange
	}
	if len(s.RouteTableIds) > 0 {
		m["route_table_ids"] = s.RouteTableIds
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.FsxAdminPassword != "" {
		m["fsx_admin_password"] = s.FsxAdminPassword
	}
	if s.DiskIopsConfiguration != nil {
		m["disk_iops_configuration"] = s.DiskIopsConfiguration.toMap()
	}
	if s.AutomaticBackupRetentionDays != 0 {
		m["automatic_backup_retention_days"] = s.AutomaticBackupRetentionDays
	}
	if s.DailyAutomaticBackupStartTime != "" {
		m["daily_automatic_backup_start_time"] = s.DailyAutomaticBackupStartTime
	}
	if s.CopyTagsToBackups {
		m["copy_tags_to_backups"] = s.CopyTagsToBackups
	}
	if s.SkipFinalBackup {
		m["skip_final_backup"] = s.SkipFinalBackup
	}
	if s.WeeklyMaintenanceStartTime != "" {
		m["weekly_maintenance_start_time"] = s.WeeklyMaintenanceStartTime
	}
	return m
}

// AwsFsxOntapFileSystemDiskIopsConfiguration controls the SSD IOPS provisioned
//
//	for the file system. In AUTOMATIC mode, IOPS scale with storage capacity
//	(3 IOPS per GiB). In USER_PROVISIONED mode, you specify the exact IOPS
//	independently of storage, up to 2,400,000 IOPS for scale-out configurations.
type AwsFsxOntapFileSystemDiskIopsConfigurationInput struct {
	// IOPS provisioning mode.
	//
	//  - "AUTOMATIC": IOPS scale automatically based on storage capacity.
	//    Provides 3 IOPS per GiB of storage.
	//  - "USER_PROVISIONED": you specify the exact IOPS via the `iops` field.
	//    Allows higher performance independent of storage size but at extra cost.
	//
	//  Default: AUTOMATIC
	Mode string `json:"mode,omitempty" jsonschema:"IOPS provisioning mode. - 'AUTOMATIC': IOPS scale automatically based on storage capacity. Provides 3 IOPS per GiB of storage. - 'USER_PROVISIONED': you specify the exact IOPS via the 'iops' field. Al..."`
	// Total SSD IOPS provisioned. Only valid when mode is "USER_PROVISIONED".
	//
	//  Valid range: 0–2,400,000. The maximum achievable IOPS depends on the number
	//  of HA pairs and their throughput capacity tier.
	Iops int32 `json:"iops,omitempty" jsonschema:"Total SSD IOPS provisioned. Only valid when mode is 'USER_PROVISIONED'. Valid range: 0–2;400;000. The maximum achievable IOPS depends on the number of HA pairs and their throughput capacity tier."`
}

func (s *AwsFsxOntapFileSystemDiskIopsConfigurationInput) validate() error {
	return nil
}

func (s *AwsFsxOntapFileSystemDiskIopsConfigurationInput) applyDefaults() {
	if s.Mode == "" {
		s.Mode = "AUTOMATIC"
	}
}

func (s *AwsFsxOntapFileSystemDiskIopsConfigurationInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Mode != "" {
		m["mode"] = s.Mode
	}
	if s.Iops != 0 {
		m["iops"] = s.Iops
	}
	return m
}

// ParseAwsFsxOntapFileSystem validates and normalizes a AwsFsxOntapFileSystem cloud_object.
func ParseAwsFsxOntapFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsFsxOntapFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsFsxOntapFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
