// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-27T00:55:48+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantonhq/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// AwsEksNodeGroup represents a containerized application deployed on AWS ECS.
//
//	This resource manages ECS services that can run on either Fargate or EC2.
type AwsEksNodeGroupSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// cluster_name is the name of the EKS cluster to attach this node group to.
	//  The cluster must already exist (e.g., created by an AwsEksCluster resource).
	//  If referencing an AwsEksCluster resource, this pulls its metadata.name.
	ClusterName string `json:"cluster_name" jsonschema:"required,cluster_name is the name of the EKS cluster to attach this node group to. The cluster must already exist (e.g.; created by an AwsEksCluster resource). If referencing an AwsEksCluster resource; this pu..."`
	// node_role_arn is the ARN of the IAM role to associate with the EC2 nodes.
	//  This role must have the necessary EKS worker node policies. If referencing
	//  an AwsIamRole resource, this uses its status.outputs.role_arn.
	NodeRoleArn string `json:"node_role_arn" jsonschema:"required,node_role_arn is the ARN of the IAM role to associate with the EC2 nodes. This role must have the necessary EKS worker node policies. If referencing an AwsIamRole resource; this uses its status.output..."`
	// subnet_ids are the IDs of at least two subnets where the worker nodes will be launched.
	//  Typically these are private subnets in the cluster's VPC to ensure high availability.
	//  If referencing an AwsVpc resource, this defaults to its status.outputs.private_subnets[*].id.
	SubnetIds []string `json:"subnet_ids" jsonschema:"required,subnet_ids are the IDs of at least two subnets where the worker nodes will be launched. Typically these are private subnets in the cluster's VPC to ensure high availability. If referencing an AwsVpc r..."`
	// instance_type is the EC2 instance type for the worker nodes.
	//  Example values: "t3.small", "m5.xlarge". Must match the pattern "<family>.<size>",
	//  e.g., a letter family and size like nano, micro, small, medium, large, xlarge or Nxlarge.
	InstanceType string `json:"instance_type" jsonschema:"required,instance_type is the EC2 instance type for the worker nodes. Example values: 't3.small'; 'm5.xlarge'. Must match the pattern '<family>.<size>'; e.g.; a letter family and size like nano; micro; small; ..."`
	// scaling defines the auto-scaling configuration (min, max, desired node counts) for the node group.
	Scaling *AwsEksNodeGroupScalingConfigInput `json:"scaling" jsonschema:"required,scaling defines the auto-scaling configuration (min; max; desired node counts) for the node group."`
	// capacity_type specifies whether to use on-demand or Spot instances for this node group.
	//  If not set, it defaults to on_demand.
	CapacityType string `json:"capacity_type,omitempty" jsonschema:"enum=spot,capacity_type specifies whether to use on-demand or Spot instances for this node group. If not set; it defaults to on_demand."`
	// disk_size_gb is the EBS volume size (in GiB) for each node's root disk.
	//  If omitted, it is recommended to use 100 GiB by default.
	DiskSizeGb int32 `json:"disk_size_gb,omitempty" jsonschema:"disk_size_gb is the EBS volume size (in GiB) for each node's root disk. If omitted; it is recommended to use 100 GiB by default."`
	// ssh_key_name is the name of an existing EC2 Key Pair to enable SSH access to nodes.
	//  If provided, nodes will allow SSH using this key. Max length is 255 characters.
	SshKeyName string `json:"ssh_key_name,omitempty" jsonschema:"ssh_key_name is the name of an existing EC2 Key Pair to enable SSH access to nodes. If provided; nodes will allow SSH using this key. Max length is 255 characters."`
	// labels is a set of Kubernetes labels to apply to the node group (and its nodes).
	//  Keys and values can be at most 63 characters each.
	Labels map[string]string `json:"labels,omitempty" jsonschema:"labels is a set of Kubernetes labels to apply to the node group (and its nodes). Keys and values can be at most 63 characters each."`
}

func (s *AwsEksNodeGroupSpecInput) validate() error {
	if s.ClusterName == "" {
		return fmt.Errorf("cluster_name is required")
	}
	if s.NodeRoleArn == "" {
		return fmt.Errorf("node_role_arn is required")
	}
	if len(s.SubnetIds) == 0 {
		return fmt.Errorf("subnet_ids is required")
	}
	if len(s.SubnetIds) < 2 {
		return fmt.Errorf("subnet_ids requires at least 2 items, got %d", len(s.SubnetIds))
	}
	if s.InstanceType == "" {
		return fmt.Errorf("instance_type is required")
	}
	if s.Scaling == nil {
		return fmt.Errorf("scaling is required")
	}
	if s.Scaling != nil {
		if err := s.Scaling.validate(); err != nil {
			return fmt.Errorf("scaling: %w", err)
		}
	}
	switch s.CapacityType {
	case "", "spot":
	default:
		return fmt.Errorf("invalid capacity_type: %q", s.CapacityType)
	}
	return nil
}

func (s *AwsEksNodeGroupSpecInput) applyDefaults() {
	if s.Scaling != nil {
		s.Scaling.applyDefaults()
	}
}

func (s *AwsEksNodeGroupSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	m["cluster_name"] = s.ClusterName
	m["node_role_arn"] = s.NodeRoleArn
	m["subnet_ids"] = s.SubnetIds
	m["instance_type"] = s.InstanceType
	if s.Scaling != nil {
		m["scaling"] = s.Scaling.toMap()
	}
	if s.CapacityType != "" {
		m["capacity_type"] = s.CapacityType
	}
	if s.DiskSizeGb != 0 {
		m["disk_size_gb"] = s.DiskSizeGb
	}
	if s.SshKeyName != "" {
		m["ssh_key_name"] = s.SshKeyName
	}
	if len(s.Labels) > 0 {
		m["labels"] = s.Labels
	}
	return m
}

// ScalingConfig defines the node group scaling constraints.
type AwsEksNodeGroupScalingConfigInput struct {
	// min_size is the minimum number of nodes to keep in the group (must be at least 1).
	MinSize int32 `json:"min_size,omitempty" jsonschema:"min_size is the minimum number of nodes to keep in the group (must be at least 1)."`
	// max_size is the maximum number of nodes allowed in the group.
	//  Must be >= min_size.
	MaxSize int32 `json:"max_size,omitempty" jsonschema:"max_size is the maximum number of nodes allowed in the group. Must be >= min_size."`
	// desired_size is the initial or target number of nodes for the group.
	//  It should be between min_size and max_size (inclusive).
	DesiredSize int32 `json:"desired_size,omitempty" jsonschema:"desired_size is the initial or target number of nodes for the group. It should be between min_size and max_size (inclusive)."`
}

func (s *AwsEksNodeGroupScalingConfigInput) validate() error {
	return nil
}

func (s *AwsEksNodeGroupScalingConfigInput) applyDefaults() {
}

func (s *AwsEksNodeGroupScalingConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.MinSize != 0 {
		m["min_size"] = s.MinSize
	}
	if s.MaxSize != 0 {
		m["max_size"] = s.MaxSize
	}
	if s.DesiredSize != 0 {
		m["desired_size"] = s.DesiredSize
	}
	return m
}

// ParseAwsEksNodeGroup validates and normalizes a AwsEksNodeGroup cloud_object.
func ParseAwsEksNodeGroup(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsEksNodeGroup"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsEksNodeGroupSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
