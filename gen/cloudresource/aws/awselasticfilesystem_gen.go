// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T21:50:49+05:30

package aws

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/gen/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// aws-elastic-file-system
type AwsElasticFileSystemSpecInput struct {
	// The AWS region where the resource will be created.
	//  Example: "us-west-2", "eu-west-1"
	Region string `json:"region,omitempty" jsonschema:"The AWS region where the resource will be created. Example: 'us-west-2'; 'eu-west-1'"`
	// Enable encryption at rest for all data and metadata stored in the file system.
	//  ForceNew — cannot be added after creation. Production environments should
	//  always enable encryption.
	Encrypted bool `json:"encrypted,omitempty" jsonschema:"Enable encryption at rest for all data and metadata stored in the file system. ForceNew — cannot be added after creation. Production environments should always enable encryption."`
	// Customer-managed KMS key for encryption at rest. When omitted, EFS uses the
	//  AWS-managed key `aws/elasticfilesystem`. ForceNew — the KMS key cannot be
	//  changed after creation. Requires `encrypted` to be true.
	KmsKeyId string `json:"kms_key_id,omitempty" jsonschema:"Customer-managed KMS key for encryption at rest. When omitted; EFS uses the AWS-managed key 'aws/elasticfilesystem'. ForceNew — the KMS key cannot be changed after creation. Requires 'encrypted' to ..."`
	// File system performance mode. ForceNew — cannot be changed after creation.
	//
	//  - "generalPurpose" (default): lowest latency, suitable for most workloads.
	//    Recommended for all new file systems, especially with "elastic" throughput.
	//  - "maxIO": higher aggregate throughput for highly parallelized wor...
	PerformanceMode string `json:"performance_mode,omitempty" jsonschema:"File system performance mode. ForceNew — cannot be changed after creation. - 'generalPurpose' (default): lowest latency; suitable for most workloads. Recommended for all new file systems; especially..."`
	// Throughput mode controlling how EFS delivers read/write bandwidth.
	//
	//  - "bursting" (default): throughput scales with file system size. 50 MiB/s
	//    per TiB of Standard storage, with bursts up to 100 MiB/s.
	//  - "provisioned": fixed throughput independent of storage size. Set
	//    `provisioned_throughput_i...
	ThroughputMode string `json:"throughput_mode,omitempty" jsonschema:"Throughput mode controlling how EFS delivers read/write bandwidth. - 'bursting' (default): throughput scales with file system size. 50 MiB/s per TiB of Standard storage; with bursts up to 100 MiB/s. -..."`
	// Provisioned throughput in MiB/s. Only applicable when `throughput_mode` is
	//  "provisioned". Range: 1.0–3414.0 for generalPurpose; 1.0–1024.0 for maxIO.
	ProvisionedThroughputInMibps float64 `json:"provisioned_throughput_in_mibps,omitempty" jsonschema:"Provisioned throughput in MiB/s. Only applicable when 'throughput_mode' is 'provisioned'. Range: 1.0–3414.0 for generalPurpose; 1.0–1024.0 for maxIO."`
	// AWS Availability Zone name for One Zone storage classes (e.g., "us-east-1a").
	//  ForceNew — cannot be changed after creation. One Zone storage is ~47% cheaper
	//  than Standard (multi-AZ) but data is stored in a single AZ with no cross-AZ
	//  redundancy. Suitable for dev/test or workloads that tolerate AZ...
	AvailabilityZoneName string `json:"availability_zone_name,omitempty" jsonschema:"AWS Availability Zone name for One Zone storage classes (e.g.; 'us-east-1a'). ForceNew — cannot be changed after creation. One Zone storage is ~47% cheaper than Standard (multi-AZ) but data is store..."`
	// Transition files to Infrequent Access (IA) storage after the specified period
	//  of not being accessed. IA storage costs ~92% less than Standard but charges
	//  per-access fees.
	//
	//  Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS,
	//  AFTER_60_DAYS, AFTER_90_DAYS, AFTER_180_DAYS, AFTER_2...
	TransitionToIa string `json:"transition_to_ia,omitempty" jsonschema:"Transition files to Infrequent Access (IA) storage after the specified period of not being accessed. IA storage costs ~92% less than Standard but charges per-access fees. Valid values: AFTER_1_DAY; AF..."`
	// Transition IA files to Archive storage after the specified period. Archive
	//  storage costs ~96% less than Standard. Requires `transition_to_ia` to be set
	//  (files must pass through IA before reaching Archive).
	//
	//  Same valid values as transition_to_ia.
	TransitionToArchive string `json:"transition_to_archive,omitempty" jsonschema:"Transition IA files to Archive storage after the specified period. Archive storage costs ~96% less than Standard. Requires 'transition_to_ia' to be set (files must pass through IA before reaching Arch..."`
	// Transition files back to Standard storage when accessed from IA or Archive.
	//  This enables automatic "warming" of frequently accessed files.
	//
	//  Only valid value: "AFTER_1_ACCESS". Leave empty to keep files in IA/Archive
	//  even after access.
	TransitionToPrimaryStorageClass string `json:"transition_to_primary_storage_class,omitempty" jsonschema:"Transition files back to Standard storage when accessed from IA or Archive. This enables automatic 'warming' of frequently accessed files. Only valid value: 'AFTER_1_ACCESS'. Leave empty to keep files..."`
	// Enable automatic daily backups via AWS Backup. AWS recommends enabling
	//  backups for all production file systems. Mutable — can be toggled at any time.
	BackupEnabled bool `json:"backup_enabled,omitempty" jsonschema:"Enable automatic daily backups via AWS Backup. AWS recommends enabling backups for all production file systems. Mutable — can be toggled at any time."`
	// Subnet IDs to create mount targets in. Required (min 1). One mount target is
	//  created per subnet. AWS allows at most one mount target per Availability Zone
	//  — providing two subnets in the same AZ will cause an API error at deploy time.
	//
	//  For regional (multi-AZ) file systems, provide one subnet per...
	SubnetIds []string `json:"subnet_ids" jsonschema:"required,Subnet IDs to create mount targets in. Required (min 1). One mount target is created per subnet. AWS allows at most one mount target per Availability Zone — providing two subnets in the same AZ will..."`
	// Security groups to apply to all mount targets. These must allow inbound NFS
	//  traffic (TCP port 2049) from the clients that will mount the file system.
	SecurityGroupIds []string `json:"security_group_ids,omitempty" jsonschema:"Security groups to apply to all mount targets. These must allow inbound NFS traffic (TCP port 2049) from the clients that will mount the file system."`
	// Access points provide application-specific entry points into the file system,
	//  each with its own POSIX user/group identity and root directory. Commonly used
	//  with ECS tasks and Lambda functions to enforce least-privilege file access.
	//
	//  Each access point must have a unique `name` which serves as the ...
	AccessPoints []*AwsElasticFileSystemAccessPointInput `json:"access_points,omitempty" jsonschema:"Access points provide application-specific entry points into the file system; each with its own POSIX user/group identity and root directory. Commonly used with ECS tasks and Lambda functions to enfor..."`
	// IAM resource policy for the file system. Common uses:
	//  - Enforce encryption in transit (deny unencrypted NFS connections)
	//  - Restrict access to specific IAM principals or VPCs
	//  - Prevent root access from NFS clients
	//
	//  Provide as a JSON object structure. Serialized to JSON by IaC modules.
	//  Consistent...
	Policy any `json:"policy,omitempty" jsonschema:"IAM resource policy for the file system. Common uses: - Enforce encryption in transit (deny unencrypted NFS connections) - Restrict access to specific IAM principals or VPCs - Prevent root access from..."`
}

func (s *AwsElasticFileSystemSpecInput) validate() error {
	if len(s.SubnetIds) == 0 {
		return fmt.Errorf("subnet_ids is required")
	}
	if len(s.SubnetIds) < 1 {
		return fmt.Errorf("subnet_ids requires at least 1 items, got %d", len(s.SubnetIds))
	}
	for i, v := range s.AccessPoints {
		if v != nil {
			if err := v.validate(); err != nil {
				return fmt.Errorf("access_points[%d]: %w", i, err)
			}
		}
	}
	return nil
}

func (s *AwsElasticFileSystemSpecInput) applyDefaults() {
}

func (s *AwsElasticFileSystemSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	if s.Region != "" {
		m["region"] = s.Region
	}
	if s.Encrypted {
		m["encrypted"] = s.Encrypted
	}
	if s.KmsKeyId != "" {
		m["kms_key_id"] = s.KmsKeyId
	}
	if s.PerformanceMode != "" {
		m["performance_mode"] = s.PerformanceMode
	}
	if s.ThroughputMode != "" {
		m["throughput_mode"] = s.ThroughputMode
	}
	if s.ProvisionedThroughputInMibps != 0 {
		m["provisioned_throughput_in_mibps"] = s.ProvisionedThroughputInMibps
	}
	if s.AvailabilityZoneName != "" {
		m["availability_zone_name"] = s.AvailabilityZoneName
	}
	if s.TransitionToIa != "" {
		m["transition_to_ia"] = s.TransitionToIa
	}
	if s.TransitionToArchive != "" {
		m["transition_to_archive"] = s.TransitionToArchive
	}
	if s.TransitionToPrimaryStorageClass != "" {
		m["transition_to_primary_storage_class"] = s.TransitionToPrimaryStorageClass
	}
	if s.BackupEnabled {
		m["backup_enabled"] = s.BackupEnabled
	}
	m["subnet_ids"] = s.SubnetIds
	if len(s.SecurityGroupIds) > 0 {
		m["security_group_ids"] = s.SecurityGroupIds
	}
	if len(s.AccessPoints) > 0 {
		items := make([]any, len(s.AccessPoints))
		for i, v := range s.AccessPoints {
			if v != nil {
				items[i] = v.toMap()
			}
		}
		m["access_points"] = items
	}
	// unsupported type "object" for field Policy
	return m
}

// AwsElasticFileSystemAccessPoint defines an EFS access point — an application-
//
//	specific entry point into the file system that enforces a POSIX user/group
//	identity and optionally restricts the visible root directory.
//
//	Access points are the recommended way to give ECS tasks and Lambda functions
//	file system access, as they enforce least-privilege without requiring the
//	application to manage POSIX permissions.
type AwsElasticFileSystemAccessPointInput struct {
	// Unique name for this access point within the file system. Used as the map key
	//  in `access_point_ids` and `access_point_arns` stack outputs.
	Name string `json:"name" jsonschema:"required,Unique name for this access point within the file system. Used as the map key in 'access_point_ids' and 'access_point_arns' stack outputs."`
	// POSIX user and group identity enforced for all file operations through this
	//  access point. When set, the NFS client's identity is overridden — regardless
	//  of what UID/GID the client claims, all operations use these values.
	PosixUser *AwsElasticFileSystemAccessPointPosixUserInput `json:"posix_user,omitempty" jsonschema:"POSIX user and group identity enforced for all file operations through this access point. When set; the NFS client's identity is overridden — regardless of what UID/GID the client claims; all operat..."`
	// Root directory exposed as "/" when mounting through this access point. If the
	//  directory does not exist, provide `creation_info` to have EFS create it
	//  automatically with the specified ownership and permissions.
	RootDirectory *AwsElasticFileSystemAccessPointRootDirectoryInput `json:"root_directory,omitempty" jsonschema:"Root directory exposed as '/' when mounting through this access point. If the directory does not exist; provide 'creation_info' to have EFS create it automatically with the specified ownership and per..."`
}

func (s *AwsElasticFileSystemAccessPointInput) validate() error {
	if s.Name == "" {
		return fmt.Errorf("name is required")
	}
	if s.PosixUser != nil {
		if err := s.PosixUser.validate(); err != nil {
			return fmt.Errorf("posix_user: %w", err)
		}
	}
	if s.RootDirectory != nil {
		if err := s.RootDirectory.validate(); err != nil {
			return fmt.Errorf("root_directory: %w", err)
		}
	}
	return nil
}

func (s *AwsElasticFileSystemAccessPointInput) applyDefaults() {
	if s.PosixUser != nil {
		s.PosixUser.applyDefaults()
	}
	if s.RootDirectory != nil {
		s.RootDirectory.applyDefaults()
	}
}

func (s *AwsElasticFileSystemAccessPointInput) toMap() map[string]any {
	m := make(map[string]any)
	m["name"] = s.Name
	if s.PosixUser != nil {
		m["posix_user"] = s.PosixUser.toMap()
	}
	if s.RootDirectory != nil {
		m["root_directory"] = s.RootDirectory.toMap()
	}
	return m
}

// AwsElasticFileSystemAccessPointCreationInfo specifies the POSIX ownership and
//
//	permissions applied when EFS automatically creates the access point's root
//	directory.
type AwsElasticFileSystemAccessPointCreationInfoInput struct {
	// POSIX user ID for the directory owner.
	OwnerUid int32 `json:"owner_uid" jsonschema:"required,POSIX user ID for the directory owner."`
	// POSIX group ID for the directory owner.
	OwnerGid int32 `json:"owner_gid" jsonschema:"required,POSIX group ID for the directory owner."`
	// POSIX permissions for the directory, in octal notation (e.g., "0755", "0750").
	Permissions string `json:"permissions" jsonschema:"required,POSIX permissions for the directory; in octal notation (e.g.; '0755'; '0750')."`
}

func (s *AwsElasticFileSystemAccessPointCreationInfoInput) validate() error {
	if s.Permissions == "" {
		return fmt.Errorf("permissions is required")
	}
	return nil
}

func (s *AwsElasticFileSystemAccessPointCreationInfoInput) applyDefaults() {
}

func (s *AwsElasticFileSystemAccessPointCreationInfoInput) toMap() map[string]any {
	m := make(map[string]any)
	m["owner_uid"] = s.OwnerUid
	m["owner_gid"] = s.OwnerGid
	m["permissions"] = s.Permissions
	return m
}

// AwsElasticFileSystemAccessPointPosixUser defines the POSIX identity enforced
//
//	for all file operations through an access point.
type AwsElasticFileSystemAccessPointPosixUserInput struct {
	// POSIX user ID. All file system operations through this access point use
	//  this UID as the file owner.
	Uid int32 `json:"uid" jsonschema:"required,POSIX user ID. All file system operations through this access point use this UID as the file owner."`
	// POSIX primary group ID. All file system operations through this access point
	//  use this GID as the file group.
	Gid int32 `json:"gid" jsonschema:"required,POSIX primary group ID. All file system operations through this access point use this GID as the file group."`
	// Secondary POSIX group IDs. These supplement the primary GID for group
	//  permission checks.
	SecondaryGids []int32 `json:"secondary_gids,omitempty" jsonschema:"Secondary POSIX group IDs. These supplement the primary GID for group permission checks."`
}

func (s *AwsElasticFileSystemAccessPointPosixUserInput) validate() error {
	return nil
}

func (s *AwsElasticFileSystemAccessPointPosixUserInput) applyDefaults() {
}

func (s *AwsElasticFileSystemAccessPointPosixUserInput) toMap() map[string]any {
	m := make(map[string]any)
	m["uid"] = s.Uid
	m["gid"] = s.Gid
	if len(s.SecondaryGids) > 0 {
		m["secondary_gids"] = s.SecondaryGids
	}
	return m
}

// AwsElasticFileSystemAccessPointRootDirectory configures the directory on the
//
//	EFS file system that is exposed as the root when mounting through an access
//	point.
type AwsElasticFileSystemAccessPointRootDirectoryInput struct {
	// Path on the EFS file system to expose as the root directory. Must be an
	//  absolute path (starts with "/"). Up to 4 subdirectories deep.
	//  Default: "/" (entire file system).
	//
	//  If this path does not exist and `creation_info` is provided, EFS creates
	//  the directory with the specified POSIX ownership and ...
	Path string `json:"path" jsonschema:"required,Path on the EFS file system to expose as the root directory. Must be an absolute path (starts with '/'). Up to 4 subdirectories deep. Default: '/' (entire file system). If this path does not exist and..."`
	// POSIX ownership and permissions to apply when creating the root directory.
	//  Required when the path does not already exist on the file system.
	CreationInfo *AwsElasticFileSystemAccessPointCreationInfoInput `json:"creation_info,omitempty" jsonschema:"POSIX ownership and permissions to apply when creating the root directory. Required when the path does not already exist on the file system."`
}

func (s *AwsElasticFileSystemAccessPointRootDirectoryInput) validate() error {
	if s.Path == "" {
		return fmt.Errorf("path is required")
	}
	if s.CreationInfo != nil {
		if err := s.CreationInfo.validate(); err != nil {
			return fmt.Errorf("creation_info: %w", err)
		}
	}
	return nil
}

func (s *AwsElasticFileSystemAccessPointRootDirectoryInput) applyDefaults() {
	if s.CreationInfo != nil {
		s.CreationInfo.applyDefaults()
	}
}

func (s *AwsElasticFileSystemAccessPointRootDirectoryInput) toMap() map[string]any {
	m := make(map[string]any)
	m["path"] = s.Path
	if s.CreationInfo != nil {
		m["creation_info"] = s.CreationInfo.toMap()
	}
	return m
}

// ParseAwsElasticFileSystem validates and normalizes a AwsElasticFileSystem cloud_object.
func ParseAwsElasticFileSystem(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "aws.openmcf.org/v1", "AwsElasticFileSystem"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec AwsElasticFileSystemSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
