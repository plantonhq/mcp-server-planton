// Code generated by schema2go. DO NOT EDIT.
// Generated: 2026-02-26T22:01:03+05:30

package confluent

import (
	"encoding/json"
	"fmt"

	"github.com/plantoncloud/mcp-server-planton/internal/parse"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	_ = json.Marshal
	_ = fmt.Errorf
	_ = parse.ValidateHeader
	_ = (*structpb.Struct)(nil)
)

// confluent-kafka
type ConfluentKafkaSpecInput struct {
	// cloud provider
	// https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#cloud_yaml
	Cloud string `json:"cloud" jsonschema:"required,cloud provider https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#cloud_yaml"`
	// region is the cloud-specific region where the cluster will be deployed (e.g., us-east-2, us-central1, eastus)
	// https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#region_yaml
	Region string `json:"region" jsonschema:"required,region is the cloud-specific region where the cluster will be deployed (e.g.; us-east-2; us-central1; eastus) https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#region_yaml"`
	// availability determines high availability configuration
	// SINGLE_ZONE: Development/testing, no SLA
	// MULTI_ZONE: Production, 99.99% SLA (required for Standard/Dedicated)
	// LOW and HIGH are legacy values for Basic clusters
	// https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#avail...
	Availability string `json:"availability" jsonschema:"required,availability determines high availability configuration SINGLE_ZONE: Development/testing; no SLA MULTI_ZONE: Production; 99.99% SLA (required for Standard/Dedicated) LOW and HIGH are legacy values for..."`
	// environment_id is the ID of the Confluent Cloud environment (parent container for clusters)
	// https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#environment_yaml
	EnvironmentId string `json:"environment_id" jsonschema:"required,environment_id is the ID of the Confluent Cloud environment (parent container for clusters) https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#environment_yaml"`
	// cluster_type determines the deployment type and capabilities
	// BASIC: Multi-tenant, development/testing, single-zone only, public internet only
	// STANDARD: Multi-tenant, production, elastic scaling, public internet only
	// ENTERPRISE: Multi-tenant, production, elastic scaling, supports private networking
	// D...
	ClusterType string `json:"cluster_type,omitempty" jsonschema:"cluster_type determines the deployment type and capabilities BASIC: Multi-tenant; development/testing; single-zone only; public internet only STANDARD: Multi-tenant; production; elastic scaling; publi..."`
	// dedicated_config is required only when cluster_type is DEDICATED
	// configures provisioned capacity (CKU) for dedicated clusters
	DedicatedConfig *ConfluentKafkaDedicatedConfigInput `json:"dedicated_config,omitempty" jsonschema:"dedicated_config is required only when cluster_type is DEDICATED configures provisioned capacity (CKU) for dedicated clusters"`
	// network_config configures private networking (PrivateLink, VNet Peering, Private Service Connect)
	// Only available for ENTERPRISE and DEDICATED cluster types
	// Optional: If not specified, cluster uses public internet access
	NetworkConfig *ConfluentKafkaNetworkConfigInput `json:"network_config,omitempty" jsonschema:"network_config configures private networking (PrivateLink; VNet Peering; Private Service Connect) Only available for ENTERPRISE and DEDICATED cluster types Optional: If not specified; cluster uses pub..."`
	// display_name is the human-readable name shown in Confluent Cloud UI
	// Optional: If not specified, defaults to metadata.name
	DisplayName string `json:"display_name,omitempty" jsonschema:"display_name is the human-readable name shown in Confluent Cloud UI Optional: If not specified; defaults to metadata.name"`
}

func (s *ConfluentKafkaSpecInput) validate() error {
	if s.Cloud == "" {
		return fmt.Errorf("cloud is required")
	}
	if s.Region == "" {
		return fmt.Errorf("region is required")
	}
	if s.Availability == "" {
		return fmt.Errorf("availability is required")
	}
	if s.EnvironmentId == "" {
		return fmt.Errorf("environment_id is required")
	}
	if s.DedicatedConfig != nil {
		if err := s.DedicatedConfig.validate(); err != nil {
			return fmt.Errorf("dedicated_config: %w", err)
		}
	}
	if s.NetworkConfig != nil {
		if err := s.NetworkConfig.validate(); err != nil {
			return fmt.Errorf("network_config: %w", err)
		}
	}
	return nil
}

func (s *ConfluentKafkaSpecInput) applyDefaults() {
	if s.DedicatedConfig != nil {
		s.DedicatedConfig.applyDefaults()
	}
	if s.NetworkConfig != nil {
		s.NetworkConfig.applyDefaults()
	}
}

func (s *ConfluentKafkaSpecInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cloud"] = s.Cloud
	m["region"] = s.Region
	m["availability"] = s.Availability
	m["environment_id"] = s.EnvironmentId
	if s.ClusterType != "" {
		m["cluster_type"] = s.ClusterType
	}
	if s.DedicatedConfig != nil {
		m["dedicated_config"] = s.DedicatedConfig.toMap()
	}
	if s.NetworkConfig != nil {
		m["network_config"] = s.NetworkConfig.toMap()
	}
	if s.DisplayName != "" {
		m["display_name"] = s.DisplayName
	}
	return m
}

// confluent-kafka dedicated cluster configuration
// Required when cluster_type is DEDICATED
type ConfluentKafkaDedicatedConfigInput struct {
	// cku (Confluent Kafka Units) is the provisioned capacity for dedicated clusters
	// Minimum: 1 CKU, can be scaled up/down but not to zero
	// https://www.pulumi.com/registry/packages/confluentcloud/api-docs/kafkacluster/#cku_yaml
	Cku int32 `json:"cku" jsonschema:"required,cku (Confluent Kafka Units) is the provisioned capacity for dedicated clusters Minimum: 1 CKU; can be scaled up/down but not to zero https://www.pulumi.com/registry/packages/confluentcloud/api-docs/ka..."`
}

func (s *ConfluentKafkaDedicatedConfigInput) validate() error {
	return nil
}

func (s *ConfluentKafkaDedicatedConfigInput) applyDefaults() {
}

func (s *ConfluentKafkaDedicatedConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["cku"] = s.Cku
	return m
}

// confluent-kafka network configuration for private networking
// Enables PrivateLink (AWS), Private Link (Azure), or Private Service Connect (GCP)
// Only available for ENTERPRISE and DEDICATED cluster types
type ConfluentKafkaNetworkConfigInput struct {
	// network_id is the ID of the Confluent Cloud network resource
	// Must be pre-created in the same environment
	// https://docs.confluent.io/cloud/current/networking/overview.html
	NetworkId string `json:"network_id" jsonschema:"required,network_id is the ID of the Confluent Cloud network resource Must be pre-created in the same environment https://docs.confluent.io/cloud/current/networking/overview.html"`
}

func (s *ConfluentKafkaNetworkConfigInput) validate() error {
	if s.NetworkId == "" {
		return fmt.Errorf("network_id is required")
	}
	return nil
}

func (s *ConfluentKafkaNetworkConfigInput) applyDefaults() {
}

func (s *ConfluentKafkaNetworkConfigInput) toMap() map[string]any {
	m := make(map[string]any)
	m["network_id"] = s.NetworkId
	return m
}

// ParseConfluentKafka validates and normalizes a ConfluentKafka cloud_object.
func ParseConfluentKafka(cloudObject map[string]any) (*structpb.Struct, error) {
	if err := parse.ValidateHeader(cloudObject, "confluent.openmcf.org/v1", "ConfluentKafka"); err != nil {
		return nil, err
	}

	specMap, err := parse.ExtractSpecMap(cloudObject)
	if err != nil {
		return nil, err
	}

	specBytes, err := json.Marshal(specMap)
	if err != nil {
		return nil, fmt.Errorf("marshal spec: %w", err)
	}

	var spec ConfluentKafkaSpecInput
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		return nil, fmt.Errorf("invalid spec: %w", err)
	}

	if err := spec.validate(); err != nil {
		return nil, err
	}

	spec.applyDefaults()

	return parse.RebuildCloudObject(cloudObject, spec.toMap())
}
